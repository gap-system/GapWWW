<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (ref) - Chapter 72: Class Functions</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap72"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chap16.html">16</a>  <a href="chap17.html">17</a>  <a href="chap18.html">18</a>  <a href="chap19.html">19</a>  <a href="chap20.html">20</a>  <a href="chap21.html">21</a>  <a href="chap22.html">22</a>  <a href="chap23.html">23</a>  <a href="chap24.html">24</a>  <a href="chap25.html">25</a>  <a href="chap26.html">26</a>  <a href="chap27.html">27</a>  <a href="chap28.html">28</a>  <a href="chap29.html">29</a>  <a href="chap30.html">30</a>  <a href="chap31.html">31</a>  <a href="chap32.html">32</a>  <a href="chap33.html">33</a>  <a href="chap34.html">34</a>  <a href="chap35.html">35</a>  <a href="chap36.html">36</a>  <a href="chap37.html">37</a>  <a href="chap38.html">38</a>  <a href="chap39.html">39</a>  <a href="chap40.html">40</a>  <a href="chap41.html">41</a>  <a href="chap42.html">42</a>  <a href="chap43.html">43</a>  <a href="chap44.html">44</a>  <a href="chap45.html">45</a>  <a href="chap46.html">46</a>  <a href="chap47.html">47</a>  <a href="chap48.html">48</a>  <a href="chap49.html">49</a>  <a href="chap50.html">50</a>  <a href="chap51.html">51</a>  <a href="chap52.html">52</a>  <a href="chap53.html">53</a>  <a href="chap54.html">54</a>  <a href="chap55.html">55</a>  <a href="chap56.html">56</a>  <a href="chap57.html">57</a>  <a href="chap58.html">58</a>  <a href="chap59.html">59</a>  <a href="chap60.html">60</a>  <a href="chap61.html">61</a>  <a href="chap62.html">62</a>  <a href="chap63.html">63</a>  <a href="chap64.html">64</a>  <a href="chap65.html">65</a>  <a href="chap66.html">66</a>  <a href="chap67.html">67</a>  <a href="chap68.html">68</a>  <a href="chap69.html">69</a>  <a href="chap70.html">70</a>  <a href="chap71.html">71</a>  <a href="chap72.html">72</a>  <a href="chap73.html">73</a>  <a href="chap74.html">74</a>  <a href="chap75.html">75</a>  <a href="chap76.html">76</a>  <a href="chap77.html">77</a>  <a href="chap78.html">78</a>  <a href="chap79.html">79</a>  <a href="chap80.html">80</a>  <a href="chap81.html">81</a>  <a href="chap82.html">82</a>  <a href="chap83.html">83</a>  <a href="chap84.html">84</a>  <a href="chap85.html">85</a>  <a href="chap86.html">86</a>  <a href="chap87.html">87</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap71.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap73.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap72_mj.html">[MathJax on]</a></p>
<p><a id="X7C91D0D17850E564" name="X7C91D0D17850E564"></a></p>
<div class="ChapSects"><a href="chap72.html#X7C91D0D17850E564">72 <span class="Heading">Class Functions</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap72.html#X823319217E4B6852">72.1 <span class="Heading">Why Class Functions?</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7E75A70F7BF00A0D">72.1-1 IsClassFunction</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap72.html#X8192EDDB84ADD46E">72.2 <span class="Heading">Basic Operations for Class Functions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X81B55C067D123B76">72.2-1 UnderlyingCharacterTable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7FE14712843C6486">72.2-2 ValuesOfClassFunction</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap72.html#X829EFBF57FCB1A94">72.3 <span class="Heading">Comparison of Class Functions</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap72.html#X83B9F0C5871A5F7F">72.4 <span class="Heading">Arithmetic Operations for Class Functions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X83AAD5527BBAFA03">72.4-1 Characteristic</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X856AB97E785E0B04">72.4-2 ComplexConjugate</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7BCE99B88285EB39">72.4-3 Order</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap72.html#X828AD0C57EA57C21">72.5 <span class="Heading">Printing Class Functions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7BDD2D4A7F7FB3B1">72.5-1 ViewObj</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X871160B98595D4BA">72.5-2 PrintObj</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X8430D31B8163C230">72.5-3 Display</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap72.html#X7BB90A8F86FFA456">72.6 <span class="Heading">Creating Class Functions from Values Lists</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X78F4E23985FCA259">72.6-1 ClassFunction</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7805AFF77EFC3306">72.6-2 VirtualCharacter</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X849DD34C7968206C">72.6-3 Character</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7B38035981D71B1B">72.6-4 ClassFunctionSameType</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap72.html#X8727C2CB7ABEBC84">72.7 <span class="Heading">Creating Class Functions using Groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X86129DC37C55E4D6">72.7-1 <span class="Heading">TrivialCharacter</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X82C01DDB82D751A9">72.7-2 NaturalCharacter</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7938621F81B65E03">72.7-3 <span class="Heading">PermutationCharacter</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap72.html#X86DDB47A7C6B45D0">72.8 <span class="Heading">Operations for Class Functions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7FE3CD08794051F8">72.8-1 IsCharacter</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X788DD05C86CB7030">72.8-2 IsVirtualCharacter</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X79A4B1D3870C8807">72.8-3 IsIrreducibleCharacter</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7802BC157C69DD75">72.8-4 DegreeOfCharacter</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X855FD9F983D275CD">72.8-5 ScalarProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X858DF4E67EBB99DA">72.8-6 MatScalarProducts</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X8572B18A7BAED73E">72.8-7 Norm</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X78550D7087DB1181">72.8-8 ConstituentsOfCharacter</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7E0A24498710F12B">72.8-9 KernelOfCharacter</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7B4708B47D9C05B3">72.8-10 ClassPositionsOfKernel</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7E77D4147A0836D3">72.8-11 CentreOfCharacter</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7CE5B4137B399274">72.8-12 ClassPositionsOfCentre</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7C3187387C2D9938">72.8-13 InertiaSubgroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X8269BE0079A64D43">72.8-14 CycleStructureClass</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X86EDB4047C5AD6E7">72.8-15 IsTransitive</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X801DC07B8029841B">72.8-16 Transitivity</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7DD8FDCF7FB7834A">72.8-17 CentralCharacter</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7A292A58827B95B8">72.8-18 DeterminantOfCharacter</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X861B435C7F68AE7D">72.8-19 EigenvaluesChar</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7A106BE281EFD953">72.8-20 Tensored</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap72.html#X854A4E3A85C5F89B">72.9 <span class="Heading">Restricted and Induced Class Functions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X86BABEA6841A40CF">72.9-1 RestrictedClassFunction</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X86DB64F08035D219">72.9-2 RestrictedClassFunctions</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7FE39D3D78855D3B">72.9-3 <span class="Heading">InducedClassFunction</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X8484C0F985AD2D28">72.9-4 InducedClassFunctions</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7C72003880743D28">72.9-5 InducedClassFunctionsByFusionMap</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7C055F327C99CE71">72.9-6 InducedCyclic</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap72.html#X7C95F7937B752F48">72.10 <span class="Heading">Reducing Virtual Characters</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X86F360D983343C2A">72.10-1 ReducedClassFunctions</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7B7138ED8586F09E">72.10-2 ReducedCharacters</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7D3289BB865BCF98">72.10-3 IrreducibleDifferences</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X85B360C085B360C0">72.10-4 LLL</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X808D71A57D104ED7">72.10-5 Extract</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7F97B34A879D11BA">72.10-6 OrthogonalEmbeddingsSpecialDimension</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X8799AB967C58C0E9">72.10-7 Decreased</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X85D510DC873A99B4">72.10-8 DnLattice</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X78754D007F3572A7">72.10-9 DnLatticeIterative</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap72.html#X87ED98F385B00D34">72.11 <span class="Heading">Symmetrizations of Class Functions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7E220413823330EC">72.11-1 Symmetrizations</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X85CE68CA87CA383A">72.11-2 SymmetricParts</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X8329E934829FE965">72.11-3 AntiSymmetricParts</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X78648E367C65B1F1">72.11-4 OrthogonalComponents</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X788B9AA17DD9418C">72.11-5 SymplecticComponents</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap72.html#X87B86B427A88CD25">72.12 <span class="Heading">Molien Series</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7D7F94D2820B1177">72.12-1 MolienSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X82AC06A880EAA0AB">72.12-2 MolienSeriesInfo</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X87083C4E7D11A02E">72.12-3 ValueMolienSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X86BAA3C487CE86D2">72.12-4 MolienSeriesWithGivenDenominator</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap72.html#X7D6336857E6BDF46">72.13 <span class="Heading">Possible Permutation Characters</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X8477004C7A31D28C">72.13-1 PermCharInfo</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7A8CB0298730D808">72.13-2 PermCharInfoRelative</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap72.html#X8330FDCE83D3DED3">72.14 <span class="Heading">Computing Possible Permutation Characters</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7D02541482C196A6">72.14-1 PermChars</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X8127771D7EAB6EA7">72.14-2 <span class="Heading">TestPerm1, ..., TestPerm5</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X879D2A127BE366A5">72.14-3 PermBounds</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X7F11AFB783352903">72.14-4 PermComb</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X866942167802E036">72.14-5 Inequalities</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap72.html#X8204FB9F847340C8">72.15 <span class="Heading">Operations for Brauer Characters</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X79BACBC47B4C413E">72.15-1 FrobeniusCharacterValue</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X8304B68E84511685">72.15-2 BrauerCharacterValue</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X8038FA0480B78243">72.15-3 SizeOfFieldOfDefinition</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap72.html#X782400277F6316A4">72.15-4 RealizableBrauerCharacters</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap72.html#X7FEEDC0981A22850">72.16 <span class="Heading">Domains Generated by Class Functions</span></a>
</span>
</div>
</div>

<h3>72 <span class="Heading">Class Functions</span></h3>

<p>This chapter describes operations for <em>class functions of finite groups</em>. For operations concerning <em>character tables</em>, see Chapter <a href="chap71.html#X7B7A9EE881E01C10"><span class="RefLink">71</span></a>.</p>

<p>Several examples in this chapter require the <strong class="pkg">GAP</strong> Character Table Library to be available. If it is not yet loaded then we load it now.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "ctbllib" );</span>
true
</pre></div>

<p><a id="X823319217E4B6852" name="X823319217E4B6852"></a></p>

<h4>72.1 <span class="Heading">Why Class Functions?</span></h4>

<p>In principle it is possible to represent group characters or more general class functions by the plain lists of their values, and in fact many operations for class functions work with plain lists of class function values. But this has two disadvantages.</p>

<p>First, it is then necessary to regard a values list explicitly as a class function of a particular character table, by supplying this character table as an argument. In practice this means that with this setup, the user has the task to put the objects into the right context. For example, forming the scalar product or the tensor product of two class functions or forming an induced class function or a conjugate class function then needs three arguments in this case; this is particularly inconvenient in cases where infix operations cannot be used because of the additional argument, as for tensor products and induced class functions.</p>

<p>Second, when one says that "<span class="SimpleMath">χ</span> is a character of a group <span class="SimpleMath">G</span>" then this object <span class="SimpleMath">χ</span> carries a lot of information. <span class="SimpleMath">χ</span> has certain properties such as being irreducible or not. Several subgroups of <span class="SimpleMath">G</span> are related to <span class="SimpleMath">χ</span>, such as the kernel and the centre of <span class="SimpleMath">χ</span>. Other attributes of characters are the determinant and the central character. This knowledge cannot be stored in a plain list.</p>

<p>For dealing with a group together with its characters, and maybe also subgroups and their characters, it is desirable that <strong class="pkg">GAP</strong> keeps track of the interpretation of characters. On the other hand, for using characters without accessing their groups, such as characters of tables from the <strong class="pkg">GAP</strong> table library, dealing just with values lists is often sufficient. In particular, if one deals with incomplete character tables then it is often necessary to specify the arguments explicitly, for example one has to choose a fusion map or power map from a set of possibilities.</p>

<p>The main idea behind class function objects is that a class function object is equal to its values list in the sense of <code class="func">\=</code> (<a href="chap31.html#X7EF67D047F03CA6F"><span class="RefLink">31.11-1</span></a>), so class function objects can be used wherever their values lists can be used, but there are operations for class function objects that do not work just with values lists. <strong class="pkg">GAP</strong> library functions prefer to return class function objects rather than returning just values lists, for example <code class="func">Irr</code> (<a href="chap71.html#X873B3CC57E9A5492"><span class="RefLink">71.8-2</span></a>) lists consist of class function objects, and <code class="func">TrivialCharacter</code> (<a href="chap72.html#X86129DC37C55E4D6"><span class="RefLink">72.7-1</span></a>) returns a class function object.</p>

<p>Here is an <em>example</em> that shows both approaches. First we define some groups.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S4:= SymmetricGroup( 4 );;  SetName( S4, "S4" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D8:= SylowSubgroup( S4, 2 );; SetName( D8, "D8" );</span>
</pre></div>

<p>We do some computations using the functions described later in this Chapter, first with class function objects.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irrS4:= Irr( S4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irrD8:= Irr( D8 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chi:= irrD8[4];</span>
Character( CharacterTable( D8 ), [ 1, -1, 1, -1, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chi * chi;</span>
Character( CharacterTable( D8 ), [ 1, 1, 1, 1, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ind:= chi ^ S4;</span>
Character( CharacterTable( S4 ), [ 3, -1, -1, 0, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( irrS4, x -&gt; ScalarProduct( x, ind ) );</span>
[ 0, 1, 0, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">det:= Determinant( ind );</span>
Character( CharacterTable( S4 ), [ 1, 1, 1, 1, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cent:= CentralCharacter( ind );</span>
ClassFunction( CharacterTable( S4 ), [ 1, -2, -1, 0, 2 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rest:= Restricted( cent, D8 );</span>
ClassFunction( CharacterTable( D8 ), [ 1, -2, -1, -1, 2 ] )
</pre></div>

<p>Now we repeat these calculations with plain lists of character values. Here we need the character tables in some places.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tS4:= CharacterTable( S4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tD8:= CharacterTable( D8 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chi:= ValuesOfClassFunction( irrD8[4] );</span>
[ 1, -1, 1, -1, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Tensored( [ chi ], [ chi ] )[1];</span>
[ 1, 1, 1, 1, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ind:= InducedClassFunction( tD8, chi, tS4 );</span>
ClassFunction( CharacterTable( S4 ), [ 3, -1, -1, 0, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( Irr( tS4 ), x -&gt; ScalarProduct( tS4, x, ind ) );</span>
[ 0, 1, 0, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">det:= DeterminantOfCharacter( tS4, ind );</span>
ClassFunction( CharacterTable( S4 ), [ 1, 1, 1, 1, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cent:= CentralCharacter( tS4, ind );</span>
ClassFunction( CharacterTable( S4 ), [ 1, -2, -1, 0, 2 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rest:= Restricted( tS4, cent, tD8 );</span>
ClassFunction( CharacterTable( D8 ), [ 1, -2, -1, -1, 2 ] )
</pre></div>

<p>If one deals with character tables from the <strong class="pkg">GAP</strong> table library then one has no access to their groups, but often the tables provide enough information for computing induced or restricted class functions, symmetrizations etc., because the relevant class fusions and power maps are often stored on library tables. In these cases it is possible to use the tables instead of the groups as arguments. (If necessary information is not uniquely determined by the tables then an error is signalled.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s5 := CharacterTable( "A5.2" );; irrs5 := Irr( s5  );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m11:= CharacterTable( "M11"  );; irrm11:= Irr( m11 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chi:= TrivialCharacter( s5 );</span>
Character( CharacterTable( "A5.2" ), [ 1, 1, 1, 1, 1, 1, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chi ^ m11;</span>
Character( CharacterTable( "M11" ), [ 66, 10, 3, 2, 1, 1, 0, 0, 0, 0 
 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Determinant( irrs5[4] );</span>
Character( CharacterTable( "A5.2" ), [ 1, 1, 1, 1, -1, -1, -1 ] )
</pre></div>

<p>Functions that compute <em>normal</em> subgroups related to characters have counterparts that return the list of class positions corresponding to these groups.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassPositionsOfKernel( irrs5[2] );</span>
[ 1, 2, 3, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassPositionsOfCentre( irrs5[2] );</span>
[ 1, 2, 3, 4, 5, 6, 7 ]
</pre></div>

<p>Non-normal subgroups cannot be described this way, so for example inertia subgroups (see <code class="func">InertiaSubgroup</code> (<a href="chap72.html#X7C3187387C2D9938"><span class="RefLink">72.8-13</span></a>)) can in general not be computed from character tables without access to their groups.</p>

<p><a id="X7E75A70F7BF00A0D" name="X7E75A70F7BF00A0D"></a></p>

<h5>72.1-1 IsClassFunction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsClassFunction</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>A <em>class function</em> (in characteristic <span class="SimpleMath">p</span>) of a finite group <span class="SimpleMath">G</span> is a map from the set of (<span class="SimpleMath">p</span>-regular) elements in <span class="SimpleMath">G</span> to the field of cyclotomics that is constant on conjugacy classes of <span class="SimpleMath">G</span>.</p>

<p>Each class function in <strong class="pkg">GAP</strong> is represented by an <em>immutable list</em>, where at the <span class="SimpleMath">i</span>-th position the value on the <span class="SimpleMath">i</span>-th conjugacy class of the character table of <span class="SimpleMath">G</span> is stored. The ordering of the conjugacy classes is the one used in the underlying character table. Note that if the character table has access to its underlying group then the ordering of conjugacy classes in the group and in the character table may differ (see <a href="chap71.html#X793E0EBF84B07313"><span class="RefLink">71.6</span></a>); class functions always refer to the ordering of classes in the character table.</p>

<p><em>Class function objects</em> in <strong class="pkg">GAP</strong> are not just plain lists, they store the character table of the group <span class="SimpleMath">G</span> as value of the attribute <code class="func">UnderlyingCharacterTable</code> (<a href="chap72.html#X81B55C067D123B76"><span class="RefLink">72.2-1</span></a>). The group <span class="SimpleMath">G</span> itself is accessible only via the character table and thus only if the character table stores its group, as value of the attribute <code class="func">UnderlyingGroup</code> (<a href="chap71.html#X7FF4826A82B667AF"><span class="RefLink">71.6-1</span></a>). The reason for this is that many computations with class functions are possible without using their groups, for example class functions of character tables in the <strong class="pkg">GAP</strong> character table library do in general not have access to their underlying groups.</p>

<p>There are (at least) two reasons why class functions in <strong class="pkg">GAP</strong> are <em>not</em> implemented as mappings. First, we want to distinguish class functions in different characteristics, for example to be able to define the Frobenius character of a given Brauer character; viewed as mappings, the trivial characters in all characteristics coprime to the order of <span class="SimpleMath">G</span> are equal. Second, the product of two class functions shall be again a class function, whereas the product of general mappings is defined as composition.</p>

<p>A further argument is that the typical operations for mappings such as <code class="func">Image</code> (<a href="chap32.html#X87F4D35A826599C6"><span class="RefLink">32.4-6</span></a>) and <code class="func">PreImage</code> (<a href="chap32.html#X836FAEAC78B55BF4"><span class="RefLink">32.5-6</span></a>) play no important role for class functions.</p>

<p><a id="X8192EDDB84ADD46E" name="X8192EDDB84ADD46E"></a></p>

<h4>72.2 <span class="Heading">Basic Operations for Class Functions</span></h4>

<p>Basic operations for class functions are <code class="func">UnderlyingCharacterTable</code> (<a href="chap72.html#X81B55C067D123B76"><span class="RefLink">72.2-1</span></a>), <code class="func">ValuesOfClassFunction</code> (<a href="chap72.html#X7FE14712843C6486"><span class="RefLink">72.2-2</span></a>), and the basic operations for lists (see <a href="chap21.html#X7B202D147A5C2884"><span class="RefLink">21.2</span></a>).</p>

<p><a id="X81B55C067D123B76" name="X81B55C067D123B76"></a></p>

<h5>72.2-1 UnderlyingCharacterTable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingCharacterTable</code>( <var class="Arg">psi</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For a class function <var class="Arg">psi</var> of the group <span class="SimpleMath">G</span>, say, the character table of <span class="SimpleMath">G</span> is stored as value of <code class="func">UnderlyingCharacterTable</code>. The ordering of entries in the list <var class="Arg">psi</var> (see <code class="func">ValuesOfClassFunction</code> (<a href="chap72.html#X7FE14712843C6486"><span class="RefLink">72.2-2</span></a>)) refers to the ordering of conjugacy classes in this character table.</p>

<p>If <var class="Arg">psi</var> is an ordinary class function then the underlying character table is the ordinary character table of <span class="SimpleMath">G</span> (see <code class="func">OrdinaryCharacterTable</code> (<a href="chap71.html#X8011EEB684848039"><span class="RefLink">71.8-4</span></a>)), if <var class="Arg">psi</var> is a class function in characteristic <span class="SimpleMath">p ≠ 0</span> then the underlying character table is the <span class="SimpleMath">p</span>-modular Brauer table of <span class="SimpleMath">G</span> (see <code class="func">BrauerTable</code> (<a href="chap71.html#X8476B25A79D7A7FC"><span class="RefLink">71.3-2</span></a>)). So the underlying characteristic of <var class="Arg">psi</var> can be read off from the underlying character table.</p>

<p><a id="X7FE14712843C6486" name="X7FE14712843C6486"></a></p>

<h5>72.2-2 ValuesOfClassFunction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ValuesOfClassFunction</code>( <var class="Arg">psi</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>is the list of values of the class function <var class="Arg">psi</var>, the <span class="SimpleMath">i</span>-th entry being the value on the <span class="SimpleMath">i</span>-th conjugacy class of the underlying character table (see <code class="func">UnderlyingCharacterTable</code> (<a href="chap72.html#X81B55C067D123B76"><span class="RefLink">72.2-1</span></a>)).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= SymmetricGroup( 4 );</span>
Sym( [ 1 .. 4 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">psi:= TrivialCharacter( g );</span>
Character( CharacterTable( Sym( [ 1 .. 4 ] ) ), [ 1, 1, 1, 1, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingCharacterTable( psi );</span>
CharacterTable( Sym( [ 1 .. 4 ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ValuesOfClassFunction( psi );</span>
[ 1, 1, 1, 1, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsList( psi );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">psi[1];</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( psi );</span>
5
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsBound( psi[6] );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Concatenation( psi, [ 2, 3 ] );</span>
[ 1, 1, 1, 1, 1, 2, 3 ]
</pre></div>

<p><a id="X829EFBF57FCB1A94" name="X829EFBF57FCB1A94"></a></p>

<h4>72.3 <span class="Heading">Comparison of Class Functions</span></h4>

<p>With respect to <code class="func">\=</code> (<a href="chap31.html#X7EF67D047F03CA6F"><span class="RefLink">31.11-1</span></a>) and <code class="func">\&lt;</code> (<a href="chap31.html#X7EF67D047F03CA6F"><span class="RefLink">31.11-1</span></a>), class functions behave equally to their lists of values (see <code class="func">ValuesOfClassFunction</code> (<a href="chap72.html#X7FE14712843C6486"><span class="RefLink">72.2-2</span></a>)). So two class functions are equal if and only if their lists of values are equal, no matter whether they are class functions of the same character table, of the same group but w.r.t. different class ordering, or of different groups.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">grps:= Filtered( AllSmallGroups( 8 ), g -&gt; not IsAbelian( g ) );</span>
[ &lt;pc group of size 8 with 3 generators&gt;, 
  &lt;pc group of size 8 with 3 generators&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t1:= CharacterTable( grps[1] );  SetName( t1, "t1" );</span>
CharacterTable( &lt;pc group of size 8 with 3 generators&gt; )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t2:= CharacterTable( grps[2] );  SetName( t2, "t2" );</span>
CharacterTable( &lt;pc group of size 8 with 3 generators&gt; )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irr1:= Irr( grps[1] );</span>
[ Character( t1, [ 1, 1, 1, 1, 1 ] ), 
  Character( t1, [ 1, -1, -1, 1, 1 ] ), 
  Character( t1, [ 1, -1, 1, 1, -1 ] ), 
  Character( t1, [ 1, 1, -1, 1, -1 ] ), 
  Character( t1, [ 2, 0, 0, -2, 0 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irr2:= Irr( grps[2] );</span>
[ Character( t2, [ 1, 1, 1, 1, 1 ] ), 
  Character( t2, [ 1, -1, -1, 1, 1 ] ), 
  Character( t2, [ 1, -1, 1, 1, -1 ] ), 
  Character( t2, [ 1, 1, -1, 1, -1 ] ), 
  Character( t2, [ 2, 0, 0, -2, 0 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irr1 = irr2;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSSortedList( irr1 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irr1[1] &lt; irr1[2];</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irr1[2] &lt; irr1[3];</span>
true
</pre></div>

<p><a id="X83B9F0C5871A5F7F" name="X83B9F0C5871A5F7F"></a></p>

<h4>72.4 <span class="Heading">Arithmetic Operations for Class Functions</span></h4>

<p>Class functions are <em>row vectors</em> of cyclotomics. The <em>additive</em> behaviour of class functions is defined such that they are equal to the plain lists of class function values except that the results are represented again as class functions whenever this makes sense. The <em>multiplicative</em> behaviour, however, is different. This is motivated by the fact that the tensor product of class functions is a more interesting operation than the vector product of plain lists. (Another candidate for a multiplication of compatible class functions would have been the inner product, which is implemented via the function <code class="func">ScalarProduct</code> (<a href="chap72.html#X855FD9F983D275CD"><span class="RefLink">72.8-5</span></a>). In terms of filters, the arithmetic of class functions is based on the decision that they lie in <code class="func">IsGeneralizedRowVector</code> (<a href="chap21.html#X87ABCEE9809585A0"><span class="RefLink">21.12-1</span></a>), with additive nesting depth <span class="SimpleMath">1</span>, but they do <em>not</em> lie in <code class="func">IsMultiplicativeGeneralizedRowVector</code> (<a href="chap21.html#X7FBCA5B58308C158"><span class="RefLink">21.12-2</span></a>).</p>

<p>More specifically, the scalar multiple of a class function with a cyclotomic is a class function, and the sum and the difference of two class functions of the same underlying character table (see <code class="func">UnderlyingCharacterTable</code> (<a href="chap72.html#X81B55C067D123B76"><span class="RefLink">72.2-1</span></a>)) are again class functions of this table. The sum and the difference of a class function and a list that is <em>not</em> a class function are plain lists, as well as the sum and the difference of two class functions of different character tables.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= SymmetricGroup( 4 );;  tbl:= CharacterTable( g );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( tbl, "S4" );  irr:= Irr( g );</span>
[ Character( S4, [ 1, -1, 1, 1, -1 ] ), 
  Character( S4, [ 3, -1, -1, 0, 1 ] ), 
  Character( S4, [ 2, 0, 2, -1, 0 ] ), 
  Character( S4, [ 3, 1, -1, 0, -1 ] ), 
  Character( S4, [ 1, 1, 1, 1, 1 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2 * irr[5];</span>
Character( S4, [ 2, 2, 2, 2, 2 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irr[1] / 7;</span>
ClassFunction( S4, [ 1/7, -1/7, 1/7, 1/7, -1/7 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lincomb:= irr[3] + irr[1] - irr[5];</span>
VirtualCharacter( S4, [ 2, -2, 2, -1, -2 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lincomb:= lincomb + 2 * irr[5];</span>
VirtualCharacter( S4, [ 4, 0, 4, 1, 0 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCharacter( lincomb );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lincomb;</span>
Character( S4, [ 4, 0, 4, 1, 0 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irr[5] + 2;</span>
[ 3, 3, 3, 3, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irr[5] + [ 1, 2, 3, 4, 5 ];</span>
[ 2, 3, 4, 5, 6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">zero:= 0 * irr[1];</span>
VirtualCharacter( S4, [ 0, 0, 0, 0, 0 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">zero + Z(3);</span>
[ Z(3), Z(3), Z(3), Z(3), Z(3) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irr[5] + TrivialCharacter( DihedralGroup( 8 ) );</span>
[ 2, 2, 2, 2, 2 ]
</pre></div>

<p>The product of two class functions of the same character table is the tensor product (pointwise product) of these class functions. Thus the set of all class functions of a fixed group forms a ring, and for any field <span class="SimpleMath">F</span> of cyclotomics, the <span class="SimpleMath">F</span>-span of a given set of class functions forms an algebra.</p>

<p>The product of two class functions of <em>different</em> tables and the product of a class function and a list that is <em>not</em> a class function are not defined, an error is signalled in these cases. Note that in this respect, class functions behave differently from their values lists, for which the product is defined as the standard scalar product.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tens:= irr[3] * irr[4];</span>
Character( S4, [ 6, 0, -2, 0, 0 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ValuesOfClassFunction( irr[3] ) * ValuesOfClassFunction( irr[4] );</span>
4
</pre></div>

<p>Class functions without zero values are invertible, the <em>inverse</em> is defined pointwise. As a consequence, for example groups of linear characters can be formed.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tens / irr[1];</span>
Character( S4, [ 6, 0, -2, 0, 0 ] )
</pre></div>

<p>Other (somewhat strange) implications of the definition of arithmetic operations for class functions, together with the general rules of list arithmetic (see <a href="chap21.html#X845EEAF083D43CCE"><span class="RefLink">21.11</span></a>), apply to the case of products involving <em>lists</em> of class functions. No inverse of the list of irreducible characters as a matrix is defined; if one is interested in the inverse matrix then one can compute it from the matrix of class function values.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Inverse( List( irr, ValuesOfClassFunction ) );</span>
[ [ 1/24, 1/8, 1/12, 1/8, 1/24 ], [ -1/4, -1/4, 0, 1/4, 1/4 ], 
  [ 1/8, -1/8, 1/4, -1/8, 1/8 ], [ 1/3, 0, -1/3, 0, 1/3 ], 
  [ -1/4, 1/4, 0, -1/4, 1/4 ] ]
</pre></div>

<p>Also the product of a class function with a list of class functions is <em>not</em> a vector-matrix product but the list of pointwise products.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irr[1] * irr{ [ 1 .. 3 ] };</span>
[ Character( S4, [ 1, 1, 1, 1, 1 ] ), 
  Character( S4, [ 3, 1, -1, 0, -1 ] ), 
  Character( S4, [ 2, 0, 2, -1, 0 ] ) ]
</pre></div>

<p>And the product of two lists of class functions is <em>not</em> the matrix product but the sum of the pointwise products.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irr * irr;</span>
Character( S4, [ 24, 4, 8, 3, 4 ] )
</pre></div>

<p>The <em>powering</em> operator <code class="func">\^</code> (<a href="chap31.html#X8481C9B97B214C23"><span class="RefLink">31.12-1</span></a>) has several meanings for class functions. The power of a class function by a nonnegative integer is clearly the tensor power. The power of a class function by an element that normalizes the underlying group or by a Galois automorphism is the conjugate class function. (As a consequence, the application of the permutation induced by such an action cannot be denoted by <code class="func">\^</code> (<a href="chap31.html#X8481C9B97B214C23"><span class="RefLink">31.12-1</span></a>); instead one can use <code class="func">Permuted</code> (<a href="chap21.html#X7B5A19098406347A"><span class="RefLink">21.20-18</span></a>).) The power of a class function by a group or a character table is the induced class function (see <code class="func">InducedClassFunction</code> (<a href="chap72.html#X7FE39D3D78855D3B"><span class="RefLink">72.9-3</span></a>)). The power of a group element by a class function is the class function value at (the conjugacy class containing) this element.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irr[3] ^ 3;</span>
Character( S4, [ 8, 0, 8, -1, 0 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lin:= LinearCharacters( DerivedSubgroup( g ) );</span>
[ Character( CharacterTable( Alt( [ 1 .. 4 ] ) ), [ 1, 1, 1, 1 ] ), 
  Character( CharacterTable( Alt( [ 1 .. 4 ] ) ),
  [ 1, 1, E(3), E(3)^2 ] ),
  Character( CharacterTable( Alt( [ 1 .. 4 ] ) ),
  [ 1, 1, E(3)^2, E(3) ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( lin, chi -&gt; chi ^ (1,2) );</span>
[ Character( CharacterTable( Alt( [ 1 .. 4 ] ) ), [ 1, 1, 1, 1 ] ), 
  Character( CharacterTable( Alt( [ 1 .. 4 ] ) ),
  [ 1, 1, E(3)^2, E(3) ] ),
  Character( CharacterTable( Alt( [ 1 .. 4 ] ) ),
  [ 1, 1, E(3), E(3)^2 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Orbit( GaloisGroup( CF(3) ), lin[2] );</span>
[ Character( CharacterTable( Alt( [ 1 .. 4 ] ) ),
  [ 1, 1, E(3), E(3)^2 ] ),
  Character( CharacterTable( Alt( [ 1 .. 4 ] ) ),
  [ 1, 1, E(3)^2, E(3) ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lin[1]^g;</span>
Character( S4, [ 2, 0, 2, 2, 0 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">(1,2,3)^lin[2];</span>
E(3)
</pre></div>

<p><a id="X83AAD5527BBAFA03" name="X83AAD5527BBAFA03"></a></p>

<h5>72.4-1 Characteristic</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Characteristic</code>( <var class="Arg">chi</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The <em>characteristic</em> of class functions is zero, as for all list of cyclotomics. For class functions of a <span class="SimpleMath">p</span>-modular character table, such as Brauer characters, the prime <span class="SimpleMath">p</span> is given by the <code class="func">UnderlyingCharacteristic</code> (<a href="chap71.html#X7F58A82F7D88000A"><span class="RefLink">71.9-5</span></a>) value of the character table.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Characteristic( irr[1] );</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irrmod2:= Irr( g, 2 );</span>
[ Character( BrauerTable( Sym( [ 1 .. 4 ] ), 2 ), [ 1, 1 ] ), 
  Character( BrauerTable( Sym( [ 1 .. 4 ] ), 2 ), [ 2, -1 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Characteristic( irrmod2[1] );</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingCharacteristic( UnderlyingCharacterTable( irrmod2[1] ) );</span>
2
</pre></div>

<p><a id="X856AB97E785E0B04" name="X856AB97E785E0B04"></a></p>

<h5>72.4-2 ComplexConjugate</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ComplexConjugate</code>( <var class="Arg">chi</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GaloisCyc</code>( <var class="Arg">chi</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Permuted</code>( <var class="Arg">chi</var>, <var class="Arg">pi</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>The operations <code class="func">ComplexConjugate</code>, <code class="func">GaloisCyc</code>, and <code class="func">Permuted</code> return a class function when they are called with a class function; The complex conjugate of a class function that is known to be a (virtual) character is again known to be a (virtual) character, and applying an arbitrary Galois automorphism to an ordinary (virtual) character yields a (virtual) character.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ComplexConjugate( lin[2] );</span>
Character( CharacterTable( Alt( [ 1 .. 4 ] ) ),
 [ 1, 1, E(3)^2, E(3) ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GaloisCyc( lin[2], 5 );</span>
Character( CharacterTable( Alt( [ 1 .. 4 ] ) ),
 [ 1, 1, E(3)^2, E(3) ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Permuted( lin[2], (2,3,4) );</span>
ClassFunction( CharacterTable( Alt( [ 1 .. 4 ] ) ),
 [ 1, E(3)^2, 1, E(3) ] )
</pre></div>

<p><a id="X7BCE99B88285EB39" name="X7BCE99B88285EB39"></a></p>

<h5>72.4-3 Order</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Order</code>( <var class="Arg">chi</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>By definition of <code class="func">Order</code> (<a href="chap31.html#X84F59A2687C62763"><span class="RefLink">31.10-10</span></a>) for arbitrary monoid elements, the return value of <code class="func">Order</code> (<a href="chap31.html#X84F59A2687C62763"><span class="RefLink">31.10-10</span></a>) for a character must be its multiplicative order. The <em>determinantal order</em> (see <code class="func">DeterminantOfCharacter</code> (<a href="chap72.html#X7A292A58827B95B8"><span class="RefLink">72.8-18</span></a>)) of a character <var class="Arg">chi</var> can be computed as <code class="code">Order( Determinant( <var class="Arg">chi</var> ) )</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">det:= Determinant( irr[3] );</span>
Character( S4, [ 1, -1, 1, 1, -1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order( det );</span>
2
</pre></div>

<p><a id="X828AD0C57EA57C21" name="X828AD0C57EA57C21"></a></p>

<h4>72.5 <span class="Heading">Printing Class Functions</span></h4>

<p><a id="X7BDD2D4A7F7FB3B1" name="X7BDD2D4A7F7FB3B1"></a></p>

<h5>72.5-1 ViewObj</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ViewObj</code>( <var class="Arg">chi</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>The default <code class="func">ViewObj</code> (<a href="chap6.html#X815BF22186FD43C9"><span class="RefLink">6.3-5</span></a>) methods for class functions print one of the strings <code class="code">"ClassFunction"</code>, <code class="code">"VirtualCharacter"</code>, <code class="code">"Character"</code> (depending on whether the class function is known to be a character or virtual character, see <code class="func">IsCharacter</code> (<a href="chap72.html#X7FE3CD08794051F8"><span class="RefLink">72.8-1</span></a>), <code class="func">IsVirtualCharacter</code> (<a href="chap72.html#X788DD05C86CB7030"><span class="RefLink">72.8-2</span></a>)), followed by the <code class="func">ViewObj</code> (<a href="chap6.html#X815BF22186FD43C9"><span class="RefLink">6.3-5</span></a>) output for the underlying character table (see <a href="chap71.html#X7C1941F17BE9FC21"><span class="RefLink">71.13</span></a>), and the list of values. The table is chosen (and not the group) in order to distinguish class functions of different underlying characteristic (see <code class="func">UnderlyingCharacteristic</code> (<a href="chap71.html#X7F58A82F7D88000A"><span class="RefLink">71.9-5</span></a>)).</p>

<p><a id="X871160B98595D4BA" name="X871160B98595D4BA"></a></p>

<h5>72.5-2 PrintObj</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PrintObj</code>( <var class="Arg">chi</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>The default <code class="func">PrintObj</code> (<a href="chap6.html#X815BF22186FD43C9"><span class="RefLink">6.3-5</span></a>) method for class functions does the same as <code class="func">ViewObj</code> (<a href="chap6.html#X815BF22186FD43C9"><span class="RefLink">6.3-5</span></a>), except that the character table is is <code class="func">Print</code> (<a href="chap6.html#X7AFA64D97A1F39A3"><span class="RefLink">6.3-4</span></a>)-ed instead of <code class="func">View</code> (<a href="chap6.html#X851902C583B84CDC"><span class="RefLink">6.3-3</span></a>)-ed.</p>

<p><em>Note</em> that if a class function is shown only with one of the strings <code class="code">"ClassFunction"</code>, <code class="code">"VirtualCharacter"</code>, it may still be that it is in fact a character; just this was not known at the time when the class function was printed.</p>

<p>In order to reduce the space that is needed to print a class function, it may be useful to give a name (see <code class="func">Name</code> (<a href="chap12.html#X7F14EF9D81432113"><span class="RefLink">12.8-2</span></a>)) to the underlying character table.</p>

<p><a id="X8430D31B8163C230" name="X8430D31B8163C230"></a></p>

<h5>72.5-3 Display</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Display</code>( <var class="Arg">chi</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>The default <code class="func">Display</code> (<a href="chap6.html#X83A5C59278E13248"><span class="RefLink">6.3-6</span></a>) method for a class function <var class="Arg">chi</var> calls <code class="func">Display</code> (<a href="chap6.html#X83A5C59278E13248"><span class="RefLink">6.3-6</span></a>) for its underlying character table (see <a href="chap71.html#X7C1941F17BE9FC21"><span class="RefLink">71.13</span></a>), with <var class="Arg">chi</var> as the only entry in the <code class="code">chars</code> list of the options record.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chi:= TrivialCharacter( CharacterTable( "A5" ) );</span>
Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( chi );</span>
A5

     2  2  2  .  .  .
     3  1  .  1  .  .
     5  1  .  .  1  1

       1a 2a 3a 5a 5b
    2P 1a 1a 3a 5b 5a
    3P 1a 2a 1a 5b 5a
    5P 1a 2a 3a 1a 1a

Y.1     1  1  1  1  1
</pre></div>

<p><a id="X7BB90A8F86FFA456" name="X7BB90A8F86FFA456"></a></p>

<h4>72.6 <span class="Heading">Creating Class Functions from Values Lists</span></h4>

<p><a id="X78F4E23985FCA259" name="X78F4E23985FCA259"></a></p>

<h5>72.6-1 ClassFunction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassFunction</code>( <var class="Arg">tbl</var>, <var class="Arg">values</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassFunction</code>( <var class="Arg">G</var>, <var class="Arg">values</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>In the first form, <code class="func">ClassFunction</code> returns the class function of the character table <var class="Arg">tbl</var> with values given by the list <var class="Arg">values</var> of cyclotomics. In the second form, <var class="Arg">G</var> must be a group, and the class function of its ordinary character table is returned.</p>

<p>Note that <var class="Arg">tbl</var> determines the underlying characteristic of the returned class function (see <code class="func">UnderlyingCharacteristic</code> (<a href="chap71.html#X7F58A82F7D88000A"><span class="RefLink">71.9-5</span></a>)).</p>

<p><a id="X7805AFF77EFC3306" name="X7805AFF77EFC3306"></a></p>

<h5>72.6-2 VirtualCharacter</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VirtualCharacter</code>( <var class="Arg">tbl</var>, <var class="Arg">values</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VirtualCharacter</code>( <var class="Arg">G</var>, <var class="Arg">values</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p><code class="func">VirtualCharacter</code> returns the virtual character (see <code class="func">IsVirtualCharacter</code> (<a href="chap72.html#X788DD05C86CB7030"><span class="RefLink">72.8-2</span></a>)) of the character table <var class="Arg">tbl</var> or the group <var class="Arg">G</var>, respectively, with values given by the list <var class="Arg">values</var>.</p>

<p>It is <em>not</em> checked whether the given values really describe a virtual character.</p>

<p><a id="X849DD34C7968206C" name="X849DD34C7968206C"></a></p>

<h5>72.6-3 Character</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Character</code>( <var class="Arg">tbl</var>, <var class="Arg">values</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Character</code>( <var class="Arg">G</var>, <var class="Arg">values</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p><code class="func">Character</code> returns the character (see <code class="func">IsCharacter</code> (<a href="chap72.html#X7FE3CD08794051F8"><span class="RefLink">72.8-1</span></a>)) of the character table <var class="Arg">tbl</var> or the group <var class="Arg">G</var>, respectively, with values given by the list <var class="Arg">values</var>.</p>

<p>It is <em>not</em> checked whether the given values really describe a character.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= DihedralGroup( 8 );  tbl:= CharacterTable( g );</span>
&lt;pc group of size 8 with 3 generators&gt;
CharacterTable( &lt;pc group of size 8 with 3 generators&gt; )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( tbl, "D8" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi:= ClassFunction( g, [ 1, -1, 0, 2, -2 ] );</span>
ClassFunction( D8, [ 1, -1, 0, 2, -2 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">psi:= ClassFunction( tbl,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             List( Irr( g ), chi -&gt; ScalarProduct( chi, phi ) ) );</span>
ClassFunction( D8, [ -3/8, 9/8, 5/8, 1/8, -1/4 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chi:= VirtualCharacter( g, [ 0, 0, 8, 0, 0 ] );</span>
VirtualCharacter( D8, [ 0, 0, 8, 0, 0 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">reg:= Character( tbl, [ 8, 0, 0, 0, 0 ] );</span>
Character( D8, [ 8, 0, 0, 0, 0 ] )
</pre></div>

<p><a id="X7B38035981D71B1B" name="X7B38035981D71B1B"></a></p>

<h5>72.6-4 ClassFunctionSameType</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassFunctionSameType</code>( <var class="Arg">tbl</var>, <var class="Arg">chi</var>, <var class="Arg">values</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">tbl</var> be a character table, <var class="Arg">chi</var> a class function object (<em>not</em> necessarily a class function of <var class="Arg">tbl</var>), and <var class="Arg">values</var> a list of cyclotomics. <code class="func">ClassFunctionSameType</code> returns the class function <span class="SimpleMath">ψ</span> of <var class="Arg">tbl</var> with values list <var class="Arg">values</var>, constructed with <code class="func">ClassFunction</code> (<a href="chap72.html#X78F4E23985FCA259"><span class="RefLink">72.6-1</span></a>).</p>

<p>If <var class="Arg">chi</var> is known to be a (virtual) character then <span class="SimpleMath">ψ</span> is also known to be a (virtual) character.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h:= Centre( g );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">centbl:= CharacterTable( h );;  SetName( centbl, "C2" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassFunctionSameType( centbl, phi, [ 1, 1 ] );</span>
ClassFunction( C2, [ 1, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassFunctionSameType( centbl, chi, [ 1, 1 ] );</span>
VirtualCharacter( C2, [ 1, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassFunctionSameType( centbl, reg, [ 1, 1 ] );</span>
Character( C2, [ 1, 1 ] )
</pre></div>

<p><a id="X8727C2CB7ABEBC84" name="X8727C2CB7ABEBC84"></a></p>

<h4>72.7 <span class="Heading">Creating Class Functions using Groups</span></h4>

<p><a id="X86129DC37C55E4D6" name="X86129DC37C55E4D6"></a></p>

<h5>72.7-1 <span class="Heading">TrivialCharacter</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TrivialCharacter</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TrivialCharacter</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>is the <em>trivial character</em> of the group <var class="Arg">G</var> or its character table <var class="Arg">tbl</var>, respectively. This is the class function with value equal to <span class="SimpleMath">1</span> for each class.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TrivialCharacter( CharacterTable( "A5" ) );</span>
Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TrivialCharacter( SymmetricGroup( 3 ) );</span>
Character( CharacterTable( Sym( [ 1 .. 3 ] ) ), [ 1, 1, 1 ] )
</pre></div>

<p><a id="X82C01DDB82D751A9" name="X82C01DDB82D751A9"></a></p>

<h5>72.7-2 NaturalCharacter</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalCharacter</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalCharacter</code>( <var class="Arg">hom</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>If the argument is a permutation group <var class="Arg">G</var> then <code class="func">NaturalCharacter</code> returns the (ordinary) character of the natural permutation representation of <var class="Arg">G</var> on the set of moved points (see <code class="func">MovedPoints</code> (<a href="chap42.html#X85E61B9C7A6B0CCA"><span class="RefLink">42.3-3</span></a>)), that is, the value on each class is the number of points among the moved points of <var class="Arg">G</var> that are fixed by any permutation in that class.</p>

<p>If the argument is a matrix group <var class="Arg">G</var> in characteristic zero then <code class="func">NaturalCharacter</code> returns the (ordinary) character of the natural matrix representation of <var class="Arg">G</var>, that is, the value on each class is the trace of any matrix in that class.</p>

<p>If the argument is a group homomorphism <var class="Arg">hom</var> whose image is a permutation group or a matrix group then <code class="func">NaturalCharacter</code> returns the restriction of the natural character of the image of <var class="Arg">hom</var> to the preimage of <var class="Arg">hom</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NaturalCharacter( SymmetricGroup( 3 ) );</span>
Character( CharacterTable( Sym( [ 1 .. 3 ] ) ), [ 3, 1, 0 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NaturalCharacter( Group( [ [ 0, -1 ], [ 1, -1 ] ] ) );</span>
Character( CharacterTable( Group([ [ [ 0, -1 ], [ 1, -1 ] ] ]) ), 
[ 2, -1, -1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d8:= DihedralGroup( 8 );;  hom:= IsomorphismPermGroup( d8 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NaturalCharacter( hom );</span>
Character( CharacterTable( &lt;pc group of size 8 with 3 generators&gt; ), 
[ 8, 0, 0, 0, 0 ] )
</pre></div>

<p><a id="X7938621F81B65E03" name="X7938621F81B65E03"></a></p>

<h5>72.7-3 <span class="Heading">PermutationCharacter</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PermutationCharacter</code>( <var class="Arg">G</var>, <var class="Arg">D</var>, <var class="Arg">opr</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PermutationCharacter</code>( <var class="Arg">G</var>, <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Called with a group <var class="Arg">G</var>, an action domain or proper set <var class="Arg">D</var>, and an action function <var class="Arg">opr</var> (see Chapter <a href="chap41.html#X87115591851FB7F4"><span class="RefLink">41</span></a>), <code class="func">PermutationCharacter</code> returns the <em>permutation character</em> of the action of <var class="Arg">G</var> on <var class="Arg">D</var> via <var class="Arg">opr</var>, that is, the value on each class is the number of points in <var class="Arg">D</var> that are fixed by an element in this class under the action <var class="Arg">opr</var>.</p>

<p>If the arguments are a group <var class="Arg">G</var> and a subgroup <var class="Arg">U</var> of <var class="Arg">G</var> then <code class="func">PermutationCharacter</code> returns the permutation character of the action of <var class="Arg">G</var> on the right cosets of <var class="Arg">U</var> via right multiplication.</p>

<p>To compute the permutation character of a <em>transitive permutation group</em> <var class="Arg">G</var> on the cosets of a point stabilizer <var class="Arg">U</var>, the attribute <code class="func">NaturalCharacter</code> (<a href="chap72.html#X82C01DDB82D751A9"><span class="RefLink">72.7-2</span></a>) of <var class="Arg">G</var> can be used instead of <code class="code">PermutationCharacter( <var class="Arg">G</var>, <var class="Arg">U</var> )</code>.</p>

<p>More facilities concerning permutation characters are the transitivity test (see Section <a href="chap72.html#X86DDB47A7C6B45D0"><span class="RefLink">72.8</span></a>) and several tools for computing possible permutation characters (see <a href="chap72.html#X7D6336857E6BDF46"><span class="RefLink">72.13</span></a>, <a href="chap72.html#X8330FDCE83D3DED3"><span class="RefLink">72.14</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PermutationCharacter( GL(2,2), AsSSortedList( GF(2)^2 ), OnRight );</span>
Character( CharacterTable( SL(2,2) ), [ 4, 2, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s3:= SymmetricGroup( 3 );;  a3:= DerivedSubgroup( s3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PermutationCharacter( s3, a3 );</span>
Character( CharacterTable( Sym( [ 1 .. 3 ] ) ), [ 2, 0, 2 ] )
</pre></div>

<p><a id="X86DDB47A7C6B45D0" name="X86DDB47A7C6B45D0"></a></p>

<h4>72.8 <span class="Heading">Operations for Class Functions</span></h4>

<p>In the description of the following operations, the optional first argument <var class="Arg">tbl</var> is needed only if the argument <var class="Arg">chi</var> is a plain list and not a class function object. In this case, <var class="Arg">tbl</var> must always be the character table of which <var class="Arg">chi</var> shall be regarded as a class function.</p>

<p><a id="X7FE3CD08794051F8" name="X7FE3CD08794051F8"></a></p>

<h5>72.8-1 IsCharacter</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCharacter</code>( [<var class="Arg">tbl</var>, ]<var class="Arg">chi</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>An <em>ordinary character</em> of a group <span class="SimpleMath">G</span> is a class function of <span class="SimpleMath">G</span> whose values are the traces of a complex matrix representation of <span class="SimpleMath">G</span>.</p>

<p>A <em>Brauer character</em> of <span class="SimpleMath">G</span> in characteristic <span class="SimpleMath">p</span> is a class function of <span class="SimpleMath">G</span> whose values are the complex lifts of a matrix representation of <span class="SimpleMath">G</span> with image a finite field of characteristic <span class="SimpleMath">p</span>.</p>

<p><a id="X788DD05C86CB7030" name="X788DD05C86CB7030"></a></p>

<h5>72.8-2 IsVirtualCharacter</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsVirtualCharacter</code>( [<var class="Arg">tbl</var>, ]<var class="Arg">chi</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>A <em>virtual character</em> is a class function that can be written as the difference of two proper characters (see <code class="func">IsCharacter</code> (<a href="chap72.html#X7FE3CD08794051F8"><span class="RefLink">72.8-1</span></a>)).</p>

<p><a id="X79A4B1D3870C8807" name="X79A4B1D3870C8807"></a></p>

<h5>72.8-3 IsIrreducibleCharacter</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsIrreducibleCharacter</code>( [<var class="Arg">tbl</var>, ]<var class="Arg">chi</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>A character is <em>irreducible</em> if it cannot be written as the sum of two characters. For ordinary characters this can be checked using the scalar product of class functions (see <code class="func">ScalarProduct</code> (<a href="chap72.html#X855FD9F983D275CD"><span class="RefLink">72.8-5</span></a>)). For Brauer characters there is no generic method for checking irreducibility.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S4:= SymmetricGroup( 4 );;  SetName( S4, "S4" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">psi:= ClassFunction( S4, [ 1, 1, 1, -2, 1 ] );</span>
ClassFunction( CharacterTable( S4 ), [ 1, 1, 1, -2, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsVirtualCharacter( psi );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCharacter( psi );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chi:= ClassFunction( S4, SizesCentralizers( CharacterTable( S4 ) ) );</span>
ClassFunction( CharacterTable( S4 ), [ 24, 4, 8, 3, 4 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCharacter( chi );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIrreducibleCharacter( chi );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIrreducibleCharacter( TrivialCharacter( S4 ) );</span>
true
</pre></div>

<p><a id="X7802BC157C69DD75" name="X7802BC157C69DD75"></a></p>

<h5>72.8-4 DegreeOfCharacter</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DegreeOfCharacter</code>( <var class="Arg">chi</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>is the value of the character <var class="Arg">chi</var> on the identity element. This can also be obtained as <var class="Arg">chi</var><code class="code">[1]</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( Irr( S4 ), DegreeOfCharacter );</span>
[ 1, 3, 2, 3, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nat:= NaturalCharacter( S4 );</span>
Character( CharacterTable( S4 ), [ 4, 2, 0, 1, 0 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nat[1];</span>
4
</pre></div>

<p><a id="X855FD9F983D275CD" name="X855FD9F983D275CD"></a></p>

<h5>72.8-5 ScalarProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ScalarProduct</code>( [<var class="Arg">tbl</var>, ]<var class="Arg">chi</var>, <var class="Arg">psi</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: the scalar product of the class functions <var class="Arg">chi</var> and <var class="Arg">psi</var>, which belong to the same character table <var class="Arg">tbl</var>.</p>

<p>If <var class="Arg">chi</var> and <var class="Arg">psi</var> are class function objects, the argument <var class="Arg">tbl</var> is not needed, but <var class="Arg">tbl</var> is necessary if at least one of <var class="Arg">chi</var>, <var class="Arg">psi</var> is just a plain list.</p>

<p>The scalar product of two <em>ordinary</em> class functions <span class="SimpleMath">χ</span>, <span class="SimpleMath">ψ</span> of a group <span class="SimpleMath">G</span> is defined as</p>

<p><span class="SimpleMath">( ∑_{g ∈ G} χ(g) ψ(g^{-1}) ) / |G|</span>.</p>

<p>For two <em><span class="SimpleMath">p</span>-modular</em> class functions, the scalar product is defined as <span class="SimpleMath">( ∑_{g ∈ S} χ(g) ψ(g^{-1}) ) / |G|</span>, where <span class="SimpleMath">S</span> is the set of <span class="SimpleMath">p</span>-regular elements in <span class="SimpleMath">G</span>.</p>

<p><a id="X858DF4E67EBB99DA" name="X858DF4E67EBB99DA"></a></p>

<h5>72.8-6 MatScalarProducts</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MatScalarProducts</code>( [<var class="Arg">tbl</var>, ]<var class="Arg">list</var>[, <var class="Arg">list2</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Called with two lists <var class="Arg">list</var>, <var class="Arg">list2</var> of class functions of the same character table (which may be given as the argument <var class="Arg">tbl</var>), <code class="func">MatScalarProducts</code> returns the matrix of scalar products (see <code class="func">ScalarProduct</code> (<a href="chap72.html#X855FD9F983D275CD"><span class="RefLink">72.8-5</span></a>)) More precisely, this matrix contains in the <span class="SimpleMath">i</span>-th row the list of scalar products of <span class="SimpleMath"><var class="Arg">list2</var>[i]</span> with the entries of <var class="Arg">list</var>.</p>

<p>If only one list <var class="Arg">list</var> of class functions is given then a lower triangular matrix of scalar products is returned, containing (for <span class="SimpleMath">j ≤ i</span>) in the <span class="SimpleMath">i</span>-th row in column <span class="SimpleMath">j</span> the value <code class="code">ScalarProduct</code><span class="SimpleMath">( <var class="Arg">tbl</var>, <var class="Arg">list</var>[j], <var class="Arg">list</var>[i] )</span>.</p>

<p><a id="X8572B18A7BAED73E" name="X8572B18A7BAED73E"></a></p>

<h5>72.8-7 Norm</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Norm</code>( [<var class="Arg">tbl</var>, ]<var class="Arg">chi</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For an ordinary class function <var class="Arg">chi</var> of the group <span class="SimpleMath">G</span>, say, we have <span class="SimpleMath"><var class="Arg">chi</var> = ∑_{χ ∈ Irr(G)} a_χ χ</span>, with complex coefficients <span class="SimpleMath">a_χ</span>. The <em>norm</em> of <var class="Arg">chi</var> is defined as <span class="SimpleMath">∑_{χ ∈ Irr(G)} a_χ overline{a_χ}</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( "A5" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ScalarProduct( TrivialCharacter( tbl ), Sum( Irr( tbl ) ) );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ScalarProduct( tbl, [ 1, 1, 1, 1, 1 ], Sum( Irr( tbl ) ) );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl2:= tbl mod 2;  </span>
BrauerTable( "A5", 2 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chi:= Irr( tbl2 )[1];</span>
Character( BrauerTable( "A5", 2 ), [ 1, 1, 1, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ScalarProduct( chi, chi );</span>
3/4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ScalarProduct( tbl2, [ 1, 1, 1, 1 ], [ 1, 1, 1, 1 ] );</span>
3/4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chars:= Irr( tbl ){ [ 2 .. 4 ] };;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chars:= Set( Tensored( chars, chars ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MatScalarProducts( Irr( tbl ), chars );</span>
[ [ 0, 0, 0, 1, 1 ], [ 1, 1, 0, 0, 1 ], [ 1, 0, 1, 0, 1 ], 
  [ 0, 1, 0, 1, 1 ], [ 0, 0, 1, 1, 1 ], [ 1, 1, 1, 1, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MatScalarProducts( tbl, chars );</span>
[ [ 2 ], [ 1, 3 ], [ 1, 2, 3 ], [ 2, 2, 1, 3 ], [ 2, 1, 2, 2, 3 ], 
  [ 2, 3, 3, 3, 3, 5 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( chars, Norm );</span>
[ 2, 3, 3, 3, 3, 5 ]
</pre></div>

<p><a id="X78550D7087DB1181" name="X78550D7087DB1181"></a></p>

<h5>72.8-8 ConstituentsOfCharacter</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConstituentsOfCharacter</code>( [<var class="Arg">tbl</var>, ]<var class="Arg">chi</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">chi</var> be an ordinary or modular (virtual) character. If an ordinary or modular character table <var class="Arg">tbl</var> is given then <var class="Arg">chi</var> may also be a list of character values.</p>

<p><code class="func">ConstituentsOfCharacter</code> returns the set of those irreducible characters that occur in the decomposition of <var class="Arg">chi</var> with nonzero coefficient.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nat:= NaturalCharacter( S4 );</span>
Character( CharacterTable( S4 ), [ 4, 2, 0, 1, 0 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConstituentsOfCharacter( nat );</span>
[ Character( CharacterTable( S4 ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( S4 ), [ 3, 1, -1, 0, -1 ] ) ]
</pre></div>

<p><a id="X7E0A24498710F12B" name="X7E0A24498710F12B"></a></p>

<h5>72.8-9 KernelOfCharacter</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; KernelOfCharacter</code>( [<var class="Arg">tbl</var>, ]<var class="Arg">chi</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For a class function <var class="Arg">chi</var> of the group <span class="SimpleMath">G</span>, say, <code class="func">KernelOfCharacter</code> returns the normal subgroup of <span class="SimpleMath">G</span> that is formed by those conjugacy classes for which the value of <var class="Arg">chi</var> equals the degree of <var class="Arg">chi</var>. If the underlying character table of <var class="Arg">chi</var> does not store the group <span class="SimpleMath">G</span> then an error is signalled. (See <code class="func">ClassPositionsOfKernel</code> (<a href="chap72.html#X7B4708B47D9C05B3"><span class="RefLink">72.8-10</span></a>) for a way to handle the kernel implicitly, by listing the positions of conjugacy classes in the kernel.)</p>

<p>The returned group is the kernel of any representation of <span class="SimpleMath">G</span> that affords <var class="Arg">chi</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( Irr( S4 ), KernelOfCharacter );</span>
[ Alt( [ 1 .. 4 ] ), Group(()), Group([ (1,2)(3,4), (1,4)(2,3) ]),
  Group(()), Group([ (), (1,2), (1,2)(3,4), (1,2,3), (1,2,3,4) ]) ]
</pre></div>

<p><a id="X7B4708B47D9C05B3" name="X7B4708B47D9C05B3"></a></p>

<h5>72.8-10 ClassPositionsOfKernel</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassPositionsOfKernel</code>( <var class="Arg">chi</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>is the list of positions of those conjugacy classes that form the kernel of the character <var class="Arg">chi</var>, that is, those positions with character value equal to the character degree.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( Irr( S4 ), ClassPositionsOfKernel );</span>
[ [ 1, 3, 4 ], [ 1 ], [ 1, 3 ], [ 1 ], [ 1, 2, 3, 4, 5 ] ]
</pre></div>

<p><a id="X7E77D4147A0836D3" name="X7E77D4147A0836D3"></a></p>

<h5>72.8-11 CentreOfCharacter</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CentreOfCharacter</code>( [<var class="Arg">tbl</var>, ]<var class="Arg">chi</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For a character <var class="Arg">chi</var> of the group <span class="SimpleMath">G</span>, say, <code class="func">CentreOfCharacter</code> returns the <em>centre</em> of <var class="Arg">chi</var>, that is, the normal subgroup of all those elements of <span class="SimpleMath">G</span> for which the quotient of the value of <var class="Arg">chi</var> by the degree of <var class="Arg">chi</var> is a root of unity.</p>

<p>If the underlying character table of <var class="Arg">psi</var> does not store the group <span class="SimpleMath">G</span> then an error is signalled. (See <code class="func">ClassPositionsOfCentre</code> (<a href="chap72.html#X7CE5B4137B399274"><span class="RefLink">72.8-12</span></a>) for a way to handle the centre implicitly, by listing the positions of conjugacy classes in the centre.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( Irr( S4 ), CentreOfCharacter );</span>
[ Group([ (), (1,2), (1,2)(3,4), (1,2,3), (1,2,3,4) ]), Group(()),
  Group([ (1,2)(3,4), (1,4)(2,3) ]), Group(()), Group([ (), (1,2), (1,
   2)(3,4), (1,2,3), (1,2,3,4) ]) ]
</pre></div>

<p><a id="X7CE5B4137B399274" name="X7CE5B4137B399274"></a></p>

<h5>72.8-12 ClassPositionsOfCentre</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassPositionsOfCentre</code>( <var class="Arg">chi</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>is the list of positions of classes forming the centre of the character <var class="Arg">chi</var> (see <code class="func">CentreOfCharacter</code> (<a href="chap72.html#X7E77D4147A0836D3"><span class="RefLink">72.8-11</span></a>)).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( Irr( S4 ), ClassPositionsOfCentre );</span>
[ [ 1, 2, 3, 4, 5 ], [ 1 ], [ 1, 3 ], [ 1 ], [ 1, 2, 3, 4, 5 ] ]
</pre></div>

<p><a id="X7C3187387C2D9938" name="X7C3187387C2D9938"></a></p>

<h5>72.8-13 InertiaSubgroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InertiaSubgroup</code>( [<var class="Arg">tbl</var>, ]<var class="Arg">G</var>, <var class="Arg">chi</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">chi</var> be a character of the group <span class="SimpleMath">H</span>, say, and <var class="Arg">tbl</var> the character table of <span class="SimpleMath">H</span>; if the argument <var class="Arg">tbl</var> is not given then the underlying character table of <var class="Arg">chi</var> (see <code class="func">UnderlyingCharacterTable</code> (<a href="chap72.html#X81B55C067D123B76"><span class="RefLink">72.2-1</span></a>)) is used instead. Furthermore, let <var class="Arg">G</var> be a group that contains <span class="SimpleMath">H</span> as a normal subgroup.</p>

<p><code class="func">InertiaSubgroup</code> returns the stabilizer in <var class="Arg">G</var> of <var class="Arg">chi</var>, w.r.t. the action of <var class="Arg">G</var> on the classes of <span class="SimpleMath">H</span> via conjugation. In other words, <code class="func">InertiaSubgroup</code> returns the group of all those elements <span class="SimpleMath">g ∈ <var class="Arg">G</var></span> that satisfy <span class="SimpleMath"><var class="Arg">chi</var>^g = <var class="Arg">chi</var></span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">der:= DerivedSubgroup( S4 );</span>
Alt( [ 1 .. 4 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( Irr( der ), chi -&gt; InertiaSubgroup( S4, chi ) );</span>
[ S4, Alt( [ 1 .. 4 ] ), Alt( [ 1 .. 4 ] ), S4 ]
</pre></div>

<p><a id="X8269BE0079A64D43" name="X8269BE0079A64D43"></a></p>

<h5>72.8-14 CycleStructureClass</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CycleStructureClass</code>( [<var class="Arg">tbl</var>, ]<var class="Arg">chi</var>, <var class="Arg">class</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">permchar</var> be a permutation character, and <var class="Arg">class</var> be the position of a conjugacy class of the character table of <var class="Arg">permchar</var>. <code class="func">CycleStructureClass</code> returns a list describing the cycle structure of each element in class <var class="Arg">class</var> in the underlying permutation representation, in the same format as the result of <code class="func">CycleStructurePerm</code> (<a href="chap42.html#X7944D1447804A69A"><span class="RefLink">42.4-2</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nat:= NaturalCharacter( S4 );</span>
Character( CharacterTable( S4 ), [ 4, 2, 0, 1, 0 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( [ 1 .. 5 ], i -&gt; CycleStructureClass( nat, i ) );</span>
[ [  ], [ 1 ], [ 2 ], [ , 1 ], [ ,, 1 ] ]
</pre></div>

<p><a id="X86EDB4047C5AD6E7" name="X86EDB4047C5AD6E7"></a></p>

<h5>72.8-15 IsTransitive</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsTransitive</code>( [<var class="Arg">tbl</var>, ]<var class="Arg">chi</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>For a permutation character <var class="Arg">chi</var> of the group <span class="SimpleMath">G</span> that corresponds to an action on the <span class="SimpleMath">G</span>-set <span class="SimpleMath">Ω</span> (see <code class="func">PermutationCharacter</code> (<a href="chap72.html#X7938621F81B65E03"><span class="RefLink">72.7-3</span></a>)), <code class="func">IsTransitive</code> (<a href="chap41.html#X79B15750851828CB"><span class="RefLink">41.10-1</span></a>) returns <code class="keyw">true</code> if the action of <span class="SimpleMath">G</span> on <span class="SimpleMath">Ω</span> is transitive, and <code class="keyw">false</code> otherwise.</p>

<p><a id="X801DC07B8029841B" name="X801DC07B8029841B"></a></p>

<h5>72.8-16 Transitivity</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Transitivity</code>( [<var class="Arg">tbl</var>, ]<var class="Arg">chi</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For a permutation character <var class="Arg">chi</var> of the group <span class="SimpleMath">G</span> that corresponds to an action on the <span class="SimpleMath">G</span>-set <span class="SimpleMath">Ω</span> (see <code class="func">PermutationCharacter</code> (<a href="chap72.html#X7938621F81B65E03"><span class="RefLink">72.7-3</span></a>)), <code class="func">Transitivity</code> returns the maximal nonnegative integer <span class="SimpleMath">k</span> such that the action of <span class="SimpleMath">G</span> on <span class="SimpleMath">Ω</span> is <span class="SimpleMath">k</span>-transitive.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsTransitive( nat );  Transitivity( nat );</span>
true
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Transitivity( 2 * TrivialCharacter( S4 ) );</span>
0
</pre></div>

<p><a id="X7DD8FDCF7FB7834A" name="X7DD8FDCF7FB7834A"></a></p>

<h5>72.8-17 CentralCharacter</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CentralCharacter</code>( [<var class="Arg">tbl</var>, ]<var class="Arg">chi</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For a character <var class="Arg">chi</var> of the group <span class="SimpleMath">G</span>, say, <code class="func">CentralCharacter</code> returns the <em>central character</em> of <var class="Arg">chi</var>.</p>

<p>The central character of <span class="SimpleMath">χ</span> is the class function <span class="SimpleMath">ω_χ</span> defined by <span class="SimpleMath">ω_χ(g) = |g^G| ⋅ χ(g)/χ(1)</span> for each <span class="SimpleMath">g ∈ G</span>.</p>

<p><a id="X7A292A58827B95B8" name="X7A292A58827B95B8"></a></p>

<h5>72.8-18 DeterminantOfCharacter</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DeterminantOfCharacter</code>( [<var class="Arg">tbl</var>, ]<var class="Arg">chi</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><code class="func">DeterminantOfCharacter</code> returns the <em>determinant character</em> of the character <var class="Arg">chi</var>. This is defined to be the character obtained by taking the determinant of representing matrices of any representation affording <var class="Arg">chi</var>; the determinant can be computed using <code class="func">EigenvaluesChar</code> (<a href="chap72.html#X861B435C7F68AE7D"><span class="RefLink">72.8-19</span></a>).</p>

<p>It is also possible to call <code class="func">Determinant</code> (<a href="chap24.html#X83045F6F82C180E1"><span class="RefLink">24.4-4</span></a>) instead of <code class="func">DeterminantOfCharacter</code>.</p>

<p>Note that the determinant character is well-defined for virtual characters.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CentralCharacter( TrivialCharacter( S4 ) );</span>
ClassFunction( CharacterTable( S4 ), [ 1, 6, 3, 8, 6 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DeterminantOfCharacter( Irr( S4 )[3] );</span>
Character( CharacterTable( S4 ), [ 1, -1, 1, 1, -1 ] )
</pre></div>

<p><a id="X861B435C7F68AE7D" name="X861B435C7F68AE7D"></a></p>

<h5>72.8-19 EigenvaluesChar</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EigenvaluesChar</code>( [<var class="Arg">tbl</var>, ]<var class="Arg">chi</var>, <var class="Arg">class</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">chi</var> be a character of the group <span class="SimpleMath">G</span>, say. For an element <span class="SimpleMath">g ∈ G</span> in the <var class="Arg">class</var>-th conjugacy class, of order <span class="SimpleMath">n</span>, let <span class="SimpleMath">M</span> be a matrix of a representation affording <var class="Arg">chi</var>.</p>

<p><code class="func">EigenvaluesChar</code> returns the list of length <span class="SimpleMath">n</span> where at position <span class="SimpleMath">k</span> the multiplicity of <code class="code">E</code><span class="SimpleMath">(n)^k = exp(2 π i k / n)</span> as an eigenvalue of <span class="SimpleMath">M</span> is stored.</p>

<p>We have <code class="code"><var class="Arg">chi</var>[ <var class="Arg">class</var> ] = List( [ 1 .. n ], k -&gt; E(n)^k ) * EigenvaluesChar( <var class="Arg">tbl</var>, <var class="Arg">chi</var>, <var class="Arg">class</var> )</code>.</p>

<p>It is also possible to call <code class="func">Eigenvalues</code> (<a href="chap24.html#X8413C6FB7CEE9D59"><span class="RefLink">24.8-3</span></a>) instead of <code class="func">EigenvaluesChar</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chi:= Irr( CharacterTable( "A5" ) )[2];</span>
Character( CharacterTable( "A5" ), 
[ 3, -1, 0, -E(5)-E(5)^4, -E(5)^2-E(5)^3 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( [ 1 .. 5 ], i -&gt; Eigenvalues( chi, i ) );</span>
[ [ 3 ], [ 2, 1 ], [ 1, 1, 1 ], [ 0, 1, 1, 0, 1 ], [ 1, 0, 0, 1, 1 ] ]
</pre></div>

<p><a id="X7A106BE281EFD953" name="X7A106BE281EFD953"></a></p>

<h5>72.8-20 Tensored</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Tensored</code>( <var class="Arg">chars1</var>, <var class="Arg">chars2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">chars1</var> and <var class="Arg">chars2</var> be lists of (values lists of) class functions of the same character table. <code class="func">Tensored</code> returns the list of tensor products of all entries in <var class="Arg">chars1</var> with all entries in <var class="Arg">chars2</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irra5:= Irr( CharacterTable( "A5" ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chars1:= irra5{ [ 1 .. 3 ] };;  chars2:= irra5{ [ 2, 3 ] };;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Tensored( chars1, chars2 );</span>
[ Character( CharacterTable( "A5" ), 
    [ 3, -1, 0, -E(5)-E(5)^4, -E(5)^2-E(5)^3 ] ), 
  Character( CharacterTable( "A5" ), 
    [ 3, -1, 0, -E(5)^2-E(5)^3, -E(5)-E(5)^4 ] ), 
  Character( CharacterTable( "A5" ), 
    [ 9, 1, 0, -2*E(5)-E(5)^2-E(5)^3-2*E(5)^4, 
      -E(5)-2*E(5)^2-2*E(5)^3-E(5)^4 ] ), 
  Character( CharacterTable( "A5" ), [ 9, 1, 0, -1, -1 ] ), 
  Character( CharacterTable( "A5" ), [ 9, 1, 0, -1, -1 ] ), 
  Character( CharacterTable( "A5" ), 
    [ 9, 1, 0, -E(5)-2*E(5)^2-2*E(5)^3-E(5)^4, 
      -2*E(5)-E(5)^2-E(5)^3-2*E(5)^4 ] ) ]
</pre></div>

<p><a id="X854A4E3A85C5F89B" name="X854A4E3A85C5F89B"></a></p>

<h4>72.9 <span class="Heading">Restricted and Induced Class Functions</span></h4>

<p>For restricting a class function of a group <span class="SimpleMath">G</span> to a subgroup <span class="SimpleMath">H</span> and for inducing a class function of <span class="SimpleMath">H</span> to <span class="SimpleMath">G</span>, the <em>class fusion</em> from <span class="SimpleMath">H</span> to <span class="SimpleMath">G</span> must be known (see <a href="chap73.html#X806975FE81534444"><span class="RefLink">73.3</span></a>).</p>

<p>If <span class="SimpleMath">F</span> is the factor group of <span class="SimpleMath">G</span> by the normal subgroup <span class="SimpleMath">N</span> then each class function of <span class="SimpleMath">F</span> can be naturally regarded as a class function of <span class="SimpleMath">G</span>, with <span class="SimpleMath">N</span> in its kernel. For a class function of <span class="SimpleMath">F</span>, the corresponding class function of <span class="SimpleMath">G</span> is called the <em>inflated</em> class function. Restriction and inflation are in principle the same, namely indirection of a class function by the appropriate fusion map, and thus no extra operation is needed for this process. But note that contrary to the case of a subgroup fusion, the factor fusion can in general not be computed from the groups <span class="SimpleMath">G</span> and <span class="SimpleMath">F</span>; either one needs the natural homomorphism, or the factor fusion to the character table of <span class="SimpleMath">F</span> must be stored on the table of <span class="SimpleMath">G</span>. This explains the different syntax for computing restricted and inflated class functions.</p>

<p>In the following, the meaning of the optional first argument <var class="Arg">tbl</var> is the same as in Section <a href="chap72.html#X86DDB47A7C6B45D0"><span class="RefLink">72.8</span></a>.</p>

<p><a id="X86BABEA6841A40CF" name="X86BABEA6841A40CF"></a></p>

<h5>72.9-1 RestrictedClassFunction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RestrictedClassFunction</code>( [<var class="Arg">tbl</var>, ]<var class="Arg">chi</var>, <var class="Arg">target</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">chi</var> be a class function of the group <span class="SimpleMath">G</span>, say, and let <var class="Arg">target</var> be either a subgroup <span class="SimpleMath">H</span> of <span class="SimpleMath">G</span> or an injective homomorphism from <span class="SimpleMath">H</span> to <span class="SimpleMath">G</span> or the character table of <var class="Arg">H</var>. Then <code class="func">RestrictedClassFunction</code> returns the class function of <span class="SimpleMath">H</span> obtained by restricting <var class="Arg">chi</var> to <span class="SimpleMath">H</span>.</p>

<p>If <var class="Arg">chi</var> is a class function of a <em>factor group</em> <span class="SimpleMath">G</span>of <span class="SimpleMath">H</span>, where <var class="Arg">target</var> is either the group <span class="SimpleMath">H</span> or a homomorphism from <span class="SimpleMath">H</span> to <span class="SimpleMath">G</span> or the character table of <span class="SimpleMath">H</span> then the restriction can be computed in the case of the homomorphism; in the other cases, this is possible only if the factor fusion from <span class="SimpleMath">H</span> to <span class="SimpleMath">G</span> is stored on the character table of <span class="SimpleMath">H</span>.</p>

<p><a id="X86DB64F08035D219" name="X86DB64F08035D219"></a></p>

<h5>72.9-2 RestrictedClassFunctions</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RestrictedClassFunctions</code>( [<var class="Arg">tbl</var>, ]<var class="Arg">chars</var>, <var class="Arg">target</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p><code class="func">RestrictedClassFunctions</code> is similar to <code class="func">RestrictedClassFunction</code> (<a href="chap72.html#X86BABEA6841A40CF"><span class="RefLink">72.9-1</span></a>), the only difference is that it takes a list <var class="Arg">chars</var> of class functions instead of one class function, and returns the list of restricted class functions.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a5:= CharacterTable( "A5" );;  s5:= CharacterTable( "S5" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RestrictedClassFunction( Irr( s5 )[2], a5 );</span>
Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RestrictedClassFunctions( Irr( s5 ), a5 );</span>
[ Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 6, -2, 0, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 4, 0, 1, -1, -1 ] ), 
  Character( CharacterTable( "A5" ), [ 4, 0, 1, -1, -1 ] ), 
  Character( CharacterTable( "A5" ), [ 5, 1, -1, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 5, 1, -1, 0, 0 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom:= NaturalHomomorphismByNormalSubgroup( S4, der );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RestrictedClassFunctions( Irr( Image( hom ) ), hom );</span>
[ Character( CharacterTable( S4 ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( S4 ), [ 1, -1, 1, 1, -1 ] ) ]
</pre></div>

<p><a id="X7FE39D3D78855D3B" name="X7FE39D3D78855D3B"></a></p>

<h5>72.9-3 <span class="Heading">InducedClassFunction</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InducedClassFunction</code>( [<var class="Arg">tbl</var>, ]<var class="Arg">chi</var>, <var class="Arg">H</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InducedClassFunction</code>( [<var class="Arg">tbl</var>, ]<var class="Arg">chi</var>, <var class="Arg">hom</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InducedClassFunction</code>( [<var class="Arg">tbl</var>, ]<var class="Arg">chi</var>, <var class="Arg">suptbl</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">chi</var> be a class function of the group <span class="SimpleMath">G</span>, say, and let <var class="Arg">target</var> be either a supergroup <span class="SimpleMath">H</span> of <span class="SimpleMath">G</span> or an injective homomorphism from <span class="SimpleMath">H</span> to <span class="SimpleMath">G</span> or the character table of <var class="Arg">H</var>. Then <code class="func">InducedClassFunction</code> returns the class function of <span class="SimpleMath">H</span> obtained by inducing <var class="Arg">chi</var> to <span class="SimpleMath">H</span>.</p>

<p><a id="X8484C0F985AD2D28" name="X8484C0F985AD2D28"></a></p>

<h5>72.9-4 InducedClassFunctions</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InducedClassFunctions</code>( [<var class="Arg">tbl</var>, ]<var class="Arg">chars</var>, <var class="Arg">target</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p><code class="func">InducedClassFunctions</code> is similar to <code class="func">InducedClassFunction</code> (<a href="chap72.html#X7FE39D3D78855D3B"><span class="RefLink">72.9-3</span></a>), the only difference is that it takes a list <var class="Arg">chars</var> of class functions instead of one class function, and returns the list of induced class functions.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InducedClassFunctions( Irr( a5 ), s5 );</span>
[ Character( CharacterTable( "A5.2" ), [ 2, 2, 2, 2, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5.2" ), [ 6, -2, 0, 1, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5.2" ), [ 6, -2, 0, 1, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5.2" ), [ 8, 0, 2, -2, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5.2" ), [ 10, 2, -2, 0, 0, 0, 0 ] ) ]
</pre></div>

<p><a id="X7C72003880743D28" name="X7C72003880743D28"></a></p>

<h5>72.9-5 InducedClassFunctionsByFusionMap</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InducedClassFunctionsByFusionMap</code>( <var class="Arg">subtbl</var>, <var class="Arg">tbl</var>, <var class="Arg">chars</var>, <var class="Arg">fusionmap</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">subtbl</var> and <var class="Arg">tbl</var> be two character tables of groups <span class="SimpleMath">H</span> and <span class="SimpleMath">G</span>, such that <span class="SimpleMath">H</span> is a subgroup of <span class="SimpleMath">G</span>, let <var class="Arg">chars</var> be a list of class functions of <var class="Arg">subtbl</var>, and let <var class="Arg">fusionmap</var> be a fusion map from <var class="Arg">subtbl</var> to <var class="Arg">tbl</var>. The function returns the list of induced class functions of <var class="Arg">tbl</var> that correspond to <var class="Arg">chars</var>, w.r.t. the given fusion map.</p>

<p><code class="func">InducedClassFunctionsByFusionMap</code> is the function that does the work for <code class="func">InducedClassFunction</code> (<a href="chap72.html#X7FE39D3D78855D3B"><span class="RefLink">72.9-3</span></a>) and <code class="func">InducedClassFunctions</code> (<a href="chap72.html#X8484C0F985AD2D28"><span class="RefLink">72.9-4</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= PossibleClassFusions( a5, s5 );</span>
[ [ 1, 2, 3, 4, 4 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InducedClassFunctionsByFusionMap( a5, s5, Irr( a5 ), fus[1] );</span>
[ Character( CharacterTable( "A5.2" ), [ 2, 2, 2, 2, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5.2" ), [ 6, -2, 0, 1, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5.2" ), [ 6, -2, 0, 1, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5.2" ), [ 8, 0, 2, -2, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5.2" ), [ 10, 2, -2, 0, 0, 0, 0 ] ) ]
</pre></div>

<p><a id="X7C055F327C99CE71" name="X7C055F327C99CE71"></a></p>

<h5>72.9-6 InducedCyclic</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InducedCyclic</code>( <var class="Arg">tbl</var>[, <var class="Arg">classes</var>][, <var class="Arg">"all"</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p><code class="func">InducedCyclic</code> calculates characters induced up from cyclic subgroups of the ordinary character table <var class="Arg">tbl</var> to <var class="Arg">tbl</var>, and returns the strictly sorted list of the induced characters.</p>

<p>If the string <code class="code">"all"</code> is specified then all irreducible characters of these subgroups are induced, otherwise only the permutation characters are calculated.</p>

<p>If a list <var class="Arg">classes</var> is specified then only those cyclic subgroups generated by these classes are considered, otherwise all classes of <var class="Arg">tbl</var> are considered.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InducedCyclic( a5, "all" );</span>
[ Character( CharacterTable( "A5" ), [ 12, 0, 0, 2, 2 ] ), 
  Character( CharacterTable( "A5" ), 
    [ 12, 0, 0, E(5)^2+E(5)^3, E(5)+E(5)^4 ] ), 
  Character( CharacterTable( "A5" ), 
    [ 12, 0, 0, E(5)+E(5)^4, E(5)^2+E(5)^3 ] ), 
  Character( CharacterTable( "A5" ), [ 20, 0, -1, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 20, 0, 2, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 30, -2, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 30, 2, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 60, 0, 0, 0, 0 ] ) ]
</pre></div>

<p><a id="X7C95F7937B752F48" name="X7C95F7937B752F48"></a></p>

<h4>72.10 <span class="Heading">Reducing Virtual Characters</span></h4>

<p>The following operations are intended for the situation that one is given a list of virtual characters of a character table and is interested in the irreducible characters of this table. The idea is to compute virtual characters of small norm from the given ones, hoping to get eventually virtual characters of norm <span class="SimpleMath">1</span>.</p>

<p><a id="X86F360D983343C2A" name="X86F360D983343C2A"></a></p>

<h5>72.10-1 ReducedClassFunctions</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ReducedClassFunctions</code>( [<var class="Arg">tbl</var>, ][<var class="Arg">constituents</var>, ]<var class="Arg">reducibles</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">reducibles</var> be a list of ordinary virtual characters of the group <span class="SimpleMath">G</span>, say. If <var class="Arg">constituents</var> is given then it must also be a list of ordinary virtual characters of <span class="SimpleMath">G</span>, otherwise we have <var class="Arg">constituents</var> equal to <var class="Arg">reducibles</var> in the following.</p>

<p><code class="func">ReducedClassFunctions</code> returns a record with the components <code class="code">remainders</code> and <code class="code">irreducibles</code>, both lists of virtual characters of <span class="SimpleMath">G</span>. These virtual characters are computed as follows.</p>

<p>Let <code class="code">rems</code> be the set of nonzero class functions obtained by subtraction of</p>

<p class="pcenter">∑_χ ( [<var class="Arg">reducibles</var>[i], χ] / [χ, χ] ) ⋅ χ</p>

<p>from <span class="SimpleMath"><var class="Arg">reducibles</var>[i]</span>, where the summation runs over <var class="Arg">constituents</var> and <span class="SimpleMath">[χ, ψ]</span> denotes the scalar product of <span class="SimpleMath">G</span>-class functions. Let <code class="code">irrs</code> be the list of irreducible characters in <code class="code">rems</code>.</p>

<p>We project <code class="code">rems</code> into the orthogonal space of <code class="code">irrs</code> and all those irreducibles found this way until no new irreducibles arise. Then the <code class="code">irreducibles</code> list is the set of all found irreducible characters, and the <code class="code">remainders</code> list is the set of all nonzero remainders.</p>

<p><a id="X7B7138ED8586F09E" name="X7B7138ED8586F09E"></a></p>

<h5>72.10-2 ReducedCharacters</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ReducedCharacters</code>( [<var class="Arg">tbl</var>, ]<var class="Arg">constituents</var>, <var class="Arg">reducibles</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p><code class="func">ReducedCharacters</code> is similar to <code class="func">ReducedClassFunctions</code> (<a href="chap72.html#X86F360D983343C2A"><span class="RefLink">72.10-1</span></a>), the only difference is that <var class="Arg">constituents</var> and <var class="Arg">reducibles</var> are assumed to be lists of characters. This means that only those scalar products must be formed where the degree of the character in <var class="Arg">constituents</var> does not exceed the degree of the character in <var class="Arg">reducibles</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( "A5" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chars:= Irr( tbl ){ [ 2 .. 4 ] };;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chars:= Set( Tensored( chars, chars ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">red:= ReducedClassFunctions( chars );</span>
rec( 
  irreducibles := 
    [ Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
      Character( CharacterTable( "A5" ), 
        [ 3, -1, 0, -E(5)-E(5)^4, -E(5)^2-E(5)^3 ] ), 
      Character( CharacterTable( "A5" ), 
        [ 3, -1, 0, -E(5)^2-E(5)^3, -E(5)-E(5)^4 ] ), 
      Character( CharacterTable( "A5" ), [ 4, 0, 1, -1, -1 ] ), 
      Character( CharacterTable( "A5" ), [ 5, 1, -1, 0, 0 ] ) ], 
  remainders := [  ] )
</pre></div>

<p><a id="X7D3289BB865BCF98" name="X7D3289BB865BCF98"></a></p>

<h5>72.10-3 IrreducibleDifferences</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IrreducibleDifferences</code>( <var class="Arg">tbl</var>, <var class="Arg">reducibles</var>, <var class="Arg">reducibles2</var>[, <var class="Arg">scprmat</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="func">IrreducibleDifferences</code> returns the list of irreducible characters which occur as difference of an element of <var class="Arg">reducibles</var> and an element of <var class="Arg">reducibles2</var>, where these two arguments are lists of class functions of the character table <var class="Arg">tbl</var>.</p>

<p>If <var class="Arg">reducibles2</var> is the string <code class="code">"triangle"</code> then the differences of elements in <var class="Arg">reducibles</var> are considered.</p>

<p>If <var class="Arg">scprmat</var> is not specified then it will be calculated, otherwise we must have <code class="code"><var class="Arg">scprmat</var> = MatScalarProducts( <var class="Arg">tbl</var>, <var class="Arg">reducibles</var>, <var class="Arg">reducibles2</var> )</code> or <code class="code"><var class="Arg">scprmat</var> = MatScalarProducts( <var class="Arg">tbl</var>, <var class="Arg">reducibles</var> )</code>, respectively.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IrreducibleDifferences( a5, chars, "triangle" );</span>
[ Character( CharacterTable( "A5" ), 
    [ 3, -1, 0, -E(5)-E(5)^4, -E(5)^2-E(5)^3 ] ), 
  Character( CharacterTable( "A5" ), 
    [ 3, -1, 0, -E(5)^2-E(5)^3, -E(5)-E(5)^4 ] ) ]
</pre></div>

<p><a id="X85B360C085B360C0" name="X85B360C085B360C0"></a></p>

<h5>72.10-4 LLL</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LLL</code>( <var class="Arg">tbl</var>, <var class="Arg">characters</var>[, <var class="Arg">y</var>][, <var class="Arg">"sort"</var>][, <var class="Arg">"linearcomb"</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="func">LLL</code> calls the LLL algorithm (see <code class="func">LLLReducedBasis</code> (<a href="chap25.html#X7D0FCEF8859E8637"><span class="RefLink">25.5-1</span></a>)) in the case of lattices spanned by the virtual characters <var class="Arg">characters</var> of the ordinary character table <var class="Arg">tbl</var> (see <code class="func">ScalarProduct</code> (<a href="chap72.html#X855FD9F983D275CD"><span class="RefLink">72.8-5</span></a>)). By finding shorter vectors in the lattice spanned by <var class="Arg">characters</var>, i.e., virtual characters of smaller norm, in some cases <code class="func">LLL</code> is able to find irreducible characters.</p>

<p><code class="func">LLL</code> returns a record with at least components <code class="code">irreducibles</code> (the list of found irreducible characters), <code class="code">remainders</code> (a list of reducible virtual characters), and <code class="code">norms</code> (the list of norms of the vectors in <code class="code">remainders</code>). <code class="code">irreducibles</code> together with <code class="code">remainders</code> form a basis of the <span class="SimpleMath">ℤ</span>-lattice spanned by <var class="Arg">characters</var>.</p>

<p>Note that the vectors in the <code class="code">remainders</code> list are in general <em>not</em> orthogonal (see <code class="func">ReducedClassFunctions</code> (<a href="chap72.html#X86F360D983343C2A"><span class="RefLink">72.10-1</span></a>)) to the irreducible characters in <code class="code">irreducibles</code>.</p>

<p>Optional arguments of <code class="func">LLL</code> are</p>


<dl>
<dt><strong class="Mark"><var class="Arg">y</var></strong></dt>
<dd><p>controls the sensitivity of the algorithm, see <code class="func">LLLReducedBasis</code> (<a href="chap25.html#X7D0FCEF8859E8637"><span class="RefLink">25.5-1</span></a>),</p>

</dd>
<dt><strong class="Mark"><var class="Arg">"sort"</var></strong></dt>
<dd><p><code class="func">LLL</code> sorts <var class="Arg">characters</var> and the <code class="code">remainders</code> component of the result according to the degrees,</p>

</dd>
<dt><strong class="Mark"><var class="Arg">"linearcomb"</var></strong></dt>
<dd><p>the returned record contains components <code class="code">irreddecomp</code> and <code class="code">reddecomp</code>, which are decomposition matrices of <code class="code">irreducibles</code> and <code class="code">remainders</code>, with respect to <var class="Arg">characters</var>.</p>

</dd>
</dl>

<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s4:= CharacterTable( "Symmetric", 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chars:= [ [ 8, 0, 0, -1, 0 ], [ 6, 0, 2, 0, 2 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [ 12, 0, -4, 0, 0 ], [ 6, 0, -2, 0, 0 ], [ 24, 0, 0, 0, 0 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [ 12, 0, 4, 0, 0 ], [ 6, 0, 2, 0, -2 ], [ 12, -2, 0, 0, 0 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [ 8, 0, 0, 2, 0 ], [ 12, 2, 0, 0, 0 ], [ 1, 1, 1, 1, 1 ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LLL( s4, chars );</span>
rec( 
  irreducibles := 
    [ Character( CharacterTable( "Sym(4)" ), [ 2, 0, 2, -1, 0 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 1, 1, 1, 1, 1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 3, 1, -1, 0, -1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 3, -1, -1, 0, 1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 1, -1, 1, 1, -1 ] ) ], 
  norms := [  ], remainders := [  ] )
</pre></div>

<p><a id="X808D71A57D104ED7" name="X808D71A57D104ED7"></a></p>

<h5>72.10-5 Extract</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Extract</code>( <var class="Arg">tbl</var>, <var class="Arg">reducibles</var>, <var class="Arg">grammat</var>[, <var class="Arg">missing</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">tbl</var> be an ordinary character table, <var class="Arg">reducibles</var> a list of characters of <var class="Arg">tbl</var>, and <var class="Arg">grammat</var> the matrix of scalar products of <var class="Arg">reducibles</var> (see <code class="func">MatScalarProducts</code> (<a href="chap72.html#X858DF4E67EBB99DA"><span class="RefLink">72.8-6</span></a>)). <code class="func">Extract</code> tries to find irreducible characters by drawing conclusions out of the scalar products, using combinatorial and backtrack means.</p>

<p>The optional argument <var class="Arg">missing</var> is the maximal number of irreducible characters that occur as constituents of <var class="Arg">reducibles</var>. Specification of <var class="Arg">missing</var> may accelerate <code class="func">Extract</code>.</p>

<p><code class="func">Extract</code> returns a record <var class="Arg">ext</var> with the components <code class="code">solution</code> and <code class="code">choice</code>, where the value of <code class="code">solution</code> is a list <span class="SimpleMath">[ M_1, ..., M_n ]</span> of decomposition matrices <span class="SimpleMath">M_i</span> (up to permutations of rows) with the property that <span class="SimpleMath">M_i^tr ⋅ X</span> is equal to the sublist at the positions <var class="Arg">ext</var><code class="code">.choice[i]</code> of <var class="Arg">reducibles</var>, for a matrix <span class="SimpleMath">X</span> of irreducible characters; the value of <code class="code">choice</code> is a list of length <span class="SimpleMath">n</span> whose entries are lists of indices.</p>

<p>So the <span class="SimpleMath">j</span>-th column in each matrix <span class="SimpleMath">M_i</span> corresponds to <span class="SimpleMath"><var class="Arg">reducibles</var>[j]</span>, and each row in <span class="SimpleMath">M_i</span> corresponds to an irreducible character. <code class="func">Decreased</code> (<a href="chap72.html#X8799AB967C58C0E9"><span class="RefLink">72.10-7</span></a>) can be used to examine the solution for computable irreducibles.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s4:= CharacterTable( "Symmetric", 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">red:= [ [ 5, 1, 5, 2, 1 ], [ 2, 0, 2, 2, 0 ], [ 3, -1, 3, 0, -1 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           [ 6, 0, -2, 0, 0 ], [ 4, 0, 0, 1, 2 ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gram:= MatScalarProducts( s4, red, red );</span>
[ [ 6, 3, 2, 0, 2 ], [ 3, 2, 1, 0, 1 ], [ 2, 1, 2, 0, 0 ], 
  [ 0, 0, 0, 2, 1 ], [ 2, 1, 0, 1, 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ext:= Extract( s4, red, gram, 5 );</span>
rec( choice := [ [ 2, 5, 3, 4, 1 ] ], 
  solution := 
    [ 
      [ [ 1, 1, 0, 0, 2 ], [ 1, 0, 1, 0, 1 ], [ 0, 1, 0, 1, 0 ], 
          [ 0, 0, 1, 0, 1 ], [ 0, 0, 0, 1, 0 ] ] ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">dec:= Decreased( s4, red, ext.solution[1], ext.choice[1] );</span>
rec( 
  irreducibles := 
    [ Character( CharacterTable( "Sym(4)" ), [ 1, 1, 1, 1, 1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 3, -1, -1, 0, 1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 1, -1, 1, 1, -1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 3, 1, -1, 0, -1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 2, 0, 2, -1, 0 ] ) ], 
  matrix := [  ], remainders := [  ] )
</pre></div>

<p><a id="X7F97B34A879D11BA" name="X7F97B34A879D11BA"></a></p>

<h5>72.10-6 OrthogonalEmbeddingsSpecialDimension</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OrthogonalEmbeddingsSpecialDimension</code>( <var class="Arg">tbl</var>, <var class="Arg">reducibles</var>, <var class="Arg">grammat</var>[, <var class="Arg">"positive"</var>], <var class="Arg">dim</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="func">OrthogonalEmbeddingsSpecialDimension</code> is a variant of <code class="func">OrthogonalEmbeddings</code> (<a href="chap25.html#X842280C2808FF05D"><span class="RefLink">25.6-1</span></a>) for the situation that <var class="Arg">tbl</var> is an ordinary character table, <var class="Arg">reducibles</var> is a list of virtual characters of <var class="Arg">tbl</var>, <var class="Arg">grammat</var> is the matrix of scalar products (see <code class="func">MatScalarProducts</code> (<a href="chap72.html#X858DF4E67EBB99DA"><span class="RefLink">72.8-6</span></a>)), and <var class="Arg">dim</var> is an upper bound for the number of irreducible characters of <var class="Arg">tbl</var> that occur as constituents of <var class="Arg">reducibles</var>; if the vectors in <var class="Arg">reducibles</var> are known to be proper characters then the string <code class="code">"positive"</code> may be entered as fourth argument. (See <code class="func">OrthogonalEmbeddings</code> (<a href="chap25.html#X842280C2808FF05D"><span class="RefLink">25.6-1</span></a>) for information why this may help.)</p>

<p><code class="func">OrthogonalEmbeddingsSpecialDimension</code> first uses <code class="func">OrthogonalEmbeddings</code> (<a href="chap25.html#X842280C2808FF05D"><span class="RefLink">25.6-1</span></a>) to compute all orthogonal embeddings of <var class="Arg">grammat</var> into a standard lattice of dimension up to <var class="Arg">dim</var>, and then calls <code class="func">Decreased</code> (<a href="chap72.html#X8799AB967C58C0E9"><span class="RefLink">72.10-7</span></a>) in order to find irreducible characters of <var class="Arg">tbl</var>.</p>

<p><code class="func">OrthogonalEmbeddingsSpecialDimension</code> returns a record with the following components.</p>


<dl>
<dt><strong class="Mark"><code class="code">irreducibles</code></strong></dt>
<dd><p>a list of found irreducibles, the intersection of all lists of irreducibles found by <code class="func">Decreased</code> (<a href="chap72.html#X8799AB967C58C0E9"><span class="RefLink">72.10-7</span></a>), for all possible embeddings, and</p>

</dd>
<dt><strong class="Mark"><code class="code">remainders</code></strong></dt>
<dd><p>a list of remaining reducible virtual characters.</p>

</dd>
</dl>

<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s6:= CharacterTable( "S6" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">red:= InducedCyclic( s6, "all" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Add( red, TrivialCharacter( s6 ) );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lll:= LLL( s6, red );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irred:= lll.irreducibles;</span>
[ Character( CharacterTable( "A6.2_1" ), 
    [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A6.2_1" ), 
    [ 9, 1, 0, 0, 1, -1, -3, -3, 1, 0, 0 ] ), 
  Character( CharacterTable( "A6.2_1" ), 
    [ 16, 0, -2, -2, 0, 1, 0, 0, 0, 0, 0 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Set( Flat( MatScalarProducts( s6, irred, lll.remainders ) ) );</span>
[ 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">dim:= NrConjugacyClasses( s6 ) - Length( lll.irreducibles );</span>
8
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rem:= lll.remainders;;  Length( rem );</span>
8
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gram:= MatScalarProducts( s6, rem, rem );;  RankMat( gram );</span>
8
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">emb1:= OrthogonalEmbeddings( gram, 8 );</span>
rec( norms := [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], 
  solutions := [ [ 1, 2, 3, 7, 11, 12, 13, 15 ], 
      [ 1, 2, 4, 8, 10, 12, 13, 14 ], [ 1, 2, 5, 6, 9, 12, 13, 16 ] ],
  vectors := 
    [ [ -1, 0, 1, 0, 1, 0, 1, 0 ], [ 1, 0, 0, 1, 0, 1, 0, 0 ], 
      [ 0, 1, 1, 0, 0, 0, 1, 1 ], [ 0, 1, 1, 0, 0, 0, 1, 0 ], 
      [ 0, 1, 1, 0, 0, 0, 0, 0 ], [ 0, 1, 0, 0, 0, 0, 1, 0 ], 
      [ 0, -1, 0, 0, 0, 0, 0, 1 ], [ 0, 1, 0, 0, 0, 0, 0, 0 ], 
      [ 0, 0, 1, 0, 0, 0, 1, 1 ], [ 0, 0, 1, 0, 0, 0, 0, 1 ], 
      [ 0, 0, 1, 0, 0, 0, 0, 0 ], [ 0, 0, 0, -1, 1, 0, 0, 0 ], 
      [ 0, 0, 0, 0, 0, 1, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 1, 1 ], 
      [ 0, 0, 0, 0, 0, 0, 1, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 1 ] ] )
</pre></div>

<p>In the following example we temporarily decrease the line length limit from its default value <span class="SimpleMath">80</span> to <span class="SimpleMath">62</span> in order to get a nicer output format.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">emb2:= OrthogonalEmbeddingsSpecialDimension( s6, rem, gram, 8 );</span>
rec( 
  irreducibles := 
    [ Character( CharacterTable( "A6.2_1" ), 
        [ 5, 1, -1, 2, -1, 0, 1, -3, -1, 1, 0 ] ), 
      Character( CharacterTable( "A6.2_1" ), 
        [ 5, 1, 2, -1, -1, 0, -3, 1, -1, 0, 1 ] ), 
      Character( CharacterTable( "A6.2_1" ), 
        [ 10, -2, 1, 1, 0, 0, -2, 2, 0, 1, -1 ] ), 
      Character( CharacterTable( "A6.2_1" ), 
        [ 10, -2, 1, 1, 0, 0, 2, -2, 0, -1, 1 ] ) ], 
  remainders := 
    [ VirtualCharacter( CharacterTable( "A6.2_1" ), 
        [ 0, 0, 3, -3, 0, 0, 4, -4, 0, 1, -1 ] ), 
      VirtualCharacter( CharacterTable( "A6.2_1" ), 
        [ 6, 2, 3, 0, 0, 1, 2, -2, 0, -1, -2 ] ), 
      VirtualCharacter( CharacterTable( "A6.2_1" ), 
        [ 10, 2, 1, 1, 2, 0, 2, 2, -2, -1, -1 ] ), 
      VirtualCharacter( CharacterTable( "A6.2_1" ), 
        [ 14, 2, 2, -1, 0, -1, 6, 2, 0, 0, -1 ] ) ] )
</pre></div>

<p><a id="X8799AB967C58C0E9" name="X8799AB967C58C0E9"></a></p>

<h5>72.10-7 Decreased</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Decreased</code>( <var class="Arg">tbl</var>, <var class="Arg">chars</var>, <var class="Arg">decompmat</var>[, <var class="Arg">choice</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">tbl</var> be an ordinary character table, <var class="Arg">chars</var> a list of virtual characters of <var class="Arg">tbl</var>, and <var class="Arg">decompmat</var> a decomposition matrix, that is, a matrix <span class="SimpleMath">M</span> with the property that <span class="SimpleMath">M^tr ⋅ X = <var class="Arg">chars</var></span> holds, where <span class="SimpleMath">X</span> is a list of irreducible characters of <var class="Arg">tbl</var>. <code class="func">Decreased</code> tries to compute the irreducibles in <span class="SimpleMath">X</span> or at least some of them.</p>

<p>Usually <code class="func">Decreased</code> is applied to the output of <code class="func">Extract</code> (<a href="chap72.html#X808D71A57D104ED7"><span class="RefLink">72.10-5</span></a>) or <code class="func">OrthogonalEmbeddings</code> (<a href="chap25.html#X842280C2808FF05D"><span class="RefLink">25.6-1</span></a>) or <code class="func">OrthogonalEmbeddingsSpecialDimension</code> (<a href="chap72.html#X7F97B34A879D11BA"><span class="RefLink">72.10-6</span></a>). In the case of <code class="func">Extract</code> (<a href="chap72.html#X808D71A57D104ED7"><span class="RefLink">72.10-5</span></a>), the choice component corresponding to the decomposition matrix must be entered as argument <var class="Arg">choice</var> of <code class="func">Decreased</code>.</p>

<p><code class="func">Decreased</code> returns <code class="keyw">fail</code> if it can prove that no list <span class="SimpleMath">X</span> of irreducible characters corresponding to the arguments exists; otherwise <code class="func">Decreased</code> returns a record with the following components.</p>


<dl>
<dt><strong class="Mark"><code class="code">irreducibles</code></strong></dt>
<dd><p>the list of found irreducible characters,</p>

</dd>
<dt><strong class="Mark"><code class="code">remainders</code></strong></dt>
<dd><p>the remaining reducible characters, and</p>

</dd>
<dt><strong class="Mark"><code class="code">matrix</code></strong></dt>
<dd><p>the decomposition matrix of the characters in the <code class="code">remainders</code> component.</p>

</dd>
</dl>
<p>In the following example we temporarily decrease the line length limit from its default value <span class="SimpleMath">80</span> to <span class="SimpleMath">62</span> in order to get a nicer output format.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s4:= CharacterTable( "Symmetric", 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:= Irr( s4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">red:= [ x[1]+x[2], -x[1]-x[3], -x[1]+x[3], -x[2]-x[4] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat:= MatScalarProducts( s4, red, red );</span>
[ [ 2, -1, -1, -1 ], [ -1, 2, 0, 0 ], [ -1, 0, 2, 0 ], 
  [ -1, 0, 0, 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">emb:= OrthogonalEmbeddings( mat );</span>
rec( norms := [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], 
  solutions := [ [ 1, 6, 7, 12 ], [ 2, 5, 8, 11 ], [ 3, 4, 9, 10 ] ], 
  vectors := [ [ -1, 1, 1, 0 ], [ -1, 1, 0, 1 ], [ 1, -1, 0, 0 ], 
      [ -1, 0, 1, 1 ], [ -1, 0, 1, 0 ], [ -1, 0, 0, 1 ], 
      [ 0, -1, 1, 0 ], [ 0, -1, 0, 1 ], [ 0, 1, 0, 0 ], 
      [ 0, 0, -1, 1 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">dec:= Decreased( s4, red, emb.vectors{ emb.solutions[1] } );</span>
rec( 
  irreducibles := 
    [ Character( CharacterTable( "Sym(4)" ), [ 3, -1, -1, 0, 1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 1, -1, 1, 1, -1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 2, 0, 2, -1, 0 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 3, 1, -1, 0, -1 ] ) ], 
  matrix := [  ], remainders := [  ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Decreased( s4, red, emb.vectors{ emb.solutions[2] } );</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Decreased( s4, red, emb.vectors{ emb.solutions[3] } );</span>
fail
</pre></div>

<p><a id="X85D510DC873A99B4" name="X85D510DC873A99B4"></a></p>

<h5>72.10-8 DnLattice</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DnLattice</code>( <var class="Arg">tbl</var>, <var class="Arg">grammat</var>, <var class="Arg">reducibles</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">tbl</var> be an ordinary character table, and <var class="Arg">reducibles</var> a list of virtual characters of <var class="Arg">tbl</var>.</p>

<p><code class="func">DnLattice</code> searches for sublattices isomorphic to root lattices of type <span class="SimpleMath">D_n</span>, for <span class="SimpleMath">n ≥ 4</span>, in the lattice that is generated by <var class="Arg">reducibles</var>; each vector in <var class="Arg">reducibles</var> must have norm <span class="SimpleMath">2</span>, and the matrix of scalar products (see <code class="func">MatScalarProducts</code> (<a href="chap72.html#X858DF4E67EBB99DA"><span class="RefLink">72.8-6</span></a>)) of <var class="Arg">reducibles</var> must be entered as argument <var class="Arg">grammat</var>.</p>

<p><code class="func">DnLattice</code> is able to find irreducible characters if there is a lattice of type <span class="SimpleMath">D_n</span> with <span class="SimpleMath">n &gt; 4</span>. In the case <span class="SimpleMath">n = 4</span>, <code class="func">DnLattice</code> may fail to determine irreducibles.</p>

<p><code class="func">DnLattice</code> returns a record with components</p>


<dl>
<dt><strong class="Mark"><code class="code">irreducibles</code></strong></dt>
<dd><p>the list of found irreducible characters,</p>

</dd>
<dt><strong class="Mark"><code class="code">remainders</code></strong></dt>
<dd><p>the list of remaining reducible virtual characters, and</p>

</dd>
<dt><strong class="Mark"><code class="code">gram</code></strong></dt>
<dd><p>the Gram matrix of the vectors in <code class="code">remainders</code>.</p>

</dd>
</dl>
<p>The <code class="code">remainders</code> list is transformed in such a way that the <code class="code">gram</code> matrix is a block diagonal matrix that exhibits the structure of the lattice generated by the vectors in <code class="code">remainders</code>. So <code class="func">DnLattice</code> might be useful even if it fails to find irreducible characters.</p>

<p>In the following example we temporarily decrease the line length limit from its default value <span class="SimpleMath">80</span> to <span class="SimpleMath">62</span> in order to get a nicer output format.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s4:= CharacterTable( "Symmetric", 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">red:= [ [ 2, 0, 2, 2, 0 ], [ 4, 0, 0, 1, 2 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           [ 5, -1, 1, -1, 1 ], [ -1, 1, 3, -1, -1 ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gram:= MatScalarProducts( s4, red, red );</span>
[ [ 2, 1, 0, 0 ], [ 1, 2, 1, -1 ], [ 0, 1, 2, 0 ], [ 0, -1, 0, 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">dn:= DnLattice( s4, gram, red );</span>
rec( gram := [  ], 
  irreducibles := 
    [ Character( CharacterTable( "Sym(4)" ), [ 2, 0, 2, -1, 0 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 1, -1, 1, 1, -1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 1, 1, 1, 1, 1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 3, -1, -1, 0, 1 ] ) ], 
  remainders := [  ] )
</pre></div>

<p><a id="X78754D007F3572A7" name="X78754D007F3572A7"></a></p>

<h5>72.10-9 DnLatticeIterative</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DnLatticeIterative</code>( <var class="Arg">tbl</var>, <var class="Arg">reducibles</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">tbl</var> be an ordinary character table, and <var class="Arg">reducibles</var> either a list of virtual characters of <var class="Arg">tbl</var> or a record with components <code class="code">remainders</code> and <code class="code">norms</code>, for example a record returned by <code class="func">LLL</code> (<a href="chap72.html#X85B360C085B360C0"><span class="RefLink">72.10-4</span></a>).</p>

<p><code class="func">DnLatticeIterative</code> was designed for iterative use of <code class="func">DnLattice</code> (<a href="chap72.html#X85D510DC873A99B4"><span class="RefLink">72.10-8</span></a>). <code class="func">DnLatticeIterative</code> selects the vectors of norm <span class="SimpleMath">2</span> among the given virtual character, calls <code class="func">DnLattice</code> (<a href="chap72.html#X85D510DC873A99B4"><span class="RefLink">72.10-8</span></a>) for them, reduces the virtual characters with found irreducibles, calls <code class="func">DnLattice</code> (<a href="chap72.html#X85D510DC873A99B4"><span class="RefLink">72.10-8</span></a>) again for the remaining virtual characters, and so on, until no new irreducibles are found.</p>

<p><code class="func">DnLatticeIterative</code> returns a record with the same components and meaning of components as <code class="func">LLL</code> (<a href="chap72.html#X85B360C085B360C0"><span class="RefLink">72.10-4</span></a>).</p>

<p>In the following example we temporarily decrease the line length limit from its default value <span class="SimpleMath">80</span> to <span class="SimpleMath">62</span> in order to get a nicer output format.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s4:= CharacterTable( "Symmetric", 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">red:= [ [ 2, 0, 2, 2, 0 ], [ 4, 0, 0, 1, 2 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           [ 5, -1, 1, -1, 1 ], [ -1, 1, 3, -1, -1 ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">dn:= DnLatticeIterative( s4, red );</span>
rec( 
  irreducibles := 
    [ Character( CharacterTable( "Sym(4)" ), [ 2, 0, 2, -1, 0 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 1, -1, 1, 1, -1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 1, 1, 1, 1, 1 ] ), 
      Character( CharacterTable( "Sym(4)" ), [ 3, -1, -1, 0, 1 ] ) ], 
  norms := [  ], remainders := [  ] )
</pre></div>

<p><a id="X87ED98F385B00D34" name="X87ED98F385B00D34"></a></p>

<h4>72.11 <span class="Heading">Symmetrizations of Class Functions</span></h4>

<p><a id="X7E220413823330EC" name="X7E220413823330EC"></a></p>

<h5>72.11-1 Symmetrizations</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Symmetrizations</code>( [<var class="Arg">tbl</var>, ]<var class="Arg">characters</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p><code class="func">Symmetrizations</code> returns the list of symmetrizations of the characters <var class="Arg">characters</var> of the ordinary character table <var class="Arg">tbl</var> with the ordinary irreducible characters of the symmetric group of degree <var class="Arg">n</var>; instead of the integer <var class="Arg">n</var>, the character table of the symmetric group can be entered.</p>

<p>The symmetrization <span class="SimpleMath">χ^[λ]</span> of the character <span class="SimpleMath">χ</span> of <var class="Arg">tbl</var> with the character <span class="SimpleMath">λ</span> of the symmetric group <span class="SimpleMath">S_n</span> of degree <span class="SimpleMath">n</span> is defined by</p>

<p class="pcenter">χ^[λ](g) = ( ∑_{ρ ∈ S_n} λ(ρ) ∏_{k=1}^n χ(g^k)^{a_k(ρ)} ) / n! ,</p>

<p>where <span class="SimpleMath">a_k(ρ)</span> is the number of cycles of length <span class="SimpleMath">k</span> in <span class="SimpleMath">ρ</span>.</p>

<p>For special kinds of symmetrizations, see <code class="func">SymmetricParts</code> (<a href="chap72.html#X85CE68CA87CA383A"><span class="RefLink">72.11-2</span></a>), <code class="func">AntiSymmetricParts</code> (<a href="chap72.html#X8329E934829FE965"><span class="RefLink">72.11-3</span></a>), <code class="func">MinusCharacter</code> (<a href="chap73.html#X805B6C1C78AA5DB6"><span class="RefLink">73.6-5</span></a>) and <code class="func">OrthogonalComponents</code> (<a href="chap72.html#X78648E367C65B1F1"><span class="RefLink">72.11-4</span></a>), <code class="func">SymplecticComponents</code> (<a href="chap72.html#X788B9AA17DD9418C"><span class="RefLink">72.11-5</span></a>).</p>

<p><em>Note</em> that the returned list may contain zero class functions, and duplicates are not deleted.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( "A5" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Symmetrizations( Irr( tbl ){ [ 1 .. 3 ] }, 3 );</span>
[ VirtualCharacter( CharacterTable( "A5" ), [ 0, 0, 0, 0, 0 ] ), 
  VirtualCharacter( CharacterTable( "A5" ), [ 0, 0, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), 
    [ 8, 0, -1, -E(5)-E(5)^4, -E(5)^2-E(5)^3 ] ), 
  Character( CharacterTable( "A5" ), [ 10, -2, 1, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), 
    [ 8, 0, -1, -E(5)^2-E(5)^3, -E(5)-E(5)^4 ] ), 
  Character( CharacterTable( "A5" ), [ 10, -2, 1, 0, 0 ] ) ]
</pre></div>

<p><a id="X85CE68CA87CA383A" name="X85CE68CA87CA383A"></a></p>

<h5>72.11-2 SymmetricParts</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SymmetricParts</code>( <var class="Arg">tbl</var>, <var class="Arg">characters</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>is the list of symmetrizations of the characters <var class="Arg">characters</var> of the character table <var class="Arg">tbl</var> with the trivial character of the symmetric group of degree <var class="Arg">n</var> (see <code class="func">Symmetrizations</code> (<a href="chap72.html#X7E220413823330EC"><span class="RefLink">72.11-1</span></a>)).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SymmetricParts( tbl, Irr( tbl ), 3 );</span>
[ Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 10, -2, 1, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 10, -2, 1, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 20, 0, 2, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 35, 3, 2, 0, 0 ] ) ]
</pre></div>

<p><a id="X8329E934829FE965" name="X8329E934829FE965"></a></p>

<h5>72.11-3 AntiSymmetricParts</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AntiSymmetricParts</code>( <var class="Arg">tbl</var>, <var class="Arg">characters</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>is the list of symmetrizations of the characters <var class="Arg">characters</var> of the character table <var class="Arg">tbl</var> with the alternating character of the symmetric group of degree <var class="Arg">n</var> (see <code class="func">Symmetrizations</code> (<a href="chap72.html#X7E220413823330EC"><span class="RefLink">72.11-1</span></a>)).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AntiSymmetricParts( tbl, Irr( tbl ), 3 );</span>
[ VirtualCharacter( CharacterTable( "A5" ), [ 0, 0, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 4, 0, 1, -1, -1 ] ), 
  Character( CharacterTable( "A5" ), [ 10, -2, 1, 0, 0 ] ) ]
</pre></div>

<p><a id="X78648E367C65B1F1" name="X78648E367C65B1F1"></a></p>

<h5>72.11-4 OrthogonalComponents</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OrthogonalComponents</code>( <var class="Arg">tbl</var>, <var class="Arg">chars</var>, <var class="Arg">m</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>If <span class="SimpleMath">χ</span> is a nonlinear character with indicator <span class="SimpleMath">+1</span>, a splitting of the tensor power <span class="SimpleMath">χ^m</span> is given by the so-called Murnaghan functions (see <a href="chapBib.html#biBMur58">[Mur58]</a>). These components in general have fewer irreducible constituents than the symmetrizations with the symmetric group of degree <var class="Arg">m</var> (see <code class="func">Symmetrizations</code> (<a href="chap72.html#X7E220413823330EC"><span class="RefLink">72.11-1</span></a>)).</p>

<p><code class="func">OrthogonalComponents</code> returns the Murnaghan components of the nonlinear characters of the character table <var class="Arg">tbl</var> in the list <var class="Arg">chars</var> up to the power <var class="Arg">m</var>, where <var class="Arg">m</var> is an integer between 2 and 6.</p>

<p>The Murnaghan functions are implemented as in <a href="chapBib.html#biBFra82">[Fra82]</a>.</p>

<p><em>Note</em>: If <var class="Arg">chars</var> is a list of character objects (see <code class="func">IsCharacter</code> (<a href="chap72.html#X7FE3CD08794051F8"><span class="RefLink">72.8-1</span></a>)) then also the result consists of class function objects. It is not checked whether all characters in <var class="Arg">chars</var> do really have indicator <span class="SimpleMath">+1</span>; if there are characters with indicator <span class="SimpleMath">0</span> or <span class="SimpleMath">-1</span>, the result might contain virtual characters (see also <code class="func">SymplecticComponents</code> (<a href="chap72.html#X788B9AA17DD9418C"><span class="RefLink">72.11-5</span></a>)), therefore the entries of the result do in general not know that they are characters.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( "A8" );;  chi:= Irr( tbl )[2];</span>
Character( CharacterTable( "A8" ), [ 7, -1, 3, 4, 1, -1, 1, 2, 0, -1, 
  0, 0, -1, -1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrthogonalComponents( tbl, [ chi ], 3 );</span>
[ ClassFunction( CharacterTable( "A8" ), 
    [ 21, -3, 1, 6, 0, 1, -1, 1, -2, 0, 0, 0, 1, 1 ] ), 
  ClassFunction( CharacterTable( "A8" ), 
    [ 27, 3, 7, 9, 0, -1, 1, 2, 1, 0, -1, -1, -1, -1 ] ), 
  ClassFunction( CharacterTable( "A8" ), 
    [ 105, 1, 5, 15, -3, 1, -1, 0, -1, 1, 0, 0, 0, 0 ] ), 
  ClassFunction( CharacterTable( "A8" ), 
    [ 35, 3, -5, 5, 2, -1, -1, 0, 1, 0, 0, 0, 0, 0 ] ), 
  ClassFunction( CharacterTable( "A8" ), 
    [ 77, -3, 13, 17, 2, 1, 1, 2, 1, 0, 0, 0, 2, 2 ] ) ]
</pre></div>

<p><a id="X788B9AA17DD9418C" name="X788B9AA17DD9418C"></a></p>

<h5>72.11-5 SymplecticComponents</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SymplecticComponents</code>( <var class="Arg">tbl</var>, <var class="Arg">chars</var>, <var class="Arg">m</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>If <span class="SimpleMath">χ</span> is a (nonlinear) character with indicator <span class="SimpleMath">-1</span>, a splitting of the tensor power <span class="SimpleMath">χ^m</span> is given in terms of the so-called Murnaghan functions (see <a href="chapBib.html#biBMur58">[Mur58]</a>). These components in general have fewer irreducible constituents than the symmetrizations with the symmetric group of degree <var class="Arg">m</var> (see <code class="func">Symmetrizations</code> (<a href="chap72.html#X7E220413823330EC"><span class="RefLink">72.11-1</span></a>)).</p>

<p><code class="func">SymplecticComponents</code> returns the symplectic symmetrizations of the nonlinear characters of the character table <var class="Arg">tbl</var> in the list <var class="Arg">chars</var> up to the power <var class="Arg">m</var>, where <var class="Arg">m</var> is an integer between <span class="SimpleMath">2</span> and <span class="SimpleMath">5</span>.</p>

<p><em>Note</em>: If <var class="Arg">chars</var> is a list of character objects (see <code class="func">IsCharacter</code> (<a href="chap72.html#X7FE3CD08794051F8"><span class="RefLink">72.8-1</span></a>)) then also the result consists of class function objects. It is not checked whether all characters in <var class="Arg">chars</var> do really have indicator <span class="SimpleMath">-1</span>; if there are characters with indicator <span class="SimpleMath">0</span> or <span class="SimpleMath">+1</span>, the result might contain virtual characters (see also <code class="func">OrthogonalComponents</code> (<a href="chap72.html#X78648E367C65B1F1"><span class="RefLink">72.11-4</span></a>)), therefore the entries of the result do in general not know that they are characters.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( "U3(3)" );;  chi:= Irr( tbl )[2];</span>
Character( CharacterTable( "U3(3)" ), 
[ 6, -2, -3, 0, -2, -2, 2, 1, -1, -1, 0, 0, 1, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SymplecticComponents( tbl, [ chi ], 3 );</span>
[ ClassFunction( CharacterTable( "U3(3)" ), 
    [ 14, -2, 5, -1, 2, 2, 2, 1, 0, 0, 0, 0, -1, -1 ] ), 
  ClassFunction( CharacterTable( "U3(3)" ), 
    [ 21, 5, 3, 0, 1, 1, 1, -1, 0, 0, -1, -1, 1, 1 ] ), 
  ClassFunction( CharacterTable( "U3(3)" ), 
    [ 64, 0, -8, -2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 ] ), 
  ClassFunction( CharacterTable( "U3(3)" ), 
    [ 14, 6, -4, 2, -2, -2, 2, 0, 0, 0, 0, 0, -2, -2 ] ), 
  ClassFunction( CharacterTable( "U3(3)" ), 
    [ 56, -8, 2, 2, 0, 0, 0, -2, 0, 0, 0, 0, 0, 0 ] ) ]
</pre></div>

<p><a id="X87B86B427A88CD25" name="X87B86B427A88CD25"></a></p>

<h4>72.12 <span class="Heading">Molien Series</span></h4>

<p><a id="X7D7F94D2820B1177" name="X7D7F94D2820B1177"></a></p>

<h5>72.12-1 MolienSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MolienSeries</code>( [<var class="Arg">tbl</var>, ]<var class="Arg">psi</var>[, <var class="Arg">chi</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>The <em>Molien series</em> of the character <span class="SimpleMath">ψ</span>, relative to the character <span class="SimpleMath">χ</span>, is the rational function given by the series <span class="SimpleMath">M_{ψ,χ}(z) = ∑_{d = 0}^∞ [χ,ψ^[d]] z^d</span>, where <span class="SimpleMath">ψ^[d]</span> denotes the symmetrization of <span class="SimpleMath">ψ</span> with the trivial character of the symmetric group <span class="SimpleMath">S_d</span> (see <code class="func">SymmetricParts</code> (<a href="chap72.html#X85CE68CA87CA383A"><span class="RefLink">72.11-2</span></a>)).</p>

<p><code class="func">MolienSeries</code> returns the Molien series of <var class="Arg">psi</var>, relative to <var class="Arg">chi</var>, where <var class="Arg">psi</var> and <var class="Arg">chi</var> must be characters of the same character table; this table must be entered as <var class="Arg">tbl</var> if <var class="Arg">chi</var> and <var class="Arg">psi</var> are only lists of character values. The default for <var class="Arg">chi</var> is the trivial character of <var class="Arg">tbl</var>.</p>

<p>The return value of <code class="func">MolienSeries</code> stores a value for the attribute <code class="func">MolienSeriesInfo</code> (<a href="chap72.html#X82AC06A880EAA0AB"><span class="RefLink">72.12-2</span></a>). This admits the computation of coefficients of the series with <code class="func">ValueMolienSeries</code> (<a href="chap72.html#X87083C4E7D11A02E"><span class="RefLink">72.12-3</span></a>). Furthermore, this attribute gives access to numerator and denominator of the Molien series viewed as rational function, where the denominator is a product of polynomials of the form <span class="SimpleMath">(1-z^r)^k</span>; the Molien series is also displayed in this form. Note that such a representation is not unique, one can use <code class="func">MolienSeriesWithGivenDenominator</code> (<a href="chap72.html#X86BAA3C487CE86D2"><span class="RefLink">72.12-4</span></a>) to obtain the series with a prescribed denominator.</p>

<p>For more information about Molien series, see <a href="chapBib.html#biBNPP84">[NPP84]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( AlternatingGroup( 5 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">psi:= First( Irr( t ), x -&gt; Degree( x ) = 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mol:= MolienSeries( psi );</span>
( 1-z^2-z^3+z^6+z^7-z^9 ) / ( (1-z^5)*(1-z^3)*(1-z^2)^2 )
</pre></div>

<p><a id="X82AC06A880EAA0AB" name="X82AC06A880EAA0AB"></a></p>

<h5>72.12-2 MolienSeriesInfo</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MolienSeriesInfo</code>( <var class="Arg">ratfun</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>If the rational function <var class="Arg">ratfun</var> was constructed by <code class="func">MolienSeries</code> (<a href="chap72.html#X7D7F94D2820B1177"><span class="RefLink">72.12-1</span></a>), a representation as quotient of polynomials is known such that the denominator is a product of terms of the form <span class="SimpleMath">(1-z^r)^k</span>. This information is encoded as value of <code class="func">MolienSeriesInfo</code>. Additionally, there is a special <code class="func">PrintObj</code> (<a href="chap6.html#X815BF22186FD43C9"><span class="RefLink">6.3-5</span></a>) method for Molien series based on this.</p>

<p><code class="func">MolienSeriesInfo</code> returns a record that describes the rational function <var class="Arg">ratfun</var> as a Molien series. The components of this record are</p>


<dl>
<dt><strong class="Mark"><code class="code">numer</code></strong></dt>
<dd><p>numerator of <var class="Arg">ratfun</var> (in general a multiple of the numerator one gets by <code class="func">NumeratorOfRationalFunction</code> (<a href="chap66.html#X7D7D2667803D8D8A"><span class="RefLink">66.4-2</span></a>)),</p>

</dd>
<dt><strong class="Mark"><code class="code">denom</code></strong></dt>
<dd><p>denominator of <var class="Arg">ratfun</var> (in general a multiple of the denominator one gets by <code class="func">NumeratorOfRationalFunction</code> (<a href="chap66.html#X7D7D2667803D8D8A"><span class="RefLink">66.4-2</span></a>)),</p>

</dd>
<dt><strong class="Mark"><code class="code">ratfun</code></strong></dt>
<dd><p>the rational function <var class="Arg">ratfun</var> itself,</p>

</dd>
<dt><strong class="Mark"><code class="code">numerstring</code></strong></dt>
<dd><p>string corresponding to the polynomial <code class="code">numer</code>, expressed in terms of <code class="code">z</code>,</p>

</dd>
<dt><strong class="Mark"><code class="code">denomstring</code></strong></dt>
<dd><p>string corresponding to the polynomial <code class="code">denom</code>, expressed in terms of <code class="code">z</code>,</p>

</dd>
<dt><strong class="Mark"><code class="code">denominfo</code></strong></dt>
<dd><p>a list of the form <span class="SimpleMath">[ [ r_1, k_1 ], ..., [ r_n, k_n ] ]</span> such that <code class="code">denom</code> is <span class="SimpleMath">∏_{i = 1}^n (1-z^{r_i})^{k_i}</span>.</p>

</dd>
<dt><strong class="Mark"><code class="code">summands</code></strong></dt>
<dd><p>a list of records, each with the components <code class="code">numer</code>, <code class="code">r</code>, and <code class="code">k</code>, describing the summand <code class="code">numer</code><span class="SimpleMath">/ (1-z^r)^k</span>,</p>

</dd>
<dt><strong class="Mark"><code class="code">pol</code></strong></dt>
<dd><p>a list of coefficients, describing a final polynomial which is added to those described by <code class="code">summands</code>,</p>

</dd>
<dt><strong class="Mark"><code class="code">size</code></strong></dt>
<dd><p>the order of the underlying matrix group,</p>

</dd>
<dt><strong class="Mark"><code class="code">degree</code></strong></dt>
<dd><p>the degree of the underlying matrix representation.</p>

</dd>
</dl>

<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HasMolienSeriesInfo( mol );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MolienSeriesInfo( mol );</span>
rec( degree := 3, 
  denom := x_1^12-2*x_1^10-x_1^9+x_1^8+x_1^7+x_1^5+x_1^4-x_1^3-2*x_1^2\
+1, denominfo := [ 5, 1, 3, 1, 2, 2 ], 
  denomstring := "(1-z^5)*(1-z^3)*(1-z^2)^2", 
  numer := -x_1^9+x_1^7+x_1^6-x_1^3-x_1^2+1, 
  numerstring := "1-z^2-z^3+z^6+z^7-z^9", pol := [  ], 
  ratfun := ( 1-z^2-z^3+z^6+z^7-z^9 ) / ( (1-z^5)*(1-z^3)*(1-z^2)^2 ),
  size := 60, 
  summands := [ rec( k := 1, numer := [ -24, -12, -24 ], r := 5 ), 
      rec( k := 1, numer := [ -20 ], r := 3 ), 
      rec( k := 2, numer := [ -45/4, 75/4, -15/4, -15/4 ], r := 2 ), 
      rec( k := 3, numer := [ -1 ], r := 1 ), 
      rec( k := 1, numer := [ -15/4 ], r := 1 ) ] )
</pre></div>

<p><a id="X87083C4E7D11A02E" name="X87083C4E7D11A02E"></a></p>

<h5>72.12-3 ValueMolienSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ValueMolienSeries</code>( <var class="Arg">molser</var>, <var class="Arg">i</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>is the <var class="Arg">i</var>-th coefficient of the Molien series <var class="Arg">series</var> computed by <code class="func">MolienSeries</code> (<a href="chap72.html#X7D7F94D2820B1177"><span class="RefLink">72.12-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( [ 0 .. 20 ], i -&gt; ValueMolienSeries( mol, i ) );</span>
[ 1, 0, 1, 0, 1, 0, 2, 0, 2, 0, 3, 0, 4, 0, 4, 1, 5, 1, 6, 1, 7 ]
</pre></div>

<p><a id="X86BAA3C487CE86D2" name="X86BAA3C487CE86D2"></a></p>

<h5>72.12-4 MolienSeriesWithGivenDenominator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MolienSeriesWithGivenDenominator</code>( <var class="Arg">molser</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>is a Molien series equal to <var class="Arg">molser</var> as rational function, but viewed as quotient with denominator <span class="SimpleMath">∏_{i = 1}^n (1-z^{r_i})</span>, where <span class="SimpleMath"><var class="Arg">list</var> = [ r_1, r_2, ..., r_n ]</span>. If <var class="Arg">molser</var> cannot be represented this way, <code class="keyw">fail</code> is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MolienSeriesWithGivenDenominator( mol, [ 2, 6, 10 ] );</span>
( 1+z^15 ) / ( (1-z^10)*(1-z^6)*(1-z^2) )
</pre></div>

<p><a id="X7D6336857E6BDF46" name="X7D6336857E6BDF46"></a></p>

<h4>72.13 <span class="Heading">Possible Permutation Characters</span></h4>

<p>For groups <span class="SimpleMath">H</span> and <span class="SimpleMath">G</span> with <span class="SimpleMath">H ≤ G</span>, the induced character <span class="SimpleMath">(1_G)^H</span> is called the <em>permutation character</em> of the operation of <span class="SimpleMath">G</span> on the right cosets of <span class="SimpleMath">H</span>. If only the character table of <span class="SimpleMath">G</span> is available and not the group <span class="SimpleMath">G</span> itself, one can try to get information about possible subgroups of <span class="SimpleMath">G</span> by inspection of those <span class="SimpleMath">G</span>-class functions that might be permutation characters, using that such a class function <span class="SimpleMath">π</span> must have at least the following properties. (For details, see <a href="chapBib.html#biBIsa76">[Isa76, Theorem 5.18.]</a>),</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p><span class="SimpleMath">π</span> is a character of <span class="SimpleMath">G</span>,</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p><span class="SimpleMath">π(g)</span> is a nonnegative integer for all <span class="SimpleMath">g ∈ G</span>,</p>

</dd>
<dt><strong class="Mark">(c)</strong></dt>
<dd><p><span class="SimpleMath">π(1)</span> divides <span class="SimpleMath">|G|</span>,</p>

</dd>
<dt><strong class="Mark">(d)</strong></dt>
<dd><p><span class="SimpleMath">π(g^n) ≥ π(g)</span> for <span class="SimpleMath">g ∈ G</span> and integers <span class="SimpleMath">n</span>,</p>

</dd>
<dt><strong class="Mark">(e)</strong></dt>
<dd><p><span class="SimpleMath">[π, 1_G] = 1</span>,</p>

</dd>
<dt><strong class="Mark">(f)</strong></dt>
<dd><p>the multiplicity of any rational irreducible <span class="SimpleMath">G</span>-character <span class="SimpleMath">ψ</span> as a constituent of <span class="SimpleMath">π</span> is at most <span class="SimpleMath">ψ(1)/[ψ, ψ]</span>,</p>

</dd>
<dt><strong class="Mark">(g)</strong></dt>
<dd><p><span class="SimpleMath">π(g) = 0</span> if the order of <span class="SimpleMath">g</span> does not divide <span class="SimpleMath">|G|/π(1)</span>,</p>

</dd>
<dt><strong class="Mark">(h)</strong></dt>
<dd><p><span class="SimpleMath">π(1) |N_G(g)|</span> divides <span class="SimpleMath">π(g) |G|</span> for all <span class="SimpleMath">g ∈ G</span>,</p>

</dd>
<dt><strong class="Mark">(i)</strong></dt>
<dd><p><span class="SimpleMath">π(g) ≤ (|G| - π(1)) / (|g^G| |Gal_G(g)|)</span> for all nonidentity <span class="SimpleMath">g ∈ G</span>, where <span class="SimpleMath">|Gal_G(g)|</span> denotes the number of conjugacy classes of <span class="SimpleMath">G</span> that contain generators of the group <span class="SimpleMath">⟨ g ⟩</span>,</p>

</dd>
<dt><strong class="Mark">(j)</strong></dt>
<dd><p>if <span class="SimpleMath">p</span> is a prime that divides <span class="SimpleMath">|G|/π(1)</span> only once then <span class="SimpleMath">s/(p-1)</span> divides <span class="SimpleMath">|G|/π(1)</span> and is congruent to <span class="SimpleMath">1</span> modulo <span class="SimpleMath">p</span>, where <span class="SimpleMath">s</span> is the number of elements of order <span class="SimpleMath">p</span> in the (hypothetical) subgroup <span class="SimpleMath">H</span> for which <span class="SimpleMath">π = (1_H)^G</span> holds. (Note that <span class="SimpleMath">s/(p-1)</span> equals the number of Sylow <span class="SimpleMath">p</span> subgroups in <span class="SimpleMath">H</span>.)</p>

</dd>
</dl>
<p>Any <span class="SimpleMath">G</span>-class function with these properties is called a <em>possible permutation character</em> in <strong class="pkg">GAP</strong>.</p>

<p>(Condition (d) is checked only for those power maps that are stored in the character table of <span class="SimpleMath">G</span>; clearly (d) holds for all integers if it holds for all prime divisors of the group order <span class="SimpleMath">|G|</span>.)</p>

<p><strong class="pkg">GAP</strong> provides some algorithms to compute possible permutation characters (see <code class="func">PermChars</code> (<a href="chap72.html#X7D02541482C196A6"><span class="RefLink">72.14-1</span></a>)), and also provides functions to check a few more criteria whether a given character can be a transitive permutation character (see <code class="func">TestPerm1</code> (<a href="chap72.html#X8127771D7EAB6EA7"><span class="RefLink">72.14-2</span></a>)).</p>

<p>Some information about the subgroup <span class="SimpleMath">U</span> can be computed from the permutation character <span class="SimpleMath">(1_U)^G</span> using <code class="func">PermCharInfo</code> (<a href="chap72.html#X8477004C7A31D28C"><span class="RefLink">72.13-1</span></a>).</p>

<p><a id="X8477004C7A31D28C" name="X8477004C7A31D28C"></a></p>

<h5>72.13-1 PermCharInfo</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PermCharInfo</code>( <var class="Arg">tbl</var>, <var class="Arg">permchars</var>[, <var class="Arg">format</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">tbl</var> be the ordinary character table of the group <span class="SimpleMath">G</span>, and <var class="Arg">permchars</var> either the permutation character <span class="SimpleMath">(1_U)^G</span>, for a subgroup <span class="SimpleMath">U</span> of <span class="SimpleMath">G</span>, or a list of such permutation characters. <code class="func">PermCharInfo</code> returns a record with the following components.</p>


<dl>
<dt><strong class="Mark"><code class="code">contained</code>:</strong></dt>
<dd><p>a list containing, for each character <span class="SimpleMath">ψ = (1_U)^G</span> in <var class="Arg">permchars</var>, a list containing at position <span class="SimpleMath">i</span> the number <span class="SimpleMath">ψ[i] |U| /</span> <code class="code">SizesCentralizers( </code><var class="Arg">tbl</var><code class="code"> )</code><span class="SimpleMath">[i]</span>, which equals the number of those elements of <span class="SimpleMath">U</span> that are contained in class <span class="SimpleMath">i</span> of <var class="Arg">tbl</var>,</p>

</dd>
<dt><strong class="Mark"><code class="code">bound</code>:</strong></dt>
<dd><p>a list containing, for each character <span class="SimpleMath">ψ = (1_U)^G</span> in <var class="Arg">permchars</var>, a list containing at position <span class="SimpleMath">i</span> the number <span class="SimpleMath">|U| / gcd( |U|,</span> <code class="code">SizesCentralizers( <var class="Arg">tbl</var> )</code><span class="SimpleMath">[i] )</span>, which divides the class length in <span class="SimpleMath">U</span> of an element in class <span class="SimpleMath">i</span> of <var class="Arg">tbl</var>,</p>

</dd>
<dt><strong class="Mark"><code class="code">display</code>:</strong></dt>
<dd><p>a record that can be used as second argument of <code class="func">Display</code> (<a href="chap6.html#X83A5C59278E13248"><span class="RefLink">6.3-6</span></a>) to display each permutation character in <var class="Arg">permchars</var> and the corresponding components <code class="code">contained</code> and <code class="code">bound</code>, for those classes where at least one character of <var class="Arg">permchars</var> is nonzero,</p>

</dd>
<dt><strong class="Mark"><code class="code">ATLAS</code>:</strong></dt>
<dd><p>a list of strings describing the decomposition of the permutation characters in <var class="Arg">permchars</var> into the irreducible characters of <var class="Arg">tbl</var>, given in an <strong class="pkg">Atlas</strong>-like notation. This means that the irreducible constituents are indicated by their degrees followed by lower case letters <code class="code">a</code>, <code class="code">b</code>, <code class="code">c</code>, <span class="SimpleMath">...</span>, which indicate the successive irreducible characters of <var class="Arg">tbl</var> of that degree, in the order in which they appear in <code class="code">Irr( </code><var class="Arg">tbl</var><code class="code"> )</code>. A sequence of small letters (not necessarily distinct) after a single number indicates a sum of irreducible constituents all of the same degree, an exponent <var class="Arg">n</var> for the letter <var class="Arg">lett</var> means that <var class="Arg">lett</var> is repeated <var class="Arg">n</var> times. The default notation for exponentiation is <code class="code"><var class="Arg">lett</var>^{<var class="Arg">n</var>}</code>, this is also chosen if the optional third argument <var class="Arg">format</var> is the string <code class="code">"LaTeX"</code>; if the third argument is the string <code class="code">"HTML"</code> then exponentiation is denoted by <code class="code"><var class="Arg">lett</var>&lt;sup&gt;<var class="Arg">n</var>&lt;/sup&gt;</code>.</p>

</dd>
</dl>

<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "A6" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">psi:= Sum( Irr( t ){ [ 1, 3, 6 ] } );</span>
Character( CharacterTable( "A6" ), [ 15, 3, 0, 3, 1, 0, 0 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">info:= PermCharInfo( t, psi );</span>
rec( ATLAS := [ "1a+5b+9a" ], bound := [ [ 1, 3, 8, 8, 6, 24, 24 ] ], 
  contained := [ [ 1, 9, 0, 8, 6, 0, 0 ] ], 
  display := 
    rec( 
      chars := [ [ 15, 3, 0, 3, 1, 0, 0 ], [ 1, 9, 0, 8, 6, 0, 0 ], 
          [ 1, 3, 8, 8, 6, 24, 24 ] ], classes := [ 1, 2, 4, 5 ], 
      letter := "I" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( t, info.display );</span>
A6

     2  3  3  .  2
     3  2  .  2  .
     5  1  .  .  .

       1a 2a 3b 4a
    2P 1a 1a 3b 2a
    3P 1a 2a 1a 4a
    5P 1a 2a 3b 4a

I.1    15  3  3  1
I.2     1  9  8  6
I.3     1  3  8  6
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">j1:= CharacterTable( "J1" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">psi:= TrivialCharacter( CharacterTable( "7:6" ) )^j1;</span>
Character( CharacterTable( "J1" ), [ 4180, 20, 10, 0, 0, 2, 1, 0, 0, 
  0, 0, 0, 0, 0, 0 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PermCharInfo( j1, psi ).ATLAS;</span>
[ "1a+56aabb+76aaab+77aabbcc+120aaabbbccc+133a^{4}bbcc+209a^{5}" ]
</pre></div>

<p><a id="X7A8CB0298730D808" name="X7A8CB0298730D808"></a></p>

<h5>72.13-2 PermCharInfoRelative</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PermCharInfoRelative</code>( <var class="Arg">tbl</var>, <var class="Arg">tbl2</var>, <var class="Arg">permchars</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">tbl</var> and <var class="Arg">tbl2</var> be the ordinary character tables of two groups <span class="SimpleMath">H</span> and <span class="SimpleMath">G</span>, respectively, where <span class="SimpleMath">H</span> is of index two in <span class="SimpleMath">G</span>, and <var class="Arg">permchars</var> either the permutation character <span class="SimpleMath">(1_U)^G</span>, for a subgroup <span class="SimpleMath">U</span> of <span class="SimpleMath">G</span>, or a list of such permutation characters. <code class="func">PermCharInfoRelative</code> returns a record with the same components as <code class="func">PermCharInfo</code> (<a href="chap72.html#X8477004C7A31D28C"><span class="RefLink">72.13-1</span></a>), the only exception is that the entries of the <code class="code">ATLAS</code> component are names relative to <var class="Arg">tbl</var>.</p>

<p>More precisely, the <span class="SimpleMath">i</span>-th entry of the <code class="code">ATLAS</code> component is a string describing the decomposition of the <span class="SimpleMath">i</span>-th entry in <var class="Arg">permchars</var>. The degrees and distinguishing letters of the constituents refer to the irreducibles of <var class="Arg">tbl</var>, as follows. The two irreducible characters of <var class="Arg">tbl2</var> of degree <span class="SimpleMath">N</span>, say, that extend the irreducible character <span class="SimpleMath">N</span> <code class="code">a</code> of <var class="Arg">tbl</var> are denoted by <span class="SimpleMath">N</span> <code class="code">a</code><span class="SimpleMath">^+</span> and <span class="SimpleMath">N</span><code class="code">a</code><span class="SimpleMath">^-</span>. The irreducible character of <var class="Arg">tbl2</var> of degree <span class="SimpleMath">2N</span>, say, whose restriction to <var class="Arg">tbl</var> is the sum of the irreducible characters <span class="SimpleMath">N</span> <code class="code">a</code> and <span class="SimpleMath">N</span> <code class="code">b</code> is denoted as <span class="SimpleMath">N</span> <code class="code">ab</code>. Multiplicities larger than <span class="SimpleMath">1</span> of constituents are denoted by exponents.</p>

<p>(This format is useful mainly for multiplicity free permutation characters.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "A5" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t2:= CharacterTable( "A5.2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( Irr( t2 ), x -&gt; x[1] );</span>
[ 1, 1, 6, 4, 4, 5, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( Irr( t ), x -&gt; x[1] );</span>
[ 1, 3, 3, 4, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">permchars:= List( [ [1], [1,2], [1,7], [1,3,4,4,6,6,7] ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                     l -&gt; Sum( Irr( t2 ){ l } ) );</span>
[ Character( CharacterTable( "A5.2" ), [ 1, 1, 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5.2" ), [ 2, 2, 2, 2, 0, 0, 0 ] ), 
  Character( CharacterTable( "A5.2" ), [ 6, 2, 0, 1, 0, 2, 0 ] ), 
  Character( CharacterTable( "A5.2" ), [ 30, 2, 0, 0, 6, 0, 0 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">info:= PermCharInfoRelative( t, t2, permchars );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">info.ATLAS;</span>
[ "1a^+", "1a^{\\pm}", "1a^++5a^-", 
  "1a^++3ab+4(a^+)^{2}+5a^+a^{\\pm}" ]
</pre></div>

<p><a id="X8330FDCE83D3DED3" name="X8330FDCE83D3DED3"></a></p>

<h4>72.14 <span class="Heading">Computing Possible Permutation Characters</span></h4>

<p><a id="X7D02541482C196A6" name="X7D02541482C196A6"></a></p>

<h5>72.14-1 PermChars</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PermChars</code>( <var class="Arg">tbl</var>[, <var class="Arg">cond</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><strong class="pkg">GAP</strong> provides several algorithms to determine possible permutation characters from a given character table. They are described in detail in <a href="chapBib.html#biBBP98">[BP98]</a>. The algorithm is selected from the choice of the optional argument <var class="Arg">cond</var>. The user is encouraged to try different approaches, especially if one choice fails to come to an end.</p>

<p>Regardless of the algorithm used in a specific case, <code class="func">PermChars</code> returns a list of <em>all</em> possible permutation characters with the properties described by <var class="Arg">cond</var>. There is no guarantee that a character of this list is in fact a permutation character. But an empty list always means there is no permutation character with these properties (e.g., of a certain degree).</p>

<p>Called with only one argument, a character table <var class="Arg">tbl</var>, <code class="func">PermChars</code> returns the list of all possible permutation characters of the group with this character table. This list might be rather long for big groups, and its computation might take much time. The algorithm is described in <a href="chapBib.html#biBBP98">[BP98, Section 3.2]</a>; it depends on a preprocessing step, where the inequalities arising from the condition <span class="SimpleMath">π(g) ≥ 0</span> are transformed into a system of inequalities that guides the search (see <code class="func">Inequalities</code> (<a href="chap72.html#X866942167802E036"><span class="RefLink">72.14-5</span></a>)). So the following commands compute the list of 39 possible permutation characters of the Mathieu group <span class="SimpleMath">M_11</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m11:= CharacterTable( "M11" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( m11, "m11" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">perms:= PermChars( m11 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( perms );</span>
39
</pre></div>

<p>There are two different search strategies for this algorithm. The default strategy simply constructs all characters with nonnegative values and then tests for each such character whether its degree is a divisor of the order of the group. The other strategy uses the inequalities to predict whether a character of a certain degree can lie in the currently searched part of the search tree. To choose this strategy, enter a record as the second argument of <code class="func">PermChars</code>, and set its component <code class="code">degree</code> to the range of degrees (which might also be a range containing all divisors of the group order) you want to look for; additionally, the record component <code class="code">ineq</code> can take the inequalities computed by <code class="func">Inequalities</code> (<a href="chap72.html#X866942167802E036"><span class="RefLink">72.14-5</span></a>) if they are needed more than once.</p>

<p>If a positive integer is given as the second argument <var class="Arg">cond</var>, <code class="func">PermChars</code> returns the list of all possible permutation characters of <var class="Arg">tbl</var> that have degree <var class="Arg">cond</var>. For that purpose, a preprocessing step is performed where essentially the rational character table is inverted in order to determine boundary points for the simplex in which the possible permutation characters of the given degree must lie (see <code class="func">PermBounds</code> (<a href="chap72.html#X879D2A127BE366A5"><span class="RefLink">72.14-3</span></a>)). The algorithm is described at the end of <a href="chapBib.html#biBBP98">[BP98, Section 3.2]</a>. Note that inverting big integer matrices needs a lot of time and space. So this preprocessing is restricted to groups with less than 100 classes, say.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">deg220:= PermChars( m11, 220 );</span>
[ Character( m11, [ 220, 4, 4, 0, 0, 4, 0, 0, 0, 0 ] ), 
  Character( m11, [ 220, 12, 4, 4, 0, 0, 0, 0, 0, 0 ] ), 
  Character( m11, [ 220, 20, 4, 0, 0, 2, 0, 0, 0, 0 ] ) ]
</pre></div>

<p>If a record is given as the second argument <var class="Arg">cond</var>, <code class="func">PermChars</code> returns the list of all possible permutation characters that have the properties described by the components of this record. One such situation has been mentioned above. If <var class="Arg">cond</var> contains a degree as value of the record component <code class="code">degree</code> then <code class="func">PermChars</code> will behave exactly as if this degree was entered as <var class="Arg">cond</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">deg220 = PermChars( m11, rec( degree:= 220 ) );</span>
true
</pre></div>

<p>For the meaning of additional components of <var class="Arg">cond</var> besides <code class="code">degree</code>, see <code class="func">PermComb</code> (<a href="chap72.html#X7F11AFB783352903"><span class="RefLink">72.14-4</span></a>).</p>

<p>Instead of <code class="code">degree</code>, <var class="Arg">cond</var> may have the component <code class="code">torso</code> bound to a list that contains some known values of the required characters at the right positions; at least the degree <var class="Arg">cond</var><code class="code">.torso[1]</code> must be an integer. In this case, the algorithm described in <a href="chapBib.html#biBBP98">[BP98, Section 3.3]</a> is chosen. The component <code class="code">chars</code>, if present, holds a list of all those <em>rational</em> irreducible characters of <var class="Arg">tbl</var> that might be constituents of the required characters.</p>

<p>(<em>Note</em>: If <var class="Arg">cond</var><code class="code">.chars</code> is bound and does not contain <em>all</em> rational irreducible characters of <var class="Arg">tbl</var>, <strong class="pkg">GAP</strong> checks whether the scalar products of all class functions in the result list with the omitted rational irreducible characters of <var class="Arg">tbl</var> are nonnegative; so there should be nontrivial reasons for excluding a character that is known to be not a constituent of the desired possible permutation characters.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PermChars( m11, rec( torso:= [ 220 ] ) );</span>
[ Character( m11, [ 220, 4, 4, 0, 0, 4, 0, 0, 0, 0 ] ), 
  Character( m11, [ 220, 20, 4, 0, 0, 2, 0, 0, 0, 0 ] ), 
  Character( m11, [ 220, 12, 4, 4, 0, 0, 0, 0, 0, 0 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PermChars( m11, rec( torso:= [ 220,,,,, 2 ] ) );</span>
[ Character( m11, [ 220, 20, 4, 0, 0, 2, 0, 0, 0, 0 ] ) ]
</pre></div>

<p>An additional restriction on the possible permutation characters computed can be forced if <var class="Arg">con</var> contains, in addition to <code class="code">torso</code>, the components <code class="code">normalsubgroup</code> and <code class="code">nonfaithful</code>, with values a list of class positions of a normal subgroup <span class="SimpleMath">N</span> of the group <span class="SimpleMath">G</span> of <var class="Arg">tbl</var> and a possible permutation character <span class="SimpleMath">π</span> of <span class="SimpleMath">G</span>, respectively, such that <span class="SimpleMath">N</span> is contained in the kernel of <span class="SimpleMath">π</span>. In this case, <code class="func">PermChars</code> returns the list of those possible permutation characters <span class="SimpleMath">ψ</span> of <var class="Arg">tbl</var> coinciding with <code class="code">torso</code> wherever its values are bound and having the property that no irreducible constituent of <span class="SimpleMath">ψ - π</span> has <span class="SimpleMath">N</span> in its kernel. If the component <code class="code">chars</code> is bound in <var class="Arg">cond</var> then the above statements apply. An interpretation of the computed characters is the following. Suppose there exists a subgroup <span class="SimpleMath">V</span> of <span class="SimpleMath">G</span> such that <span class="SimpleMath">π = (1_V)^G</span>; Then <span class="SimpleMath">N ≤ V</span>, and if a computed character is of the form <span class="SimpleMath">(1_U)^G</span>, for a subgroup <span class="SimpleMath">U</span> of <span class="SimpleMath">G</span>, then <span class="SimpleMath">V = UN</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s4:= CharacterTable( "Symmetric", 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nsg:= ClassPositionsOfDerivedSubgroup( s4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= TrivialCharacter( s4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PermChars( s4, rec( torso:= [ 12 ], normalsubgroup:= nsg,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                       nonfaithful:= pi ) );</span>
[ Character( CharacterTable( "Sym(4)" ), [ 12, 2, 0, 0, 0 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= Sum( Filtered( Irr( s4 ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             chi -&gt; IsSubset( ClassPositionsOfKernel( chi ), nsg ) ) );</span>
Character( CharacterTable( "Sym(4)" ), [ 2, 0, 2, 2, 0 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PermChars( s4, rec( torso:= [ 12 ], normalsubgroup:= nsg,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                       nonfaithful:= pi ) );</span>
[ Character( CharacterTable( "Sym(4)" ), [ 12, 0, 4, 0, 0 ] ) ]
</pre></div>

<p>The class functions returned by <code class="func">PermChars</code> have the properties tested by <code class="func">TestPerm1</code> (<a href="chap72.html#X8127771D7EAB6EA7"><span class="RefLink">72.14-2</span></a>), <code class="func">TestPerm2</code> (<a href="chap72.html#X8127771D7EAB6EA7"><span class="RefLink">72.14-2</span></a>), and <code class="func">TestPerm3</code> (<a href="chap72.html#X8127771D7EAB6EA7"><span class="RefLink">72.14-2</span></a>). So they are possible permutation characters. See <code class="func">TestPerm1</code> (<a href="chap72.html#X8127771D7EAB6EA7"><span class="RefLink">72.14-2</span></a>) for criteria whether a possible permutation character can in fact be a permutation character.</p>

<p><a id="X8127771D7EAB6EA7" name="X8127771D7EAB6EA7"></a></p>

<h5>72.14-2 <span class="Heading">TestPerm1, ..., TestPerm5</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TestPerm1</code>( <var class="Arg">tbl</var>, <var class="Arg">char</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TestPerm2</code>( <var class="Arg">tbl</var>, <var class="Arg">char</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TestPerm3</code>( <var class="Arg">tbl</var>, <var class="Arg">chars</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TestPerm4</code>( <var class="Arg">tbl</var>, <var class="Arg">chars</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TestPerm5</code>( <var class="Arg">tbl</var>, <var class="Arg">chars</var>, <var class="Arg">modtbl</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>The first three of these functions implement tests of the properties of possible permutation characters listed in Section <a href="chap72.html#X7D6336857E6BDF46"><span class="RefLink">72.13</span></a>, The other two implement test of additional properties. Let <var class="Arg">tbl</var> be the ordinary character table of a group <span class="SimpleMath">G</span>, say, <var class="Arg">char</var> a rational character of <var class="Arg">tbl</var>, and <var class="Arg">chars</var> a list of rational characters of <var class="Arg">tbl</var>. For applying <code class="func">TestPerm5</code>, the knowledge of a <span class="SimpleMath">p</span>-modular Brauer table <var class="Arg">modtbl</var> of <span class="SimpleMath">G</span> is required. <code class="func">TestPerm4</code> and <code class="func">TestPerm5</code> expect the characters in <var class="Arg">chars</var> to satisfy the conditions checked by <code class="func">TestPerm1</code> and <code class="func">TestPerm2</code> (see below).</p>

<p>The return values of the functions were chosen parallel to the tests listed in <a href="chapBib.html#biBNPP84">[NPP84]</a>.</p>

<p><code class="func">TestPerm1</code> return <code class="code">1</code> or <code class="code">2</code> if <var class="Arg">char</var> fails because of (T1) or (T2), respectively; this corresponds to the criteria (b) and (d). Note that only those power maps are considered that are stored on <var class="Arg">tbl</var>. If <var class="Arg">char</var> satisfies the conditions, <code class="code">0</code> is returned.</p>

<p><code class="func">TestPerm2</code> returns <code class="code">1</code> if <var class="Arg">char</var> fails because of the criterion (c), it returns <code class="code">3</code>, <code class="code">4</code>, or <code class="code">5</code> if <var class="Arg">char</var> fails because of (T3), (T4), or (T5), respectively; these tests correspond to (g), a weaker form of (h), and (j). If <var class="Arg">char</var> satisfies the conditions, <code class="code">0</code> is returned.</p>

<p><code class="func">TestPerm3</code> returns the list of all those class functions in the list <var class="Arg">chars</var> that satisfy criterion (h); this is a stronger version of (T6).</p>

<p><code class="func">TestPerm4</code> returns the list of all those class functions in the list <var class="Arg">chars</var> that satisfy (T8) and (T9) for each prime divisor <span class="SimpleMath">p</span> of the order of <span class="SimpleMath">G</span>; these tests use modular representation theory but do not require the knowledge of decomposition matrices (cf. <code class="func">TestPerm5</code> below).</p>

<p>(T8) implements the test of the fact that in the case that <span class="SimpleMath">p</span> divides <span class="SimpleMath">|G|</span> and the degree of a transitive permutation character <span class="SimpleMath">π</span> exactly once, the projective cover of the trivial character is a summand of <span class="SimpleMath">π</span>. (This test is omitted if the projective cover cannot be identified.)</p>

<p>Given a permutation character <span class="SimpleMath">π</span> of a group <span class="SimpleMath">G</span> and a prime integer <span class="SimpleMath">p</span>, the restriction <span class="SimpleMath">π_B</span> to a <span class="SimpleMath">p</span>-block <span class="SimpleMath">B</span> of <span class="SimpleMath">G</span> has the following property, which is checked by (T9). For each <span class="SimpleMath">g ∈ G</span> such that <span class="SimpleMath">g^n</span> is a <span class="SimpleMath">p</span>-element of <span class="SimpleMath">G</span>, <span class="SimpleMath">π_B(g^n)</span> is a nonnegative integer that satisfies <span class="SimpleMath">|π_B(g)| ≤ π_B(g^n) ≤ π(g^n)</span>. (This is <a href="chapBib.html#biBSco73">[Sco73, Corollary A on p. 113]</a>.)</p>

<p><code class="func">TestPerm5</code> requires the <span class="SimpleMath">p</span>-modular Brauer table <var class="Arg">modtbl</var> of <span class="SimpleMath">G</span>, for some prime <span class="SimpleMath">p</span> dividing the order of <span class="SimpleMath">G</span>, and checks whether those characters in the list <var class="Arg">chars</var> whose degree is divisible by the <span class="SimpleMath">p</span>-part of the order of <span class="SimpleMath">G</span> can be decomposed into projective indecomposable characters; <code class="func">TestPerm5</code> returns the sublist of all those characters in <var class="Arg">chars</var> that either satisfy this condition or to which the test does not apply.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( "A5" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rat:= RationalizedMat( Irr( tbl ) );</span>
[ Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 6, -2, 0, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 4, 0, 1, -1, -1 ] ), 
  Character( CharacterTable( "A5" ), [ 5, 1, -1, 0, 0 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tup:= Filtered( Tuples( [ 0, 1 ], 4 ), x -&gt; not IsZero( x ) );</span>
[ [ 0, 0, 0, 1 ], [ 0, 0, 1, 0 ], [ 0, 0, 1, 1 ], [ 0, 1, 0, 0 ], 
  [ 0, 1, 0, 1 ], [ 0, 1, 1, 0 ], [ 0, 1, 1, 1 ], [ 1, 0, 0, 0 ], 
  [ 1, 0, 0, 1 ], [ 1, 0, 1, 0 ], [ 1, 0, 1, 1 ], [ 1, 1, 0, 0 ], 
  [ 1, 1, 0, 1 ], [ 1, 1, 1, 0 ], [ 1, 1, 1, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lincomb:= List( tup, coeff -&gt; coeff * rat );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( lincomb, psi -&gt; TestPerm1( tbl, psi ) );</span>
[ 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( lincomb, psi -&gt; TestPerm2( tbl, psi ) );</span>
[ 0, 5, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Set( List( TestPerm3(tbl, lincomb), x -&gt; Position(lincomb, x) ) );</span>
[ 1, 4, 6, 7, 8, 9, 10, 11, 13 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( "A7" );</span>
CharacterTable( "A7" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">perms:= PermChars( tbl, rec( degree:= 315 ) );</span>
[ Character( CharacterTable( "A7" ), [ 315, 3, 0, 0, 3, 0, 0, 0, 0 ] )
    , Character( CharacterTable( "A7" ), 
    [ 315, 15, 0, 0, 1, 0, 0, 0, 0 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TestPerm4( tbl, perms );</span>
[ Character( CharacterTable( "A7" ), [ 315, 15, 0, 0, 1, 0, 0, 0, 0 
     ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">perms:= PermChars( tbl, rec( degree:= 15 ) );</span>
[ Character( CharacterTable( "A7" ), [ 15, 3, 0, 3, 1, 0, 0, 1, 1 ] ),
  Character( CharacterTable( "A7" ), [ 15, 3, 3, 0, 1, 0, 3, 1, 1 ] ) 
 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TestPerm5( tbl, perms, tbl mod 5 );</span>
[ Character( CharacterTable( "A7" ), [ 15, 3, 0, 3, 1, 0, 0, 1, 1 ] ) 
 ]
</pre></div>

<p><a id="X879D2A127BE366A5" name="X879D2A127BE366A5"></a></p>

<h5>72.14-3 PermBounds</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PermBounds</code>( <var class="Arg">tbl</var>, <var class="Arg">d</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">tbl</var> be the ordinary character table of the group <span class="SimpleMath">G</span>. All <span class="SimpleMath">G</span>-characters <span class="SimpleMath">π</span> satisfying <span class="SimpleMath">π(g) &gt; 0</span> and <span class="SimpleMath">π(1) = <var class="Arg">d</var></span>, for a given degree <var class="Arg">d</var>, lie in a simplex described by these conditions. <code class="func">PermBounds</code> computes the boundary points of this simplex for <span class="SimpleMath">d = 0</span>, from which the boundary points for any other <var class="Arg">d</var> are easily derived. (Some conditions from the power maps of <var class="Arg">tbl</var> are also involved.) For this purpose, a matrix similar to the rational character table of <span class="SimpleMath">G</span> has to be inverted. These boundary points are used by <code class="func">PermChars</code> (<a href="chap72.html#X7D02541482C196A6"><span class="RefLink">72.14-1</span></a>) to construct all possible permutation characters (see <a href="chap72.html#X7D6336857E6BDF46"><span class="RefLink">72.13</span></a>) of a given degree. <code class="func">PermChars</code> (<a href="chap72.html#X7D02541482C196A6"><span class="RefLink">72.14-1</span></a>) either calls <code class="func">PermBounds</code> or takes this information from the <code class="code">bounds</code> component of its argument record.</p>

<p><a id="X7F11AFB783352903" name="X7F11AFB783352903"></a></p>

<h5>72.14-4 PermComb</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PermComb</code>( <var class="Arg">tbl</var>, <var class="Arg">arec</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="func">PermComb</code> computes possible permutation characters of the character table <var class="Arg">tbl</var> by the improved combinatorial approach described at the end of <a href="chapBib.html#biBBP98">[BP98, Section 3.2]</a>.</p>

<p>For computing the possible linear combinations <em>without</em> prescribing better bounds (i.e., when the computation of bounds shall be suppressed), enter</p>

<p><code class="code"><var class="Arg">arec</var>:= rec( degree := <var class="Arg">degree</var>, bounds := false )</code>,</p>

<p>where <var class="Arg">degree</var> is the character degree; this is useful if the multiplicities are expected to be small, and if this is forced by high irreducible degrees.</p>

<p>A list of upper bounds on the multiplicities of the rational irreducibles characters can be explicitly prescribed as a <code class="code">maxmult</code> component in <var class="Arg">arec</var>.</p>

<p><a id="X866942167802E036" name="X866942167802E036"></a></p>

<h5>72.14-5 Inequalities</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Inequalities</code>( <var class="Arg">tbl</var>, <var class="Arg">chars</var>[, <var class="Arg">option</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">tbl</var> be the ordinary character table of a group <span class="SimpleMath">G</span>. The condition <span class="SimpleMath">π(g) ≥ 0</span> for every possible permutation character <span class="SimpleMath">π</span> of <span class="SimpleMath">G</span> places restrictions on the multiplicities <span class="SimpleMath">a_i</span> of the irreducible constituents <span class="SimpleMath">χ_i</span> of <span class="SimpleMath">π = ∑_{i = 1}^r a_i χ_i</span>. For every element <span class="SimpleMath">g ∈ G</span>, we have <span class="SimpleMath">∑_{i = 1}^r a_i χ_i(g) ≥ 0</span>. The power maps provide even stronger conditions.</p>

<p>This system of inequalities is kind of diagonalized, resulting in a system of inequalities restricting <span class="SimpleMath">a_i</span> in terms of <span class="SimpleMath">a_j</span>, <span class="SimpleMath">j &lt; i</span>. These inequalities are used to construct characters with nonnegative values (see <code class="func">PermChars</code> (<a href="chap72.html#X7D02541482C196A6"><span class="RefLink">72.14-1</span></a>)). <code class="func">PermChars</code> (<a href="chap72.html#X7D02541482C196A6"><span class="RefLink">72.14-1</span></a>) either calls <code class="func">Inequalities</code> or takes this information from the <code class="code">ineq</code> component of its argument record.</p>

<p>The number of inequalities arising in the process of diagonalization may grow very strongly.</p>

<p>There are two ways to organize the projection. The first, which is chosen if no <var class="Arg">option</var> argument is present, is the straight approach which takes the rational irreducible characters in their original order and by this guarantees the character with the smallest degree to be considered first. The other way, which is chosen if the string <code class="code">"small"</code> is entered as third argument <var class="Arg">option</var>, tries to keep the number of intermediate inequalities small by eventually changing the order of characters.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( "M11" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PermComb( tbl, rec( degree:= 110 ) );</span>
[ Character( CharacterTable( "M11" ), 
    [ 110, 6, 2, 2, 0, 0, 2, 2, 0, 0 ] ), 
  Character( CharacterTable( "M11" ), 
    [ 110, 6, 2, 6, 0, 0, 0, 0, 0, 0 ] ), 
  Character( CharacterTable( "M11" ), [ 110, 14, 2, 2, 0, 2, 0, 0, 0, 
      0 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># Now compute only multiplicity free permutation characters.</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bounds:= List( RationalizedMat( Irr( tbl ) ), x -&gt; 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PermComb( tbl, rec( degree:= 110, maxmult:= bounds ) );</span>
[ Character( CharacterTable( "M11" ), 
    [ 110, 6, 2, 2, 0, 0, 2, 2, 0, 0 ] ) ]
</pre></div>

<p><a id="X8204FB9F847340C8" name="X8204FB9F847340C8"></a></p>

<h4>72.15 <span class="Heading">Operations for Brauer Characters</span></h4>

<p><a id="X79BACBC47B4C413E" name="X79BACBC47B4C413E"></a></p>

<h5>72.15-1 FrobeniusCharacterValue</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FrobeniusCharacterValue</code>( <var class="Arg">value</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">value</var> be a cyclotomic whose coefficients over the rationals are in the ring <span class="SimpleMath">ℤ_<var class="Arg">p</var></span> of <var class="Arg">p</var>-local numbers, where <var class="Arg">p</var> is a prime integer. Assume that <var class="Arg">value</var> lies in <span class="SimpleMath">ℤ_<var class="Arg">p</var>[ζ]</span> for <span class="SimpleMath">ζ = exp(<var class="Arg">p</var>^n-1)</span>, for some positive integer <span class="SimpleMath">n</span>.</p>

<p><code class="func">FrobeniusCharacterValue</code> returns the image of <var class="Arg">value</var> under the ring homomorphism from <span class="SimpleMath">ℤ_<var class="Arg">p</var>[ζ]</span> to the field with <span class="SimpleMath"><var class="Arg">p</var>^n</span> elements that is defined with the help of Conway polynomials (see <code class="func">ConwayPolynomial</code> (<a href="chap59.html#X7C2425A786F09054"><span class="RefLink">59.5-1</span></a>)), more information can be found in <a href="chapBib.html#biBJLPW95">[JLPW95, Sections 2-5]</a>.</p>

<p>If <var class="Arg">value</var> is a Brauer character value in characteristic <var class="Arg">p</var> then the result can be described as the corresponding value of the Frobenius character, that is, as the trace of a representing matrix with the given Brauer character value.</p>

<p>If the result of <code class="func">FrobeniusCharacterValue</code> cannot be expressed as an element of a finite field in <strong class="pkg">GAP</strong> (see Chapter <a href="chap59.html#X7893ABF67A028802"><span class="RefLink">59</span></a>) then <code class="func">FrobeniusCharacterValue</code> returns <code class="keyw">fail</code>.</p>

<p>If the Conway polynomial of degree <span class="SimpleMath">n</span> is required for the computation then it is computed only if <code class="func">IsCheapConwayPolynomial</code> (<a href="chap59.html#X78A7C1247E129AD9"><span class="RefLink">59.5-2</span></a>) returns <code class="keyw">true</code> when it is called with <var class="Arg">p</var> and <span class="SimpleMath">n</span>, otherwise <code class="keyw">fail</code> is returned.</p>

<p><a id="X8304B68E84511685" name="X8304B68E84511685"></a></p>

<h5>72.15-2 BrauerCharacterValue</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BrauerCharacterValue</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For an invertible matrix <var class="Arg">mat</var> over a finite field <span class="SimpleMath">F</span>, <code class="func">BrauerCharacterValue</code> returns the Brauer character value of <var class="Arg">mat</var> if the order of <var class="Arg">mat</var> is coprime to the characteristic of <span class="SimpleMath">F</span>, and <code class="keyw">fail</code> otherwise.</p>

<p>The <em>Brauer character value</em> of a matrix is the sum of complex lifts of its eigenvalues.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= SL(2,4);;           # 2-dim. irreducible representation of A5</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ccl:= ConjugacyClasses( g );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rep:= List( ccl, Representative );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( rep, Order );</span>
[ 1, 2, 5, 5, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi:= List( rep, BrauerCharacterValue );</span>
[ 2, fail, E(5)^2+E(5)^3, E(5)+E(5)^4, -1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( phi{ [ 1, 3, 4, 5 ] }, x -&gt; FrobeniusCharacterValue( x, 2 ) );</span>
[ 0*Z(2), Z(2^2), Z(2^2)^2, Z(2)^0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( rep{ [ 1, 3, 4, 5 ] }, TraceMat );</span>
[ 0*Z(2), Z(2^2), Z(2^2)^2, Z(2)^0 ]
</pre></div>

<p><a id="X8038FA0480B78243" name="X8038FA0480B78243"></a></p>

<h5>72.15-3 SizeOfFieldOfDefinition</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SizeOfFieldOfDefinition</code>( <var class="Arg">val</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>For a cyclotomic or a list of cyclotomics <var class="Arg">val</var>, and a prime integer <var class="Arg">p</var>, <code class="func">SizeOfFieldOfDefinition</code> returns the size of the smallest finite field in characteristic <var class="Arg">p</var> that contains the <var class="Arg">p</var>-modular reduction of <var class="Arg">val</var>.</p>

<p>The reduction map is defined as in <a href="chapBib.html#biBJLPW95">[JLPW95]</a>, that is, the complex <span class="SimpleMath">(<var class="Arg">p</var>^d-1)</span>-th root of unity <span class="SimpleMath">exp(<var class="Arg">p</var>^d-1)</span> is mapped to the residue class of the indeterminate, modulo the ideal spanned by the Conway polynomial (see <code class="func">ConwayPolynomial</code> (<a href="chap59.html#X7C2425A786F09054"><span class="RefLink">59.5-1</span></a>)) of degree <span class="SimpleMath">d</span> over the field with <span class="SimpleMath">p</span> elements.</p>

<p>If <var class="Arg">val</var> is a Brauer character then the value returned is the size of the smallest finite field in characteristic <var class="Arg">p</var> over which the corresponding representation lives.</p>

<p><a id="X782400277F6316A4" name="X782400277F6316A4"></a></p>

<h5>72.15-4 RealizableBrauerCharacters</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RealizableBrauerCharacters</code>( <var class="Arg">matrix</var>, <var class="Arg">q</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>For a list <var class="Arg">matrix</var> of absolutely irreducible Brauer characters in characteristic <span class="SimpleMath">p</span>, and a power <var class="Arg">q</var> of <span class="SimpleMath">p</span>, <code class="func">RealizableBrauerCharacters</code> returns a duplicate-free list of sums of Frobenius conjugates of the rows of <var class="Arg">matrix</var>, each irreducible over the field with <var class="Arg">q</var> elements.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irr:= Irr( CharacterTable( "A5" ) mod 2 );</span>
[ Character( BrauerTable( "A5", 2 ), [ 1, 1, 1, 1 ] ), 
  Character( BrauerTable( "A5", 2 ), 
    [ 2, -1, E(5)+E(5)^4, E(5)^2+E(5)^3 ] ), 
  Character( BrauerTable( "A5", 2 ), 
    [ 2, -1, E(5)^2+E(5)^3, E(5)+E(5)^4 ] ), 
  Character( BrauerTable( "A5", 2 ), [ 4, 1, -1, -1 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( irr, phi -&gt; SizeOfFieldOfDefinition( phi, 2 ) );</span>
[ 2, 4, 4, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RealizableBrauerCharacters( irr, 2 );</span>
[ Character( BrauerTable( "A5", 2 ), [ 1, 1, 1, 1 ] ), 
  ClassFunction( BrauerTable( "A5", 2 ), [ 4, -2, -1, -1 ] ), 
  Character( BrauerTable( "A5", 2 ), [ 4, 1, -1, -1 ] ) ]
</pre></div>

<p><a id="X7FEEDC0981A22850" name="X7FEEDC0981A22850"></a></p>

<h4>72.16 <span class="Heading">Domains Generated by Class Functions</span></h4>

<p><strong class="pkg">GAP</strong> supports groups, vector spaces, and algebras generated by class functions.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap71.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap73.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chap16.html">16</a>  <a href="chap17.html">17</a>  <a href="chap18.html">18</a>  <a href="chap19.html">19</a>  <a href="chap20.html">20</a>  <a href="chap21.html">21</a>  <a href="chap22.html">22</a>  <a href="chap23.html">23</a>  <a href="chap24.html">24</a>  <a href="chap25.html">25</a>  <a href="chap26.html">26</a>  <a href="chap27.html">27</a>  <a href="chap28.html">28</a>  <a href="chap29.html">29</a>  <a href="chap30.html">30</a>  <a href="chap31.html">31</a>  <a href="chap32.html">32</a>  <a href="chap33.html">33</a>  <a href="chap34.html">34</a>  <a href="chap35.html">35</a>  <a href="chap36.html">36</a>  <a href="chap37.html">37</a>  <a href="chap38.html">38</a>  <a href="chap39.html">39</a>  <a href="chap40.html">40</a>  <a href="chap41.html">41</a>  <a href="chap42.html">42</a>  <a href="chap43.html">43</a>  <a href="chap44.html">44</a>  <a href="chap45.html">45</a>  <a href="chap46.html">46</a>  <a href="chap47.html">47</a>  <a href="chap48.html">48</a>  <a href="chap49.html">49</a>  <a href="chap50.html">50</a>  <a href="chap51.html">51</a>  <a href="chap52.html">52</a>  <a href="chap53.html">53</a>  <a href="chap54.html">54</a>  <a href="chap55.html">55</a>  <a href="chap56.html">56</a>  <a href="chap57.html">57</a>  <a href="chap58.html">58</a>  <a href="chap59.html">59</a>  <a href="chap60.html">60</a>  <a href="chap61.html">61</a>  <a href="chap62.html">62</a>  <a href="chap63.html">63</a>  <a href="chap64.html">64</a>  <a href="chap65.html">65</a>  <a href="chap66.html">66</a>  <a href="chap67.html">67</a>  <a href="chap68.html">68</a>  <a href="chap69.html">69</a>  <a href="chap70.html">70</a>  <a href="chap71.html">71</a>  <a href="chap72.html">72</a>  <a href="chap73.html">73</a>  <a href="chap74.html">74</a>  <a href="chap75.html">75</a>  <a href="chap76.html">76</a>  <a href="chap77.html">77</a>  <a href="chap78.html">78</a>  <a href="chap79.html">79</a>  <a href="chap80.html">80</a>  <a href="chap81.html">81</a>  <a href="chap82.html">82</a>  <a href="chap83.html">83</a>  <a href="chap84.html">84</a>  <a href="chap85.html">85</a>  <a href="chap86.html">86</a>  <a href="chap87.html">87</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
