<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (ref) - Chapter 46: Pc Groups</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap46"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chap14_mj.html">14</a>  <a href="chap15_mj.html">15</a>  <a href="chap16_mj.html">16</a>  <a href="chap17_mj.html">17</a>  <a href="chap18_mj.html">18</a>  <a href="chap19_mj.html">19</a>  <a href="chap20_mj.html">20</a>  <a href="chap21_mj.html">21</a>  <a href="chap22_mj.html">22</a>  <a href="chap23_mj.html">23</a>  <a href="chap24_mj.html">24</a>  <a href="chap25_mj.html">25</a>  <a href="chap26_mj.html">26</a>  <a href="chap27_mj.html">27</a>  <a href="chap28_mj.html">28</a>  <a href="chap29_mj.html">29</a>  <a href="chap30_mj.html">30</a>  <a href="chap31_mj.html">31</a>  <a href="chap32_mj.html">32</a>  <a href="chap33_mj.html">33</a>  <a href="chap34_mj.html">34</a>  <a href="chap35_mj.html">35</a>  <a href="chap36_mj.html">36</a>  <a href="chap37_mj.html">37</a>  <a href="chap38_mj.html">38</a>  <a href="chap39_mj.html">39</a>  <a href="chap40_mj.html">40</a>  <a href="chap41_mj.html">41</a>  <a href="chap42_mj.html">42</a>  <a href="chap43_mj.html">43</a>  <a href="chap44_mj.html">44</a>  <a href="chap45_mj.html">45</a>  <a href="chap46_mj.html">46</a>  <a href="chap47_mj.html">47</a>  <a href="chap48_mj.html">48</a>  <a href="chap49_mj.html">49</a>  <a href="chap50_mj.html">50</a>  <a href="chap51_mj.html">51</a>  <a href="chap52_mj.html">52</a>  <a href="chap53_mj.html">53</a>  <a href="chap54_mj.html">54</a>  <a href="chap55_mj.html">55</a>  <a href="chap56_mj.html">56</a>  <a href="chap57_mj.html">57</a>  <a href="chap58_mj.html">58</a>  <a href="chap59_mj.html">59</a>  <a href="chap60_mj.html">60</a>  <a href="chap61_mj.html">61</a>  <a href="chap62_mj.html">62</a>  <a href="chap63_mj.html">63</a>  <a href="chap64_mj.html">64</a>  <a href="chap65_mj.html">65</a>  <a href="chap66_mj.html">66</a>  <a href="chap67_mj.html">67</a>  <a href="chap68_mj.html">68</a>  <a href="chap69_mj.html">69</a>  <a href="chap70_mj.html">70</a>  <a href="chap71_mj.html">71</a>  <a href="chap72_mj.html">72</a>  <a href="chap73_mj.html">73</a>  <a href="chap74_mj.html">74</a>  <a href="chap75_mj.html">75</a>  <a href="chap76_mj.html">76</a>  <a href="chap77_mj.html">77</a>  <a href="chap78_mj.html">78</a>  <a href="chap79_mj.html">79</a>  <a href="chap80_mj.html">80</a>  <a href="chap81_mj.html">81</a>  <a href="chap82_mj.html">82</a>  <a href="chap83_mj.html">83</a>  <a href="chap84_mj.html">84</a>  <a href="chap85_mj.html">85</a>  <a href="chap86_mj.html">86</a>  <a href="chap87_mj.html">87</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap45_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap47_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap46.html">[MathJax off]</a></p>
<p><a id="X7EAD57C97EBF7E67" name="X7EAD57C97EBF7E67"></a></p>
<div class="ChapSects"><a href="chap46_mj.html#X7EAD57C97EBF7E67">46 <span class="Heading">Pc Groups</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap46_mj.html#X78E9E4D778A57A96">46.1 <span class="Heading">The Family Pcgs</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X79EDB35E82C99304">46.1-1 FamilyPcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X80893D2A7FFC791B">46.1-2 IsFamilyPcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X85C1596A867BE93D">46.1-3 InducedPcgsWrtFamilyPcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X8333ACCB7F530406">46.1-4 IsParentPcgsFamilyPcgs</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap46_mj.html#X842526BE7FEFE8BD">46.2 <span class="Heading">Elements of Pc Groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X869DCE7D86E32337">46.2-1 <span class="Heading">Comparison of elements of pc groups</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X7D1B700882FC6C78">46.2-2 <span class="Heading">Arithmetic operations for elements of pc groups</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap46_mj.html#X87B866C386B386E4">46.3 <span class="Heading">Pc Groups versus Fp Groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X7D1F506D7830B1D9">46.3-1 IsPcGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X7D2735A18111FE39">46.3-2 IsomorphismFpGroupByPcgs</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap46_mj.html#X8581887880556E0C">46.4 <span class="Heading">Constructing Pc Groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X84C10D1F7CB5274F">46.4-1 PcGroupFpGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X7E958DB281E070FD">46.4-2 SingleCollector</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X86A08D887E049347">46.4-3 SetConjugate</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X7B25997C7DF92B6D">46.4-4 SetCommutator</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X7BC319BA8698420C">46.4-5 SetPower</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X84F0521486672C3C">46.4-6 GroupByRws</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X7DF4835F79667099">46.4-7 IsConfluent</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X7E6226597DFE5F8F">46.4-8 IsomorphismRefinedPcGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X821560A387762DD1">46.4-9 RefinedPcGroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap46_mj.html#X83F69FE27B024E24">46.5 <span class="Heading">Computing Pc Groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X81C55D4F825C36D4">46.5-1 PcGroupWithPcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X873CEB137BA1CD6E">46.5-2 IsomorphismPcGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X82BE14A986FA6882">46.5-3 IsomorphismSpecialPcGroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap46_mj.html#X85696AB9791DF047">46.6 <span class="Heading">Saving a Pc Group</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X8593253380D84508">46.6-1 GapInputPcGroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap46_mj.html#X8391EE8D782D0C9E">46.7 <span class="Heading">Operations for Pc Groups</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap46_mj.html#X877AAB887D4507E3">46.8 <span class="Heading"><span class="SimpleMath">\(2\)</span>-Cohomology and Extensions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X78E6E11E8285E288">46.8-1 TwoCoboundaries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X784FCA207B8694A6">46.8-2 TwoCocycles</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X838065F97F60468F">46.8-3 TwoCohomology</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X8236AD927A5A0E5A">46.8-4 Extensions</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X7B3BE908867CE4F9">46.8-5 Extension</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X83DCB5AB7B6EE785">46.8-6 SplitExtension</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X7EAC6B8B7ABEEB86">46.8-7 ModuleOfExtension</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X824F2B2E7C11ABAF">46.8-8 CompatiblePairs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X854FFEF187C4AAB9">46.8-9 ExtensionRepresentatives</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X84E2DA897FAAF6D8">46.8-10 SplitExtension</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap46_mj.html#X874E4B107BD78F5A">46.9 <span class="Heading">Coding a Pc Presentation</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X79948F1D7D4FF8D9">46.9-1 CodePcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X8041C2D88721EEA9">46.9-2 CodePcGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X826BFDA07A707C54">46.9-3 PcGroupCode</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap46_mj.html#X81D211D8838B875C">46.10 <span class="Heading">Random Isomorphism Testing</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap46_mj.html#X84F6F9787CB2CF16">46.10-1 RandomIsomorphismTest</a></span>
</div></div>
</div>

<h3>46 <span class="Heading">Pc Groups</span></h3>

<p>Pc groups are polycyclic groups that use the polycyclic presentation for element arithmetic. This presentation gives them a "natural" pcgs, the <code class="func">FamilyPcgs</code> (<a href="chap46_mj.html#X79EDB35E82C99304"><span class="RefLink">46.1-1</span></a>) with respect to which pcgs operations as described in chapter <a href="chap45_mj.html#X86007B0083F60470"><span class="RefLink">45</span></a> are particularly efficient.</p>

<p>Let <span class="SimpleMath">\(G\)</span> be a polycyclic group with pcgs <span class="SimpleMath">\(P = (g_1, \ldots, g_n)\)</span> and corresponding relative orders <span class="SimpleMath">\((r_1, \ldots, r_n)\)</span>. Recall that the <span class="SimpleMath">\(r_i\)</span> are positive integers or infinity and let <span class="SimpleMath">\(I\)</span> be the set of indices <span class="SimpleMath">\(i\)</span> with <span class="SimpleMath">\(r_i\)</span> a positive integer. Then <span class="SimpleMath">\(G\)</span> has a finite presentation on the generators <span class="SimpleMath">\(g_1, \ldots, g_n\)</span> with relations of the following form.</p>

<div class="pcenter"><table class="GAPDocTablenoborder">
<tr>
<td class="tdleft"><span class="SimpleMath">\(g_i^{{r_i}}\)</span></td>
<td class="tdcenter">=</td>
<td class="tdleft"><span class="SimpleMath">\(g_{{i+1}}^{a(i,i,i+1)} \cdots g_n^{a(i,i,n)}\)</span></td>
</tr>
<tr>
<td class="tdleft"></td>
<td class="tdcenter"></td>
<td class="tdleft">for <span class="SimpleMath">\(1 \leq i \leq n\)</span> and <span class="SimpleMath">\(i \in I\)</span></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">\(g_i^{{-1}} g_j g_i\)</span></td>
<td class="tdcenter">=</td>
<td class="tdleft"><span class="SimpleMath">\(g_{{i+1}}^{a(i,j,i+1)} \cdots g_n^{a(i,j,n)}\)</span></td>
</tr>
<tr>
<td class="tdleft"></td>
<td class="tdcenter"></td>
<td class="tdleft">for <span class="SimpleMath">\(1 \leq i &lt; j \leq n\)</span></td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p>For infinite groups we need additionally</p>

<div class="pcenter"><table class="GAPDocTablenoborder">
<tr>
<td class="tdleft"><span class="SimpleMath">\(g_i^{{-1}} g_j^{{-1}} g_i\)</span></td>
<td class="tdcenter">=</td>
<td class="tdleft"><span class="SimpleMath">\(g_{{i+1}}^{b(i,j,i+1)} \cdots g_n^{b(i,j,n)}\)</span></td>
</tr>
<tr>
<td class="tdleft"></td>
<td class="tdcenter"></td>
<td class="tdleft">for <span class="SimpleMath">\(1 \leq i &lt; j \leq n\)</span> and <span class="SimpleMath">\(j \not \in I\)</span></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">\(g_i g_j g_i^{{-1}}\)</span></td>
<td class="tdcenter">=</td>
<td class="tdleft"><span class="SimpleMath">\(g_{{i+1}}^{c(i,j,i+1)} \cdots g_n^{c(i,j,n)}\)</span></td>
</tr>
<tr>
<td class="tdleft"></td>
<td class="tdcenter"></td>
<td class="tdleft">for <span class="SimpleMath">\(1 \leq i &lt; j \leq n\)</span> and <span class="SimpleMath">\(i \not \in I\)</span></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">\(g_i g_j^{{-1}} g_i^{{-1}}\)</span></td>
<td class="tdcenter">=</td>
<td class="tdleft"><span class="SimpleMath">\(g_{{i+1}}^{d(i,j,i+1)} \cdots g_n^{d(i,j,n)}\)</span></td>
</tr>
<tr>
<td class="tdleft"></td>
<td class="tdcenter"></td>
<td class="tdleft">for <span class="SimpleMath">\(1 \leq i &lt; j \leq n\)</span> and <span class="SimpleMath">\(i, j, \not \in I\)</span></td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p>Here the right hand sides are assumed to be words in normal form; that is, for <span class="SimpleMath">\(k \in I\)</span> we have for all exponents <span class="SimpleMath">\(0 \leq a(i,j,k), b(i,j,k), c(i,j,k), d(i,j,k) &lt; r_k\)</span>.</p>

<p>A finite presentation of this type is called a <em>power-conjugate presentation</em> and a <em>pc group</em> is a polycyclic group defined by a power-conjugate presentation. Instead of conjugates we could just as well work with commutators and then the presentation would be called a <em>power-commutator</em> presentation. Both types of presentation are abbreviated as <em>pc presentation</em>. Note that a pc presentation is a rewriting system.</p>

<p>Clearly, whenever a group <span class="SimpleMath">\(G\)</span> with pcgs <span class="SimpleMath">\(P\)</span> is given, then we can write down the corresponding pc presentation. On the other hand, one may just write down a presentation on <span class="SimpleMath">\(n\)</span> abstract generators <span class="SimpleMath">\(g_1, \ldots, g_n\)</span> with relations of the above form and define a group <span class="SimpleMath">\(H\)</span> by this. Then the subgroups <span class="SimpleMath">\(C_i = \langle g_i, \ldots, g_n \rangle\)</span> of <span class="SimpleMath">\(H\)</span> form a subnormal series whose factors are cyclic or trivial. In the case that all factors are non-trivial, we say that the pc presentation of <span class="SimpleMath">\(H\)</span> is <em>confluent</em>. Note that <strong class="pkg">GAP</strong> 4 can only work correctly with pc groups defined by a confluent pc presentation.</p>

<p>At the current state of implementations the <strong class="pkg">GAP</strong> library contains methods to compute with finite polycyclic groups, while the <strong class="pkg">GAP</strong> package <strong class="pkg">Polycyclic</strong> by Bettina Eick and Werner Nickel allows also computations with infinite polycyclic groups which are given by a pc-presentation.</p>

<p>Algorithms for pc groups use the methods for polycyclic groups described in chapter <a href="chap45_mj.html#X86007B0083F60470"><span class="RefLink">45</span></a>.</p>

<p><a id="X78E9E4D778A57A96" name="X78E9E4D778A57A96"></a></p>

<h4>46.1 <span class="Heading">The Family Pcgs</span></h4>

<p>Clearly, the generators of a power-conjugate presentation of a pc group <span class="SimpleMath">\(G\)</span> form a pcgs of the pc group. This pcgs is called the <em>family pcgs</em>.</p>

<p><a id="X79EDB35E82C99304" name="X79EDB35E82C99304"></a></p>

<h5>46.1-1 FamilyPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FamilyPcgs</code>( <var class="Arg">grp</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns a "natural" pcgs of a pc group <var class="Arg">grp</var> (with respect to which pcgs operations as described in Chapter <a href="chap45_mj.html#X86007B0083F60470"><span class="RefLink">45</span></a> are particularly efficient).</p>

<p><a id="X80893D2A7FFC791B" name="X80893D2A7FFC791B"></a></p>

<h5>46.1-2 IsFamilyPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFamilyPcgs</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>specifies whether the pcgs is a <code class="func">FamilyPcgs</code> (<a href="chap46_mj.html#X79EDB35E82C99304"><span class="RefLink">46.1-1</span></a>) of a pc group.</p>

<p><a id="X85C1596A867BE93D" name="X85C1596A867BE93D"></a></p>

<h5>46.1-3 InducedPcgsWrtFamilyPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InducedPcgsWrtFamilyPcgs</code>( <var class="Arg">grp</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns the pcgs which induced with respect to a family pcgs (see <code class="func">IsParentPcgsFamilyPcgs</code> (<a href="chap46_mj.html#X8333ACCB7F530406"><span class="RefLink">46.1-4</span></a>) for further details).</p>

<p><a id="X8333ACCB7F530406" name="X8333ACCB7F530406"></a></p>

<h5>46.1-4 IsParentPcgsFamilyPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsParentPcgsFamilyPcgs</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>This property indicates that the pcgs <var class="Arg">pcgs</var> is induced with respect to a family pcgs.</p>

<p>This property is needed to distinguish between different independent polycyclic generating sequences which a pc group may have, since the elementary operations for a non-family pcgs may not be as efficient as the elementary operations for the family pcgs.</p>

<p>This can have a significant influence on the performance of algorithms for polycyclic groups. Many algorithms require a pcgs that corresponds to an elementary abelian series (see <code class="func">PcgsElementaryAbelianSeries</code> (<a href="chap45_mj.html#X863A20B57EA37BAC"><span class="RefLink">45.11-2</span></a>)) or even a special pcgs (see <a href="chap45_mj.html#X83039CF97D27D819"><span class="RefLink">45.13</span></a>). If the family pcgs has the required properties, it will be used for these purposes, if not <strong class="pkg">GAP</strong> has to work with respect to a new pcgs which is <em>not</em> the family pcgs and thus takes longer for elementary calculations like <code class="func">ExponentsOfPcElement</code> (<a href="chap45_mj.html#X848DAEBF7DC448A5"><span class="RefLink">45.5-3</span></a>).</p>

<p>Therefore, if the family pcgs chosen for arithmetic is not of importance it might be worth to <em>change</em> to another, nicer, pcgs to speed up calculations. This can be achieved, for example, by using the <code class="func">Range</code> (<a href="chap32_mj.html#X7B6FD7277CDE9FCB"><span class="RefLink">32.3-7</span></a>) value of the isomorphism obtained by <code class="func">IsomorphismSpecialPcGroup</code> (<a href="chap46_mj.html#X82BE14A986FA6882"><span class="RefLink">46.5-3</span></a>).</p>

<p><a id="X842526BE7FEFE8BD" name="X842526BE7FEFE8BD"></a></p>

<h4>46.2 <span class="Heading">Elements of Pc Groups</span></h4>

<p><a id="X869DCE7D86E32337" name="X869DCE7D86E32337"></a></p>

<h5>46.2-1 <span class="Heading">Comparison of elements of pc groups</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; \=</code>( <var class="Arg">pcword1</var>, <var class="Arg">pcword2</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; \&lt;</code>( <var class="Arg">pcword1</var>, <var class="Arg">pcword2</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>The elements of a pc group <span class="SimpleMath">\(G\)</span> are always represented as words in normal form with respect to the family pcgs of <span class="SimpleMath">\(G\)</span>. Thus it is straightforward to compare elements of a pc group, since this boils down to a mere comparison of exponent vectors with respect to the family pcgs. In particular, the word problem is efficiently solvable in pc groups.</p>

<p><a id="X7D1B700882FC6C78" name="X7D1B700882FC6C78"></a></p>

<h5>46.2-2 <span class="Heading">Arithmetic operations for elements of pc groups</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; \*</code>( <var class="Arg">pcword1</var>, <var class="Arg">pcword2</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Inverse</code>( <var class="Arg">pcword</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>However, multiplication and inversion of elements in pc groups is not as straightforward as in arbitrary finitely presented groups where a simple concatenation or reversion of the corresponding words is sufficient (but one cannot solve the word problem).</p>

<p>To multiply two elements in a pc group, we first concatenate the corresponding words and then use an algorithm called <em>collection</em> to transform the new word into a word in normal form.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := FamilyPcgs( SmallGroup( 24, 12 ) );</span>
Pcgs([ f1, f2, f3, f4 ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g[4] * g[1];</span>
f1*f3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">(g[2] * g[3])^-1;</span>
f2^2*f3*f4
</pre></div>

<p><a id="X87B866C386B386E4" name="X87B866C386B386E4"></a></p>

<h4>46.3 <span class="Heading">Pc Groups versus Fp Groups</span></h4>

<p>In theory pc groups are finitely presented groups. In practice the arithmetic in pc groups is different from the arithmetic in fp groups. Thus for technical reasons the pc groups in <strong class="pkg">GAP</strong> do not form a subcategory of the fp groups and hence the methods for fp groups cannot be applied to pc groups in general.</p>

<p><a id="X7D1F506D7830B1D9" name="X7D1F506D7830B1D9"></a></p>

<h5>46.3-1 IsPcGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPcGroup</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>tests whether <var class="Arg">G</var> is a pc group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SmallGroup( 24, 12 );</span>
&lt;pc group of size 24 with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPcGroup( G );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsFpGroup( G );</span>
false
</pre></div>

<p><a id="X7D2735A18111FE39" name="X7D2735A18111FE39"></a></p>

<h5>46.3-2 IsomorphismFpGroupByPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismFpGroupByPcgs</code>( <var class="Arg">pcgs</var>, <var class="Arg">str</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>It is possible to convert a pc group to a fp group in <strong class="pkg">GAP</strong>. The function <code class="func">IsomorphismFpGroupByPcgs</code> computes the power-commutator presentation defined by <var class="Arg">pcgs</var>. The string <var class="Arg">str</var> can be used to give a name to the generators of the fp group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := FamilyPcgs( SmallGroup( 24, 12 ) );</span>
Pcgs([ f1, f2, f3, f4 ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso := IsomorphismFpGroupByPcgs( p, "g" );</span>
[ f1, f2, f3, f4 ] -&gt; [ g1, g2, g3, g4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := Image( iso );</span>
&lt;fp group of size 24 on the generators [ g1, g2, g3, g4 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RelatorsOfFpGroup( F );</span>
[ g1^2, g2^-1*g1^-1*g2*g1*g2^-1, g3^-1*g1^-1*g3*g1*g4^-1*g3^-1, 
  g4^-1*g1^-1*g4*g1*g4^-1*g3^-1, g2^3, g3^-1*g2^-1*g3*g2*g4^-1*g3^-1, 
  g4^-1*g2^-1*g4*g2*g3^-1, g3^2, g4^-1*g3^-1*g4*g3, g4^2 ]
</pre></div>

<p><a id="X8581887880556E0C" name="X8581887880556E0C"></a></p>

<h4>46.4 <span class="Heading">Constructing Pc Groups</span></h4>

<p>If necessary, you can supply <strong class="pkg">GAP</strong> with a pc presentation by hand. (Although this is the most tedious way to input a pc group.) Note that the pc presentation has to be confluent in order to work with the pc group in <strong class="pkg">GAP</strong>.</p>

<p>(If you have already a suitable pcgs in another representation, use <code class="func">PcGroupWithPcgs</code> (<a href="chap46_mj.html#X81C55D4F825C36D4"><span class="RefLink">46.5-1</span></a>), see below.)</p>

<p>One way is to define a finitely presented group with a pc presentation in <strong class="pkg">GAP</strong> and then convert this presentation into a pc group, see <code class="func">PcGroupFpGroup</code> (<a href="chap46_mj.html#X84C10D1F7CB5274F"><span class="RefLink">46.4-1</span></a>). Note that this does not work for arbitrary presentations of polycyclic groups, see Chapter <a href="chap47_mj.html#X846072F779B51087"><span class="RefLink">47.14</span></a> for further information.</p>

<p>Another way is to create and manipulate a collector of a pc group by hand and to use it to define a pc group. <strong class="pkg">GAP</strong> provides different collectors for different collecting strategies; at the moment, there are two collectors to choose from: the single collector for finite pc groups (see <code class="func">SingleCollector</code> (<a href="chap46_mj.html#X7E958DB281E070FD"><span class="RefLink">46.4-2</span></a>)) and the combinatorial collector for finite <span class="SimpleMath">\(p\)</span>-groups. See <a href="chapBib_mj.html#biBSims94">[Sim94]</a> for further information on collecting strategies.</p>

<p>A collector is initialized with an underlying free group and the relative orders of the pc series. Then one adds the right hand sides of the power and the commutator or conjugate relations one by one. Note that omitted relators are assumed to be trivial.</p>

<p>For performance reasons it is beneficial to enforce a "syllable" representation in the free group (see <a href="chap37_mj.html#X80A9F39582ED296E"><span class="RefLink">37.6</span></a>).</p>

<p>Note that in the end, the collector has to be converted to a group, see <code class="func">GroupByRws</code> (<a href="chap46_mj.html#X84F0521486672C3C"><span class="RefLink">46.4-6</span></a>).</p>

<p>With these methods a pc group with arbitrary defining pcgs can be constructed. However, for almost all applications within <strong class="pkg">GAP</strong> we need to have a pc group whose defining pcgs is a prime order pcgs, see <code class="func">IsomorphismRefinedPcGroup</code> (<a href="chap46_mj.html#X7E6226597DFE5F8F"><span class="RefLink">46.4-8</span></a>) and <code class="func">RefinedPcGroup</code> (<a href="chap46_mj.html#X821560A387762DD1"><span class="RefLink">46.4-9</span></a>).</p>

<p><a id="X84C10D1F7CB5274F" name="X84C10D1F7CB5274F"></a></p>

<h5>46.4-1 PcGroupFpGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PcGroupFpGroup</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>creates a pc group <var class="Arg">P</var> from an fp group (see Chapter <a href="chap47_mj.html#X7AA982637E90B35A"><span class="RefLink">47</span></a>) <var class="Arg">G</var> whose presentation is polycyclic. The resulting group <var class="Arg">P</var> has generators corresponding to the generators of <var class="Arg">G</var>. They are printed in the same way as generators of <var class="Arg">G</var>, but they lie in a different family. If the pc presentation of <var class="Arg">G</var> is not confluent, an error message occurs.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := FreeGroup(IsSyllableWordsFamily,"a","b","c","d");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := F.1;; b := F.2;; c := F.3;; d := F.4;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rels := [a^2, b^3, c^2, d^2, Comm(b,a)/b, Comm(c,a)/d, Comm(d,a),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            Comm(c,b)/(c*d), Comm(d,b)/c, Comm(d,c)];</span>
[ a^2, b^3, c^2, d^2, b^-1*a^-1*b*a*b^-1, c^-1*a^-1*c*a*d^-1, 
  d^-1*a^-1*d*a, c^-1*b^-1*c*b*d^-1*c^-1, d^-1*b^-1*d*b*c^-1, 
  d^-1*c^-1*d*c ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := F / rels;</span>
&lt;fp group on the generators [ a, b, c, d ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := PcGroupFpGroup( G );</span>
&lt;pc group of size 24 with 4 generators&gt;
</pre></div>

<p><a id="X7E958DB281E070FD" name="X7E958DB281E070FD"></a></p>

<h5>46.4-2 SingleCollector</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SingleCollector</code>( <var class="Arg">fgrp</var>, <var class="Arg">relorders</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CombinatorialCollector</code>( <var class="Arg">fgrp</var>, <var class="Arg">relorders</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>initializes a single collector or a combinatorial collector, where <var class="Arg">fgrp</var> must be a free group and <var class="Arg">relorders</var> must be a list of the relative orders of the pc series.</p>

<p>A combinatorial collector can only be set up for a finite <span class="SimpleMath">\(p\)</span>-group. Here, the relative orders <var class="Arg">relorders</var> must all be equal and a prime.</p>

<p><a id="X86A08D887E049347" name="X86A08D887E049347"></a></p>

<h5>46.4-3 SetConjugate</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SetConjugate</code>( <var class="Arg">coll</var>, <var class="Arg">j</var>, <var class="Arg">i</var>, <var class="Arg">w</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Let <span class="SimpleMath">\(f_1, \ldots, f_n\)</span> be the generators of the underlying free group of the collector <var class="Arg">coll</var>.</p>

<p>For <var class="Arg">i</var> <span class="SimpleMath">\(&lt;\)</span> <var class="Arg">j</var>, <code class="func">SetConjugate</code> sets the conjugate <span class="SimpleMath">\(f_j^{{f_i}}\)</span> to equal <var class="Arg">w</var>, which is assumed to be a word in <span class="SimpleMath">\(f_{{i+1}}, \ldots, f_n\)</span>.</p>

<p><a id="X7B25997C7DF92B6D" name="X7B25997C7DF92B6D"></a></p>

<h5>46.4-4 SetCommutator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SetCommutator</code>( <var class="Arg">coll</var>, <var class="Arg">j</var>, <var class="Arg">i</var>, <var class="Arg">w</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Let <span class="SimpleMath">\(f_1, \ldots, f_n\)</span> be the generators of the underlying free group of the collector <var class="Arg">coll</var>.</p>

<p>For <var class="Arg">i</var> <span class="SimpleMath">\(&lt;\)</span> <var class="Arg">j</var>, <code class="func">SetCommutator</code> sets the commutator of <span class="SimpleMath">\(f_j\)</span> and <span class="SimpleMath">\(f_i\)</span> to equal <var class="Arg">w</var>, which is assumed to be a word in <span class="SimpleMath">\(f_{{i+1}}, \ldots, f_n\)</span>.</p>

<p><a id="X7BC319BA8698420C" name="X7BC319BA8698420C"></a></p>

<h5>46.4-5 SetPower</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SetPower</code>( <var class="Arg">coll</var>, <var class="Arg">i</var>, <var class="Arg">w</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Let <span class="SimpleMath">\(f_1, \ldots, f_n\)</span> be the generators of the underlying free group of the collector <var class="Arg">coll</var>, and let <span class="SimpleMath">\(r_i\)</span> be the corresponding relative orders.</p>

<p><code class="func">SetPower</code> sets the power <span class="SimpleMath">\(f_i^{{r_i}}\)</span> to equal <var class="Arg">w</var>, which is assumed to be a word in <span class="SimpleMath">\(f_{{i+1}}, \ldots, f_n\)</span>.</p>

<p><a id="X84F0521486672C3C" name="X84F0521486672C3C"></a></p>

<h5>46.4-6 GroupByRws</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GroupByRws</code>( <var class="Arg">coll</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GroupByRwsNC</code>( <var class="Arg">coll</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>creates a group from a rewriting system. In the first version it is checked whether the rewriting system is confluent, in the second version this is assumed to be true.</p>

<p><a id="X7DF4835F79667099" name="X7DF4835F79667099"></a></p>

<h5>46.4-7 IsConfluent</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsConfluent</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>checks whether the pc group <var class="Arg">G</var> has been built from a collector with a confluent power-commutator presentation.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := FreeGroup(IsSyllableWordsFamily, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coll1 := SingleCollector( F, [2,3] );</span>
&lt;&lt;single collector, 8 Bits&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetConjugate( coll1, 2, 1, F.2 );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetPower( coll1, 1, F.2 );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G1 := GroupByRws( coll1 );</span>
&lt;pc group of size 6 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsConfluent(G1);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAbelian(G1);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coll2 := SingleCollector( F, [2,3] );</span>
&lt;&lt;single collector, 8 Bits&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetConjugate( coll2, 2, 1, F.2^2 );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G2 := GroupByRws( coll2 );</span>
&lt;pc group of size 6 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAbelian(G2);</span>
false
</pre></div>

<p><a id="X7E6226597DFE5F8F" name="X7E6226597DFE5F8F"></a></p>

<h5>46.4-8 IsomorphismRefinedPcGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismRefinedPcGroup</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns an isomorphism from <var class="Arg">G</var> onto an isomorphic pc group whose family pcgs is a prime order pcgs.</p>

<p><a id="X821560A387762DD1" name="X821560A387762DD1"></a></p>

<h5>46.4-9 RefinedPcGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RefinedPcGroup</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns the range of the <code class="func">IsomorphismRefinedPcGroup</code> (<a href="chap46_mj.html#X7E6226597DFE5F8F"><span class="RefLink">46.4-8</span></a>) value of <var class="Arg">G</var>.</p>

<p><a id="X83F69FE27B024E24" name="X83F69FE27B024E24"></a></p>

<h4>46.5 <span class="Heading">Computing Pc Groups</span></h4>

<p>Another possibility to get a pc group in <strong class="pkg">GAP</strong> is to convert a polycyclic group given by some other representation to a pc group. For finitely presented groups there are various quotient methods available. For all other types of groups one can use the following functions.</p>

<p><a id="X81C55D4F825C36D4" name="X81C55D4F825C36D4"></a></p>

<h5>46.5-1 PcGroupWithPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PcGroupWithPcgs</code>( <var class="Arg">mpcgs</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>creates a new pc group <var class="Arg">G</var> whose family pcgs is isomorphic to the (modulo) pcgs <var class="Arg">mpcgs</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := Group( (1,2,3), (3,4,1) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PcGroupWithPcgs( Pcgs(G) );</span>
&lt;pc group of size 12 with 3 generators&gt;
</pre></div>

<p>If a pcgs is only given by a list of pc elements, <code class="func">PcgsByPcSequence</code> (<a href="chap45_mj.html#X7E139C3D80847D76"><span class="RefLink">45.3-1</span></a>) can be used:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:=Group((1,2,3,4),(1,2));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p:=PcgsByPcSequence(FamilyObj(One(G)),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ]);</span>
Pcgs([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PcGroupWithPcgs(p);</span>
&lt;pc group of size 24 with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SymmetricGroup( 5 );</span>
Sym( [ 1 .. 5 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := Subgroup( G, [(1,2,3,4,5), (3,4,5)] );</span>
Group([ (1,2,3,4,5), (3,4,5) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">modu := ModuloPcgs( G, H );</span>
Pcgs([ (4,5) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PcGroupWithPcgs(modu);</span>
&lt;pc group of size 2 with 1 generators&gt;
</pre></div>

<p><a id="X873CEB137BA1CD6E" name="X873CEB137BA1CD6E"></a></p>

<h5>46.5-2 IsomorphismPcGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismPcGroup</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns an isomorphism from <var class="Arg">G</var> onto an isomorphic pc group. The series chosen for this pc representation depends on the method chosen. <var class="Arg">G</var> must be a polycyclic group of any kind, for example a solvable permutation group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := Group( (1,2,3), (3,4,1) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso := IsomorphismPcGroup( G );</span>
Pcgs([ (2,4,3), (1,2)(3,4), (1,3)(2,4) ]) -&gt; [ f1, f2, f3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := Image( iso );</span>
Group([ f1, f2, f3 ])
</pre></div>

<p><a id="X82BE14A986FA6882" name="X82BE14A986FA6882"></a></p>

<h5>46.5-3 IsomorphismSpecialPcGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismSpecialPcGroup</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns an isomorphism from <var class="Arg">G</var> onto an isomorphic pc group whose family pcgs is a special pcgs. (This can be beneficial to the runtime of calculations.) <var class="Arg">G</var> may be a polycyclic group of any kind, for example a solvable permutation group.</p>

<p><a id="X85696AB9791DF047" name="X85696AB9791DF047"></a></p>

<h4>46.6 <span class="Heading">Saving a Pc Group</span></h4>

<p>As printing a polycyclic group does not display the presentation, one cannot simply print a pc group to a file to save it. For this purpose we need the following function.</p>

<p><a id="X8593253380D84508" name="X8593253380D84508"></a></p>

<h5>46.6-1 GapInputPcGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GapInputPcGroup</code>( <var class="Arg">grp</var>, <var class="Arg">string</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>

<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SmallGroup( 24, 12 );</span>
&lt;pc group of size 24 with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintTo( "save", GapInputPcGroup( G, "H" ) );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Read( "save" );</span>
#I A group of order 24 has been defined.
#I It is called H
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H = G;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdSmallGroup( H ) = IdSmallGroup( G );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RemoveFile( "save" );;</span>
</pre></div>

<p><a id="X8391EE8D782D0C9E" name="X8391EE8D782D0C9E"></a></p>

<h4>46.7 <span class="Heading">Operations for Pc Groups</span></h4>

<p>All the operations described in Chapters <a href="chap39_mj.html#X8716635F7951801B"><span class="RefLink">39</span></a> and <a href="chap45_mj.html#X86007B0083F60470"><span class="RefLink">45</span></a> apply to a pc group. Nearly all methods for pc groups are methods for groups with pcgs as described in Chapter <a href="chap45_mj.html#X86007B0083F60470"><span class="RefLink">45</span></a>. The only method with is special for pc groups is a method to compute intersections of subgroups, since here a pcgs of a parent group is needed and this can only by guaranteed within pc groups. Section <a href="chap39_mj.html#X7BD95B8D879B73A3"><span class="RefLink">39.25</span></a> describes operations and methods for arbitrary finite groups.</p>

<p><a id="X877AAB887D4507E3" name="X877AAB887D4507E3"></a></p>

<h4>46.8 <span class="Heading"><span class="SimpleMath">\(2\)</span>-Cohomology and Extensions</span></h4>

<p>One of the most interesting applications of pc groups is the possibility to compute with extensions of these groups by elementary abelian groups; that is, <span class="SimpleMath">\(H\)</span> is an extension of <span class="SimpleMath">\(G\)</span> by <span class="SimpleMath">\(M\)</span>, if there exists a normal subgroup <span class="SimpleMath">\(N\)</span> in <span class="SimpleMath">\(H\)</span> which is isomorphic to <span class="SimpleMath">\(M\)</span> such that <span class="SimpleMath">\(H/N\)</span> is isomorphic to <span class="SimpleMath">\(G\)</span>.</p>

<p>Pc groups are particularly suited for such applications, since the <span class="SimpleMath">\(2\)</span>-cohomology can be computed efficiently for such groups and, moreover, extensions of pc groups by elementary abelian groups can be represented as pc groups again.</p>

<p>To define the elementary abelian group <span class="SimpleMath">\(M\)</span> together with an action of <span class="SimpleMath">\(G\)</span> on <span class="SimpleMath">\(M\)</span> we consider <span class="SimpleMath">\(M\)</span> as a MeatAxe module for <span class="SimpleMath">\(G\)</span> over a finite field (section <code class="func">IrreducibleModules</code> (<a href="chap71_mj.html#X87E82F8085745523"><span class="RefLink">71.15-1</span></a>) describes functions that can be used to obtain certain modules). For further information on meataxe modules see Chapter <a href="chap69_mj.html#X7BF9D3CB81A8F8F9"><span class="RefLink">69</span></a>. Note that the matrices defining the module must correspond to the pcgs of the group <var class="Arg">G</var>.</p>

<p>There exists an action of the subgroup of <em>compatible pairs</em> in <span class="SimpleMath">\(Aut(G) \times Aut(M)\)</span> which acts on the second cohomology group, see <code class="func">CompatiblePairs</code> (<a href="chap46_mj.html#X824F2B2E7C11ABAF"><span class="RefLink">46.8-8</span></a>). <span class="SimpleMath">\(2\)</span>-cocycles which lie in the same orbit under this action define isomorphic extensions of <span class="SimpleMath">\(G\)</span>. However, there may be isomorphic extensions of <span class="SimpleMath">\(G\)</span> corresponding to cocycles in different orbits.</p>

<p>See also the <strong class="pkg">GAP</strong> package <strong class="pkg">GrpConst</strong> by Hans Ulrich Besche and Bettina Eick that contains methods to construct up to isomorphism the groups of a given order.</p>

<p>Finally we note that for the computation of split extensions it is not necessary that <var class="Arg">M</var> must correspond to an elementary abelian group. Here it is possible to construct split extensions of arbitrary pc groups, see <code class="func">SplitExtension</code> (<a href="chap46_mj.html#X83DCB5AB7B6EE785"><span class="RefLink">46.8-6</span></a>).</p>

<p><a id="X78E6E11E8285E288" name="X78E6E11E8285E288"></a></p>

<h5>46.8-1 TwoCoboundaries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TwoCoboundaries</code>( <var class="Arg">G</var>, <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns the group of <span class="SimpleMath">\(2\)</span>-coboundaries of a pc group <var class="Arg">G</var> by the <var class="Arg">G</var>-module <var class="Arg">M</var>. The generators of <var class="Arg">M</var> must correspond to the <code class="func">Pcgs</code> (<a href="chap45_mj.html#X84C3750C7A4EEC34"><span class="RefLink">45.2-1</span></a>) value of <var class="Arg">G</var>. The group of coboundaries is given as vector space over the field underlying <var class="Arg">M</var>.</p>

<p><a id="X784FCA207B8694A6" name="X784FCA207B8694A6"></a></p>

<h5>46.8-2 TwoCocycles</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TwoCocycles</code>( <var class="Arg">G</var>, <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns the <span class="SimpleMath">\(2\)</span>-cocycles of a pc group <var class="Arg">G</var> by the <var class="Arg">G</var>-module <var class="Arg">M</var>. The generators of <var class="Arg">M</var> must correspond to the <code class="func">Pcgs</code> (<a href="chap45_mj.html#X84C3750C7A4EEC34"><span class="RefLink">45.2-1</span></a>) value of <var class="Arg">G</var>. The operation returns a list of vectors over the field underlying <var class="Arg">M</var> and the additive group generated by these vectors is the group of <span class="SimpleMath">\(2\)</span>-cocyles.</p>

<p><a id="X838065F97F60468F" name="X838065F97F60468F"></a></p>

<h5>46.8-3 TwoCohomology</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TwoCohomology</code>( <var class="Arg">G</var>, <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>This operation computes the second cohomology group for the special case of a Pc Group. It returns a record defining the second cohomology group as factor space of the space of cocycles by the space of coboundaries. <var class="Arg">G</var> must be a pc group and the generators of <var class="Arg">M</var> must correspond to the pcgs of <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SmallGroup( 4, 2 );</span>
&lt;pc group of size 4 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats := List( Pcgs( G ), x -&gt; IdentityMat( 1, GF(2) ) );</span>
[ [ &lt;a GF2 vector of length 1&gt; ], [ &lt;a GF2 vector of length 1&gt; ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := GModuleByMats( mats, GF(2) );</span>
rec( IsOverFiniteField := true, dimension := 1, field := GF(2), 
  generators := [ &lt;an immutable 1x1 matrix over GF2&gt;, 
      &lt;an immutable 1x1 matrix over GF2&gt; ], isMTXModule := true )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TwoCoboundaries( G, M );</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TwoCocycles( G, M );</span>
[ [ Z(2)^0, 0*Z(2), 0*Z(2) ], [ 0*Z(2), Z(2)^0, 0*Z(2) ], 
  [ 0*Z(2), 0*Z(2), Z(2)^0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cc := TwoCohomology( G, M );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cc.cohom;</span>
&lt;linear mapping by matrix, &lt;vector space of dimension 3 over GF(
2)&gt; -&gt; ( GF(2)^3 )&gt;
</pre></div>

<p><a id="X8236AD927A5A0E5A" name="X8236AD927A5A0E5A"></a></p>

<h5>46.8-4 Extensions</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Extensions</code>( <var class="Arg">G</var>, <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns all extensions of <var class="Arg">G</var> by the <var class="Arg">G</var>-module <var class="Arg">M</var> up to equivalence as pc groups.</p>

<p><a id="X7B3BE908867CE4F9" name="X7B3BE908867CE4F9"></a></p>

<h5>46.8-5 Extension</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Extension</code>( <var class="Arg">G</var>, <var class="Arg">M</var>, <var class="Arg">c</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExtensionNC</code>( <var class="Arg">G</var>, <var class="Arg">M</var>, <var class="Arg">c</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns the extension of <var class="Arg">G</var> by the <var class="Arg">G</var>-module <var class="Arg">M</var> via the cocycle <var class="Arg">c</var> as pc groups. The <code class="code">NC</code> version does not check the resulting group for consistence.</p>

<p><a id="X83DCB5AB7B6EE785" name="X83DCB5AB7B6EE785"></a></p>

<h5>46.8-6 SplitExtension</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SplitExtension</code>( <var class="Arg">G</var>, <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns the split extension of <var class="Arg">G</var> by the <var class="Arg">G</var>-module <var class="Arg">M</var>. See also <code class="func">SplitExtension</code> (<a href="chap46_mj.html#X84E2DA897FAAF6D8"><span class="RefLink">46.8-10</span></a>) for its 3-argument version.</p>

<p><a id="X7EAC6B8B7ABEEB86" name="X7EAC6B8B7ABEEB86"></a></p>

<h5>46.8-7 ModuleOfExtension</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ModuleOfExtension</code>( <var class="Arg">E</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns the module of an extension <var class="Arg">E</var> of <var class="Arg">G</var> by <var class="Arg">M</var>. This is the normal subgroup of <var class="Arg">E</var> which corresponds to <var class="Arg">M</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SmallGroup( 4, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats := List( Pcgs( G ), x -&gt; IdentityMat( 1, GF(2) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := GModuleByMats( mats, GF(2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">co := TwoCocycles( G, M );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Extension( G, M, co[2] );</span>
&lt;pc group of size 8 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SplitExtension( G, M );</span>
&lt;pc group of size 8 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Extensions( G, M );</span>
[ &lt;pc group of size 8 with 3 generators&gt;, 
  &lt;pc group of size 8 with 3 generators&gt;, 
  &lt;pc group of size 8 with 3 generators&gt;, 
  &lt;pc group of size 8 with 3 generators&gt;, 
  &lt;pc group of size 8 with 3 generators&gt;, 
  &lt;pc group of size 8 with 3 generators&gt;, 
  &lt;pc group of size 8 with 3 generators&gt;, 
  &lt;pc group of size 8 with 3 generators&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(last, IdSmallGroup);</span>
[ [ 8, 5 ], [ 8, 2 ], [ 8, 3 ], [ 8, 3 ], [ 8, 2 ], [ 8, 2 ], 
  [ 8, 3 ], [ 8, 4 ] ]
</pre></div>

<p>Note that the extensions returned by <code class="func">Extensions</code> (<a href="chap46_mj.html#X8236AD927A5A0E5A"><span class="RefLink">46.8-4</span></a>) are computed up to equivalence, but not up to isomorphism.</p>

<p><a id="X824F2B2E7C11ABAF" name="X824F2B2E7C11ABAF"></a></p>

<h5>46.8-8 CompatiblePairs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CompatiblePairs</code>( <var class="Arg">G</var>, <var class="Arg">M</var>[, <var class="Arg">D</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns the group of compatible pairs of the group <var class="Arg">G</var> with the <var class="Arg">G</var>-module <var class="Arg">M</var> as subgroup of the direct product Aut(<var class="Arg">G</var>) <span class="SimpleMath">\(\times\)</span> Aut(<var class="Arg">M</var>). Here Aut(<var class="Arg">M</var>) is considered as subgroup of a general linear group. The optional argument <var class="Arg">D</var> should be a subgroup of Aut(<var class="Arg">G</var>) <span class="SimpleMath">\(\times\)</span> Aut(<var class="Arg">M</var>). If it is given, then only the compatible pairs in <var class="Arg">D</var> are computed.</p>

<p><a id="X854FFEF187C4AAB9" name="X854FFEF187C4AAB9"></a></p>

<h5>46.8-9 ExtensionRepresentatives</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExtensionRepresentatives</code>( <var class="Arg">G</var>, <var class="Arg">M</var>, <var class="Arg">P</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns all extensions of <var class="Arg">G</var> by the <var class="Arg">G</var>-module <var class="Arg">M</var> up to equivalence under action of <var class="Arg">P</var> where <var class="Arg">P</var> has to be a subgroup of the group of compatible pairs of <var class="Arg">G</var> with <var class="Arg">M</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SmallGroup( 4, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats := List( Pcgs( G ), x -&gt; IdentityMat( 1, GF(2) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := GModuleByMats( mats, GF(2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A := AutomorphismGroup( G );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := GL( 1, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DirectProduct( A, B );; Size(D);</span>
6
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P := CompatiblePairs( G, M, D );</span>
&lt;group of size 6 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExtensionRepresentatives( G, M, P );</span>
[ &lt;pc group of size 8 with 3 generators&gt;, 
  &lt;pc group of size 8 with 3 generators&gt;, 
  &lt;pc group of size 8 with 3 generators&gt;, 
  &lt;pc group of size 8 with 3 generators&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Extensions( G, M );</span>
[ &lt;pc group of size 8 with 3 generators&gt;, 
  &lt;pc group of size 8 with 3 generators&gt;, 
  &lt;pc group of size 8 with 3 generators&gt;, 
  &lt;pc group of size 8 with 3 generators&gt;, 
  &lt;pc group of size 8 with 3 generators&gt;, 
  &lt;pc group of size 8 with 3 generators&gt;, 
  &lt;pc group of size 8 with 3 generators&gt;, 
  &lt;pc group of size 8 with 3 generators&gt; ]
</pre></div>

<p><a id="X84E2DA897FAAF6D8" name="X84E2DA897FAAF6D8"></a></p>

<h5>46.8-10 SplitExtension</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SplitExtension</code>( <var class="Arg">G</var>, <var class="Arg">aut</var>, <var class="Arg">N</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns the split extensions of the pc group <var class="Arg">G</var> by the pc group <var class="Arg">N</var>. <var class="Arg">aut</var> should be a homomorphism from <var class="Arg">G</var> into Aut(<var class="Arg">N</var>).</p>

<p>In the following example we construct the holomorph of <span class="SimpleMath">\(Q_8\)</span> as split extension of <span class="SimpleMath">\(Q_8\)</span> by <span class="SimpleMath">\(S_4\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N := SmallGroup( 8, 4 );</span>
&lt;pc group of size 8 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAbelian( N );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A := AutomorphismGroup( N );</span>
&lt;group of size 24 with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso := IsomorphismPcGroup( A );</span>
CompositionMapping( Pcgs([ (2,6,5,3), (1,3,5)(2,4,6), (2,5)(3,6), 
  (1,4)(3,6) ]) -&gt; [ f1, f2, f3, f4 ], &lt;action isomorphism&gt; )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := Image( iso );</span>
Group([ f1, f2, f3, f4 ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := Subgroup( H, Pcgs(H){[1,2]} );</span>
Group([ f1, f2 ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inv := InverseGeneralMapping( iso );</span>
[ f1*f2, f2^2*f3, f4, f3 ] -&gt; 
[ Pcgs([ f1, f2, f3 ]) -&gt; [ f1*f2, f2, f3 ], 
  Pcgs([ f1, f2, f3 ]) -&gt; [ f2, f1*f2, f3 ], 
  Pcgs([ f1, f2, f3 ]) -&gt; [ f1*f3, f2, f3 ], 
  Pcgs([ f1, f2, f3 ]) -&gt; [ f1, f2*f3, f3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K := SplitExtension( G, inv, N );</span>
&lt;pc group of size 192 with 7 generators&gt;
</pre></div>

<p><a id="X874E4B107BD78F5A" name="X874E4B107BD78F5A"></a></p>

<h4>46.9 <span class="Heading">Coding a Pc Presentation</span></h4>

<p>If one wants to store a large number of pc groups, then it can be useful to store them in a compressed format, since pc presentations can be space consuming. Here we introduce a method to code and decode pc presentations by integers. To decode a given code the size of the underlying pc group is needed as well. For the full definition and the coding and decoding procedures see <a href="chapBib_mj.html#biBBescheEick98">[BE99]</a>. This method is used with the small groups library (see <a href="../../pkg/SmallGrp-1.4.1/doc/chap1_mj.html#X7C16EA1580AC7586"><span class="RefLink">smallgrp: The Small Groups Library</span></a>.</p>

<p><a id="X79948F1D7D4FF8D9" name="X79948F1D7D4FF8D9"></a></p>

<h5>46.9-1 CodePcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CodePcgs</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns the code corresponding to <var class="Arg">pcgs</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := CyclicGroup(512);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := Pcgs( G );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CodePcgs( p );  </span>
162895587718739690298008513020159
</pre></div>

<p><a id="X8041C2D88721EEA9" name="X8041C2D88721EEA9"></a></p>

<h5>46.9-2 CodePcGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CodePcGroup</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns the code for a pcgs of <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := DihedralGroup(512);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CodePcGroup( G );       </span>
2940208627577393070560341803949986912431725641726
</pre></div>

<p><a id="X826BFDA07A707C54" name="X826BFDA07A707C54"></a></p>

<h5>46.9-3 PcGroupCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PcGroupCode</code>( <var class="Arg">code</var>, <var class="Arg">size</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns a pc group of size <var class="Arg">size</var> corresponding to <var class="Arg">code</var>. The argument <var class="Arg">code</var> must be a valid code for a pcgs, otherwise anything may happen. Valid codes are usually obtained by one of the functions <code class="func">CodePcgs</code> (<a href="chap46_mj.html#X79948F1D7D4FF8D9"><span class="RefLink">46.9-1</span></a>) or <code class="func">CodePcGroup</code> (<a href="chap46_mj.html#X8041C2D88721EEA9"><span class="RefLink">46.9-2</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SmallGroup( 24, 12 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := Pcgs( G );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">code := CodePcgs( p );</span>
5790338948
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := PcGroupCode( code, 24 );</span>
&lt;pc group of size 24 with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">map := GroupHomomorphismByImages( G, H, p, FamilyPcgs(H) );</span>
Pcgs([ f1, f2, f3, f4 ]) -&gt; Pcgs([ f1, f2, f3, f4 ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsBijective(map);</span>
true
</pre></div>

<p><a id="X81D211D8838B875C" name="X81D211D8838B875C"></a></p>

<h4>46.10 <span class="Heading">Random Isomorphism Testing</span></h4>

<p>The generic isomorphism test for groups may be applied to pc groups as well. However, this test is often quite time consuming. Here we describe another method to test isomorphism by a probabilistic approach.</p>

<p><a id="X84F6F9787CB2CF16" name="X84F6F9787CB2CF16"></a></p>

<h5>46.10-1 RandomIsomorphismTest</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RandomIsomorphismTest</code>( <var class="Arg">coderecs</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>The first argument is a list <var class="Arg">coderecs</var> containing records describing groups, and the second argument is a non-negative integer <var class="Arg">n</var>.</p>

<p>The test returns a sublist of <var class="Arg">coderecs</var> where isomorphic copies detected by the probabilistic test have been removed.</p>

<p>The list <var class="Arg">coderecs</var> should contain records with two components, <code class="code">code</code> and <code class="code">order</code>, describing a group via <code class="code">PcGroupCode( code, order )</code> (see <code class="func">PcGroupCode</code> (<a href="chap46_mj.html#X826BFDA07A707C54"><span class="RefLink">46.9-3</span></a>)).</p>

<p>The integer <var class="Arg">n</var> gives a certain amount of control over the probability to detect all isomorphisms. If it is <span class="SimpleMath">\(0\)</span>, then nothing will be done at all. The larger <var class="Arg">n</var> is, the larger is the probability of finding all isomorphisms. However, due to the underlying method we can not guarantee that the algorithm finds all isomorphisms, no matter how large <var class="Arg">n</var> is.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap45_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap47_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chap14_mj.html">14</a>  <a href="chap15_mj.html">15</a>  <a href="chap16_mj.html">16</a>  <a href="chap17_mj.html">17</a>  <a href="chap18_mj.html">18</a>  <a href="chap19_mj.html">19</a>  <a href="chap20_mj.html">20</a>  <a href="chap21_mj.html">21</a>  <a href="chap22_mj.html">22</a>  <a href="chap23_mj.html">23</a>  <a href="chap24_mj.html">24</a>  <a href="chap25_mj.html">25</a>  <a href="chap26_mj.html">26</a>  <a href="chap27_mj.html">27</a>  <a href="chap28_mj.html">28</a>  <a href="chap29_mj.html">29</a>  <a href="chap30_mj.html">30</a>  <a href="chap31_mj.html">31</a>  <a href="chap32_mj.html">32</a>  <a href="chap33_mj.html">33</a>  <a href="chap34_mj.html">34</a>  <a href="chap35_mj.html">35</a>  <a href="chap36_mj.html">36</a>  <a href="chap37_mj.html">37</a>  <a href="chap38_mj.html">38</a>  <a href="chap39_mj.html">39</a>  <a href="chap40_mj.html">40</a>  <a href="chap41_mj.html">41</a>  <a href="chap42_mj.html">42</a>  <a href="chap43_mj.html">43</a>  <a href="chap44_mj.html">44</a>  <a href="chap45_mj.html">45</a>  <a href="chap46_mj.html">46</a>  <a href="chap47_mj.html">47</a>  <a href="chap48_mj.html">48</a>  <a href="chap49_mj.html">49</a>  <a href="chap50_mj.html">50</a>  <a href="chap51_mj.html">51</a>  <a href="chap52_mj.html">52</a>  <a href="chap53_mj.html">53</a>  <a href="chap54_mj.html">54</a>  <a href="chap55_mj.html">55</a>  <a href="chap56_mj.html">56</a>  <a href="chap57_mj.html">57</a>  <a href="chap58_mj.html">58</a>  <a href="chap59_mj.html">59</a>  <a href="chap60_mj.html">60</a>  <a href="chap61_mj.html">61</a>  <a href="chap62_mj.html">62</a>  <a href="chap63_mj.html">63</a>  <a href="chap64_mj.html">64</a>  <a href="chap65_mj.html">65</a>  <a href="chap66_mj.html">66</a>  <a href="chap67_mj.html">67</a>  <a href="chap68_mj.html">68</a>  <a href="chap69_mj.html">69</a>  <a href="chap70_mj.html">70</a>  <a href="chap71_mj.html">71</a>  <a href="chap72_mj.html">72</a>  <a href="chap73_mj.html">73</a>  <a href="chap74_mj.html">74</a>  <a href="chap75_mj.html">75</a>  <a href="chap76_mj.html">76</a>  <a href="chap77_mj.html">77</a>  <a href="chap78_mj.html">78</a>  <a href="chap79_mj.html">79</a>  <a href="chap80_mj.html">80</a>  <a href="chap81_mj.html">81</a>  <a href="chap82_mj.html">82</a>  <a href="chap83_mj.html">83</a>  <a href="chap84_mj.html">84</a>  <a href="chap85_mj.html">85</a>  <a href="chap86_mj.html">86</a>  <a href="chap87_mj.html">87</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
