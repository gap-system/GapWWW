<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (ref) - Chapter 24: Matrices</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap24"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chap14_mj.html">14</a>  <a href="chap15_mj.html">15</a>  <a href="chap16_mj.html">16</a>  <a href="chap17_mj.html">17</a>  <a href="chap18_mj.html">18</a>  <a href="chap19_mj.html">19</a>  <a href="chap20_mj.html">20</a>  <a href="chap21_mj.html">21</a>  <a href="chap22_mj.html">22</a>  <a href="chap23_mj.html">23</a>  <a href="chap24_mj.html">24</a>  <a href="chap25_mj.html">25</a>  <a href="chap26_mj.html">26</a>  <a href="chap27_mj.html">27</a>  <a href="chap28_mj.html">28</a>  <a href="chap29_mj.html">29</a>  <a href="chap30_mj.html">30</a>  <a href="chap31_mj.html">31</a>  <a href="chap32_mj.html">32</a>  <a href="chap33_mj.html">33</a>  <a href="chap34_mj.html">34</a>  <a href="chap35_mj.html">35</a>  <a href="chap36_mj.html">36</a>  <a href="chap37_mj.html">37</a>  <a href="chap38_mj.html">38</a>  <a href="chap39_mj.html">39</a>  <a href="chap40_mj.html">40</a>  <a href="chap41_mj.html">41</a>  <a href="chap42_mj.html">42</a>  <a href="chap43_mj.html">43</a>  <a href="chap44_mj.html">44</a>  <a href="chap45_mj.html">45</a>  <a href="chap46_mj.html">46</a>  <a href="chap47_mj.html">47</a>  <a href="chap48_mj.html">48</a>  <a href="chap49_mj.html">49</a>  <a href="chap50_mj.html">50</a>  <a href="chap51_mj.html">51</a>  <a href="chap52_mj.html">52</a>  <a href="chap53_mj.html">53</a>  <a href="chap54_mj.html">54</a>  <a href="chap55_mj.html">55</a>  <a href="chap56_mj.html">56</a>  <a href="chap57_mj.html">57</a>  <a href="chap58_mj.html">58</a>  <a href="chap59_mj.html">59</a>  <a href="chap60_mj.html">60</a>  <a href="chap61_mj.html">61</a>  <a href="chap62_mj.html">62</a>  <a href="chap63_mj.html">63</a>  <a href="chap64_mj.html">64</a>  <a href="chap65_mj.html">65</a>  <a href="chap66_mj.html">66</a>  <a href="chap67_mj.html">67</a>  <a href="chap68_mj.html">68</a>  <a href="chap69_mj.html">69</a>  <a href="chap70_mj.html">70</a>  <a href="chap71_mj.html">71</a>  <a href="chap72_mj.html">72</a>  <a href="chap73_mj.html">73</a>  <a href="chap74_mj.html">74</a>  <a href="chap75_mj.html">75</a>  <a href="chap76_mj.html">76</a>  <a href="chap77_mj.html">77</a>  <a href="chap78_mj.html">78</a>  <a href="chap79_mj.html">79</a>  <a href="chap80_mj.html">80</a>  <a href="chap81_mj.html">81</a>  <a href="chap82_mj.html">82</a>  <a href="chap83_mj.html">83</a>  <a href="chap84_mj.html">84</a>  <a href="chap85_mj.html">85</a>  <a href="chap86_mj.html">86</a>  <a href="chap87_mj.html">87</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap23_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap25_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap24.html">[MathJax off]</a></p>
<p><a id="X812CCAB278643A59" name="X812CCAB278643A59"></a></p>
<div class="ChapSects"><a href="chap24_mj.html#X812CCAB278643A59">24 <span class="Heading">Matrices</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap24_mj.html#X801E1B5D7EC8DDD3">24.1 <span class="Heading">InfoMatrix (Info Class)</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X78EC82D27B4191DA">24.1-1 InfoMatrix</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap24_mj.html#X866E55A58164FAED">24.2 <span class="Heading">Categories of Matrices</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7E1AE46B862B185F">24.2-1 IsMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7CF42B8A845BC6A9">24.2-2 IsOrdinaryMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X86EC33E17DD12D0E">24.2-3 IsLieMatrix</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap24_mj.html#X7899335779A39A95">24.3 <span class="Heading">Operators for Matrices</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap24_mj.html#X7F5AD28E869B66CB">24.4 <span class="Heading">Properties and Attributes of Matrices</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X83A9DC2085D3A972">24.4-1 DimensionsMat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X80AE547B8095A5CB">24.4-2 DefaultFieldOfMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X793D5E87870FFBCD">24.4-3 TraceMat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X83045F6F82C180E1">24.4-4 DeterminantMat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X84277D21848B7B7F">24.4-5 DeterminantMatDestructive</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7EEA7E7A7F6BE6F3">24.4-6 DeterminantMatDivFree</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X8740D4D47D7ECD4A">24.4-7 IsEmptyMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X848B80437CE65FF3">24.4-8 IsMonomialMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7EEC8E768178696E">24.4-9 IsDiagonalMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X8740E71C799C0BCC">24.4-10 IsUpperTriangularMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X853A5B988306DBFE">24.4-11 IsLowerTriangularMatrix</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap24_mj.html#X823FB2398697B957">24.5 <span class="Heading">Matrix Constructions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7DB902CE848D1524">24.5-1 IdentityMat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X86D343A77D9B3D4D">24.5-2 NullMat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X8508A7EA812BA0CC">24.5-3 EmptyMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X81042E7A7F247ADE">24.5-4 DiagonalMat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X806C62A67A7D5379">24.5-5 PermutationMat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7C52A38C79C36C35">24.5-6 TransposedMatImmutable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7DBB40847E2B6252">24.5-7 TransposedMatDestructive</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X8634C79E7DB22934">24.5-8 KroneckerProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X845EC4D18054D140">24.5-9 ReflectionMat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7DEBC9967DFDFC18">24.5-10 PrintArray</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap24_mj.html#X79CC5F568252D341">24.6 <span class="Heading">Random Matrices</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7F957F0280A87961">24.6-1 RandomMat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7C939B4A7EDF015D">24.6-2 RandomInvertibleMat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X84743732846ACB44">24.6-3 RandomUnimodularMat</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap24_mj.html#X85485DCE809E323A">24.7 <span class="Heading">Matrices Representing Linear Equations and the Gaussian Algorithm</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7B21AE7987D4FB31">24.7-1 RankMat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7BA26C3387AB434E">24.7-2 TriangulizedMat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X8384CA8E7B3850D3">24.7-3 TriangulizeMat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7DA0D5887DB12DC4">24.7-4 NullspaceMat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X87684B0F7AB7B7DB">24.7-5 NullspaceMatDestructive</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X838A519C7CD2969E">24.7-6 SolutionMat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7A7880D27CE7C1FE">24.7-7 SolutionMatDestructive</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7AB5AC547809F999">24.7-8 BaseFixedSpace</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap24_mj.html#X871FCAA97C60B2BA">24.8 <span class="Heading">Eigenvectors and eigenvalues</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7A2462CC7B0C9D66">24.8-1 GeneralisedEigenvalues</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X845CA0457D65876D">24.8-2 GeneralisedEigenspaces</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X8413C6FB7CEE9D59">24.8-3 Eigenvalues</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7A6B047281B52FD7">24.8-4 Eigenspaces</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X8506584579D4EA18">24.8-5 Eigenvectors</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap24_mj.html#X7E5405D085661B29">24.9 <span class="Heading">Elementary Divisors</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7AC4D74F81908109">24.9-1 ElementaryDivisorsMat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7AA1C9047B102204">24.9-2 ElementaryDivisorsTransformationsMat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X85819D3F7A582180">24.9-3 DiagonalizeMat</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap24_mj.html#X7CA6B51D7AE3172B">24.10 <span class="Heading">Echelonized Matrices</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7D5D6BD07B7E981B">24.10-1 SemiEchelonMat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X8251F6F57D346385">24.10-2 SemiEchelonMatDestructive</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7EFD1DB5861A54F0">24.10-3 SemiEchelonMatTransformation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X827D7971800DB661">24.10-4 SemiEchelonMats</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X808F493B839BC7A6">24.10-5 SemiEchelonMatsDestructive</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap24_mj.html#X86B0D4A886BC0C6E">24.11 <span class="Heading">Matrices as Basis of a Row Space</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7AD6B5F5794D9E46">24.11-1 BaseMat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X78B094597E382A5F">24.11-2 BaseMatDestructive</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X78B94EFF87A455BE">24.11-3 BaseOrthogonalSpaceMat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7AFF8BCF80C88B45">24.11-4 SumIntersectionMat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X8245D54F7AC532EB">24.11-5 BaseSteinitzVectors</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap24_mj.html#X79D5E53685F0FBEE">24.12 <span class="Heading">Triangular Matrices</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7A9139D686ACB7D8">24.12-1 DiagonalOfMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X84A78C057F9DAE5E">24.12-2 UpperSubdiagonal</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X84D74DEA798A9094">24.12-3 DepthOfUpperTriangularMatrix</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap24_mj.html#X85B403857F2855F7">24.13 <span class="Heading">Matrices as Linear Mappings</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X87FA0A727CDB060B">24.13-1 CharacteristicPolynomial</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7B52560C792C1A0F">24.13-2 RationalCanonicalFormTransform</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X83F55D4E79BA5D1B">24.13-3 JordanDecomposition</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X85923C107A4569D0">24.13-4 BlownUpMat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X82AC277D84EC5749">24.13-5 BlownUpVector</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X85A1026D7CB6ABAC">24.13-6 CompanionMat</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap24_mj.html#X873822B6830CE367">24.14 <span class="Heading">Matrices over Finite Fields</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7DED2522828B6C30">24.14-1 ImmutableMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X8587A62F818AA0D6">24.14-2 ConvertToMatrixRep</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X84A76F7A7B4166BC">24.14-3 ProjectiveOrder</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X847ADC6779E33A1C">24.14-4 SimultaneousEigenvalues</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap24_mj.html#X8593A5337D3B2C70">24.15 <span class="Heading">Inverse and Nullspace of an Integer Matrix Modulo an Ideal</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7D8D1E0E83C7F872">24.15-1 InverseMatMod</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7D7DF873826A7C20">24.15-2 BasisNullspaceModN</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X86AE919983B242E2">24.15-3 NullspaceModQ</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap24_mj.html#X787DF5F07DC7D86E">24.16 <span class="Heading">Special Multiplication Algorithms for Matrices over GF(2)</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7C0C26027FAE0C83">24.16-1 PROD_GF2MAT_GF2MAT_SIMPLE</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X81965B7D7F45E088">24.16-2 PROD_GF2MAT_GF2MAT_ADVANCED</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap24_mj.html#X7F8A71F38201A250">24.17 <span class="Heading">Block Matrices</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X7D675B3C79CF8871">24.17-1 AsBlockMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X8633538685551E7A">24.17-2 BlockMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X83FAF4158180041F">24.17-3 MatrixByBlockMatrix</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap24_mj.html#X782F2EBF80C431D0">24.18 <span class="Heading">Linear Programming</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap24_mj.html#X845D5F8D7D905CB8">24.18-1 SimplexMethod</a></span>
</div></div>
</div>

<h3>24 <span class="Heading">Matrices</span></h3>

<p>Matrices are represented in <strong class="pkg">GAP</strong> by lists of row vectors (see <a href="chap23_mj.html#X82C7E6CF7BA03391"><span class="RefLink">23</span></a>) (for future changes to this policy see Chapter <a href="chap26_mj.html#X856C23B87E50F118"><span class="RefLink">26</span></a>). The vectors must all have the same length, and their elements must lie in a common ring. However, since checking rectangularness can be expensive functions and methods of operations for matrices often will not give an error message for non-rectangular lists of lists –in such cases the result is undefined.</p>

<p>Because matrices are just a special case of lists, all operations and functions for lists are applicable to matrices also (see chapter <a href="chap21_mj.html#X7B256AE5780F140A"><span class="RefLink">21</span></a>). This especially includes accessing elements of a matrix (see <a href="chap21_mj.html#X7921047F83F5FA28"><span class="RefLink">21.3</span></a>), changing elements of a matrix (see <a href="chap21_mj.html#X8611EF768210625B"><span class="RefLink">21.4</span></a>), and comparing matrices (see <a href="chap21_mj.html#X8016D50F85147A77"><span class="RefLink">21.10</span></a>).</p>

<p>Note that, since a matrix is a list of lists, the behaviour of <code class="func">ShallowCopy</code> (<a href="chap12_mj.html#X846BC7107C352031"><span class="RefLink">12.7-1</span></a>) for matrices is just a special case of <code class="func">ShallowCopy</code> (<a href="chap12_mj.html#X846BC7107C352031"><span class="RefLink">12.7-1</span></a>) for lists (see <a href="chap21_mj.html#X7ED7C0738495556F"><span class="RefLink">21.7</span></a>); called with an immutable matrix <var class="Arg">mat</var>, <code class="func">ShallowCopy</code> (<a href="chap12_mj.html#X846BC7107C352031"><span class="RefLink">12.7-1</span></a>) returns a mutable matrix whose rows are identical to the rows of <var class="Arg">mat</var>. In particular the rows are still immutable. To get a matrix whose rows are mutable, one can use <code class="code">List( <var class="Arg">mat</var>, ShallowCopy )</code>.</p>

<p><a id="X801E1B5D7EC8DDD3" name="X801E1B5D7EC8DDD3"></a></p>

<h4>24.1 <span class="Heading">InfoMatrix (Info Class)</span></h4>

<p><a id="X78EC82D27B4191DA" name="X78EC82D27B4191DA"></a></p>

<h5>24.1-1 InfoMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InfoMatrix</code></td><td class="tdright">(&nbsp;info class&nbsp;)</td></tr></table></div>
<p>The info class for matrix operations is <code class="func">InfoMatrix</code>.</p>

<p><a id="X866E55A58164FAED" name="X866E55A58164FAED"></a></p>

<h4>24.2 <span class="Heading">Categories of Matrices</span></h4>

<p><a id="X7E1AE46B862B185F" name="X7E1AE46B862B185F"></a></p>

<h5>24.2-1 IsMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsMatrix</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>By convention <em>matrix</em> is a list of lists of equal length whose entries lie in a common ring.</p>

<p>For technical reasons laid out at the top of Chapter <a href="chap24_mj.html#X812CCAB278643A59"><span class="RefLink">24</span></a>, the filter <code class="func">IsMatrix</code> is a synonym for a table of ring elements, (see <code class="func">IsTable</code> (<a href="chap21_mj.html#X80872FAF80EB5DF9"><span class="RefLink">21.1-4</span></a>) and <code class="func">IsRingElement</code> (<a href="chap31_mj.html#X84BF40CA86C07361"><span class="RefLink">31.14-16</span></a>)). This means that <code class="func">IsMatrix</code> returns <code class="keyw">true</code> for tables such as <code class="code">[[1,2],[3]]</code>. If necessary, <code class="func">IsRectangularTable</code> (<a href="chap21_mj.html#X79581E0387F7F7A9"><span class="RefLink">21.1-5</span></a>) can be used to test whether an object is a list of homogenous lists of equal lengths manually.</p>

<p>Note that matrices may have different multiplications, besides the usual matrix product there is for example the Lie product. So there are categories such as <code class="func">IsOrdinaryMatrix</code> (<a href="chap24_mj.html#X7CF42B8A845BC6A9"><span class="RefLink">24.2-2</span></a>) and <code class="func">IsLieMatrix</code> (<a href="chap24_mj.html#X86EC33E17DD12D0E"><span class="RefLink">24.2-3</span></a>) that describe the matrix multiplication. One can form the product of two matrices only if they support the same multiplication.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat:=[[1,2,3],[4,5,6],[7,8,9]];</span>
[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMatrix(mat);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat:=[[1,2],[3]];</span>
[ [ 1, 2 ], [ 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMatrix(mat);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRectangularTable(mat);</span>
false
</pre></div>

<p>Note that the empty list <code class="code">[]</code> and more complex "empty" structures such as <code class="code">[[]]</code> are <em>not</em> matrices, although special methods allow them be used in place of matrices in some situations. See <code class="func">EmptyMatrix</code> (<a href="chap24_mj.html#X8508A7EA812BA0CC"><span class="RefLink">24.5-3</span></a>) below.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[[0]]*[[]];</span>
[ [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMatrix([[]]);</span>
false
</pre></div>

<p><a id="X7CF42B8A845BC6A9" name="X7CF42B8A845BC6A9"></a></p>

<h5>24.2-2 IsOrdinaryMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsOrdinaryMatrix</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>An <em>ordinary matrix</em> is a matrix whose multiplication is the ordinary matrix multiplication.</p>

<p>Each matrix in internal representation is in the category <code class="func">IsOrdinaryMatrix</code>, and arithmetic operations with objects in <code class="func">IsOrdinaryMatrix</code> produce again matrices in <code class="func">IsOrdinaryMatrix</code>.</p>

<p>Note that we want that Lie matrices shall be matrices that behave in the same way as ordinary matrices, except that they have a different multiplication. So we must distinguish the different matrix multiplications, in order to be able to describe the applicability of multiplication, and also in order to form a matrix of the appropriate type as the sum, difference etc. of two matrices which have the same multiplication.</p>

<p><a id="X86EC33E17DD12D0E" name="X86EC33E17DD12D0E"></a></p>

<h5>24.2-3 IsLieMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLieMatrix</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>A <em>Lie matrix</em> is a matrix whose multiplication is given by the Lie bracket. (Note that a matrix with ordinary matrix multiplication is in the category <code class="func">IsOrdinaryMatrix</code> (<a href="chap24_mj.html#X7CF42B8A845BC6A9"><span class="RefLink">24.2-2</span></a>).)</p>

<p>Each matrix created by <code class="func">LieObject</code> (<a href="chap64_mj.html#X87F121978775AF48"><span class="RefLink">64.1-1</span></a>) is in the category <code class="func">IsLieMatrix</code>, and arithmetic operations with objects in <code class="func">IsLieMatrix</code> produce again matrices in <code class="func">IsLieMatrix</code>.</p>

<p><a id="X7899335779A39A95" name="X7899335779A39A95"></a></p>

<h4>24.3 <span class="Heading">Operators for Matrices</span></h4>

<p>The rules for arithmetic operations involving matrices are in fact special cases of those for the arithmetic of lists, given in Section <a href="chap21_mj.html#X845EEAF083D43CCE"><span class="RefLink">21.11</span></a> and the following sections, here we reiterate that definition, in the language of vectors and matrices.</p>

<p>Note that the additive behaviour sketched below is defined only for lists in the category <code class="func">IsGeneralizedRowVector</code> (<a href="chap21_mj.html#X87ABCEE9809585A0"><span class="RefLink">21.12-1</span></a>), and the multiplicative behaviour is defined only for lists in the category <code class="func">IsMultiplicativeGeneralizedRowVector</code> (<a href="chap21_mj.html#X7FBCA5B58308C158"><span class="RefLink">21.12-2</span></a>) (see <a href="chap21_mj.html#X84D642967B8546B7"><span class="RefLink">21.12</span></a>).</p>

<p><code class="code"><var class="Arg">mat1</var> + <var class="Arg">mat2</var></code></p>

<p>returns the sum of the two matrices <var class="Arg">mat1</var> and <var class="Arg">mat2</var>, Probably the most usual situation is that <var class="Arg">mat1</var> and <var class="Arg">mat2</var> have the same dimensions and are defined over a common field; in this case the sum is a new matrix over the same field where each entry is the sum of the corresponding entries of the matrices.</p>

<p>In more general situations, the sum of two matrices need not be a matrix, for example adding an integer matrix <var class="Arg">mat1</var> and a matrix <var class="Arg">mat2</var> over a finite field yields the table of pointwise sums, which will be a mixture of finite field elements and integers if <var class="Arg">mat1</var> has bigger dimensions than <var class="Arg">mat2</var>.</p>

<p><code class="code"><var class="Arg">scalar</var> + <var class="Arg">mat</var></code></p>

<p><code class="code"><var class="Arg">mat</var> + <var class="Arg">scalar</var></code></p>

<p>returns the sum of the scalar <var class="Arg">scalar</var> and the matrix <var class="Arg">mat</var>. Probably the most usual situation is that the entries of <var class="Arg">mat</var> lie in a common field with <var class="Arg">scalar</var>; in this case the sum is a new matrix over the same field where each entry is the sum of the scalar and the corresponding entry of the matrix.</p>

<p>More general situations are for example the sum of an integer scalar and a matrix over a finite field, or the sum of a finite field element and an integer matrix.</p>

<p><code class="code"><var class="Arg">mat1</var> - <var class="Arg">mat2</var></code></p>

<p><code class="code"><var class="Arg">scalar</var> - <var class="Arg">mat</var></code></p>

<p><code class="code"><var class="Arg">mat</var> - <var class="Arg">scalar</var></code></p>

<p>Subtracting a matrix or scalar is defined as adding its additive inverse, so the statements for the addition hold likewise.</p>

<p><code class="code"><var class="Arg">scalar</var> * <var class="Arg">mat</var></code></p>

<p><code class="code"><var class="Arg">mat</var> * <var class="Arg">scalar</var></code></p>

<p>returns the product of the scalar <var class="Arg">scalar</var> and the matrix <var class="Arg">mat</var>. Probably the most usual situation is that the elements of <var class="Arg">mat</var> lie in a common field with <var class="Arg">scalar</var>; in this case the product is a new matrix over the same field where each entry is the product of the scalar and the corresponding entry of the matrix.</p>

<p>More general situations are for example the product of an integer scalar and a matrix over a finite field, or the product of a finite field element and an integer matrix.</p>

<p><code class="code"><var class="Arg">vec</var> * <var class="Arg">mat</var></code></p>

<p>returns the product of the row vector <var class="Arg">vec</var> and the matrix <var class="Arg">mat</var>. Probably the most usual situation is that <var class="Arg">vec</var> and <var class="Arg">mat</var> have the same lengths and are defined over a common field, and that all rows of <var class="Arg">mat</var> have the same length <span class="SimpleMath">\(m\)</span>, say; in this case the product is a new row vector of length <span class="SimpleMath">\(m\)</span> over the same field which is the sum of the scalar multiples of the rows of <var class="Arg">mat</var> with the corresponding entries of <var class="Arg">vec</var>.</p>

<p>More general situations are for example the product of an integer vector and a matrix over a finite field, or the product of a vector over a finite field and an integer matrix.</p>

<p><code class="code"><var class="Arg">mat</var> * <var class="Arg">vec</var></code></p>

<p>returns the product of the matrix <var class="Arg">mat</var> and the row vector <var class="Arg">vec</var>. (This is the standard product of a matrix with a <em>column</em> vector.) Probably the most usual situation is that the length of <var class="Arg">vec</var> and of all rows of <var class="Arg">mat</var> are equal, and that the elements of <var class="Arg">mat</var> and <var class="Arg">vec</var> lie in a common field; in this case the product is a new row vector of the same length as <var class="Arg">mat</var> and over the same field which is the sum of the scalar multiples of the columns of <var class="Arg">mat</var> with the corresponding entries of <var class="Arg">vec</var>.</p>

<p>More general situations are for example the product of an integer matrix and a vector over a finite field, or the product of a matrix over a finite field and an integer vector.</p>

<p><code class="code"><var class="Arg">mat1</var> * <var class="Arg">mat2</var></code></p>

<p>This form evaluates to the (Cauchy) product of the two matrices <var class="Arg">mat1</var> and <var class="Arg">mat2</var>. Probably the most usual situation is that the number of columns of <var class="Arg">mat1</var> equals the number of rows of <var class="Arg">mat2</var>, and that the elements of <var class="Arg">mat</var> and <var class="Arg">vec</var> lie in a common field; if <var class="Arg">mat1</var> is a matrix with <span class="SimpleMath">\(m\)</span> rows and <span class="SimpleMath">\(n\)</span> columns, say, and <var class="Arg">mat2</var> is a matrix with <span class="SimpleMath">\(n\)</span> rows and <span class="SimpleMath">\(o\)</span> columns, the result is a new matrix with <span class="SimpleMath">\(m\)</span> rows and <span class="SimpleMath">\(o\)</span> columns. The element in row <span class="SimpleMath">\(i\)</span> at position <span class="SimpleMath">\(j\)</span> of the product is the sum of <span class="SimpleMath">\(\textit{mat1}[i][l] * \textit{mat2}[l][j]\)</span>, with <span class="SimpleMath">\(l\)</span> running from <span class="SimpleMath">\(1\)</span> to <span class="SimpleMath">\(n\)</span>.</p>

<p><code class="code">Inverse( <var class="Arg">mat</var> )</code></p>

<p>returns the inverse of the matrix <var class="Arg">mat</var>, which must be an invertible square matrix. If <var class="Arg">mat</var> is not invertible then <code class="keyw">fail</code> is returned.</p>

<p><code class="code"><var class="Arg">mat1</var> / <var class="Arg">mat2</var></code></p>

<p><code class="code"><var class="Arg">scalar</var> / <var class="Arg">mat</var></code></p>

<p><code class="code"><var class="Arg">mat</var> / <var class="Arg">scalar</var></code></p>

<p><code class="code"><var class="Arg">vec</var> / <var class="Arg">mat</var></code></p>

<p>In general, <code class="code"><var class="Arg">left</var> / <var class="Arg">right</var></code> is defined as <code class="code"><var class="Arg">left</var> * <var class="Arg">right</var>^-1</code>. Thus in the above forms the right operand must always be invertible.</p>

<p><code class="code"><var class="Arg">mat</var> ^ <var class="Arg">int</var></code></p>

<p><code class="code"><var class="Arg">mat1</var> ^ <var class="Arg">mat2</var></code></p>

<p><code class="code"><var class="Arg">vec</var> ^ <var class="Arg">mat</var></code></p>

<p>Powering a square matrix <var class="Arg">mat</var> by an integer <var class="Arg">int</var> yields the <var class="Arg">int</var>-th power of <var class="Arg">mat</var>; if <var class="Arg">int</var> is negative then <var class="Arg">mat</var> must be invertible, if <var class="Arg">int</var> is <code class="code">0</code> then the result is the identity matrix <code class="code">One( <var class="Arg">mat</var> )</code>, even if <var class="Arg">mat</var> is not invertible.</p>

<p>Powering a square matrix <var class="Arg">mat1</var> by an invertible square matrix <var class="Arg">mat2</var> of the same dimensions yields the conjugate of <var class="Arg">mat1</var> by <var class="Arg">mat2</var>, i.e., the matrix <code class="code"><var class="Arg">mat2</var>^-1 * <var class="Arg">mat1</var> * <var class="Arg">mat2</var></code>.</p>

<p>Powering a row vector <var class="Arg">vec</var> by a matrix <var class="Arg">mat</var> is in every respect equivalent to <code class="code"><var class="Arg">vec</var> * <var class="Arg">mat</var></code>. This operations reflects the fact that matrices act naturally on row vectors by multiplication from the right, and that the powering operator is <strong class="pkg">GAP</strong>'s standard for group actions.</p>

<p><code class="code">Comm( <var class="Arg">mat1</var>, <var class="Arg">mat2</var> )</code></p>

<p>returns the commutator of the square invertible matrices <var class="Arg">mat1</var> and <var class="Arg">mat2</var> of the same dimensions and over a common field, which is the matrix <code class="code"><var class="Arg">mat1</var>^-1 * <var class="Arg">mat2</var>^-1 * <var class="Arg">mat1</var> * <var class="Arg">mat2</var></code>.</p>

<p>The following cases are still special cases of the general list arithmetic defined in <a href="chap21_mj.html#X845EEAF083D43CCE"><span class="RefLink">21.11</span></a>.</p>

<p><code class="code"><var class="Arg">scalar</var> + <var class="Arg">matlist</var></code></p>

<p><code class="code"><var class="Arg">matlist</var> + <var class="Arg">scalar</var></code></p>

<p><code class="code"><var class="Arg">scalar</var> - <var class="Arg">matlist</var></code></p>

<p><code class="code"><var class="Arg">matlist</var> - <var class="Arg">scalar</var></code></p>

<p><code class="code"><var class="Arg">scalar</var> * <var class="Arg">matlist</var></code></p>

<p><code class="code"><var class="Arg">matlist</var> * <var class="Arg">scalar</var></code></p>

<p><code class="code"><var class="Arg">matlist</var> / <var class="Arg">scalar</var></code></p>

<p>A scalar <var class="Arg">scalar</var> may also be added, subtracted, multiplied with, or divided into a list <var class="Arg">matlist</var> of matrices. The result is a new list of matrices where each matrix is the result of performing the operation with the corresponding matrix in <var class="Arg">matlist</var>.</p>

<p><code class="code"><var class="Arg">mat</var> * <var class="Arg">matlist</var></code></p>

<p><code class="code"><var class="Arg">matlist</var> * <var class="Arg">mat</var></code></p>

<p>A matrix <var class="Arg">mat</var> may also be multiplied with a list <var class="Arg">matlist</var> of matrices. The result is a new list of matrices, where each entry is the product of <var class="Arg">mat</var> and the corresponding entry in <var class="Arg">matlist</var>.</p>

<p><code class="code"><var class="Arg">matlist</var> / <var class="Arg">mat</var></code></p>

<p>Dividing a list <var class="Arg">matlist</var> of matrices by an invertible matrix <var class="Arg">mat</var> evaluates to <code class="code"><var class="Arg">matlist</var> * <var class="Arg">mat</var>^-1</code>.</p>

<p><code class="code"><var class="Arg">vec</var> * <var class="Arg">matlist</var></code></p>

<p>returns the product of the vector <var class="Arg">vec</var> and the list of matrices <var class="Arg">mat</var>. The lengths <var class="Arg">l</var> of <var class="Arg">vec</var> and <var class="Arg">matlist</var> must be equal. All matrices in <var class="Arg">matlist</var> must have the same dimensions. The elements of <var class="Arg">vec</var> and the elements of the matrices in <var class="Arg">matlist</var> must lie in a common ring. The product is the sum over <code class="code"><var class="Arg">vec</var>[<var class="Arg">i</var>] * <var class="Arg">matlist</var>[<var class="Arg">i</var>]</code> with <var class="Arg">i</var> running from 1 to <var class="Arg">l</var>.</p>

<p>For the mutability of results of arithmetic operations, see <a href="chap12_mj.html#X7F0C119682196D65"><span class="RefLink">12.6</span></a>.</p>

<p><a id="X7F5AD28E869B66CB" name="X7F5AD28E869B66CB"></a></p>

<h4>24.4 <span class="Heading">Properties and Attributes of Matrices</span></h4>

<p><a id="X83A9DC2085D3A972" name="X83A9DC2085D3A972"></a></p>

<h5>24.4-1 DimensionsMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DimensionsMat</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>is a list of length 2, the first being the number of rows, the second being the number of columns of the matrix <var class="Arg">mat</var>. If <var class="Arg">mat</var> is malformed, that is, it is not a <code class="func">IsRectangularTable</code> (<a href="chap21_mj.html#X79581E0387F7F7A9"><span class="RefLink">21.1-5</span></a>), returns <code class="keyw">fail</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DimensionsMat([[1,2,3],[4,5,6]]);</span>
[ 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DimensionsMat([[1,2,3],[4,5]]);</span>
fail
</pre></div>

<p><a id="X80AE547B8095A5CB" name="X80AE547B8095A5CB"></a></p>

<h5>24.4-2 DefaultFieldOfMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DefaultFieldOfMatrix</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For a matrix <var class="Arg">mat</var>, <code class="func">DefaultFieldOfMatrix</code> returns either a field (not necessarily the smallest one) containing all entries of <var class="Arg">mat</var>, or <code class="keyw">fail</code>.</p>

<p>If <var class="Arg">mat</var> is a matrix of finite field elements or a matrix of cyclotomics, <code class="func">DefaultFieldOfMatrix</code> returns the default field generated by the matrix entries (see <a href="chap59_mj.html#X81B54A8378734C33"><span class="RefLink">59.3</span></a> and <a href="chap18_mj.html#X79E25C3085AA568F"><span class="RefLink">18.1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DefaultFieldOfMatrix([[Z(4),Z(8)]]);</span>
GF(2^6)
</pre></div>

<p><a id="X793D5E87870FFBCD" name="X793D5E87870FFBCD"></a></p>

<h5>24.4-3 TraceMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TraceMat</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Trace</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The trace of a square matrix is the sum of its diagonal entries.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TraceMat([[1,2,3],[4,5,6],[7,8,9]]);</span>
15
</pre></div>

<p><a id="X83045F6F82C180E1" name="X83045F6F82C180E1"></a></p>

<h5>24.4-4 DeterminantMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DeterminantMat</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Determinant</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns the determinant of the square matrix <var class="Arg">mat</var>.</p>

<p>These methods assume implicitly that <var class="Arg">mat</var> is defined over an integral domain whose quotient field is implemented in <strong class="pkg">GAP</strong>. For matrices defined over an arbitrary commutative ring with one see <code class="func">DeterminantMatDivFree</code> (<a href="chap24_mj.html#X7EEA7E7A7F6BE6F3"><span class="RefLink">24.4-6</span></a>).</p>

<p><a id="X84277D21848B7B7F" name="X84277D21848B7B7F"></a></p>

<h5>24.4-5 DeterminantMatDestructive</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DeterminantMatDestructive</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Does the same as <code class="func">DeterminantMat</code> (<a href="chap24_mj.html#X83045F6F82C180E1"><span class="RefLink">24.4-4</span></a>), with the difference that it may destroy its argument. The matrix <var class="Arg">mat</var> must be mutable.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DeterminantMat([[1,2],[2,1]]);</span>
-3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mm:= [[1,2],[2,1]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DeterminantMatDestructive( mm );</span>
-3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mm;</span>
[ [ 1, 2 ], [ 0, -3 ] ]
</pre></div>

<p><a id="X7EEA7E7A7F6BE6F3" name="X7EEA7E7A7F6BE6F3"></a></p>

<h5>24.4-6 DeterminantMatDivFree</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DeterminantMatDivFree</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns the determinant of a square matrix <var class="Arg">mat</var> over an arbitrary commutative ring with one using the division free method of Mahajan and Vinay <a href="chapBib_mj.html#biBMV97">[MV97]</a>.</p>

<p><a id="X8740D4D47D7ECD4A" name="X8740D4D47D7ECD4A"></a></p>

<h5>24.4-7 IsEmptyMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsEmptyMatrix</code>( <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: A boolean</p>

<p>Is <code class="keyw">true</code> if <var class="Arg">M</var> either has zero columns or zero rows and <code class="keyw">false</code> otherwise. In other words, a matrix is empty if it has no entries.</p>

<p><a id="X848B80437CE65FF3" name="X848B80437CE65FF3"></a></p>

<h5>24.4-8 IsMonomialMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsMonomialMatrix</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>A matrix is monomial if and only if it has exactly one nonzero entry in every row and every column.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomialMatrix([[0,1],[1,0]]);</span>
true
</pre></div>

<p><a id="X7EEC8E768178696E" name="X7EEC8E768178696E"></a></p>

<h5>24.4-9 IsDiagonalMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDiagonalMatrix</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDiagonalMat</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>return <code class="keyw">true</code> if the matrix <var class="Arg">mat</var> has only zero entries off the main diagonal, and <code class="keyw">false</code> otherwise.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDiagonalMatrix( [ [ 1 ] ] );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDiagonalMatrix( [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDiagonalMatrix( [ [ 0, 1 ], [ 1, 0 ] ] );</span>
false
</pre></div>

<p><a id="X8740E71C799C0BCC" name="X8740E71C799C0BCC"></a></p>

<h5>24.4-10 IsUpperTriangularMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsUpperTriangularMatrix</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsUpperTriangularMat</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>return <code class="keyw">true</code> if the matrix <var class="Arg">mat</var> has only zero entries below the main diagonal, and <code class="keyw">false</code> otherwise.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsUpperTriangularMatrix( [ [ 1 ] ] );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsUpperTriangularMatrix( [ [ 1, 2, 3 ], [ 0, 5, 6 ] ] );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsUpperTriangularMatrix( [ [ 0, 1 ], [ 1, 0 ] ] );</span>
false
</pre></div>

<p><a id="X853A5B988306DBFE" name="X853A5B988306DBFE"></a></p>

<h5>24.4-11 IsLowerTriangularMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLowerTriangularMatrix</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLowerTriangularMat</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>return <code class="keyw">true</code> if the matrix <var class="Arg">mat</var> has only zero entries above the main diagonal, and <code class="keyw">false</code> otherwise.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLowerTriangularMatrix( [ [ 1 ] ] );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLowerTriangularMatrix( [ [ 1, 0, 0 ], [ 2, 3, 0 ] ] );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLowerTriangularMatrix( [ [ 0, 1 ], [ 1, 0 ] ] );</span>
false
</pre></div>

<p><a id="X823FB2398697B957" name="X823FB2398697B957"></a></p>

<h4>24.5 <span class="Heading">Matrix Constructions</span></h4>

<p><a id="X7DB902CE848D1524" name="X7DB902CE848D1524"></a></p>

<h5>24.5-1 IdentityMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IdentityMat</code>( <var class="Arg">m</var>[, <var class="Arg">R</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns a (mutable) <var class="Arg">m</var><span class="SimpleMath">\(\times\)</span><var class="Arg">m</var> identity matrix over the ring given by <var class="Arg">R</var>. Here, <var class="Arg">R</var> can be either a ring, or an element of a ring. By default, an integer matrix is created.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdentityMat(3);</span>
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdentityMat(2,Integers mod 15);</span>
[ [ ZmodnZObj( 1, 15 ), ZmodnZObj( 0, 15 ) ], 
  [ ZmodnZObj( 0, 15 ), ZmodnZObj( 1, 15 ) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdentityMat(2,Z(3));</span>
[ [ Z(3)^0, 0*Z(3) ], [ 0*Z(3), Z(3)^0 ] ]
</pre></div>

<p><a id="X86D343A77D9B3D4D" name="X86D343A77D9B3D4D"></a></p>

<h5>24.5-2 NullMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NullMat</code>( <var class="Arg">m</var>, <var class="Arg">n</var>[, <var class="Arg">R</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns a (mutable) <var class="Arg">m</var><span class="SimpleMath">\(\times\)</span><var class="Arg">n</var> null matrix over the ring given by by <var class="Arg">R</var>. Here, <var class="Arg">R</var> can be either a ring, or an element of a ring. By default, an integer matrix is created.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NullMat(3,2);</span>
[ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NullMat(2,2,Integers mod 15);</span>
[ [ ZmodnZObj( 0, 15 ), ZmodnZObj( 0, 15 ) ], 
  [ ZmodnZObj( 0, 15 ), ZmodnZObj( 0, 15 ) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NullMat(3,2,Z(3));</span>
[ [ 0*Z(3), 0*Z(3) ], [ 0*Z(3), 0*Z(3) ], [ 0*Z(3), 0*Z(3) ] ]
</pre></div>

<p><a id="X8508A7EA812BA0CC" name="X8508A7EA812BA0CC"></a></p>

<h5>24.5-3 EmptyMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EmptyMatrix</code>( <var class="Arg">char</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>is an empty (ordinary) matrix in characteristic <var class="Arg">char</var> that can be added to or multiplied with empty lists (representing zero-dimensional row vectors). It also acts (via the operation <code class="func">\^</code> (<a href="chap31_mj.html#X8481C9B97B214C23"><span class="RefLink">31.12-1</span></a>)) on empty lists.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EmptyMatrix(5);</span>
EmptyMatrix( 5 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsList(last);</span>
[  ]
</pre></div>

<p><a id="X81042E7A7F247ADE" name="X81042E7A7F247ADE"></a></p>

<h5>24.5-4 DiagonalMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DiagonalMat</code>( <var class="Arg">vector</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns a diagonal matrix <var class="Arg">mat</var> with the diagonal entries given by <var class="Arg">vector</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DiagonalMat([1,2,3]);</span>
[ [ 1, 0, 0 ], [ 0, 2, 0 ], [ 0, 0, 3 ] ]
</pre></div>

<p><a id="X806C62A67A7D5379" name="X806C62A67A7D5379"></a></p>

<h5>24.5-5 PermutationMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PermutationMat</code>( <var class="Arg">perm</var>, <var class="Arg">dim</var>[, <var class="Arg">F</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns a matrix in dimension <var class="Arg">dim</var> over the field given by <var class="Arg">F</var> (i.e. the smallest field containing the element <var class="Arg">F</var> or <var class="Arg">F</var> itself if it is a field) that represents the permutation <var class="Arg">perm</var> acting by permuting the basis vectors as it permutes points.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PermutationMat((1,2,3),4,1);</span>
[ [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 1, 0, 0, 0 ], [ 0, 0, 0, 1 ] ]
</pre></div>

<p><a id="X7C52A38C79C36C35" name="X7C52A38C79C36C35"></a></p>

<h5>24.5-6 TransposedMatImmutable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TransposedMatImmutable</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TransposedMatAttr</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TransposedMat</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TransposedMatMutable</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TransposedMatOp</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>These functions all return the transposed of the matrix <var class="Arg">mat</var>, i.e., a matrix <var class="Arg">trans</var> such that <code class="code"><var class="Arg">trans</var>[<var class="Arg">i</var>][<var class="Arg">k</var>] = <var class="Arg">mat</var>[<var class="Arg">k</var>][<var class="Arg">i</var>]</code> holds.</p>

<p>They differ only w.r.t. the mutability of the result.</p>

<p><code class="func">TransposedMat</code> is an attribute and hence returns an immutable result. <code class="func">TransposedMatMutable</code> is guaranteed to return a new <em>mutable</em> matrix.</p>

<p><code class="func">TransposedMatImmutable</code> and <code class="func">TransposedMatAttr</code> are synonyms of <code class="func">TransposedMat</code>, and <code class="func">TransposedMatOp</code> is a synonym of <code class="func">TransposedMatMutable</code>, in analogy to operations such as <code class="func">Zero</code> (<a href="chap31_mj.html#X8040AC7A79FFC442"><span class="RefLink">31.10-3</span></a>).</p>

<p><a id="X7DBB40847E2B6252" name="X7DBB40847E2B6252"></a></p>

<h5>24.5-7 TransposedMatDestructive</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TransposedMatDestructive</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>If <var class="Arg">mat</var> is a mutable matrix, then the transposed is computed by swapping the entries in <var class="Arg">mat</var>. In this way <var class="Arg">mat</var> gets changed. In all other cases the transposed is computed by <code class="func">TransposedMat</code> (<a href="chap24_mj.html#X7C52A38C79C36C35"><span class="RefLink">24.5-6</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransposedMat([[1,2,3],[4,5,6],[7,8,9]]);</span>
[ [ 1, 4, 7 ], [ 2, 5, 8 ], [ 3, 6, 9 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mm:= [[1,2,3],[4,5,6],[7,8,9]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransposedMatDestructive( mm );</span>
[ [ 1, 4, 7 ], [ 2, 5, 8 ], [ 3, 6, 9 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mm;</span>
[ [ 1, 4, 7 ], [ 2, 5, 8 ], [ 3, 6, 9 ] ]
</pre></div>

<p><a id="X8634C79E7DB22934" name="X8634C79E7DB22934"></a></p>

<h5>24.5-8 KroneckerProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; KroneckerProduct</code>( <var class="Arg">mat1</var>, <var class="Arg">mat2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The Kronecker product of two matrices is the matrix obtained when replacing each entry <var class="Arg">a</var> of <var class="Arg">mat1</var> by the product <code class="code"><var class="Arg">a</var>*<var class="Arg">mat2</var></code> in one matrix.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KroneckerProduct([[1,2]],[[5,7],[9,2]]);</span>
[ [ 5, 7, 10, 14 ], [ 9, 2, 18, 4 ] ]
</pre></div>

<p><a id="X845EC4D18054D140" name="X845EC4D18054D140"></a></p>

<h5>24.5-9 ReflectionMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ReflectionMat</code>( <var class="Arg">coeffs</var>[, <var class="Arg">conj</var>][, <var class="Arg">root</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">coeffs</var> be a row vector. <code class="func">ReflectionMat</code> returns the matrix of the reflection in this vector.</p>

<p>More precisely, if <var class="Arg">coeffs</var> is the coefficients list of a vector <span class="SimpleMath">\(v\)</span> w.r.t. a basis <span class="SimpleMath">\(B\)</span> (see <code class="func">Basis</code> (<a href="chap61_mj.html#X837BE54C80DE368E"><span class="RefLink">61.5-2</span></a>)), say, then the returned matrix describes the reflection in <span class="SimpleMath">\(v\)</span> w.r.t. <span class="SimpleMath">\(B\)</span> as a map on a row space, with action from the right.</p>

<p>The optional argument <var class="Arg">root</var> is a root of unity that determines the order of the reflection. The default is a reflection of order 2. For triflections one should choose a third root of unity etc. (see <code class="func">E</code> (<a href="chap18_mj.html#X8631458886314588"><span class="RefLink">18.1-1</span></a>)).</p>

<p><var class="Arg">conj</var> is a function of one argument that conjugates a ring element. The default is <code class="func">ComplexConjugate</code> (<a href="chap18_mj.html#X7BE001A0811CD599"><span class="RefLink">18.5-2</span></a>).</p>

<p>The matrix of the reflection in <span class="SimpleMath">\(v\)</span> is defined as</p>

<p class="center">\[
M = I_n +
  \overline{{v^{tr}}} \cdot (w-1) / ( v \overline{{v^{tr}}} ) \cdot v
\]</p>

<p>where <span class="SimpleMath">\(w\)</span> equals <var class="Arg">root</var>, <span class="SimpleMath">\(n\)</span> is the length of the coefficient list, and <span class="SimpleMath">\(\overline{{\vphantom{x}}}\)</span> denotes the conjugation.</p>

<p>So <span class="SimpleMath">\(v\)</span> is mapped to <span class="SimpleMath">\(w v\)</span>, with default <span class="SimpleMath">\(-v\)</span>, and any vector <span class="SimpleMath">\(x\)</span> with the property <span class="SimpleMath">\(x \overline{{v^{tr}}} = 0\)</span> is fixed by the reflection.</p>

<p><a id="X7DEBC9967DFDFC18" name="X7DEBC9967DFDFC18"></a></p>

<h5>24.5-10 PrintArray</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PrintArray</code>( <var class="Arg">array</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>pretty-prints the array <var class="Arg">array</var>.</p>

<p><a id="X79CC5F568252D341" name="X79CC5F568252D341"></a></p>

<h4>24.6 <span class="Heading">Random Matrices</span></h4>

<p><a id="X7F957F0280A87961" name="X7F957F0280A87961"></a></p>

<h5>24.6-1 RandomMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RandomMat</code>( [<var class="Arg">rs</var>, ]<var class="Arg">m</var>, <var class="Arg">n</var>[, <var class="Arg">R</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="func">RandomMat</code> returns a new mutable random matrix with <var class="Arg">m</var> rows and <var class="Arg">n</var> columns with elements taken from the ring <var class="Arg">R</var>, which defaults to <code class="func">Integers</code> (<a href="chap14_mj.html#X853DF11B80068ED5"><span class="RefLink">14</span></a>). Optionally, a random source <var class="Arg">rs</var> can be supplied.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomMat(2,3,GF(3));</span>
[ [ Z(3), Z(3), 0*Z(3) ], [ Z(3), Z(3)^0, Z(3) ] ]
</pre></div>

<p><a id="X7C939B4A7EDF015D" name="X7C939B4A7EDF015D"></a></p>

<h5>24.6-2 RandomInvertibleMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RandomInvertibleMat</code>( [<var class="Arg">rs</var>, ]<var class="Arg">m</var>[, <var class="Arg">R</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="func">RandomInvertibleMat</code> returns a new mutable invertible random matrix with <var class="Arg">m</var> rows and columns with elements taken from the ring <var class="Arg">R</var>, which defaults to <code class="func">Integers</code> (<a href="chap14_mj.html#X853DF11B80068ED5"><span class="RefLink">14</span></a>). Optionally, a random source <var class="Arg">rs</var> can be supplied.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := RandomInvertibleMat(4);</span>
[ [ -4, 1, 0, -1 ], [ -1, -1, 1, -1 ], [ 1, -2, -1, -2 ], 
  [ 0, -1, 2, -2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m^-1;</span>
[ [ -1/8, -11/24, 1/24, 1/4 ], [ 1/4, -13/12, -1/12, 1/2 ], 
  [ -1/8, 5/24, -7/24, 1/4 ], [ -1/4, 3/4, -1/4, -1/2 ] ]
</pre></div>

<p><a id="X84743732846ACB44" name="X84743732846ACB44"></a></p>

<h5>24.6-3 RandomUnimodularMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RandomUnimodularMat</code>( [<var class="Arg">rs</var>, ]<var class="Arg">m</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns a new random mutable <var class="Arg">m</var><span class="SimpleMath">\(\times\)</span><var class="Arg">m</var> matrix with integer entries that is invertible over the integers. Optionally, a random source <var class="Arg">rs</var> can be supplied.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := RandomUnimodularMat(3);</span>
[ [ -5, 1, 0 ], [ 12, -2, -1 ], [ -14, 3, 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m^-1;</span>
[ [ -3, 0, 1 ], [ -14, 0, 5 ], [ -8, -1, 2 ] ]
</pre></div>

<p><a id="X85485DCE809E323A" name="X85485DCE809E323A"></a></p>

<h4>24.7 <span class="Heading">Matrices Representing Linear Equations and the Gaussian Algorithm</span></h4>

<p><a id="X7B21AE7987D4FB31" name="X7B21AE7987D4FB31"></a></p>

<h5>24.7-1 RankMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RankMat</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>If <var class="Arg">mat</var> is a matrix whose rows span a free module over the ring generated by the matrix entries and their inverses then <code class="func">RankMat</code> returns the dimension of this free module. Otherwise <code class="keyw">fail</code> is returned.</p>

<p>Note that <code class="func">RankMat</code> may perform a Gaussian elimination. For large rational matrices this may take very long, because the entries may become very large.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat:=[[1,2,3],[4,5,6],[7,8,9]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RankMat(mat);</span>
2
</pre></div>

<p><a id="X7BA26C3387AB434E" name="X7BA26C3387AB434E"></a></p>

<h5>24.7-2 TriangulizedMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TriangulizedMat</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RREF</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Computes an upper triangular form of the matrix <var class="Arg">mat</var> via the Gaussian Algorithm. It returns a mutable matrix in upper triangular form. This is sometimes also called "Hermite normal form" or "Reduced Row Echelon Form". <code class="code">RREF</code> is a synonym for <code class="code">TriangulizedMat</code>.</p>

<p><a id="X8384CA8E7B3850D3" name="X8384CA8E7B3850D3"></a></p>

<h5>24.7-3 TriangulizeMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TriangulizeMat</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Applies the Gaussian Algorithm to the mutable matrix <var class="Arg">mat</var> and changes <var class="Arg">mat</var> such that it is in upper triangular normal form (sometimes called "Hermite normal form" or "Reduced Row Echelon Form").</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m:=TransposedMatMutable(mat);</span>
[ [ 1, 4, 7 ], [ 2, 5, 8 ], [ 3, 6, 9 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TriangulizeMat(m);m;</span>
[ [ 1, 0, -1 ], [ 0, 1, 2 ], [ 0, 0, 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m:=TransposedMatMutable(mat);</span>
[ [ 1, 4, 7 ], [ 2, 5, 8 ], [ 3, 6, 9 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TriangulizedMat(m);m;</span>
[ [ 1, 0, -1 ], [ 0, 1, 2 ], [ 0, 0, 0 ] ]
[ [ 1, 4, 7 ], [ 2, 5, 8 ], [ 3, 6, 9 ] ]
</pre></div>

<p><a id="X7DA0D5887DB12DC4" name="X7DA0D5887DB12DC4"></a></p>

<h5>24.7-4 NullspaceMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NullspaceMat</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TriangulizedNullspaceMat</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns a list of row vectors that form a basis of the vector space of solutions to the equation <code class="code"><var class="Arg">vec</var>*<var class="Arg">mat</var>=0</code>. The result is an immutable matrix. This basis is not guaranteed to be in any specific form.</p>

<p>The variant <code class="func">TriangulizedNullspaceMat</code> returns a basis of the nullspace in triangulized form as is often needed for algorithms.</p>

<p><a id="X87684B0F7AB7B7DB" name="X87684B0F7AB7B7DB"></a></p>

<h5>24.7-5 NullspaceMatDestructive</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NullspaceMatDestructive</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TriangulizedNullspaceMatDestructive</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>This function does the same as <code class="func">NullspaceMat</code> (<a href="chap24_mj.html#X7DA0D5887DB12DC4"><span class="RefLink">24.7-4</span></a>). However, the latter function makes a copy of <var class="Arg">mat</var> to avoid having to change it. This function does not do that; it returns the nullspace and may destroy <var class="Arg">mat</var>; this saves a lot of memory in case <var class="Arg">mat</var> is big. The matrix <var class="Arg">mat</var> must be mutable.</p>

<p>The variant <code class="func">TriangulizedNullspaceMatDestructive</code> returns a basis of the nullspace in triangulized form. It may destroy the matrix <var class="Arg">mat</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat:=[[1,2,3],[4,5,6],[7,8,9]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NullspaceMat(mat);</span>
[ [ 1, -2, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mm:=[[1,2,3],[4,5,6],[7,8,9]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NullspaceMatDestructive( mm );</span>
[ [ 1, -2, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mm;</span>
[ [ 1, 2, 3 ], [ 0, -3, -6 ], [ 0, 0, 0 ] ]
</pre></div>

<p><a id="X838A519C7CD2969E" name="X838A519C7CD2969E"></a></p>

<h5>24.7-6 SolutionMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SolutionMat</code>( <var class="Arg">mat</var>, <var class="Arg">vec</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns a row vector <var class="Arg">x</var> that is a solution of the equation <code class="code"><var class="Arg">x</var> * <var class="Arg">mat</var> = <var class="Arg">vec</var></code>. It returns <code class="keyw">fail</code> if no such vector exists.</p>

<p><a id="X7A7880D27CE7C1FE" name="X7A7880D27CE7C1FE"></a></p>

<h5>24.7-7 SolutionMatDestructive</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SolutionMatDestructive</code>( <var class="Arg">mat</var>, <var class="Arg">vec</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Does the same as <code class="code">SolutionMat( <var class="Arg">mat</var>, <var class="Arg">vec</var> )</code> except that it may destroy the matrix <var class="Arg">mat</var> and the vector <var class="Arg">vec</var>. The matrix <var class="Arg">mat</var> must be mutable.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat:=[[1,2,3],[4,5,6],[7,8,9]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SolutionMat(mat,[3,5,7]);</span>
[ 5/3, 1/3, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mm:= [[1,2,3],[4,5,6],[7,8,9]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v:= [3,5,7];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SolutionMatDestructive( mm, v );</span>
[ 5/3, 1/3, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mm;</span>
[ [ 1, 2, 3 ], [ 0, -3, -6 ], [ 0, 0, 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v;</span>
[ 0, 0, 0 ]
</pre></div>

<p><a id="X7AB5AC547809F999" name="X7AB5AC547809F999"></a></p>

<h5>24.7-8 BaseFixedSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BaseFixedSpace</code>( <var class="Arg">mats</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="func">BaseFixedSpace</code> returns a list of row vectors that form a base of the vector space <span class="SimpleMath">\(V\)</span> such that <span class="SimpleMath">\(v M = v\)</span> for all <span class="SimpleMath">\(v\)</span> in <span class="SimpleMath">\(V\)</span> and all matrices <span class="SimpleMath">\(M\)</span> in the list <var class="Arg">mats</var>. (This is the common eigenspace of all matrices in <var class="Arg">mats</var> for the eigenvalue 1.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BaseFixedSpace([[[1,2],[0,1]]]);</span>
[ [ 0, 1 ] ]
</pre></div>

<p><a id="X871FCAA97C60B2BA" name="X871FCAA97C60B2BA"></a></p>

<h4>24.8 <span class="Heading">Eigenvectors and eigenvalues</span></h4>

<p><a id="X7A2462CC7B0C9D66" name="X7A2462CC7B0C9D66"></a></p>

<h5>24.8-1 GeneralisedEigenvalues</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GeneralisedEigenvalues</code>( <var class="Arg">F</var>, <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GeneralizedEigenvalues</code>( <var class="Arg">F</var>, <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The generalised eigenvalues of the matrix <var class="Arg">A</var> over the field <var class="Arg">F</var>.</p>

<p><a id="X845CA0457D65876D" name="X845CA0457D65876D"></a></p>

<h5>24.8-2 GeneralisedEigenspaces</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GeneralisedEigenspaces</code>( <var class="Arg">F</var>, <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GeneralizedEigenspaces</code>( <var class="Arg">F</var>, <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The generalised eigenspaces of the matrix <var class="Arg">A</var> over the field <var class="Arg">F</var>.</p>

<p><a id="X8413C6FB7CEE9D59" name="X8413C6FB7CEE9D59"></a></p>

<h5>24.8-3 Eigenvalues</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Eigenvalues</code>( <var class="Arg">F</var>, <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The eigenvalues of the matrix <var class="Arg">A</var> over the field <var class="Arg">F</var>.</p>

<p><a id="X7A6B047281B52FD7" name="X7A6B047281B52FD7"></a></p>

<h5>24.8-4 Eigenspaces</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Eigenspaces</code>( <var class="Arg">F</var>, <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The eigenspaces of the matrix <var class="Arg">A</var> over the field <var class="Arg">F</var>.</p>

<p><a id="X8506584579D4EA18" name="X8506584579D4EA18"></a></p>

<h5>24.8-5 Eigenvectors</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Eigenvectors</code>( <var class="Arg">F</var>, <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The eigenvectors of the matrix <var class="Arg">A</var> over the field <var class="Arg">F</var>.</p>

<p><a id="X7E5405D085661B29" name="X7E5405D085661B29"></a></p>

<h4>24.9 <span class="Heading">Elementary Divisors</span></h4>

<p>See also chapter <a href="chap25_mj.html#X8414F20D8412DDA4"><span class="RefLink">25</span></a>.</p>

<p><a id="X7AC4D74F81908109" name="X7AC4D74F81908109"></a></p>

<h5>24.9-1 ElementaryDivisorsMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementaryDivisorsMat</code>( [<var class="Arg">ring</var>, ]<var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementaryDivisorsMatDestructive</code>( <var class="Arg">ring</var>, <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns a list of the elementary divisors, i.e., the unique <span class="SimpleMath">\(d\)</span> with <span class="SimpleMath">\(d[i]\)</span> divides <span class="SimpleMath">\(d[i+1]\)</span> and <var class="Arg">mat</var> is equivalent to a diagonal matrix with the elements <span class="SimpleMath">\(d[i]\)</span> on the diagonal. The operations are performed over the euclidean ring <var class="Arg">ring</var>, which must contain all matrix entries. For compatibility reasons it can be omitted and defaults to the <code class="func">DefaultRing</code> (<a href="chap56_mj.html#X83AFFCC77DE6ABDA"><span class="RefLink">56.1-3</span></a>) of the matrix entries.</p>

<p>The function <code class="func">ElementaryDivisorsMatDestructive</code> produces the same result but in the process may destroy the contents of <var class="Arg">mat</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat:=[[1,2,3],[4,5,6],[7,8,9]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ElementaryDivisorsMat(mat);</span>
[ 1, 3, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:=Indeterminate(Rationals,"x");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat:=mat*One(x)-x*mat^0;       </span>
[ [ -x+1, 2, 3 ], [ 4, -x+5, 6 ], [ 7, 8, -x+9 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ElementaryDivisorsMat(PolynomialRing(Rationals,1),mat);</span>
[ 1, 1, x^3-15*x^2-18*x ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat:=KroneckerProduct(CompanionMat((x-1)^2),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                         CompanionMat((x^3-1)*(x-1)));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat:=mat*One(x)-x*mat^0;</span>
[ [ -x, 0, 0, 0, 0, 0, 0, 1 ], [ 0, -x, 0, 0, -1, 0, 0, -1 ], 
  [ 0, 0, -x, 0, 0, -1, 0, 0 ], [ 0, 0, 0, -x, 0, 0, -1, -1 ], 
  [ 0, 0, 0, -1, -x, 0, 0, -2 ], [ 1, 0, 0, 1, 2, -x, 0, 2 ], 
  [ 0, 1, 0, 0, 0, 2, -x, 0 ], [ 0, 0, 1, 1, 0, 0, 2, -x+2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ElementaryDivisorsMat(PolynomialRing(Rationals,1),mat);</span>
[ 1, 1, 1, 1, 1, 1, x-1, x^7-x^6-2*x^4+2*x^3+x-1 ]
</pre></div>

<p><a id="X7AA1C9047B102204" name="X7AA1C9047B102204"></a></p>

<h5>24.9-2 ElementaryDivisorsTransformationsMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementaryDivisorsTransformationsMat</code>( [<var class="Arg">ring</var>, ]<var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementaryDivisorsTransformationsMatDestructive</code>( <var class="Arg">ring</var>, <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">ElementaryDivisorsTransformations</code>, in addition to the tasks done by <code class="code">ElementaryDivisorsMat</code>, also calculates transforming matrices. It returns a record with components <code class="code">normal</code> (a matrix <span class="SimpleMath">\(S\)</span>), <code class="code">rowtrans</code> (a matrix <span class="SimpleMath">\(P\)</span>), and <code class="code">coltrans</code> (a matrix <span class="SimpleMath">\(Q\)</span>) such that <span class="SimpleMath">\(P A Q = S\)</span>. The operations are performed over the euclidean ring <var class="Arg">ring</var>, which must contain all matrix entries. For compatibility reasons it can be omitted and defaults to the <code class="func">DefaultRing</code> (<a href="chap56_mj.html#X83AFFCC77DE6ABDA"><span class="RefLink">56.1-3</span></a>) of the matrix entries.</p>

<p>The function <code class="func">ElementaryDivisorsTransformationsMatDestructive</code> produces the same result but in the process destroys the contents of <var class="Arg">mat</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat:=KroneckerProduct(CompanionMat((x-1)^2),CompanionMat((x^3-1)*(x-1)));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat:=mat*One(x)-x*mat^0;</span>
[ [ -x, 0, 0, 0, 0, 0, 0, 1 ], [ 0, -x, 0, 0, -1, 0, 0, -1 ], 
  [ 0, 0, -x, 0, 0, -1, 0, 0 ], [ 0, 0, 0, -x, 0, 0, -1, -1 ], 
  [ 0, 0, 0, -1, -x, 0, 0, -2 ], [ 1, 0, 0, 1, 2, -x, 0, 2 ], 
  [ 0, 1, 0, 0, 0, 2, -x, 0 ], [ 0, 0, 1, 1, 0, 0, 2, -x+2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:=ElementaryDivisorsTransformationsMat(PolynomialRing(Rationals,1),mat);</span>
rec( coltrans := [ [ 0, 0, 0, 0, 0, 0, 1/6*x^2-7/9*x-1/18, -3*x^3-x^2-x-1 ], 
      [ 0, 0, 0, 0, 0, 0, -1/6*x^2+x-1, 3*x^3-3*x^2 ], 
      [ 0, 0, 0, 0, 0, 1, -1/18*x^4+1/3*x^3-1/3*x^2-1/9*x, x^5-x^4+2*x^2-2*x 
         ], [ 0, 0, 0, 0, -1, 0, -1/9*x^3+1/2*x^2+1/9*x, 2*x^4+x^3+x^2+2*x ],
      [ 0, -1, 0, 0, 0, 0, -2/9*x^2+19/18*x, 4*x^3+x^2+x ], 
      [ 0, 0, -1, 0, 0, -x, 1/18*x^5-1/3*x^4+1/3*x^3+1/9*x^2, 
          -x^6+x^5-2*x^3+2*x^2 ], 
      [ 0, 0, 0, -1, x, 0, 1/9*x^4-2/3*x^3+2/3*x^2+1/18*x, 
          -2*x^5+2*x^4-x^2+x ], 
      [ 1, 0, 0, 0, 0, 0, 1/6*x^3-7/9*x^2-1/18*x, -3*x^4-x^3-x^2-x ] ], 
  normal := [ [ 1, 0, 0, 0, 0, 0, 0, 0 ], [ 0, 1, 0, 0, 0, 0, 0, 0 ], 
      [ 0, 0, 1, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 1, 0, 0, 0, 0 ], 
      [ 0, 0, 0, 0, 1, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 1, 0, 0 ], 
      [ 0, 0, 0, 0, 0, 0, x-1, 0 ], 
      [ 0, 0, 0, 0, 0, 0, 0, x^7-x^6-2*x^4+2*x^3+x-1 ] ], 
  rowtrans := [ [ 1, 0, 0, 0, 0, 0, 0, 0 ], [ 1, 1, 0, 0, 0, 0, 0, 0 ], 
      [ 0, 0, 1, 0, 0, 0, 0, 0 ], [ 1, 0, 0, 1, 0, 0, 0, 0 ], 
      [ -x+2, -x, 0, 0, 1, 0, 0, 0 ], 
      [ 2*x^2-4*x+2, 2*x^2-x, 0, 2, -2*x+1, 0, 0, 1 ], 
      [ 3*x^3-6*x^2+3*x, 3*x^3-2*x^2, 2, 3*x, -3*x^2+2*x, 0, 1, 2*x ], 
      [ 1/6*x^8-7/6*x^7+2*x^6-4/3*x^5+7/3*x^4-4*x^3+13/6*x^2-7/6*x+2, 
          1/6*x^8-17/18*x^7+13/18*x^6-5/18*x^5+35/18*x^4-31/18*x^3+1/9*x^2-x+\
2, 1/9*x^5-5/9*x^4+1/9*x^3-1/9*x^2+14/9*x-1/9, 
          1/6*x^6-5/6*x^5+1/6*x^4-1/6*x^3+11/6*x^2-1/6*x, 
          -1/6*x^7+17/18*x^6-13/18*x^5+5/18*x^4-35/18*x^3+31/18*x^2-1/9*x+1, 
          1, 1/18*x^5-5/18*x^4+1/18*x^3-1/18*x^2+23/18*x-1/18, 
          1/9*x^6-5/9*x^5+1/9*x^4-1/9*x^3+14/9*x^2-1/9*x ] ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t.rowtrans*mat*t.coltrans;</span>
[ [ 1, 0, 0, 0, 0, 0, 0, 0 ], [ 0, 1, 0, 0, 0, 0, 0, 0 ], 
  [ 0, 0, 1, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 1, 0, 0, 0, 0 ], 
  [ 0, 0, 0, 0, 1, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 1, 0, 0 ], 
  [ 0, 0, 0, 0, 0, 0, x-1, 0 ], 
  [ 0, 0, 0, 0, 0, 0, 0, x^7-x^6-2*x^4+2*x^3+x-1 ] ]
</pre></div>

<p><a id="X85819D3F7A582180" name="X85819D3F7A582180"></a></p>

<h5>24.9-3 DiagonalizeMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DiagonalizeMat</code>( <var class="Arg">ring</var>, <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>brings the mutable matrix <var class="Arg">mat</var>, considered as a matrix over <var class="Arg">ring</var>, into diagonal form by elementary row and column operations.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m:=[[1,2],[2,1]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DiagonalizeMat(Integers,m);m;</span>
[ [ 1, 0 ], [ 0, 3 ] ]
</pre></div>

<p><a id="X7CA6B51D7AE3172B" name="X7CA6B51D7AE3172B"></a></p>

<h4>24.10 <span class="Heading">Echelonized Matrices</span></h4>

<p><a id="X7D5D6BD07B7E981B" name="X7D5D6BD07B7E981B"></a></p>

<h5>24.10-1 SemiEchelonMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SemiEchelonMat</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>A matrix over a field <span class="SimpleMath">\(F\)</span> is in semi-echelon form if the first nonzero element in each row is the identity of <span class="SimpleMath">\(F\)</span>, and all values exactly below these pivots are the zero of <span class="SimpleMath">\(F\)</span>.</p>

<p><code class="func">SemiEchelonMat</code> returns a record that contains information about a semi-echelonized form of the matrix <var class="Arg">mat</var>.</p>

<p>The components of this record are</p>


<dl>
<dt><strong class="Mark"><code class="code">vectors</code></strong></dt>
<dd><p>list of row vectors, each with pivot element the identity of <span class="SimpleMath">\(F\)</span>,</p>

</dd>
<dt><strong class="Mark"><code class="code">heads</code></strong></dt>
<dd><p>list that contains at position <var class="Arg">i</var>, if nonzero, the number of the row for that the pivot element is in column <var class="Arg">i</var>.</p>

</dd>
</dl>
<p><a id="X8251F6F57D346385" name="X8251F6F57D346385"></a></p>

<h5>24.10-2 SemiEchelonMatDestructive</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SemiEchelonMatDestructive</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>This does the same as <code class="code">SemiEchelonMat( <var class="Arg">mat</var> )</code>, except that it may (and probably will) destroy the matrix <var class="Arg">mat</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mm:=[[1,2,3],[4,5,6],[7,8,9]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SemiEchelonMatDestructive( mm );</span>
rec( heads := [ 1, 2, 0 ], vectors := [ [ 1, 2, 3 ], [ 0, 1, 2 ] ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mm;</span>
[ [ 1, 2, 3 ], [ 0, 1, 2 ], [ 0, 0, 0 ] ]
</pre></div>

<p><a id="X7EFD1DB5861A54F0" name="X7EFD1DB5861A54F0"></a></p>

<h5>24.10-3 SemiEchelonMatTransformation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SemiEchelonMatTransformation</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>does the same as <code class="func">SemiEchelonMat</code> (<a href="chap24_mj.html#X7D5D6BD07B7E981B"><span class="RefLink">24.10-1</span></a>) but additionally stores the linear transformation <span class="SimpleMath">\(T\)</span> performed on the matrix. The additional components of the result are</p>


<dl>
<dt><strong class="Mark"><code class="code">coeffs</code></strong></dt>
<dd><p>a list of coefficients vectors of the <code class="code">vectors</code> component, with respect to the rows of <var class="Arg">mat</var>, that is, <code class="code">coeffs * mat</code> is the <code class="code">vectors</code> component.</p>

</dd>
<dt><strong class="Mark"><code class="code">relations</code></strong></dt>
<dd><p>a list of basis vectors for the (left) null space of <var class="Arg">mat</var>.</p>

</dd>
</dl>

<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SemiEchelonMatTransformation([[1,2,3],[0,0,1]]);</span>
rec( coeffs := [ [ 1, 0 ], [ 0, 1 ] ], heads := [ 1, 0, 2 ], 
  relations := [  ], vectors := [ [ 1, 2, 3 ], [ 0, 0, 1 ] ] )
</pre></div>

<p><a id="X827D7971800DB661" name="X827D7971800DB661"></a></p>

<h5>24.10-4 SemiEchelonMats</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SemiEchelonMats</code>( <var class="Arg">mats</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>A list of matrices over a field <span class="SimpleMath">\(F\)</span> is in semi-echelon form if the list of row vectors obtained on concatenating the rows of each matrix is a semi-echelonized matrix (see <code class="func">SemiEchelonMat</code> (<a href="chap24_mj.html#X7D5D6BD07B7E981B"><span class="RefLink">24.10-1</span></a>)).</p>

<p><code class="func">SemiEchelonMats</code> returns a record that contains information about a semi-echelonized form of the list <var class="Arg">mats</var> of matrices.</p>

<p>The components of this record are</p>


<dl>
<dt><strong class="Mark"><code class="code">vectors</code></strong></dt>
<dd><p>list of matrices, each with pivot element the identity of <span class="SimpleMath">\(F\)</span>,</p>

</dd>
<dt><strong class="Mark"><code class="code">heads</code></strong></dt>
<dd><p>matrix that contains at position [<var class="Arg">i</var>,<var class="Arg">j</var>], if nonzero, the number of the matrix that has the pivot element in this position</p>

</dd>
</dl>
<p><a id="X808F493B839BC7A6" name="X808F493B839BC7A6"></a></p>

<h5>24.10-5 SemiEchelonMatsDestructive</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SemiEchelonMatsDestructive</code>( <var class="Arg">mats</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Does the same as <code class="code">SemiEchelonmats</code>, except that it may destroy its argument. Therefore the argument must be a list of matrices that re mutable.</p>

<p><a id="X86B0D4A886BC0C6E" name="X86B0D4A886BC0C6E"></a></p>

<h4>24.11 <span class="Heading">Matrices as Basis of a Row Space</span></h4>

<p>See also chapter <a href="chap25_mj.html#X8414F20D8412DDA4"><span class="RefLink">25</span></a></p>

<p><a id="X7AD6B5F5794D9E46" name="X7AD6B5F5794D9E46"></a></p>

<h5>24.11-1 BaseMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BaseMat</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns a basis for the row space generated by the rows of <var class="Arg">mat</var> in the form of an immutable matrix.</p>

<p><a id="X78B094597E382A5F" name="X78B094597E382A5F"></a></p>

<h5>24.11-2 BaseMatDestructive</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BaseMatDestructive</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Does the same as <code class="func">BaseMat</code> (<a href="chap24_mj.html#X7AD6B5F5794D9E46"><span class="RefLink">24.11-1</span></a>), with the difference that it may destroy the matrix <var class="Arg">mat</var>. The matrix <var class="Arg">mat</var> must be mutable.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat:=[[1,2,3],[4,5,6],[7,8,9]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BaseMat(mat);</span>
[ [ 1, 2, 3 ], [ 0, 1, 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mm:= [[1,2,3],[4,5,6],[5,7,9]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BaseMatDestructive( mm );</span>
[ [ 1, 2, 3 ], [ 0, 1, 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mm;</span>
[ [ 1, 2, 3 ], [ 0, 1, 2 ], [ 0, 0, 0 ] ]
</pre></div>

<p><a id="X78B94EFF87A455BE" name="X78B94EFF87A455BE"></a></p>

<h5>24.11-3 BaseOrthogonalSpaceMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BaseOrthogonalSpaceMat</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Let <span class="SimpleMath">\(V\)</span> be the row space generated by the rows of <var class="Arg">mat</var> (over any field that contains all entries of <var class="Arg">mat</var>). <code class="code">BaseOrthogonalSpaceMat( <var class="Arg">mat</var> )</code> computes a base of the orthogonal space of <span class="SimpleMath">\(V\)</span>.</p>

<p>The rows of <var class="Arg">mat</var> need not be linearly independent.</p>

<p><a id="X7AFF8BCF80C88B45" name="X7AFF8BCF80C88B45"></a></p>

<h5>24.11-4 SumIntersectionMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SumIntersectionMat</code>( <var class="Arg">M1</var>, <var class="Arg">M2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>performs Zassenhaus' algorithm to compute bases for the sum and the intersection of spaces generated by the rows of the matrices <var class="Arg">M1</var>, <var class="Arg">M2</var>.</p>

<p>returns a list of length 2, at first position a base of the sum, at second position a base of the intersection. Both bases are in semi-echelon form (see <a href="chap24_mj.html#X7CA6B51D7AE3172B"><span class="RefLink">24.10</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SumIntersectionMat(mat,[[2,7,6],[5,9,4]]);</span>
[ [ [ 1, 2, 3 ], [ 0, 1, 2 ], [ 0, 0, 1 ] ], [ [ 1, -3/4, -5/2 ] ] ]
</pre></div>

<p><a id="X8245D54F7AC532EB" name="X8245D54F7AC532EB"></a></p>

<h5>24.11-5 BaseSteinitzVectors</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BaseSteinitzVectors</code>( <var class="Arg">bas</var>, <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>find vectors extending mat to a basis spanning the span of <var class="Arg">bas</var>. Both <var class="Arg">bas</var> and <var class="Arg">mat</var> must be matrices of full (row) rank. It returns a record with the following components:</p>


<dl>
<dt><strong class="Mark"><code class="code">subspace</code></strong></dt>
<dd><p>s a basis of the space spanned by <var class="Arg">mat</var> in upper triangular form with leading ones at all echelon steps and zeroes above these ones.</p>

</dd>
<dt><strong class="Mark"><code class="code">factorspace</code></strong></dt>
<dd><p>is a list of extending vectors in upper triangular form.</p>

</dd>
<dt><strong class="Mark"><code class="code">factorzero</code></strong></dt>
<dd><p>is a zero vector.</p>

</dd>
<dt><strong class="Mark"><code class="code">heads</code></strong></dt>
<dd><p>is a list of integers which can be used to decompose vectors in the basis vectors. The <var class="Arg">i</var>th entry indicating the vector that gives an echelon step at position <var class="Arg">i</var>. A negative number indicates an echelon step in the subspace, a positive number an echelon step in the complement, the absolute value gives the position of the vector in the lists <code class="code">subspace</code> and <code class="code">factorspace</code>.</p>

</dd>
</dl>

<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BaseSteinitzVectors(IdentityMat(3,1),[[11,13,15]]);</span>
rec( factorspace := [ [ 0, 1, 15/13 ], [ 0, 0, 1 ] ], 
  factorzero := [ 0, 0, 0 ], heads := [ -1, 1, 2 ], 
  subspace := [ [ 1, 13/11, 15/11 ] ] )
</pre></div>

<p><a id="X79D5E53685F0FBEE" name="X79D5E53685F0FBEE"></a></p>

<h4>24.12 <span class="Heading">Triangular Matrices</span></h4>

<p><a id="X7A9139D686ACB7D8" name="X7A9139D686ACB7D8"></a></p>

<h5>24.12-1 DiagonalOfMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DiagonalOfMatrix</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DiagonalOfMat</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>return the diagonal of the matrix <var class="Arg">mat</var>. If <var class="Arg">mat</var> is not a square matrix, then the result has the same length as the rows of <var class="Arg">mat</var>, and is padded with zeros if <var class="Arg">mat</var> has fewer rows than columns.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DiagonalOfMatrix( [ [ 1, 2, 3 ], [ 4, 5, 6 ] ] );</span>
[ 1, 5, 0 ]
</pre></div>

<p><a id="X84A78C057F9DAE5E" name="X84A78C057F9DAE5E"></a></p>

<h5>24.12-2 UpperSubdiagonal</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UpperSubdiagonal</code>( <var class="Arg">mat</var>, <var class="Arg">pos</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns a mutable list containing the entries of the <var class="Arg">pos</var>th upper subdiagonal of the matrix <var class="Arg">mat</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UpperSubdiagonal( [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ], 1 );</span>
[ 2, 6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UpperSubdiagonal( [ [ 1, 2 ], [ 3, 4 ], [ 5, 6 ] ], 1 );</span>
[ 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UpperSubdiagonal( [ [ 1, 2, 3, 4 ], [ 5, 6, 7, 8 ] ], 1 );</span>
[ 2, 7 ]
</pre></div>

<p><a id="X84D74DEA798A9094" name="X84D74DEA798A9094"></a></p>

<h5>24.12-3 DepthOfUpperTriangularMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DepthOfUpperTriangularMatrix</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>If <var class="Arg">mat</var> is an upper triangular matrix this attribute returns the index of the first nonzero diagonal.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DepthOfUpperTriangularMatrix([[0,1,2],[0,0,1],[0,0,0]]);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DepthOfUpperTriangularMatrix([[0,0,2],[0,0,0],[0,0,0]]);</span>
2
</pre></div>

<p><a id="X85B403857F2855F7" name="X85B403857F2855F7"></a></p>

<h4>24.13 <span class="Heading">Matrices as Linear Mappings</span></h4>

<p><a id="X87FA0A727CDB060B" name="X87FA0A727CDB060B"></a></p>

<h5>24.13-1 CharacteristicPolynomial</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CharacteristicPolynomial</code>( [<var class="Arg">F</var>, <var class="Arg">E</var>, ]<var class="Arg">mat</var>[, <var class="Arg">ind</var>] )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For a square matrix <var class="Arg">mat</var>, <code class="func">CharacteristicPolynomial</code> returns the <em>characteristic polynomial</em> of <var class="Arg">mat</var>, that is, the <code class="func">StandardAssociate</code> (<a href="chap56_mj.html#X7B1A9A4C7C59FB36"><span class="RefLink">56.5-5</span></a>) of the determinant of the matrix <span class="SimpleMath">\(\textit{mat} - X \cdot I\)</span>, where <span class="SimpleMath">\(X\)</span> is an indeterminate and <span class="SimpleMath">\(I\)</span> is the appropriate identity matrix.</p>

<p>If fields <var class="Arg">F</var> and <var class="Arg">E</var> are given, then <var class="Arg">F</var> must be a subfield of <var class="Arg">E</var>, and <var class="Arg">mat</var> must have entries in <var class="Arg">E</var>. Then <code class="func">CharacteristicPolynomial</code> returns the characteristic polynomial of the <var class="Arg">F</var>-linear mapping induced by <var class="Arg">mat</var> on the underlying <var class="Arg">E</var>-vector space of <var class="Arg">mat</var>. In this case, the characteristic polynomial is computed using <code class="func">BlownUpMat</code> (<a href="chap24_mj.html#X85923C107A4569D0"><span class="RefLink">24.13-4</span></a>) for the field extension of <span class="SimpleMath">\(E/F\)</span> generated by the default field. Thus, if <span class="SimpleMath">\(F = E\)</span>, the result is the same as for the one argument version.</p>

<p>The returned polynomials are expressed in the indeterminate number <var class="Arg">ind</var>. If <var class="Arg">ind</var> is not given, it defaults to <span class="SimpleMath">\(1\)</span>.</p>

<p><code class="code">CharacteristicPolynomial(<var class="Arg">F</var>, <var class="Arg">E</var>, <var class="Arg">mat</var>)</code> is a multiple of the minimal polynomial <code class="code">MinimalPolynomial(<var class="Arg">F</var>, <var class="Arg">mat</var>)</code> (see <code class="func">MinimalPolynomial</code> (<a href="chap66_mj.html#X8643915A8424DAF8"><span class="RefLink">66.8-1</span></a>)).</p>

<p>Note that, up to <strong class="pkg">GAP</strong> version 4.4.6, <code class="func">CharacteristicPolynomial</code> only allowed to specify one field (corresponding to <var class="Arg">F</var>) as an argument. That usage has been disabled because its definition turned out to be ambiguous and may have lead to unexpected results. (To ensure backward compatibility, it is still possible to use the old form if <var class="Arg">F</var> contains the default field of the matrix, see <code class="func">DefaultFieldOfMatrix</code> (<a href="chap24_mj.html#X80AE547B8095A5CB"><span class="RefLink">24.4-2</span></a>), but this feature will disappear in future versions of <strong class="pkg">GAP</strong>.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacteristicPolynomial( [ [ 1, 1 ], [ 0, 1 ] ] );</span>
x^2-2*x+1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0,1],[E(4)-1,E(4)]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacteristicPolynomial( mat );</span>
x^2+(-E(4))*x+(1-E(4))
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacteristicPolynomial( Rationals, CF(4), mat );</span>
x^4+3*x^2+2*x+2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat:= [ [ E(4), 1 ], [ 0, -E(4) ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacteristicPolynomial( mat );</span>
x^2+1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacteristicPolynomial( Rationals, CF(4), mat );</span>
x^4+2*x^2+1
</pre></div>

<p><a id="X7B52560C792C1A0F" name="X7B52560C792C1A0F"></a></p>

<h5>24.13-2 RationalCanonicalFormTransform</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RationalCanonicalFormTransform</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>For a matrix <code class="code">A</code>, return a matrix <code class="code">P</code> such that <span class="SimpleMath">\(A^{P}\)</span> is in rational canonical form (also called Frobenius normal form). The algorithm used is the basic textbook version and thus not of optimal complexity.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">aa:=[[0,-8,12,40,-36,4,0,59,15,-9],[-2,-2,-2,6,-11,1,-1,10,1,0],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1,5,0,-6,12,-2,0,-12,-4,2],[0,0,0,2,0,0,0,7,0,0],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[0,2,-3,-7,8,-1,0,-7,-3,2],[-5,-4,-6,18,-30,2,-2,35,5,-1],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[-1,-6,6,20,-28,3,0,24,10,-6],[0,0,0,-1,0,0,0,-3,0,0],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[0,0,-1,-2,-2,0,-1,-7,0,0],[0,-8,9,21,-36,4,-2,12,12,-8]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:=RationalCanonicalFormTransform(aa);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">aa^t;</span>
[ [ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 ], [ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
  [ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 ], [ 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 ],
  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 ], [ 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ],
  [ 0, 0, 0, 0, 0, 1, 0, 0, 0, 1 ], [ 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 ],
  [ 0, 0, 0, 0, 0, 0, 0, 1, 0, -1 ], [ 0, 0, 0, 0, 0, 0, 0, 0, 1, -1 ] ]
</pre></div>

<p><a id="X83F55D4E79BA5D1B" name="X83F55D4E79BA5D1B"></a></p>

<h5>24.13-3 JordanDecomposition</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; JordanDecomposition</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><code class="code">JordanDecomposition( <var class="Arg">mat </var> )</code> returns a list <code class="code">[S,N]</code> such that <code class="code">S</code> is a semisimple matrix and <code class="code">N</code> is nilpotent. Furthermore, <code class="code">S</code> and <code class="code">N</code> commute and <code class="code"><var class="Arg">mat</var>=S+N</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat:=[[1,2,3],[4,5,6],[7,8,9]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">JordanDecomposition(mat);</span>
[ [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ], 
  [ [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ] ] ]
</pre></div>

<p><a id="X85923C107A4569D0" name="X85923C107A4569D0"></a></p>

<h5>24.13-4 BlownUpMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BlownUpMat</code>( <var class="Arg">B</var>, <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">B</var> be a basis of a field extension <span class="SimpleMath">\(F / K\)</span>, and <var class="Arg">mat</var> a matrix whose entries are all in <span class="SimpleMath">\(F\)</span>. (This is not checked.) <code class="func">BlownUpMat</code> returns a matrix over <span class="SimpleMath">\(K\)</span> that is obtained by replacing each entry of <var class="Arg">mat</var> by its regular representation w.r.t. <var class="Arg">B</var>.</p>

<p>More precisely, regard <var class="Arg">mat</var> as the matrix of a linear transformation on the row space <span class="SimpleMath">\(F^n\)</span> w.r.t. the <span class="SimpleMath">\(F\)</span>-basis with vectors <span class="SimpleMath">\((v_1, ldots, v_n)\)</span>, say, and suppose that the basis <var class="Arg">B</var> consists of the vectors <span class="SimpleMath">\((b_1, \ldots, b_m)\)</span>; then the returned matrix is the matrix of the linear transformation on the row space <span class="SimpleMath">\(K^{mn}\)</span> w.r.t. the <span class="SimpleMath">\(K\)</span>-basis whose vectors are <span class="SimpleMath">\((b_1 v_1, \ldots b_m v_1, \ldots, b_m v_n)\)</span>.</p>

<p>Note that the linear transformations act on <em>row</em> vectors, i.e., each row of the matrix is a concatenation of vectors of <var class="Arg">B</var>-coefficients.</p>

<p><a id="X82AC277D84EC5749" name="X82AC277D84EC5749"></a></p>

<h5>24.13-5 BlownUpVector</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BlownUpVector</code>( <var class="Arg">B</var>, <var class="Arg">vector</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">B</var> be a basis of a field extension <span class="SimpleMath">\(F / K\)</span>, and <var class="Arg">vector</var> a row vector whose entries are all in <span class="SimpleMath">\(F\)</span>. <code class="func">BlownUpVector</code> returns a row vector over <span class="SimpleMath">\(K\)</span> that is obtained by replacing each entry of <var class="Arg">vector</var> by its coefficients w.r.t. <var class="Arg">B</var>.</p>

<p>So <code class="func">BlownUpVector</code> and <code class="func">BlownUpMat</code> (<a href="chap24_mj.html#X85923C107A4569D0"><span class="RefLink">24.13-4</span></a>) are compatible in the sense that for a matrix <var class="Arg">mat</var> over <span class="SimpleMath">\(F\)</span>, <code class="code">BlownUpVector( <var class="Arg">B</var>, <var class="Arg">mat</var> * <var class="Arg">vector</var> )</code> is equal to <code class="code">BlownUpMat( <var class="Arg">B</var>, <var class="Arg">mat</var> ) * BlownUpVector( <var class="Arg">B</var>, <var class="Arg">vector</var> )</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B:= Basis( CF(4), [ 1, E(4) ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat:= [ [ 1, E(4) ], [ 0, 1 ] ];;  vec:= [ 1, E(4) ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bmat:= BlownUpMat( B, mat );;  bvec:= BlownUpVector( B, vec );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( bmat );  bvec;</span>
[ [   1,   0,   0,   1 ],
  [   0,   1,  -1,   0 ],
  [   0,   0,   1,   0 ],
  [   0,   0,   0,   1 ] ]
[ 1, 0, 0, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bvec * bmat = BlownUpVector( B, vec * mat );</span>
true
</pre></div>

<p><a id="X85A1026D7CB6ABAC" name="X85A1026D7CB6ABAC"></a></p>

<h5>24.13-6 CompanionMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CompanionMat</code>( <var class="Arg">poly</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>computes a companion matrix of the polynomial <var class="Arg">poly</var>. This matrix has <var class="Arg">poly</var> as its minimal polynomial.</p>

<p><a id="X873822B6830CE367" name="X873822B6830CE367"></a></p>

<h4>24.14 <span class="Heading">Matrices over Finite Fields</span></h4>

<p>Just as for row vectors, (see section <a href="chap23_mj.html#X8679F7DD7DFCBD9C"><span class="RefLink">23.3</span></a>), <strong class="pkg">GAP</strong> has a special representation for matrices over small finite fields.</p>

<p>To be eligible to be represented in this way, each row of a matrix must be able to be represented as a compact row vector of the same length over <em>the same</em> finite field.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v := Z(2)*[1,0,0,1,1];</span>
[ Z(2)^0, 0*Z(2), 0*Z(2), Z(2)^0, Z(2)^0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConvertToVectorRep(v,2);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v;</span>
&lt;a GF2 vector of length 5&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := [v];; ConvertToMatrixRep(m,GF(2));; m;</span>
&lt;a 1x5 matrix over GF2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := [v,v];; ConvertToMatrixRep(m,GF(2));; m;</span>
&lt;a 2x5 matrix over GF2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := [v,v,v];; ConvertToMatrixRep(m,GF(2));; m;</span>
&lt;a 3x5 matrix over GF2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v := Z(3)*[1..8];</span>
[ Z(3), Z(3)^0, 0*Z(3), Z(3), Z(3)^0, 0*Z(3), Z(3), Z(3)^0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConvertToVectorRep(v);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := [v];; ConvertToMatrixRep(m,GF(3));; m;</span>
[ [ Z(3), Z(3)^0, 0*Z(3), Z(3), Z(3)^0, 0*Z(3), Z(3), Z(3)^0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RepresentationsOfObject(m);</span>
[ "IsPositionalObjectRep", "Is8BitMatrixRep" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := [v,v,v,v];; ConvertToMatrixRep(m,GF(3));; m;</span>
&lt; mutable compressed matrix 4x8 over GF(3) &gt;
</pre></div>

<p>All compressed matrices over GF(2) are viewed as <code class="code">&lt;a <var class="Arg">n</var>x<var class="Arg">m</var> matrix over GF2&gt;</code>, while over fields GF(q) for q between 3 and 256, matrices with 25 or more entries are viewed in this way, and smaller ones as lists of lists.</p>

<p>Matrices can be converted to this special representation via the following functions.</p>

<p>Note that the main advantage of this special representation of matrices is in low dimensions, where various overheads can be reduced. In higher dimensions, a list of compressed vectors will be almost as fast. Note also that list access and assignment will be somewhat slower for compressed matrices than for plain lists.</p>

<p>In order to form a row of a compressed matrix a vector must accept certain restrictions. Specifically, it cannot change its length or change the field over which it is compressed. The main consequences of this are: that only elements of the appropriate field can be assigned to entries of the vector, and only to positions between 1 and the original length; that the vector cannot be shared between two matrices compressed over different fields.</p>

<p>This is enforced by the filter <code class="code">IsLockedRepresentationVector</code>. When a vector becomes part of a compressed matrix, this filter is set for it. Assignment, <code class="func">Unbind</code> (<a href="chap21_mj.html#X78B72FDF7BD63C0B"><span class="RefLink">21.5-3</span></a>), <code class="func">ConvertToVectorRep</code> (<a href="chap23_mj.html#X810E46927F9E8F75"><span class="RefLink">23.3-1</span></a>) and <code class="func">ConvertToMatrixRep</code> (<a href="chap24_mj.html#X8587A62F818AA0D6"><span class="RefLink">24.14-2</span></a>) are all prevented from altering a vector with this filter.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v := [Z(2),Z(2)];; ConvertToVectorRep(v,GF(2));; v;</span>
&lt;a GF2 vector of length 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := [v,v]; </span>
[ &lt;a GF2 vector of length 2&gt;, &lt;a GF2 vector of length 2&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConvertToMatrixRep(m,GF(2)); </span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m2 := [m[1], [Z(4),Z(4)]]; # now try and mix in some GF(4)</span>
[ &lt;a GF2 vector of length 2&gt;, [ Z(2^2), Z(2^2) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConvertToMatrixRep(m2); # but m2[1] is locked</span>
#I  ConvertToVectorRep: locked vector not converted to different field
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m2 := [ShallowCopy(m[1]), [Z(4),Z(4)]]; # a fresh copy of row 1</span>
[ &lt;a GF2 vector of length 2&gt;, [ Z(2^2), Z(2^2) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConvertToMatrixRep(m2); # now it works</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m2;</span>
[ [ Z(2)^0, Z(2)^0 ], [ Z(2^2), Z(2^2) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RepresentationsOfObject(m2);</span>
[ "IsPositionalObjectRep", "Is8BitMatrixRep" ]
</pre></div>

<p>Arithmetic operations (see <a href="chap21_mj.html#X845EEAF083D43CCE"><span class="RefLink">21.11</span></a> and the following sections) preserve the compression status of matrices in the sense that if all arguments are compressed matrices written over the same field and the result is a matrix then also the result is a compressed matrix written over this field.</p>

<p>There are also two operations that are only available for matrices written over finite fields.</p>

<p><a id="X7DED2522828B6C30" name="X7DED2522828B6C30"></a></p>

<h5>24.14-1 ImmutableMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ImmutableMatrix</code>( <var class="Arg">field</var>, <var class="Arg">matrix</var>[, <var class="Arg">change</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns an immutable matrix equal to <var class="Arg">matrix</var> which is in the optimal (concerning space and runtime) representation for matrices defined over <var class="Arg">field</var>. This means that matrices obtained by several calls of <code class="func">ImmutableMatrix</code> for the same <var class="Arg">field</var> are compatible for fast arithmetic without need for field conversion.</p>

<p>The input matrix <var class="Arg">matrix</var> or its rows might change their representation as a side effect of this function, however the result of <code class="func">ImmutableMatrix</code> is not necessarily <em>identical</em> to <var class="Arg">matrix</var> if a conversion is not possible.</p>

<p>If <var class="Arg">change</var> is <code class="keyw">true</code>, the rows of <var class="Arg">matrix</var> (or <var class="Arg">matrix</var> itself) may be changed to become immutable; otherwise they are copied first.</p>

<p><a id="X8587A62F818AA0D6" name="X8587A62F818AA0D6"></a></p>

<h5>24.14-2 ConvertToMatrixRep</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConvertToMatrixRep</code>( <var class="Arg">list</var>[, <var class="Arg">field</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConvertToMatrixRep</code>( <var class="Arg">list</var>[, <var class="Arg">fieldsize</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConvertToMatrixRepNC</code>( <var class="Arg">list</var>[, <var class="Arg">field</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConvertToMatrixRepNC</code>( <var class="Arg">list</var>[, <var class="Arg">fieldsize</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function is more technical version of <code class="func">ImmutableMatrix</code> (<a href="chap24_mj.html#X7DED2522828B6C30"><span class="RefLink">24.14-1</span></a>), which will never copy a matrix (or any rows of it) but may fail if it encounters rows locked in the wrong representation, or various other more technical problems. Most users should use <code class="func">ImmutableMatrix</code> (<a href="chap24_mj.html#X7DED2522828B6C30"><span class="RefLink">24.14-1</span></a>) instead. The NC versions of the function do less checking of the argument and may cause unpredictable results or crashes if given unsuitable arguments. Called with one argument <var class="Arg">list</var>, <code class="func">ConvertToMatrixRep</code> converts <var class="Arg">list</var> to an internal matrix representation if possible.</p>

<p>Called with a list <var class="Arg">list</var> and a finite field <var class="Arg">field</var>, <code class="func">ConvertToMatrixRep</code> converts <var class="Arg">list</var> to an internal matrix representation appropriate for a matrix over <var class="Arg">field</var>.</p>

<p>Instead of a <var class="Arg">field</var> also its size <var class="Arg">fieldsize</var> may be given.</p>

<p>It is forbidden to call this function unless all elements of <var class="Arg">list</var> are row vectors with entries in the field <var class="Arg">field</var>. Violation of this condition can lead to unpredictable behaviour or a system crash. (Setting the assertion level to at least 2 might catch some violations before a crash, see <code class="func">SetAssertionLevel</code> (<a href="chap7_mj.html#X7C7596418423660B"><span class="RefLink">7.5-1</span></a>).)</p>

<p><var class="Arg">list</var> may already be a compressed matrix. In this case, if no <var class="Arg">field</var> or <var class="Arg">fieldsize</var> is given, then nothing happens.</p>

<p>The return value is the size of the field over which the matrix ends up written, if it is written in a compressed representation.</p>

<p><a id="X84A76F7A7B4166BC" name="X84A76F7A7B4166BC"></a></p>

<h5>24.14-3 ProjectiveOrder</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ProjectiveOrder</code>( <var class="Arg">mat</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns an integer n and a finite field element e such that <var class="Arg">A</var>^n = eI. <var class="Arg">mat</var> must be a matrix defined over a finite field.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProjectiveOrder([[1,4],[5,2]]*Z(11)^0);</span>
[ 5, Z(11)^5 ]
</pre></div>

<p><a id="X847ADC6779E33A1C" name="X847ADC6779E33A1C"></a></p>

<h5>24.14-4 SimultaneousEigenvalues</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimultaneousEigenvalues</code>( <var class="Arg">matlist</var>, <var class="Arg">expo</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>The matrices in <var class="Arg">matlist</var> must be matrices over GF(<var class="Arg">q</var>) for some prime <var class="Arg">q</var>. Together, they must generate an abelian p-group of exponent <var class="Arg">expo</var>. Then the eigenvalues of <var class="Arg">mat</var> in the splitting field <code class="code">GF(<var class="Arg">q</var>^<var class="Arg">r</var>)</code> for some <var class="Arg">r</var> are powers of an element <span class="SimpleMath">\(\xi\)</span> in the splitting field, which is of order <var class="Arg">expo</var>. <code class="func">SimultaneousEigenvalues</code> returns a matrix of integers mod <var class="Arg">expo</var>, say <span class="SimpleMath">\((a_{{i,j}})\)</span>, such that the power <span class="SimpleMath">\(\xi^{{a_{{i,j}}}}\)</span> is an eigenvalue of the <var class="Arg">i</var>-th matrix in <var class="Arg">matlist</var> and the eigenspaces of the different matrices to the eigenvalues <span class="SimpleMath">\(\xi^{{a_{{i,j}}}}\)</span> for fixed <var class="Arg">j</var> are equal.</p>

<p><a id="X8593A5337D3B2C70" name="X8593A5337D3B2C70"></a></p>

<h4>24.15 <span class="Heading">Inverse and Nullspace of an Integer Matrix Modulo an Ideal</span></h4>

<p>The following operations deal with matrices over a ring, but only care about the residues of their entries modulo some ring element. In the case of the integers and a prime number <span class="SimpleMath">\(p\)</span>, say, this is effectively computation in a matrix over the prime field in characteristic <span class="SimpleMath">\(p\)</span>.</p>

<p><a id="X7D8D1E0E83C7F872" name="X7D8D1E0E83C7F872"></a></p>

<h5>24.15-1 InverseMatMod</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InverseMatMod</code>( <var class="Arg">mat</var>, <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>For a square matrix <var class="Arg">mat</var>, <code class="func">InverseMatMod</code> returns a matrix <var class="Arg">inv</var> such that <code class="code"><var class="Arg">inv</var> * <var class="Arg">mat</var></code> is congruent to the identity matrix modulo <var class="Arg">obj</var>, if such a matrix exists, and <code class="keyw">fail</code> otherwise.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat:= [ [ 1, 2 ], [ 3, 4 ] ];;  inv:= InverseMatMod( mat, 5 );</span>
[ [ 3, 1 ], [ 4, 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat * inv;</span>
[ [ 11, 5 ], [ 25, 11 ] ]
</pre></div>

<p><a id="X7D7DF873826A7C20" name="X7D7DF873826A7C20"></a></p>

<h5>24.15-2 BasisNullspaceModN</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BasisNullspaceModN</code>( <var class="Arg">M</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><var class="Arg">M</var> must be a matrix of integers and <var class="Arg">n</var> a positive integer. Then <code class="func">BasisNullspaceModN</code> returns a set <var class="Arg">B</var> of vectors such that every vector <var class="Arg">v</var> of integer modulo <var class="Arg">n</var> satisfying <var class="Arg">v</var> <var class="Arg">M</var> = 0 modulo <var class="Arg">n</var> can be expressed by a Z-linear combination of elements of <var class="Arg">B</var>.</p>

<p><a id="X86AE919983B242E2" name="X86AE919983B242E2"></a></p>

<h5>24.15-3 NullspaceModQ</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NullspaceModQ</code>( <var class="Arg">M</var>, <var class="Arg">q</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NullspaceModN</code>( <var class="Arg">M</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><var class="Arg">M</var> must be a matrix of integers and <var class="Arg">n</var> a positive integer. Then <code class="func">NullspaceModN</code> returns the set of all vectors of integers modulo <var class="Arg">n</var>, which solve the homogeneous equation system <var class="Arg">v</var> <var class="Arg">M</var> = 0 modulo <var class="Arg">n</var>.</p>

<p><code class="func">NullspaceModQ</code> is a synonym for <code class="func">NullspaceModN</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NullspaceModN( [ [ 2 ] ], 8 );</span>
[ [ 0 ], [ 4 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NullspaceModN( [ [ 2, 1 ], [ 0, 2 ] ], 6 );</span>
[ [ 0, 0 ], [ 0, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat:= [ [ 1, 3 ], [ 1, 2 ], [ 1, 1 ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NullspaceModN( mat, 5 );</span>
[ [ 0, 0, 0 ], [ 1, 3, 1 ], [ 2, 1, 2 ], [ 3, 4, 3 ], [ 4, 2, 4 ] ]
</pre></div>

<p><a id="X787DF5F07DC7D86E" name="X787DF5F07DC7D86E"></a></p>

<h4>24.16 <span class="Heading">Special Multiplication Algorithms for Matrices over GF(2)</span></h4>

<p>When multiplying two compressed matrices <span class="SimpleMath">\(M\)</span> and <span class="SimpleMath">\(N\)</span> over GF(2) of dimensions <span class="SimpleMath">\(a \times b\)</span> and <span class="SimpleMath">\(b \times c\)</span>, say, where <span class="SimpleMath">\(a\)</span>, <span class="SimpleMath">\(b\)</span> and <span class="SimpleMath">\(c\)</span> are all greater than or equal to 128, <strong class="pkg">GAP</strong> by default uses a more sophisticated matrix multiplication algorithm, in which linear combinations of groups of 8 rows of <span class="SimpleMath">\(M\)</span> are remembered and re-used in constructing various rows of the product. This is called level 8 grease. To optimise memory access patterns, these combinations are stored for <span class="SimpleMath">\((b+255)/256\)</span> sets of 8 rows at once. This number is called the blocking level.</p>

<p>These levels of grease and blocking are found experimentally to give good performance across a range of processors and matrix sizes, but other levels may do even better in some cases. You can control the levels exactly using the functions below.</p>

<p>We plan to include greased blocked matrix multiplication for other finite fields, and greased blocked algorithms for inversion and other matrix operations in a future release.</p>

<p><a id="X7C0C26027FAE0C83" name="X7C0C26027FAE0C83"></a></p>

<h5>24.16-1 PROD_GF2MAT_GF2MAT_SIMPLE</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PROD_GF2MAT_GF2MAT_SIMPLE</code>( <var class="Arg">m1</var>, <var class="Arg">m2</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function performs the standard unblocked and ungreased matrix multiplication for matrices of any size.</p>

<p><a id="X81965B7D7F45E088" name="X81965B7D7F45E088"></a></p>

<h5>24.16-2 PROD_GF2MAT_GF2MAT_ADVANCED</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PROD_GF2MAT_GF2MAT_ADVANCED</code>( <var class="Arg">m1</var>, <var class="Arg">m2</var>, <var class="Arg">g</var>, <var class="Arg">b</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function computes the product of <var class="Arg">m1</var> and <var class="Arg">m2</var>, which must be compressed matrices over GF(2) of compatible dimensions, using level <var class="Arg">g</var> grease and level <var class="Arg">b</var> blocking.</p>

<p><a id="X7F8A71F38201A250" name="X7F8A71F38201A250"></a></p>

<h4>24.17 <span class="Heading">Block Matrices</span></h4>

<p>Block matrices are a special representation of matrices which can save a lot of memory if large matrices have a block structure with lots of zero blocks. <strong class="pkg">GAP</strong> uses the representation <code class="code">IsBlockMatrixRep</code> to store block matrices.</p>

<p><a id="X7D675B3C79CF8871" name="X7D675B3C79CF8871"></a></p>

<h5>24.17-1 AsBlockMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsBlockMatrix</code>( <var class="Arg">m</var>, <var class="Arg">nrb</var>, <var class="Arg">ncb</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns a block matrix with <var class="Arg">nrb</var> row blocks and <var class="Arg">ncb</var> column blocks which is equal to the ordinary matrix <var class="Arg">m</var>.</p>

<p><a id="X8633538685551E7A" name="X8633538685551E7A"></a></p>

<h5>24.17-2 BlockMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BlockMatrix</code>( <var class="Arg">blocks</var>, <var class="Arg">nrb</var>, <var class="Arg">ncb</var>[, <var class="Arg">rpb</var>, <var class="Arg">cpb</var>, <var class="Arg">zero</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="func">BlockMatrix</code> returns an immutable matrix in the sparse representation <code class="code">IsBlockMatrixRep</code>. The nonzero blocks are described by the list <var class="Arg">blocks</var> of triples <span class="SimpleMath">\([ \textit{i}, \textit{j}, M(i,j) ]\)</span> each consisting of a matrix <span class="SimpleMath">\(M(i,j)\)</span> and its block coordinates in the block matrix to be constructed. All matrices <span class="SimpleMath">\(M(i,j)\)</span> must have the same dimensions. As usual the first coordinate specifies the row and the second one the column. The resulting matrix has <var class="Arg">nrb</var> row blocks and <var class="Arg">ncb</var> column blocks.</p>

<p>If <var class="Arg">blocks</var> is empty (i.e., if the matrix is a zero matrix) then the dimensions of the blocks must be entered as <var class="Arg">rpb</var> and <var class="Arg">cpb</var>, and the zero element as <var class="Arg">zero</var>.</p>

<p>Note that all blocks must be ordinary matrices (see <code class="func">IsOrdinaryMatrix</code> (<a href="chap24_mj.html#X7CF42B8A845BC6A9"><span class="RefLink">24.2-2</span></a>)), and also the block matrix is an ordinary matrix.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := BlockMatrix([[1,1,[[1, 2],[ 3, 4]]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                     [1,2,[[9,10],[11,12]]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                     [2,2,[[5, 6],[ 7, 8]]]],2,2);</span>
&lt;block matrix of dimensions (2*2)x(2*2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(M);</span>
[ [   1,   2,   9,  10 ],
  [   3,   4,  11,  12 ],
  [   0,   0,   5,   6 ],
  [   0,   0,   7,   8 ] ]
</pre></div>

<p><a id="X83FAF4158180041F" name="X83FAF4158180041F"></a></p>

<h5>24.17-3 MatrixByBlockMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MatrixByBlockMatrix</code>( <var class="Arg">blockmat</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns a plain ordinary matrix that is equal to the block matrix <var class="Arg">blockmat</var>.</p>

<p><a id="X782F2EBF80C431D0" name="X782F2EBF80C431D0"></a></p>

<h4>24.18 <span class="Heading">Linear Programming</span></h4>

<p><a id="X845D5F8D7D905CB8" name="X845D5F8D7D905CB8"></a></p>

<h5>24.18-1 SimplexMethod</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimplexMethod</code>( <var class="Arg">A</var>, <var class="Arg">b</var>, <var class="Arg">c</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Find a rational vector <var class="Arg">x</var> that maximizes <span class="SimpleMath">\(\textit{x}\cdot\textit{c}\)</span>, subject to the constraint <span class="SimpleMath">\(\textit{A}\cdot\textit{x}\le\textit{b}\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A:=[[3,1,1,4],[1,-3,2,3],[2,1,3,-1]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b:=[12,7,10];;c:=[2,4,3,1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SimplexMethod(A,b,c);</span>
[ [ 0, 52/5, 0, 2/5 ], 42 ]
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap23_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap25_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chap14_mj.html">14</a>  <a href="chap15_mj.html">15</a>  <a href="chap16_mj.html">16</a>  <a href="chap17_mj.html">17</a>  <a href="chap18_mj.html">18</a>  <a href="chap19_mj.html">19</a>  <a href="chap20_mj.html">20</a>  <a href="chap21_mj.html">21</a>  <a href="chap22_mj.html">22</a>  <a href="chap23_mj.html">23</a>  <a href="chap24_mj.html">24</a>  <a href="chap25_mj.html">25</a>  <a href="chap26_mj.html">26</a>  <a href="chap27_mj.html">27</a>  <a href="chap28_mj.html">28</a>  <a href="chap29_mj.html">29</a>  <a href="chap30_mj.html">30</a>  <a href="chap31_mj.html">31</a>  <a href="chap32_mj.html">32</a>  <a href="chap33_mj.html">33</a>  <a href="chap34_mj.html">34</a>  <a href="chap35_mj.html">35</a>  <a href="chap36_mj.html">36</a>  <a href="chap37_mj.html">37</a>  <a href="chap38_mj.html">38</a>  <a href="chap39_mj.html">39</a>  <a href="chap40_mj.html">40</a>  <a href="chap41_mj.html">41</a>  <a href="chap42_mj.html">42</a>  <a href="chap43_mj.html">43</a>  <a href="chap44_mj.html">44</a>  <a href="chap45_mj.html">45</a>  <a href="chap46_mj.html">46</a>  <a href="chap47_mj.html">47</a>  <a href="chap48_mj.html">48</a>  <a href="chap49_mj.html">49</a>  <a href="chap50_mj.html">50</a>  <a href="chap51_mj.html">51</a>  <a href="chap52_mj.html">52</a>  <a href="chap53_mj.html">53</a>  <a href="chap54_mj.html">54</a>  <a href="chap55_mj.html">55</a>  <a href="chap56_mj.html">56</a>  <a href="chap57_mj.html">57</a>  <a href="chap58_mj.html">58</a>  <a href="chap59_mj.html">59</a>  <a href="chap60_mj.html">60</a>  <a href="chap61_mj.html">61</a>  <a href="chap62_mj.html">62</a>  <a href="chap63_mj.html">63</a>  <a href="chap64_mj.html">64</a>  <a href="chap65_mj.html">65</a>  <a href="chap66_mj.html">66</a>  <a href="chap67_mj.html">67</a>  <a href="chap68_mj.html">68</a>  <a href="chap69_mj.html">69</a>  <a href="chap70_mj.html">70</a>  <a href="chap71_mj.html">71</a>  <a href="chap72_mj.html">72</a>  <a href="chap73_mj.html">73</a>  <a href="chap74_mj.html">74</a>  <a href="chap75_mj.html">75</a>  <a href="chap76_mj.html">76</a>  <a href="chap77_mj.html">77</a>  <a href="chap78_mj.html">78</a>  <a href="chap79_mj.html">79</a>  <a href="chap80_mj.html">80</a>  <a href="chap81_mj.html">81</a>  <a href="chap82_mj.html">82</a>  <a href="chap83_mj.html">83</a>  <a href="chap84_mj.html">84</a>  <a href="chap85_mj.html">85</a>  <a href="chap86_mj.html">86</a>  <a href="chap87_mj.html">87</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
