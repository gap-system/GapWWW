<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (ref) - Chapter 71: Character Tables</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap71"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chap16.html">16</a>  <a href="chap17.html">17</a>  <a href="chap18.html">18</a>  <a href="chap19.html">19</a>  <a href="chap20.html">20</a>  <a href="chap21.html">21</a>  <a href="chap22.html">22</a>  <a href="chap23.html">23</a>  <a href="chap24.html">24</a>  <a href="chap25.html">25</a>  <a href="chap26.html">26</a>  <a href="chap27.html">27</a>  <a href="chap28.html">28</a>  <a href="chap29.html">29</a>  <a href="chap30.html">30</a>  <a href="chap31.html">31</a>  <a href="chap32.html">32</a>  <a href="chap33.html">33</a>  <a href="chap34.html">34</a>  <a href="chap35.html">35</a>  <a href="chap36.html">36</a>  <a href="chap37.html">37</a>  <a href="chap38.html">38</a>  <a href="chap39.html">39</a>  <a href="chap40.html">40</a>  <a href="chap41.html">41</a>  <a href="chap42.html">42</a>  <a href="chap43.html">43</a>  <a href="chap44.html">44</a>  <a href="chap45.html">45</a>  <a href="chap46.html">46</a>  <a href="chap47.html">47</a>  <a href="chap48.html">48</a>  <a href="chap49.html">49</a>  <a href="chap50.html">50</a>  <a href="chap51.html">51</a>  <a href="chap52.html">52</a>  <a href="chap53.html">53</a>  <a href="chap54.html">54</a>  <a href="chap55.html">55</a>  <a href="chap56.html">56</a>  <a href="chap57.html">57</a>  <a href="chap58.html">58</a>  <a href="chap59.html">59</a>  <a href="chap60.html">60</a>  <a href="chap61.html">61</a>  <a href="chap62.html">62</a>  <a href="chap63.html">63</a>  <a href="chap64.html">64</a>  <a href="chap65.html">65</a>  <a href="chap66.html">66</a>  <a href="chap67.html">67</a>  <a href="chap68.html">68</a>  <a href="chap69.html">69</a>  <a href="chap70.html">70</a>  <a href="chap71.html">71</a>  <a href="chap72.html">72</a>  <a href="chap73.html">73</a>  <a href="chap74.html">74</a>  <a href="chap75.html">75</a>  <a href="chap76.html">76</a>  <a href="chap77.html">77</a>  <a href="chap78.html">78</a>  <a href="chap79.html">79</a>  <a href="chap80.html">80</a>  <a href="chap81.html">81</a>  <a href="chap82.html">82</a>  <a href="chap83.html">83</a>  <a href="chap84.html">84</a>  <a href="chap85.html">85</a>  <a href="chap86.html">86</a>  <a href="chap87.html">87</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap70.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap72.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap71_mj.html">[MathJax on]</a></p>
<p><a id="X7B7A9EE881E01C10" name="X7B7A9EE881E01C10"></a></p>
<div class="ChapSects"><a href="chap71.html#X7B7A9EE881E01C10">71 <span class="Heading">Character Tables</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap71.html#X7B9FCBBC7B95F91B">71.1 <span class="Heading">Some Remarks about Character Theory in <strong class="pkg">GAP</strong></span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap71.html#X7F8AB7CB7A46002F">71.2 <span class="Heading">History of Character Theory Stuff in GAP</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap71.html#X8701174D86B586AF">71.3 <span class="Heading">Creating Character Tables</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7FCA7A7A822BDA33">71.3-1 <span class="Heading">CharacterTable</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X8476B25A79D7A7FC">71.3-2 <span class="Heading">BrauerTable</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X85DB8AE7786A2DB5">71.3-3 CharacterTableRegular</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7DBEF4BF87F10CD6">71.3-4 SupportedCharacterTableInfo</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X8195BC057B1DFAD5">71.3-5 ConvertToCharacterTable</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap71.html#X789FAC077AEF088A">71.4 <span class="Heading">Character Table Categories</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X82FF82C87CF82ADF">71.4-1 IsNearlyCharacterTable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7C6F3D947E5188D1">71.4-2 InfoCharacterTable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7FA867637EBB30F9">71.4-3 NearlyCharacterTablesFamily</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap71.html#X829C4B6E83998F40">71.5 <span class="Heading">Conventions for Character Tables</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap71.html#X793E0EBF84B07313">71.6 <span class="Heading">The Interface between Character Tables and Groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7FF4826A82B667AF">71.6-1 UnderlyingGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X849A38F887F6EC86">71.6-2 ConjugacyClasses</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X84DC12AA804C8085">71.6-3 IdentificationOfConjugacyClasses</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X8788C6C7829C1ADE">71.6-4 CharacterTableWithStoredGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X790019E87CFDDB98">71.6-5 CompatibleConjugacyClasses</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap71.html#X7CADCBC9824CB624">71.7 <span class="Heading">Operators for Character Tables</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap71.html#X7F9D58208241D35E">71.8 <span class="Heading">Attributes and Properties for Groups and Character Tables</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X81FEFF768134481A">71.8-1 <span class="Heading">CharacterDegrees</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X873B3CC57E9A5492">71.8-2 <span class="Heading">Irr</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X8549899A7DE206BA">71.8-3 <span class="Heading">LinearCharacters</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X8011EEB684848039">71.8-4 <span class="Heading">OrdinaryCharacterTable</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X81EFD9FE804AC6EE">71.8-5 <span class="Heading">Group Operations Applicable to Character Tables</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap71.html#X7995A2AD83BC58A0">71.9 <span class="Heading">Attributes and Properties only for Character Tables</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X86F455DA7A9C30EE">71.9-1 OrdersClassRepresentatives</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7CF7907F790A5DE6">71.9-2 SizesCentralizers</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7D9D2A45879A6A62">71.9-3 SizesConjugacyClasses</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7C2753DE8094F4BA">71.9-4 AutomorphismsOfTable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7F58A82F7D88000A">71.9-5 <span class="Heading">UnderlyingCharacteristic</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X804CFD597C795801">71.9-6 <span class="Heading">Class Names and Character Names</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X8333E8038308947E">71.9-7 <span class="Heading">Class Parameters and Character Parameters</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X79C40EE97890202F">71.9-8 Identifier</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7932C35180C80953">71.9-9 InfoText</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7919E2897BE8234A">71.9-10 InverseClasses</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X87FF547981456932">71.9-11 RealClasses</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7ABB007C799F7C49">71.9-12 ClassOrbit</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7F863B15804E0835">71.9-13 ClassRoots</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap71.html#X79CEBC3C7E0E63DF">71.10 <span class="Heading">Normal Subgroups Represented by Lists of Class Positions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X850C7D947B3DBFA2">71.10-1 ClassPositionsOfNormalSubgroups</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X8491DA0981D6F264">71.10-2 ClassPositionsOfAgemo</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7A6B1F8A84A495DC">71.10-3 ClassPositionsOfCentre</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7D53F60785AB22B1">71.10-4 ClassPositionsOfDirectProductDecompositions</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X79EE7BE17BD343D5">71.10-5 ClassPositionsOfDerivedSubgroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X86ABB2E179D7F6E1">71.10-6 ClassPositionsOfElementaryAbelianSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7D2A55A584F955DB">71.10-7 ClassPositionsOfFittingSubgroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X79AEFC4384769B72">71.10-8 ClassPositionsOfLowerCentralSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X86065D217A36CD9B">71.10-9 ClassPositionsOfUpperCentralSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X877FDE8A84A9F52C">71.10-10 ClassPositionsOfSolvableRadical</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X8392DD5B813250A4">71.10-11 ClassPositionsOfSupersolvableResiduum</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7BBE7EBA7A64A6B0">71.10-12 ClassPositionsOfPCore</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7FCF905D7FD7CC40">71.10-13 ClassPositionsOfNormalClosure</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap71.html#X8733F0EA801785D4">71.11 <span class="Heading">Operations Concerning Blocks</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7ACB9306804F4E3F">71.11-1 PrimeBlocks</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7E80E35985275F35">71.11-2 SameBlock</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7FF4CE4A7A272F88">71.11-3 BlocksInfo</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X84701640811D2345">71.11-4 DecompositionMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X83EC921380AF9B3B">71.11-5 LaTeXStringDecompositionMatrix</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap71.html#X873211618402ACF7">71.12 <span class="Heading">Other Operations for Character Tables</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X8441983C845F2176">71.12-1 Index</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X8123650E817926FC">71.12-2 IsInternallyConsistent</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7A0CBD1884276882">71.12-3 IsPSolvableCharacterTable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X82F523E8784B3752">71.12-4 IsClassFusionOfNormalSubgroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7FD3D3047DE6381E">71.12-5 Indicator</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X83AE05BF8085B3C8">71.12-6 NrPolyhedralSubgroups</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7E2EA9FE7D3062D3">71.12-7 ClassMultiplicationCoefficient</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7A19F56C7FD5EFC7">71.12-8 ClassStructureCharTable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X809E67E57D4933B3">71.12-9 MatClassMultCoeffsCharTable</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap71.html#X7C1941F17BE9FC21">71.13 <span class="Heading">Printing Character Tables</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7D45224B86D802E5">71.13-1 ViewObj</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X836554207C678D41">71.13-2 PrintObj</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7B41F36478C47364">71.13-3 Display</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X85E883A87A190AA4">71.13-4 DisplayOptions</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X79EC9603833AA2AB">71.13-5 PrintCharacterTable</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap71.html#X79BC08C6846718D9">71.14 <span class="Heading">Computing the Irreducible Characters of a Group</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7ED39DB680BFEA96">71.14-1 IrrDixonSchneider</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7E81BCD686561DF0">71.14-2 IrrConlon</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7BF15729839203FC">71.14-3 IrrBaumClausen</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7F29C5447B5DC102">71.14-4 IrreducibleRepresentations</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X8493ED7A86FFCB8A">71.14-5 IrreducibleRepresentationsDixon</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap71.html#X7E51AACD79CE0BC8">71.15 <span class="Heading">Representations Given by Modules</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X87E82F8085745523">71.15-1 IrreducibleModules</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7D0BD5337D1C069B">71.15-2 AbsolutelyIrreducibleModules</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7EB88B2E87AF5556">71.15-3 RegularModule</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap71.html#X86CDA4007A5EF704">71.16 <span class="Heading">The Dixon-Schneider Algorithm</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap71.html#X7C083207868066C1">71.17 <span class="Heading">Advanced Methods for Dixon-Schneider Calculations</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7C398F2680C8616B">71.17-1 DixonRecord</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7E33C03E7BDDC9B0">71.17-2 DixonInit</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X868476037907918F">71.17-3 DixontinI</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X87ABE0B081DAD476">71.17-4 DixonSplit</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7BFD4C1A821731FB">71.17-5 BestSplittingMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7C85B56C80BFA2E3">71.17-6 DxIncludeIrreducibles</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X87A5B5C77F7F348E">71.17-7 SplitCharacters</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X8089009E7EA85BC8">71.17-8 IsDxLargeGroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap71.html#X7C1153637E7D2133">71.18 <span class="Heading">Components of a Dixon Record</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap71.html#X782B5E37848786BC">71.19 <span class="Heading">An Example of Advanced Dixon-Schneider Calculations</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap71.html#X7C38C5067941D496">71.20 <span class="Heading">Constructing Character Tables from Others</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7BE1572D7BBC6AC8">71.20-1 CharacterTableDirectProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7C97CF727FBDFCAB">71.20-2 FactorsOfDirectProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7C3A4E5283B240BE">71.20-3 CharacterTableFactorGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X85BE46F784B83938">71.20-4 CharacterTableIsoclinic</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X806E55A58397B11B">71.20-5 CharacterTableOfNormalSubgroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X79B75C8582426BC5">71.20-6 CharacterTableWreathSymmetric</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X83E71B1F7FA70134">71.20-7 CharacterValueWreathSymmetric</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap71.html#X816FCD5A805F9FE8">71.21 <span class="Heading">Sorted Character Tables</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7D9C4A7F8086F671">71.21-1 CharacterTableWithSortedCharacters</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X87E3CF317D8E4EC7">71.21-2 SortedCharacters</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7E3DE0A47E62BE6B">71.21-3 CharacterTableWithSortedClasses</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X82DCAAA882416E24">71.21-4 SortedCharacterTable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X8099FEDC7DE03AEE">71.21-5 ClassPermutation</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap71.html#X7B0A669484470D09">71.22 <span class="Heading">Automorphisms and Equivalence of Character Tables</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X84353BB884AF0365">71.22-1 MatrixAutomorphisms</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X8082DD827C673138">71.22-2 TableAutomorphisms</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7D721E3D7AA319F5">71.22-3 TransformingPermutations</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X849731AA7EC9FA73">71.22-4 TransformingPermutationsCharacterTables</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X8117D940835B0B47">71.22-5 FamiliesOfRows</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap71.html#X81272CEE79F13E7B">71.23 <span class="Heading">Storing Normal Subgroup Information</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7E66174C7C7A8C0C">71.23-1 NormalSubgroupClassesInfo</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X7C2A87E085111090">71.23-2 ClassPositionsOfNormalSubgroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X87E7391F7F92377C">71.23-3 NormalSubgroupClasses</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap71.html#X79D451F0808EB252">71.23-4 FactorGroupNormalSubgroupClasses</a></span>
</div></div>
</div>

<h3>71 <span class="Heading">Character Tables</span></h3>

<p>This chapter describes operations for <em>character tables of finite groups</em>.</p>

<p>Operations for <em>characters</em> (or, more general, <em>class functions</em>) are described in Chapter <a href="chap72.html#X7C91D0D17850E564"><span class="RefLink">72</span></a>.</p>

<p>For a description of the <strong class="pkg">GAP</strong> Library of Character Tables, see the separate manual for the <strong class="pkg">GAP</strong> package <strong class="pkg">CTblLib</strong>.</p>

<p>Several examples in this chapter require the <strong class="pkg">GAP</strong> Character Table Library to be available. If it is not yet loaded then we load it now.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "ctbllib" );</span>
true
</pre></div>

<p><a id="X7B9FCBBC7B95F91B" name="X7B9FCBBC7B95F91B"></a></p>

<h4>71.1 <span class="Heading">Some Remarks about Character Theory in <strong class="pkg">GAP</strong></span></h4>

<p>It seems to be necessary to state some basic facts –and maybe warnings– at the beginning of the character theory package. This holds for people who are familiar with character theory because there is no global reference on computational character theory, although there are many papers on this topic, such as <a href="chapBib.html#biBNPP84">[NPP84]</a> or <a href="chapBib.html#biBLP91">[LP91]</a>. It holds, however, also for people who are familiar with <strong class="pkg">GAP</strong> because the general concept of domains (see Chapter <a href="chap12.html#X7BAF69417BB925F6"><span class="RefLink">12.4</span></a>) plays no important role here –we will justify this later in this section.</p>

<p>Intuitively, <em>characters</em> (or more generally, <em>class functions</em>) of a finite group <span class="SimpleMath">G</span> can be thought of as certain mappings defined on <span class="SimpleMath">G</span>, with values in the complex number field; the set of all characters of <span class="SimpleMath">G</span> forms a semiring, with both addition and multiplication defined pointwise, which is naturally embedded into the ring of <em>generalized</em> (or <em>virtual</em>) <em>characters</em> in the natural way. A <span class="SimpleMath">ℤ</span>-basis of this ring, and also a vector space basis of the complex vector space of class functions of <span class="SimpleMath">G</span>, is given by the irreducible characters of <span class="SimpleMath">G</span>.</p>

<p>At this stage one could ask where there is a problem, since all these algebraic structures are supported by <strong class="pkg">GAP</strong>. But in practice, these structures are of minor importance, compared to individual characters and the <em>character tables</em> themselves (which are not domains in the sense of <strong class="pkg">GAP</strong>).</p>

<p>For computations with characters of a finite group <span class="SimpleMath">G</span> with <span class="SimpleMath">n</span> conjugacy classes, say, we fix an ordering of the classes, and then identify each class with its position according to this ordering. Each character of <span class="SimpleMath">G</span> can be represented by a list of length <span class="SimpleMath">n</span> in which the character value for elements of the <span class="SimpleMath">i</span>-th class is stored at the <span class="SimpleMath">i</span>-th position. Note that we need not know the conjugacy classes of <span class="SimpleMath">G</span> physically, even our knowledge of <span class="SimpleMath">G</span> may be implicit in the sense that, e.g., we know how many classes of involutions <span class="SimpleMath">G</span> has, and which length these classes have, but we never have seen an element of <span class="SimpleMath">G</span>, or a presentation or representation of <span class="SimpleMath">G</span>. This allows us to work with the character tables of very large groups, e.g., of the so-called monster, where <strong class="pkg">GAP</strong> has (currently) no chance to deal with the group.</p>

<p>As a consequence, also other information involving characters is given implicitly. For example, we can talk about the kernel of a character not as a group but as a list of classes (more exactly: a list of their positions according to the chosen ordering of classes) forming this kernel; we can deduce the group order, the contained cyclic subgroups and so on, but we do not get the group itself.</p>

<p>So typical calculations with characters involve loops over lists of character values. For example, the scalar product of two characters <span class="SimpleMath">χ</span>, <span class="SimpleMath">ψ</span> of <span class="SimpleMath">G</span> given by</p>

<p class="pcenter">[ χ, ψ ] = ( ∑_{g ∈ G} χ(g) ψ(g^{-1}) ) / |G|</p>

<p>can be written as</p>


<div class="example"><pre>
Sum( [ 1 .. n ], i -&gt; SizesConjugacyClasses( t )[i] * chi[i]
                          * ComplexConjugate( psi[i] ) ) / Size( t );
</pre></div>

<p>where <code class="code">t</code> is the character table of <span class="SimpleMath">G</span>, and <code class="code">chi</code>, <code class="code">psi</code> are the lists of values of <span class="SimpleMath">χ</span>, <span class="SimpleMath">ψ</span>, respectively.</p>

<p>It is one of the advantages of character theory that after one has translated a problem concerning groups into a problem concerning only characters, the necessary calculations are mostly simple. For example, one can often prove that a group is a Galois group over the rationals using calculations with structure constants that can be computed from the character table, and information about (the character tables of) maximal subgroups. When one deals with such questions, the translation back to groups is just an interpretation by the user, it does not take place in <strong class="pkg">GAP</strong>.</p>

<p><strong class="pkg">GAP</strong> uses character <em>tables</em> to store information such as class lengths, element orders, the irreducible characters of <span class="SimpleMath">G</span> etc. in a consistent way; in the example above, we have seen that <code class="func">SizesConjugacyClasses</code> (<a href="chap71.html#X7D9D2A45879A6A62"><span class="RefLink">71.9-3</span></a>) returns the list of class lengths of its argument. Note that the values of these attributes rely on the chosen ordering of conjugacy classes, a character table is not determined by something similar to generators of groups or rings in <strong class="pkg">GAP</strong> where knowledge could in principle be recovered from the generators but is stored mainly for the sake of efficiency.</p>

<p>Note that the character table of a group <span class="SimpleMath">G</span> in <strong class="pkg">GAP</strong> must <em>not</em> be mixed up with the list of complex irreducible characters of <span class="SimpleMath">G</span>. The irreducible characters are stored in a character table via the attribute <code class="func">Irr</code> (<a href="chap71.html#X873B3CC57E9A5492"><span class="RefLink">71.8-2</span></a>).</p>

<p>Two further important instances of information that depends on the ordering of conjugacy classes are <em>power maps</em> and <em>fusion maps</em>. Both are represented as lists of integers in <strong class="pkg">GAP</strong>. The <span class="SimpleMath">k</span>-th power map maps each class to the class of <span class="SimpleMath">k</span>-th powers of its elements, the corresponding list contains at each position the position of the image. A class fusion map between the classes of a subgroup <span class="SimpleMath">H</span> of <span class="SimpleMath">G</span> and the classes of <span class="SimpleMath">G</span> maps each class <span class="SimpleMath">c</span> of <span class="SimpleMath">H</span> to that class of <span class="SimpleMath">G</span> that contains <span class="SimpleMath">c</span>, the corresponding list contains again the positions of image classes; if we know only the character tables of <span class="SimpleMath">H</span> and <span class="SimpleMath">G</span> but not the groups themselves, this means with respect to a fixed embedding of <span class="SimpleMath">H</span> into <span class="SimpleMath">G</span>. More about power maps and fusion maps can be found in Chapter <a href="chap73.html#X7DF1ACDE7E9C6294"><span class="RefLink">73</span></a>.</p>

<p>So class functions, power maps, and fusion maps are represented by lists in <strong class="pkg">GAP</strong>. If they are plain lists then they are regarded as class functions etc. of an appropriate character table when they are passed to <strong class="pkg">GAP</strong> functions that expect class functions etc. For example, a list with all entries equal to 1 is regarded as the trivial character if it is passed to a function that expects a character. Note that this approach requires the character table as an argument for such a function.</p>

<p>One can construct class function objects that store their underlying character table and other attribute values (see Chapter <a href="chap72.html#X7C91D0D17850E564"><span class="RefLink">72</span></a>). This allows one to omit the character table argument in many functions, and it allows one to use infix operations for tensoring or inducing class functions.</p>

<p><a id="X7F8AB7CB7A46002F" name="X7F8AB7CB7A46002F"></a></p>

<h4>71.2 <span class="Heading">History of Character Theory Stuff in GAP</span></h4>

<p><strong class="pkg">GAP</strong> provides functions for dealing with group characters since the version <strong class="pkg">GAP</strong> 3.1, which was released in March 1992. The reason for adding this branch of mathematics to the topics of <strong class="pkg">GAP</strong> was (apart from the usefulness of character theoretic computations in general) the insight that <strong class="pkg">GAP</strong> provides an ideal environment for developing the algorithms needed. In particular, it had been decided at Lehrstuhl D für Mathematik that the <strong class="pkg">CAS</strong> system (a standalone Fortran program together with a database of character tables, see <a href="chapBib.html#biBNPP84">[NPP84]</a>) should not be developed further and the functionality of <strong class="pkg">CAS</strong> should be made available in <strong class="pkg">GAP</strong>. The background was that extending <strong class="pkg">CAS</strong> (by new Fortran code) had turned out to be much less flexible than writing analogous <strong class="pkg">GAP</strong> library code.</p>

<p>For integrating the existing character theory algorithms, <strong class="pkg">GAP</strong>'s memory management and long integer arithmetic were useful as well as the list handling –it is an important feature of character theoretic methods that questions about groups are translated into manipulations of lists; on the other hand, the datatype of cyclotomics (see Chapter <code class="func">Cyclotomics</code> (<a href="chap18.html#X863D1E017BC9EB7F"><span class="RefLink">18.1-2</span></a>)) was added to the <strong class="pkg">GAP</strong> kernel because of the character theory algorithms. For developing further code, also other areas of <strong class="pkg">GAP</strong>'s library became interesting, such as permutation groups, finite fields, and polynomials.</p>

<p>The development of character theory code for <strong class="pkg">GAP</strong> has been supported by several DFG grants, in particular the project "Representation Theory of Finite Groups and Finite Dimensional Algebras" (until 1991), and the Schwerpunkt "Algorithmische Zahlentheorie und Algebra" (from 1991 until 1997). Besides that, several Diploma theses at Lehrstuhl D were concerned with the development and/or implementation of algorithms dealing with characters in <strong class="pkg">GAP</strong>.</p>

<p>The major contributions can be listed as follows.</p>


<ul>
<li><p>The arithmetic for the cyclotomics data type, following <a href="chapBib.html#biBZum89">[Zum89]</a>, was first implemented by Marco van Meegen; an alternative approach was studied in the diploma thesis of Michael Scherner (see <a href="chapBib.html#biBScherner92">[Sch92]</a>) but was not efficient enough; later Martin Schönert replaced the implementation by a better one.</p>

</li>
<li><p>The basic routines for characters and character tables were written by Thomas Breuer and Götz Pfeiffer.</p>

</li>
<li><p>The lattice related functions, such as <code class="func">LLL</code> (<a href="chap72.html#X85B360C085B360C0"><span class="RefLink">72.10-4</span></a>), <code class="func">OrthogonalEmbeddings</code> (<a href="chap25.html#X842280C2808FF05D"><span class="RefLink">25.6-1</span></a>), and <code class="func">DnLattice</code> (<a href="chap72.html#X85D510DC873A99B4"><span class="RefLink">72.10-8</span></a>), were implemented by Ansgar Kaup (see <a href="chapBib.html#biBKaup92">[Kau92]</a>).</p>

</li>
<li><p>Functions for computing possible class fusions, possible power maps, and table automorphisms were written by Thomas Breuer (see <a href="chapBib.html#biBBre91">[Bre91]</a>).</p>

</li>
<li><p>Functions for computing possible permutation characters were written by Thomas Breuer (see <a href="chapBib.html#biBBre91">[Bre91]</a>) and Götz Pfeiffer (see <a href="chapBib.html#biBPfe91">[Pfe91]</a>).</p>

</li>
<li><p>Functions for computing character tables from groups were written by Alexander Hulpke (Dixon-Schneider algorithm, see <a href="chapBib.html#biBHulpke93">[Hul93]</a>) and Hans Ulrich Besche (Baum algorithm and Conlon algorithm, see <a href="chapBib.html#biBBesche92">[Bes92]</a>).</p>

</li>
<li><p>Functions for dealing with Clifford matrices were written by Ute Schiffer (see <a href="chapBib.html#biBSchiffer94">[Sch94]</a>).</p>

</li>
<li><p>Functions for monomiality questions were written by Thomas Breuer and Erzsébet Horváth.</p>

</li>
</ul>
<p>Since then, the code has been maintained and extended further by Alexander Hulpke (code related to his implementation of the Dixon-Schneider algorithm) and Thomas Breuer.</p>

<p>Currently <strong class="pkg">GAP</strong> does not provide special functionality for computing Brauer character tables, but there is an interface to the <strong class="pkg">MOC</strong> system (see <a href="chapBib.html#biBHJLP92">[HJLP]</a>), and the <strong class="pkg">GAP</strong> Character Table Library contains many known Brauer character tables.</p>

<p><a id="X8701174D86B586AF" name="X8701174D86B586AF"></a></p>

<h4>71.3 <span class="Heading">Creating Character Tables</span></h4>

<p>There are in general five different ways to get a character table in <strong class="pkg">GAP</strong>. You can</p>

<ol>
<li><p>compute the table from a group,</p>

</li>
<li><p>read a file that contains the table data,</p>

</li>
<li><p>construct the table using generic formulae,</p>

</li>
<li><p>derive it from known character tables, or</p>

</li>
<li><p>combine partial information about conjugacy classes, power maps of the group in question, and about (character tables of) some subgroups and supergroups.</p>

</li>
</ol>
<p>In 1., the computation of the irreducible characters is the hardest part; the different algorithms available for this are described in <a href="chap71.html#X79BC08C6846718D9"><span class="RefLink">71.14</span></a>. Possibility 2. is used for the character tables in the <strong class="pkg">GAP</strong> Character Table Library, see the manual of this library. Generic character tables –as addressed by 3.– are described in <a href="../../pkg/ctbllib/doc/chap4.html#X81E3F9A384365282"><span class="RefLink">CTblLib: Generic Character Tables</span></a>. Several occurrences of 4. are described in <a href="chap71.html#X7C38C5067941D496"><span class="RefLink">71.20</span></a>. The last of the above possibilities <em>is currently not supported and will be described in a chapter of its own when it becomes available</em>.</p>

<p>The operation <code class="func">CharacterTable</code> (<a href="chap71.html#X7FCA7A7A822BDA33"><span class="RefLink">71.3-1</span></a>) can be used for the cases 1. to 3.</p>

<p><a id="X7FCA7A7A822BDA33" name="X7FCA7A7A822BDA33"></a></p>

<h5>71.3-1 <span class="Heading">CharacterTable</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CharacterTable</code>( <var class="Arg">G</var>[, <var class="Arg">p</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CharacterTable</code>( <var class="Arg">ordtbl</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CharacterTable</code>( <var class="Arg">name</var>[, <var class="Arg">param</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Called with a group <var class="Arg">G</var>, <code class="func">CharacterTable</code> calls the attribute <code class="func">OrdinaryCharacterTable</code> (<a href="chap71.html#X8011EEB684848039"><span class="RefLink">71.8-4</span></a>). Called with first argument a group <var class="Arg">G</var> or an ordinary character table <var class="Arg">ordtbl</var>, and second argument a prime <var class="Arg">p</var>, <code class="func">CharacterTable</code> calls the operation <code class="func">BrauerTable</code> (<a href="chap71.html#X8476B25A79D7A7FC"><span class="RefLink">71.3-2</span></a>).</p>

<p>Called with a string <var class="Arg">name</var> and perhaps optional parameters <var class="Arg">param</var>, <code class="func">CharacterTable</code> tries to access a character table from the <strong class="pkg">GAP</strong> Character Table Library. See the manual of the <strong class="pkg">GAP</strong> package <strong class="pkg">CTblLib</strong> for an overview of admissible arguments. An error is signalled if this <strong class="pkg">GAP</strong> package is not loaded in this case.</p>

<p>Probably the most interesting information about the character table is its list of irreducibles, which can be accessed as the value of the attribute <code class="func">Irr</code> (<a href="chap71.html#X873B3CC57E9A5492"><span class="RefLink">71.8-2</span></a>). If the argument of <code class="func">CharacterTable</code> is a string <var class="Arg">name</var> then the irreducibles are just read from the library file, therefore the returned table stores them already. However, if <code class="func">CharacterTable</code> is called with a group <var class="Arg">G</var> or with an ordinary character table <var class="Arg">ordtbl</var>, the irreducible characters are <em>not</em> computed by <code class="func">CharacterTable</code>. They are only computed when the <code class="func">Irr</code> (<a href="chap71.html#X873B3CC57E9A5492"><span class="RefLink">71.8-2</span></a>) value is accessed for the first time, for example when <code class="func">Display</code> (<a href="chap6.html#X83A5C59278E13248"><span class="RefLink">6.3-6</span></a>) is called for the table (see <a href="chap71.html#X7C1941F17BE9FC21"><span class="RefLink">71.13</span></a>). This means for example that <code class="func">CharacterTable</code> returns its result very quickly, and the first call of <code class="func">Display</code> (<a href="chap6.html#X83A5C59278E13248"><span class="RefLink">6.3-6</span></a>) for this table may take some time because the irreducible characters must be computed at that time before they can be displayed together with other information stored on the character table. The value of the filter <code class="code">HasIrr</code> indicates whether the irreducible characters have been computed already.</p>

<p>The reason why <code class="func">CharacterTable</code> does not compute the irreducible characters is that there are situations where one only needs the "table head", that is, the information about class lengths, power maps etc., but not the irreducibles. For example, if one wants to inspect permutation characters of a group then all one has to do is to induce the trivial characters of subgroups one is interested in; for that, only class lengths and the class fusion are needed. Or if one wants to compute the Molien series (see <code class="func">MolienSeries</code> (<a href="chap72.html#X7D7F94D2820B1177"><span class="RefLink">72.12-1</span></a>)) for a given complex matrix group, the irreducible characters of this group are in general of no interest.</p>

<p>For details about different algorithms to compute the irreducible characters, see <a href="chap71.html#X79BC08C6846718D9"><span class="RefLink">71.14</span></a>.</p>

<p>If the group <var class="Arg">G</var> is given as an argument, <code class="func">CharacterTable</code> accesses the conjugacy classes of <var class="Arg">G</var> and therefore causes that these classes are computed if they were not yet stored (see <a href="chap71.html#X793E0EBF84B07313"><span class="RefLink">71.6</span></a>).</p>

<p><a id="X8476B25A79D7A7FC" name="X8476B25A79D7A7FC"></a></p>

<h5>71.3-2 <span class="Heading">BrauerTable</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BrauerTable</code>( <var class="Arg">ordtbl</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BrauerTable</code>( <var class="Arg">G</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BrauerTableOp</code>( <var class="Arg">ordtbl</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ComputedBrauerTables</code>( <var class="Arg">ordtbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Called with an ordinary character table <var class="Arg">ordtbl</var> or a group <var class="Arg">G</var>, <code class="func">BrauerTable</code> returns its <var class="Arg">p</var>-modular character table if <strong class="pkg">GAP</strong> can compute this table, and <code class="keyw">fail</code> otherwise.</p>

<p>The <var class="Arg">p</var>-modular table can be computed in the following cases.</p>


<ul>
<li><p>The group is <var class="Arg">p</var>-solvable (see <code class="func">IsPSolvable</code> (<a href="chap39.html#X81130F9A7CFCF6BF"><span class="RefLink">39.15-24</span></a>), apply the Fong-Swan Theorem);</p>

</li>
<li><p>the Sylow <var class="Arg">p</var>-subgroup of <var class="Arg">G</var> is cyclic, and all <var class="Arg">p</var>-modular Brauer characters of <var class="Arg">G</var> lift to ordinary characters (note that this situation can be detected from the ordinary character table of <var class="Arg">G</var>);</p>

</li>
<li><p>the table <var class="Arg">ordtbl</var> stores information how it was constructed from other tables (as a direct product or as an isoclinic variant, for example), and the Brauer tables of the source tables can be computed;</p>

</li>
<li><p><var class="Arg">ordtbl</var> is a table from the <strong class="pkg">GAP</strong> character table library for which also the <var class="Arg">p</var>-modular table is contained in the table library.</p>

</li>
</ul>
<p>The default method for a group and a prime delegates to <code class="func">BrauerTable</code> for the ordinary character table of this group. The default method for <var class="Arg">ordtbl</var> uses the attribute <code class="func">ComputedBrauerTables</code> for storing the computed Brauer table at position <var class="Arg">p</var>, and calls the operation <code class="func">BrauerTableOp</code> for computing values that are not yet known.</p>

<p>So if one wants to install a new method for computing Brauer tables then it is sufficient to install it for <code class="func">BrauerTableOp</code>.</p>

<p>The <code class="keyw">mod</code> operator for a character table and a prime (see <a href="chap71.html#X7CADCBC9824CB624"><span class="RefLink">71.7</span></a>) delegates to <code class="func">BrauerTable</code>.</p>

<p><a id="X85DB8AE7786A2DB5" name="X85DB8AE7786A2DB5"></a></p>

<h5>71.3-3 CharacterTableRegular</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CharacterTableRegular</code>( <var class="Arg">tbl</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>For an ordinary character table <var class="Arg">tbl</var> and a prime integer <var class="Arg">p</var>, <code class="func">CharacterTableRegular</code> returns the "table head" of the <var class="Arg">p</var>-modular Brauer character table of <var class="Arg">tbl</var>. This is the restriction of <var class="Arg">tbl</var> to its <var class="Arg">p</var>-regular classes, like the return value of <code class="func">BrauerTable</code> (<a href="chap71.html#X8476B25A79D7A7FC"><span class="RefLink">71.3-2</span></a>), but without the irreducible Brauer characters. (In general, these characters are hard to compute, and <code class="func">BrauerTable</code> (<a href="chap71.html#X8476B25A79D7A7FC"><span class="RefLink">71.3-2</span></a>) may return <code class="keyw">fail</code> for the given arguments, for example if <var class="Arg">tbl</var> is a table from the <strong class="pkg">GAP</strong> character table library.)</p>

<p>The returned table head can be used to create <var class="Arg">p</var>-modular Brauer characters, by restricting ordinary characters, for example when one is interested in approximations of the (unknown) irreducible Brauer characters.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= SymmetricGroup( 4 );</span>
Sym( [ 1 .. 4 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( g );;  HasIrr( tbl );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblmod2:= CharacterTable( tbl, 2 );</span>
BrauerTable( Sym( [ 1 .. 4 ] ), 2 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblmod2 = CharacterTable( tbl, 2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblmod2 = BrauerTable( tbl, 2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblmod2 = BrauerTable( g, 2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">libtbl:= CharacterTable( "M" );</span>
CharacterTable( "M" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacterTableRegular( libtbl, 2 );</span>
BrauerTable( "M", 2 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BrauerTable( libtbl, 2 );</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacterTable( "Symmetric", 4 );</span>
CharacterTable( "Sym(4)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ComputedBrauerTables( tbl );</span>
[ , BrauerTable( Sym( [ 1 .. 4 ] ), 2 ) ]
</pre></div>

<p><a id="X7DBEF4BF87F10CD6" name="X7DBEF4BF87F10CD6"></a></p>

<h5>71.3-4 SupportedCharacterTableInfo</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SupportedCharacterTableInfo</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p><code class="func">SupportedCharacterTableInfo</code> is a list that contains at position <span class="SimpleMath">3i-2</span> an attribute getter function, at position <span class="SimpleMath">3i-1</span> the name of this attribute, and at position <span class="SimpleMath">3i</span> a list containing a subset of <code class="code">[ "character", "class", "mutable" ]</code>, depending on whether the attribute value relies on the ordering of characters or classes, or whether the attribute value is a mutable list or record.</p>

<p>When (ordinary or Brauer) character table objects are created from records, using <code class="func">ConvertToCharacterTable</code> (<a href="chap71.html#X8195BC057B1DFAD5"><span class="RefLink">71.3-5</span></a>), <code class="func">SupportedCharacterTableInfo</code> specifies those record components that shall be used as attribute values; other record components are <em>not</em> be regarded as attribute values in the conversion process.</p>

<p>New attributes and properties can be notified to <code class="func">SupportedCharacterTableInfo</code> by creating them with <code class="code">DeclareAttributeSuppCT</code> and <code class="code">DeclarePropertySuppCT</code> instead of <code class="func">DeclareAttribute</code> (<a href="chap13.html#X7A00FC8A7A677A56"><span class="RefLink">13.5-4</span></a>) and <code class="func">DeclareProperty</code> (<a href="chap13.html#X7F4602F082682A04"><span class="RefLink">13.7-5</span></a>).</p>

<p><a id="X8195BC057B1DFAD5" name="X8195BC057B1DFAD5"></a></p>

<h5>71.3-5 ConvertToCharacterTable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConvertToCharacterTable</code>( <var class="Arg">record</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConvertToCharacterTableNC</code>( <var class="Arg">record</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">record</var> be a record. <code class="func">ConvertToCharacterTable</code> converts <var class="Arg">record</var> into a component object (see <a href="chap79.html#X866E223484649E5A"><span class="RefLink">79.2</span></a>) representing a character table. The values of those components of <var class="Arg">record</var> whose names occur in <code class="func">SupportedCharacterTableInfo</code> (<a href="chap71.html#X7DBEF4BF87F10CD6"><span class="RefLink">71.3-4</span></a>) correspond to attribute values of the returned character table. All other components of the record simply become components of the character table object.</p>

<p>If inconsistencies in <var class="Arg">record</var> are detected, <code class="keyw">fail</code> is returned. <var class="Arg">record</var> must have the component <code class="code">UnderlyingCharacteristic</code> bound (cf. <code class="func">UnderlyingCharacteristic</code> (<a href="chap71.html#X7F58A82F7D88000A"><span class="RefLink">71.9-5</span></a>)), since this decides about whether the returned character table lies in <code class="func">IsOrdinaryTable</code> (<a href="chap71.html#X82FF82C87CF82ADF"><span class="RefLink">71.4-1</span></a>) or in <code class="func">IsBrauerTable</code> (<a href="chap71.html#X82FF82C87CF82ADF"><span class="RefLink">71.4-1</span></a>).</p>

<p><code class="func">ConvertToCharacterTableNC</code> does the same except that all checks of <var class="Arg">record</var> are omitted.</p>

<p>An example of a conversion from a record to a character table object can be found in Section <code class="func">PrintCharacterTable</code> (<a href="chap71.html#X79EC9603833AA2AB"><span class="RefLink">71.13-5</span></a>).</p>

<p><a id="X789FAC077AEF088A" name="X789FAC077AEF088A"></a></p>

<h4>71.4 <span class="Heading">Character Table Categories</span></h4>

<p><a id="X82FF82C87CF82ADF" name="X82FF82C87CF82ADF"></a></p>

<h5>71.4-1 IsNearlyCharacterTable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsNearlyCharacterTable</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCharacterTable</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsOrdinaryTable</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsBrauerTable</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCharacterTableInProgress</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>Every "character table like object" in <strong class="pkg">GAP</strong> lies in the category <code class="func">IsNearlyCharacterTable</code>. There are four important subcategories, namely the <em>ordinary</em> tables in <code class="func">IsOrdinaryTable</code>, the <em>Brauer</em> tables in <code class="func">IsBrauerTable</code>, the union of these two in <code class="func">IsCharacterTable</code>, and the <em>incomplete ordinary</em> tables in <code class="func">IsCharacterTableInProgress</code>.</p>

<p>We want to distinguish ordinary and Brauer tables because a Brauer table may delegate tasks to the ordinary table of the same group, for example the computation of power maps. A Brauer table is constructed from an ordinary table and stores this table upon construction (see <code class="func">OrdinaryCharacterTable</code> (<a href="chap71.html#X8011EEB684848039"><span class="RefLink">71.8-4</span></a>)).</p>

<p>Furthermore, <code class="func">IsOrdinaryTable</code> and <code class="func">IsBrauerTable</code> denote character tables that provide enough information to compute all power maps and irreducible characters (and in the case of Brauer tables to get the ordinary table), for example because the underlying group (see <code class="func">UnderlyingGroup</code> (<a href="chap71.html#X7FF4826A82B667AF"><span class="RefLink">71.6-1</span></a>)) is known or because the table is a library table (see the manual of the <strong class="pkg">GAP</strong> Character Table Library). We want to distinguish these tables from partially known ordinary tables that cannot be asked for all power maps or all irreducible characters.</p>

<p>The character table objects in <code class="func">IsCharacterTable</code> are always immutable (see <a href="chap12.html#X7F0C119682196D65"><span class="RefLink">12.6</span></a>). This means mainly that the ordering of conjugacy classes used for the various attributes of the character table cannot be changed; see <a href="chap71.html#X816FCD5A805F9FE8"><span class="RefLink">71.21</span></a> for how to compute a character table with a different ordering of classes.</p>

<p>The <strong class="pkg">GAP</strong> objects in <code class="func">IsCharacterTableInProgress</code> represent incomplete ordinary character tables. This means that not all irreducible characters, not all power maps are known, and perhaps even the number of classes and the centralizer orders are known. Such tables occur when the character table of a group <span class="SimpleMath">G</span> is constructed using character tables of related groups and information about <span class="SimpleMath">G</span> but for example without explicitly computing the conjugacy classes of <span class="SimpleMath">G</span>. An object in <code class="func">IsCharacterTableInProgress</code> is first of all <em>mutable</em>, so <em>nothing is stored automatically</em> on such a table, since otherwise one has no control of side-effects when a hypothesis is changed. Operations for such tables may return more general values than for other tables, for example class functions may contain unknowns (see Chapter <a href="chap74.html#X7C1FAB6280A02CCB"><span class="RefLink">74</span></a>) or lists of possible values in certain positions, the same may happen also for power maps and class fusions (see <a href="chap73.html#X7F18772E86F06179"><span class="RefLink">73.5</span></a>). <em>Incomplete tables in this sense are currently not supported and will be described in a chapter of their own when they become available.</em> Note that the term "incomplete table" shall express that <strong class="pkg">GAP</strong> cannot compute certain values such as irreducible characters or power maps. A table with access to its group is therefore always complete, also if its irreducible characters are not yet stored.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= SymmetricGroup( 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( g );  modtbl:= tbl mod 2;</span>
CharacterTable( Sym( [ 1 .. 4 ] ) )
BrauerTable( Sym( [ 1 .. 4 ] ), 2 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCharacterTable( tbl );  IsCharacterTable( modtbl );</span>
true
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsBrauerTable( modtbl );  IsBrauerTable( tbl );</span>
true
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOrdinaryTable( tbl );  IsOrdinaryTable( modtbl );</span>
true
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCharacterTable( g );  IsCharacterTable( Irr( g ) );</span>
false
false
</pre></div>

<p><a id="X7C6F3D947E5188D1" name="X7C6F3D947E5188D1"></a></p>

<h5>71.4-2 InfoCharacterTable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InfoCharacterTable</code></td><td class="tdright">(&nbsp;info class&nbsp;)</td></tr></table></div>
<p>is the info class (see <a href="chap7.html#X7A9C902479CB6F7C"><span class="RefLink">7.4</span></a>) for computations with character tables.</p>

<p><a id="X7FA867637EBB30F9" name="X7FA867637EBB30F9"></a></p>

<h5>71.4-3 NearlyCharacterTablesFamily</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NearlyCharacterTablesFamily</code></td><td class="tdright">(&nbsp;family&nbsp;)</td></tr></table></div>
<p>Every character table like object lies in this family (see <a href="chap13.html#X846063757EC05986"><span class="RefLink">13.1</span></a>).</p>

<p><a id="X829C4B6E83998F40" name="X829C4B6E83998F40"></a></p>

<h4>71.5 <span class="Heading">Conventions for Character Tables</span></h4>

<p>The following few conventions should be noted.</p>


<ul>
<li><p>The class of the <em>identity element</em> is expected to be the first one; thus the degree of a character is the character value at position <span class="SimpleMath">1</span>.</p>

</li>
<li><p>The <em>trivial character</em> of a character table need not be the first in the list of irreducibles.</p>

</li>
<li><p>Most functions that take a character table as an argument and work with characters expect these characters as an argument, too. For some functions, the list of irreducible characters serves as the default, i.e, the value of the attribute <code class="func">Irr</code> (<a href="chap71.html#X873B3CC57E9A5492"><span class="RefLink">71.8-2</span></a>); in these cases, the <code class="func">Irr</code> (<a href="chap71.html#X873B3CC57E9A5492"><span class="RefLink">71.8-2</span></a>) value is automatically computed if it was not yet known.</p>

</li>
<li><p>For a stored class fusion, the image table is denoted by its <code class="func">Identifier</code> (<a href="chap71.html#X79C40EE97890202F"><span class="RefLink">71.9-8</span></a>) value; each library table has a unique identifier by which it can be accessed (see <a href="../../pkg/ctbllib/doc/chap2.html#X84930B2D7849E019"><span class="RefLink">CTblLib: Accessing a Character Table from the Library</span></a> in the manual for the <strong class="pkg">GAP</strong> Character Table Library), tables constructed from groups get an identifier that is unique in the current <strong class="pkg">GAP</strong> session.</p>

</li>
</ul>
<p><a id="X793E0EBF84B07313" name="X793E0EBF84B07313"></a></p>

<h4>71.6 <span class="Heading">The Interface between Character Tables and Groups</span></h4>

<p>For a character table with underlying group (see <code class="func">UnderlyingGroup</code> (<a href="chap71.html#X7FF4826A82B667AF"><span class="RefLink">71.6-1</span></a>)), the interface between table and group consists of three attribute values, namely the <em>group</em>, the <em>conjugacy classes</em> stored in the table (see <code class="func">ConjugacyClasses</code> (<a href="chap71.html#X849A38F887F6EC86"><span class="RefLink">71.6-2</span></a>) below) and the <em>identification</em> of the conjugacy classes of table and group (see <code class="func">IdentificationOfConjugacyClasses</code> (<a href="chap71.html#X84DC12AA804C8085"><span class="RefLink">71.6-3</span></a>) below).</p>

<p>Character tables constructed from groups know these values upon construction, and for character tables constructed without groups, these values are usually not known and cannot be computed from the table.</p>

<p>However, given a group <span class="SimpleMath">G</span> and a character table of a group isomorphic to <span class="SimpleMath">G</span> (for example a character table from the <strong class="pkg">GAP</strong> table library), one can tell <strong class="pkg">GAP</strong> to compute a new instance of the given table and to use it as the character table of <span class="SimpleMath">G</span> (see <code class="func">CharacterTableWithStoredGroup</code> (<a href="chap71.html#X8788C6C7829C1ADE"><span class="RefLink">71.6-4</span></a>)).</p>

<p>Tasks may be delegated from a group to its character table or vice versa only if these three attribute values are stored in the character table.</p>

<p><a id="X7FF4826A82B667AF" name="X7FF4826A82B667AF"></a></p>

<h5>71.6-1 UnderlyingGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingGroup</code>( <var class="Arg">ordtbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For an ordinary character table <var class="Arg">ordtbl</var> of a finite group, the group can be stored as value of <code class="func">UnderlyingGroup</code>.</p>

<p>Brauer tables do not store the underlying group, they access it via the ordinary table (see <code class="func">OrdinaryCharacterTable</code> (<a href="chap71.html#X8011EEB684848039"><span class="RefLink">71.8-4</span></a>)).</p>

<p><a id="X849A38F887F6EC86" name="X849A38F887F6EC86"></a></p>

<h5>71.6-2 ConjugacyClasses</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConjugacyClasses</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For a character table <var class="Arg">tbl</var> with known underlying group <span class="SimpleMath">G</span>, the <code class="func">ConjugacyClasses</code> value of <var class="Arg">tbl</var> is a list of conjugacy classes of <span class="SimpleMath">G</span>. All those lists stored in the table that are related to the ordering of conjugacy classes (such as sizes of centralizers and conjugacy classes, orders of representatives, power maps, and all class functions) refer to the ordering of this list.</p>

<p>This ordering need <em>not</em> coincide with the ordering of conjugacy classes as stored in the underlying group of the table (see <a href="chap71.html#X816FCD5A805F9FE8"><span class="RefLink">71.21</span></a>). One reason for this is that otherwise we would not be allowed to use a library table as the character table of a group for which the conjugacy classes are stored already. (Another, less important reason is that we can use the same group as underlying group of character tables that differ only w.r.t. the ordering of classes.)</p>

<p>The class of the identity element must be the first class (see <a href="chap71.html#X829C4B6E83998F40"><span class="RefLink">71.5</span></a>).</p>

<p>If <var class="Arg">tbl</var> was constructed from <span class="SimpleMath">G</span> then the conjugacy classes have been stored at the same time when <span class="SimpleMath">G</span> was stored. If <span class="SimpleMath">G</span> and <var class="Arg">tbl</var> have been connected later than in the construction of <var class="Arg">tbl</var>, the recommended way to do this is via <code class="func">CharacterTableWithStoredGroup</code> (<a href="chap71.html#X8788C6C7829C1ADE"><span class="RefLink">71.6-4</span></a>). So there is no method for <code class="func">ConjugacyClasses</code> that computes the value for <var class="Arg">tbl</var> if it is not yet stored.</p>

<p>Brauer tables do not store the (<span class="SimpleMath">p</span>-regular) conjugacy classes, they access them via the ordinary table (see <code class="func">OrdinaryCharacterTable</code> (<a href="chap71.html#X8011EEB684848039"><span class="RefLink">71.8-4</span></a>)) if necessary.</p>

<p><a id="X84DC12AA804C8085" name="X84DC12AA804C8085"></a></p>

<h5>71.6-3 IdentificationOfConjugacyClasses</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IdentificationOfConjugacyClasses</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For an ordinary character table <var class="Arg">tbl</var> with known underlying group <span class="SimpleMath">G</span>, <code class="func">IdentificationOfConjugacyClasses</code> returns a list of positive integers that contains at position <span class="SimpleMath">i</span> the position of the <span class="SimpleMath">i</span>-th conjugacy class of <var class="Arg">tbl</var> in the <code class="func">ConjugacyClasses</code> (<a href="chap71.html#X849A38F887F6EC86"><span class="RefLink">71.6-2</span></a>) value of <span class="SimpleMath">G</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= SymmetricGroup( 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repres:= [ (1,2), (1,2,3), (1,2,3,4), (1,2)(3,4), () ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ccl:= List( repres, x -&gt; ConjugacyClass( g, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetConjugacyClasses( g, ccl );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( g );;   # the table stores already the values</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HasConjugacyClasses( tbl );  HasUnderlyingGroup( tbl );</span>
true
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingGroup( tbl ) = g;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HasIdentificationOfConjugacyClasses( tbl );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdentificationOfConjugacyClasses( tbl );</span>
[ 5, 1, 2, 3, 4 ]
</pre></div>

<p><a id="X8788C6C7829C1ADE" name="X8788C6C7829C1ADE"></a></p>

<h5>71.6-4 CharacterTableWithStoredGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CharacterTableWithStoredGroup</code>( <var class="Arg">G</var>, <var class="Arg">tbl</var>[, <var class="Arg">info</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">G</var> be a group and <var class="Arg">tbl</var> a character table of (a group isomorphic to) <var class="Arg">G</var>, such that <var class="Arg">G</var> does not store its <code class="func">OrdinaryCharacterTable</code> (<a href="chap71.html#X8011EEB684848039"><span class="RefLink">71.8-4</span></a>) value. <code class="func">CharacterTableWithStoredGroup</code> calls <code class="func">CompatibleConjugacyClasses</code> (<a href="chap71.html#X790019E87CFDDB98"><span class="RefLink">71.6-5</span></a>), trying to identify the classes of <var class="Arg">G</var> with the columns of <var class="Arg">tbl</var>.</p>

<p>If this identification is unique up to automorphisms of <var class="Arg">tbl</var> (see <code class="func">AutomorphismsOfTable</code> (<a href="chap71.html#X7C2753DE8094F4BA"><span class="RefLink">71.9-4</span></a>)) then <var class="Arg">tbl</var> is stored as <code class="func">CharacterTable</code> (<a href="chap71.html#X7FCA7A7A822BDA33"><span class="RefLink">71.3-1</span></a>) value of <var class="Arg">G</var>, and a new character table is returned that is equivalent to <var class="Arg">tbl</var>, is sorted in the same way as <var class="Arg">tbl</var>, and has the values of <code class="func">UnderlyingGroup</code> (<a href="chap71.html#X7FF4826A82B667AF"><span class="RefLink">71.6-1</span></a>), <code class="func">ConjugacyClasses</code> (<a href="chap71.html#X849A38F887F6EC86"><span class="RefLink">71.6-2</span></a>), and <code class="func">IdentificationOfConjugacyClasses</code> (<a href="chap71.html#X84DC12AA804C8085"><span class="RefLink">71.6-3</span></a>) set.</p>

<p>Otherwise, i.e., if <strong class="pkg">GAP</strong> cannot identify the classes of <var class="Arg">G</var> up to automorphisms of <var class="Arg">tbl</var>, <code class="keyw">fail</code> is returned.</p>

<p>If a record is present as the third argument <var class="Arg">info</var>, its meaning is the same as the optional argument <var class="Arg">arec</var> for <code class="func">CompatibleConjugacyClasses</code> (<a href="chap71.html#X790019E87CFDDB98"><span class="RefLink">71.6-5</span></a>).</p>

<p>If a list is entered as third argument <var class="Arg">info</var> it is used as value of <code class="func">IdentificationOfConjugacyClasses</code> (<a href="chap71.html#X84DC12AA804C8085"><span class="RefLink">71.6-3</span></a>), relative to the <code class="func">ConjugacyClasses</code> (<a href="chap71.html#X849A38F887F6EC86"><span class="RefLink">71.6-2</span></a>) value of <var class="Arg">G</var>, without further checking, and the corresponding character table is returned.</p>

<p><a id="X790019E87CFDDB98" name="X790019E87CFDDB98"></a></p>

<h5>71.6-5 CompatibleConjugacyClasses</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CompatibleConjugacyClasses</code>( [<var class="Arg">G</var>, <var class="Arg">ccl</var>, ]<var class="Arg">tbl</var>[, <var class="Arg">arec</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>If the arguments <var class="Arg">G</var> and <var class="Arg">ccl</var> are present then <var class="Arg">ccl</var> must be a list of the conjugacy classes of the group <var class="Arg">G</var>, and <var class="Arg">tbl</var> the ordinary character table of <var class="Arg">G</var>. Then <code class="func">CompatibleConjugacyClasses</code> returns a list <span class="SimpleMath">l</span> of positive integers that describes an identification of the columns of <var class="Arg">tbl</var> with the conjugacy classes <var class="Arg">ccl</var> in the sense that <span class="SimpleMath">l[i]</span> is the position in <var class="Arg">ccl</var> of the class corresponding to the <span class="SimpleMath">i</span>-th column of <var class="Arg">tbl</var>, if this identification is unique up to automorphisms of <var class="Arg">tbl</var> (see <code class="func">AutomorphismsOfTable</code> (<a href="chap71.html#X7C2753DE8094F4BA"><span class="RefLink">71.9-4</span></a>)); if <strong class="pkg">GAP</strong> cannot identify the classes, <code class="keyw">fail</code> is returned.</p>

<p>If <var class="Arg">tbl</var> is the first argument then it must be an ordinary character table, and <code class="func">CompatibleConjugacyClasses</code> checks whether the columns of <var class="Arg">tbl</var> can be identified with the conjugacy classes of a group isomorphic to that for which <var class="Arg">tbl</var> is the character table; the return value is a list of all those sets of class positions for which the columns of <var class="Arg">tbl</var> cannot be distinguished with the invariants used, up to automorphisms of <var class="Arg">tbl</var>. So the identification is unique if and only if the returned list is empty.</p>

<p>The usual approach is that one first calls <code class="func">CompatibleConjugacyClasses</code> in the second form for checking quickly whether the first form will be successful, and only if this is the case the more time consuming calculations with both group and character table are done.</p>

<p>The following invariants are used.</p>

<ol>
<li><p>element orders (see <code class="func">OrdersClassRepresentatives</code> (<a href="chap71.html#X86F455DA7A9C30EE"><span class="RefLink">71.9-1</span></a>)),</p>

</li>
<li><p>class lengths (see <code class="func">SizesConjugacyClasses</code> (<a href="chap71.html#X7D9D2A45879A6A62"><span class="RefLink">71.9-3</span></a>)),</p>

</li>
<li><p>power maps (see <code class="func">PowerMap</code> (<a href="chap73.html#X781FAA497E3B4D1A"><span class="RefLink">73.1-1</span></a>), <code class="func">ComputedPowerMaps</code> (<a href="chap73.html#X781FAA497E3B4D1A"><span class="RefLink">73.1-1</span></a>)),</p>

</li>
<li><p>symmetries of the table (see <code class="func">AutomorphismsOfTable</code> (<a href="chap71.html#X7C2753DE8094F4BA"><span class="RefLink">71.9-4</span></a>)).</p>

</li>
</ol>
<p>If the optional argument <var class="Arg">arec</var> is present then it must be a record whose components describe additional information for the class identification. The following components are supported.</p>


<dl>
<dt><strong class="Mark"><code class="code">natchar</code> </strong></dt>
<dd><p>if <span class="SimpleMath">G</span> is a permutation group or matrix group then the value of this component is regarded as the list of values of the natural character (see <code class="func">NaturalCharacter</code> (<a href="chap72.html#X82C01DDB82D751A9"><span class="RefLink">72.7-2</span></a>)) of <var class="Arg">G</var>, w.r.t. the ordering of classes in <var class="Arg">tbl</var>,</p>

</dd>
<dt><strong class="Mark"><code class="code">bijection</code> </strong></dt>
<dd><p>a list describing a partial bijection; the <span class="SimpleMath">i</span>-th entry, if bound, is the position of the <span class="SimpleMath">i</span>-th conjugacy class of <var class="Arg">tbl</var> in the list <var class="Arg">ccl</var>.</p>

</dd>
</dl>

<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= AlternatingGroup( 5 );</span>
Alt( [ 1 .. 5 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( "A5" );</span>
CharacterTable( "A5" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HasUnderlyingGroup( tbl );  HasOrdinaryCharacterTable( g );</span>
false
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CompatibleConjugacyClasses( tbl );   # unique identification</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">new:= CharacterTableWithStoredGroup( g, tbl );</span>
CharacterTable( Alt( [ 1 .. 5 ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Irr( new ) = Irr( tbl );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HasConjugacyClasses( new );  HasUnderlyingGroup( new );</span>
true
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdentificationOfConjugacyClasses( new );</span>
[ 1, 2, 3, 4, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># Here is an example where the identification is not unique.</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CompatibleConjugacyClasses( CharacterTable( "J2" ) );</span>
[ [ 17, 18 ], [ 9, 10 ] ]
</pre></div>

<p><a id="X7CADCBC9824CB624" name="X7CADCBC9824CB624"></a></p>

<h4>71.7 <span class="Heading">Operators for Character Tables</span></h4>

<p>The following infix operators are defined for character tables.</p>


<dl>
<dt><strong class="Mark"><code class="code"><var class="Arg">tbl1</var> * <var class="Arg">tbl2</var></code></strong></dt>
<dd><p>the direct product of two character tables (see <code class="func">CharacterTableDirectProduct</code> (<a href="chap71.html#X7BE1572D7BBC6AC8"><span class="RefLink">71.20-1</span></a>)),</p>

</dd>
<dt><strong class="Mark"><code class="code"><var class="Arg">tbl</var> / <var class="Arg">list</var></code></strong></dt>
<dd><p>the table of the factor group modulo the normal subgroup spanned by the classes in the list <var class="Arg">list</var> (see <code class="func">CharacterTableFactorGroup</code> (<a href="chap71.html#X7C3A4E5283B240BE"><span class="RefLink">71.20-3</span></a>)),</p>

</dd>
<dt><strong class="Mark"><code class="code"><var class="Arg">tbl</var> mod <var class="Arg">p</var></code></strong></dt>
<dd><p>the <var class="Arg">p</var>-modular Brauer character table corresponding to the ordinary character table <var class="Arg">tbl</var> (see <code class="func">BrauerTable</code> (<a href="chap71.html#X8476B25A79D7A7FC"><span class="RefLink">71.3-2</span></a>)),</p>

</dd>
<dt><strong class="Mark"><code class="code"><var class="Arg">tbl</var>.<var class="Arg">name</var></code></strong></dt>
<dd><p>the position of the class with name <var class="Arg">name</var> in <var class="Arg">tbl</var> (see <code class="func">ClassNames</code> (<a href="chap71.html#X804CFD597C795801"><span class="RefLink">71.9-6</span></a>)).</p>

</dd>
</dl>
<p><a id="X7F9D58208241D35E" name="X7F9D58208241D35E"></a></p>

<h4>71.8 <span class="Heading">Attributes and Properties for Groups and Character Tables</span></h4>

<p>Several <em>attributes for groups</em> are valid also for character tables.</p>

<p>These are first those that have the same meaning for both the group and its character table, and whose values can be read off or computed, respectively, from the character table, such as <code class="func">Size</code> (<a href="chap71.html#X81EFD9FE804AC6EE"><span class="RefLink">71.8-5</span></a>), <code class="func">IsAbelian</code> (<a href="chap71.html#X81EFD9FE804AC6EE"><span class="RefLink">71.8-5</span></a>), or <code class="func">IsSolvable</code> (<a href="chap71.html#X81EFD9FE804AC6EE"><span class="RefLink">71.8-5</span></a>).</p>

<p>Second, there are attributes whose meaning for character tables is different from the meaning for groups, such as <code class="func">ConjugacyClasses</code> (<a href="chap71.html#X849A38F887F6EC86"><span class="RefLink">71.6-2</span></a>).</p>

<p><a id="X81FEFF768134481A" name="X81FEFF768134481A"></a></p>

<h5>71.8-1 <span class="Heading">CharacterDegrees</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CharacterDegrees</code>( <var class="Arg">G</var>[, <var class="Arg">p</var>] )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CharacterDegrees</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>In the first form, <code class="func">CharacterDegrees</code> returns a collected list of the degrees of the absolutely irreducible characters of the group <var class="Arg">G</var>; the optional second argument <var class="Arg">p</var> must be either zero or a prime integer denoting the characteristic, the default value is zero. In the second form, <var class="Arg">tbl</var> must be an (ordinary or Brauer) character table, and <code class="func">CharacterDegrees</code> returns a collected list of the degrees of the absolutely irreducible characters of <var class="Arg">tbl</var>.</p>

<p>(The default method for the call with only argument a group is to call the operation with second argument <code class="code">0</code>.)</p>

<p>For solvable groups, the default method is based on <a href="chapBib.html#biBCon90b">[Con90b]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacterDegrees( SymmetricGroup( 4 ) );</span>
[ [ 1, 2 ], [ 2, 1 ], [ 3, 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacterDegrees( SymmetricGroup( 4 ), 2 );</span>
[ [ 1, 1 ], [ 2, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacterDegrees( CharacterTable( "A5" ) );</span>
[ [ 1, 1 ], [ 3, 2 ], [ 4, 1 ], [ 5, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacterDegrees( CharacterTable( "A5" ) mod 2 );</span>
[ [ 1, 1 ], [ 2, 2 ], [ 4, 1 ] ]
</pre></div>

<p><a id="X873B3CC57E9A5492" name="X873B3CC57E9A5492"></a></p>

<h5>71.8-2 <span class="Heading">Irr</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Irr</code>( <var class="Arg">G</var>[, <var class="Arg">p</var>] )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Irr</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Called with a group <var class="Arg">G</var>, <code class="func">Irr</code> returns the irreducible characters of the ordinary character table of <var class="Arg">G</var>. Called with a group <var class="Arg">G</var> and a prime integer <var class="Arg">p</var>, <code class="func">Irr</code> returns the irreducible characters of the <var class="Arg">p</var>-modular Brauer table of <var class="Arg">G</var>. Called with an (ordinary or Brauer) character table <var class="Arg">tbl</var>, <code class="func">Irr</code> returns the list of all complex absolutely irreducible characters of <var class="Arg">tbl</var>.</p>

<p>For a character table <var class="Arg">tbl</var> with underlying group, <code class="func">Irr</code> may delegate to the group. For a group <var class="Arg">G</var>, <code class="func">Irr</code> may delegate to its character table only if the irreducibles are already stored there.</p>

<p>(If <var class="Arg">G</var> is <var class="Arg">p</var>-solvable (see <code class="func">IsPSolvable</code> (<a href="chap39.html#X81130F9A7CFCF6BF"><span class="RefLink">39.15-24</span></a>)) then the <var class="Arg">p</var>-modular irreducible characters can be computed by the Fong-Swan Theorem; in all other cases, there may be no method.)</p>

<p>Note that the ordering of columns in the <code class="func">Irr</code> matrix of the group <var class="Arg">G</var> refers to the ordering of conjugacy classes in the <code class="func">CharacterTable</code> (<a href="chap71.html#X7FCA7A7A822BDA33"><span class="RefLink">71.3-1</span></a>) value of <var class="Arg">G</var>, which may differ from the ordering of conjugacy classes in <var class="Arg">G</var> (see <a href="chap71.html#X793E0EBF84B07313"><span class="RefLink">71.6</span></a>). As an extreme example, for a character table obtained from sorting the classes of the <code class="func">CharacterTable</code> (<a href="chap71.html#X7FCA7A7A822BDA33"><span class="RefLink">71.3-1</span></a>) value of <var class="Arg">G</var>, the ordering of columns in the <code class="func">Irr</code> matrix respects the sorting of classes (see <a href="chap71.html#X816FCD5A805F9FE8"><span class="RefLink">71.21</span></a>), so the irreducibles of such a table will in general not coincide with the irreducibles stored as the <code class="func">Irr</code> value of <var class="Arg">G</var> although also the sorted table stores the group <var class="Arg">G</var>.</p>

<p>The ordering of the entries in the attribute <code class="func">Irr</code> of a group need <em>not</em> coincide with the ordering of its <code class="func">IrreducibleRepresentations</code> (<a href="chap71.html#X7F29C5447B5DC102"><span class="RefLink">71.14-4</span></a>) value.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Irr( SymmetricGroup( 4 ) );</span>
[ Character( CharacterTable( Sym( [ 1 .. 4 ] ) ), [ 1, -1, 1, 1, -1 
     ] ), Character( CharacterTable( Sym( [ 1 .. 4 ] ) ), 
    [ 3, -1, -1, 0, 1 ] ), 
  Character( CharacterTable( Sym( [ 1 .. 4 ] ) ), [ 2, 0, 2, -1, 0 ] )
    , Character( CharacterTable( Sym( [ 1 .. 4 ] ) ), 
    [ 3, 1, -1, 0, -1 ] ), 
  Character( CharacterTable( Sym( [ 1 .. 4 ] ) ), [ 1, 1, 1, 1, 1 ] ) 
 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Irr( SymmetricGroup( 4 ), 2 );</span>
[ Character( BrauerTable( Sym( [ 1 .. 4 ] ), 2 ), [ 1, 1 ] ), 
  Character( BrauerTable( Sym( [ 1 .. 4 ] ), 2 ), [ 2, -1 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Irr( CharacterTable( "A5" ) );</span>
[ Character( CharacterTable( "A5" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), 
    [ 3, -1, 0, -E(5)-E(5)^4, -E(5)^2-E(5)^3 ] ), 
  Character( CharacterTable( "A5" ), 
    [ 3, -1, 0, -E(5)^2-E(5)^3, -E(5)-E(5)^4 ] ), 
  Character( CharacterTable( "A5" ), [ 4, 0, 1, -1, -1 ] ), 
  Character( CharacterTable( "A5" ), [ 5, 1, -1, 0, 0 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Irr( CharacterTable( "A5" ) mod 2 );</span>
[ Character( BrauerTable( "A5", 2 ), [ 1, 1, 1, 1 ] ), 
  Character( BrauerTable( "A5", 2 ), 
    [ 2, -1, E(5)+E(5)^4, E(5)^2+E(5)^3 ] ), 
  Character( BrauerTable( "A5", 2 ), 
    [ 2, -1, E(5)^2+E(5)^3, E(5)+E(5)^4 ] ), 
  Character( BrauerTable( "A5", 2 ), [ 4, 1, -1, -1 ] ) ]
</pre></div>

<p><a id="X8549899A7DE206BA" name="X8549899A7DE206BA"></a></p>

<h5>71.8-3 <span class="Heading">LinearCharacters</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LinearCharacters</code>( <var class="Arg">G</var>[, <var class="Arg">p</var>] )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LinearCharacters</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><code class="func">LinearCharacters</code> returns the linear (i.e., degree <span class="SimpleMath">1</span>) characters in the <code class="func">Irr</code> (<a href="chap71.html#X873B3CC57E9A5492"><span class="RefLink">71.8-2</span></a>) list of the group <var class="Arg">G</var> or the character table <var class="Arg">tbl</var>, respectively. In the second form, <code class="func">LinearCharacters</code> returns the <var class="Arg">p</var>-modular linear characters of the group <var class="Arg">G</var>.</p>

<p>For a character table <var class="Arg">tbl</var> with underlying group, <code class="func">LinearCharacters</code> may delegate to the group. For a group <var class="Arg">G</var>, <code class="func">LinearCharacters</code> may delegate to its character table only if the irreducibles are already stored there.</p>

<p>The ordering of linear characters in <var class="Arg">tbl</var> need not coincide with the ordering of linear characters in the irreducibles of <var class="Arg">tbl</var> (see <code class="func">Irr</code> (<a href="chap71.html#X873B3CC57E9A5492"><span class="RefLink">71.8-2</span></a>)).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LinearCharacters( SymmetricGroup( 4 ) );</span>
[ Character( CharacterTable( Sym( [ 1 .. 4 ] ) ), [ 1, 1, 1, 1, 1 ] ),
  Character( CharacterTable( Sym( [ 1 .. 4 ] ) ), [ 1, -1, 1, 1, -1 
     ] ) ]
</pre></div>

<p><a id="X8011EEB684848039" name="X8011EEB684848039"></a></p>

<h5>71.8-4 <span class="Heading">OrdinaryCharacterTable</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OrdinaryCharacterTable</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OrdinaryCharacterTable</code>( <var class="Arg">modtbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><code class="func">OrdinaryCharacterTable</code> returns the ordinary character table of the group <var class="Arg">G</var> or the Brauer character table <var class="Arg">modtbl</var>, respectively.</p>

<p>Since Brauer character tables are constructed from ordinary tables, the attribute value for <var class="Arg">modtbl</var> is already stored (cf. <a href="chap71.html#X789FAC077AEF088A"><span class="RefLink">71.4</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrdinaryCharacterTable( SymmetricGroup( 4 ) );</span>
CharacterTable( Sym( [ 1 .. 4 ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( "A5" );;  modtbl:= tbl mod 2;</span>
BrauerTable( "A5", 2 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrdinaryCharacterTable( modtbl ) = tbl;</span>
true
</pre></div>

<p><a id="X81EFD9FE804AC6EE" name="X81EFD9FE804AC6EE"></a></p>

<h5>71.8-5 <span class="Heading">Group Operations Applicable to Character Tables</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AbelianInvariants</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CommutatorLength</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Exponent</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsAbelian</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsAlmostSimple</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCyclic</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsElementaryAbelian</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFinite</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsMonomial</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsNilpotent</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPerfect</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSimple</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSolvable</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSporadicSimple</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSupersolvable</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismTypeInfoFiniteSimpleGroup</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NrConjugacyClasses</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Size</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>These operations for groups are applicable to character tables and mean the same for a character table as for its underlying group; see Chapter <a href="chap39.html#X8716635F7951801B"><span class="RefLink">39</span></a> for the definitions. The operations are mainly useful for selecting character tables with certain properties, also for character tables without access to a group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tables:= [ CharacterTable( CyclicGroup( 3 ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              CharacterTable( SymmetricGroup( 4 ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              CharacterTable( AlternatingGroup( 5 ) ) ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( tables, AbelianInvariants );</span>
[ [ 3 ], [ 2 ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( tables, CommutatorLength );</span>
[ 1, 1, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( tables, Exponent );</span>
[ 3, 12, 30 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( tables, IsAbelian );</span>
[ true, false, false ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( tables, IsAlmostSimple );</span>
[ false, false, true ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( tables, IsCyclic );</span>
[ true, false, false ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( tables, IsFinite );</span>
[ true, true, true ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( tables, IsMonomial );</span>
[ true, true, false ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( tables, IsNilpotent );</span>
[ true, false, false ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( tables, IsPerfect );</span>
[ false, false, true ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( tables, IsSimple );</span>
[ true, false, true ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( tables, IsSolvable );</span>
[ true, true, false ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( tables, IsSupersolvable );</span>
[ true, false, false ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( tables, NrConjugacyClasses );</span>
[ 3, 5, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( tables, Size );</span>
[ 3, 24, 60 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphismTypeInfoFiniteSimpleGroup( CharacterTable( "C5" ) );</span>
rec( name := "Z(5)", parameter := 5, series := "Z", shortname := "C5" 
 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphismTypeInfoFiniteSimpleGroup( CharacterTable( "S3" ) );</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphismTypeInfoFiniteSimpleGroup( CharacterTable( "S6(3)" ) );</span>
rec( name := "C(3,3) = S(6,3)", parameter := [ 3, 3 ], series := "C", 
  shortname := "S6(3)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphismTypeInfoFiniteSimpleGroup( CharacterTable( "O7(3)" ) );</span>
rec( name := "B(3,3) = O(7,3)", parameter := [ 3, 3 ], series := "B", 
  shortname := "O7(3)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphismTypeInfoFiniteSimpleGroup( CharacterTable( "A8" ) );</span>
rec( name := "A(8) ~ A(3,2) = L(4,2) ~ D(3,2) = O+(6,2)", 
  parameter := 8, series := "A", shortname := "A8" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphismTypeInfoFiniteSimpleGroup( CharacterTable( "L3(4)" ) );</span>
rec( name := "A(2,4) = L(3,4)", parameter := [ 3, 4 ], series := "L", 
  shortname := "L3(4)" )
</pre></div>

<p><a id="X7995A2AD83BC58A0" name="X7995A2AD83BC58A0"></a></p>

<h4>71.9 <span class="Heading">Attributes and Properties only for Character Tables</span></h4>

<p>The following three <em>attributes for character tables</em> –<code class="func">OrdersClassRepresentatives</code> (<a href="chap71.html#X86F455DA7A9C30EE"><span class="RefLink">71.9-1</span></a>), <code class="func">SizesCentralizers</code> (<a href="chap71.html#X7CF7907F790A5DE6"><span class="RefLink">71.9-2</span></a>), and <code class="func">SizesConjugacyClasses</code> (<a href="chap71.html#X7D9D2A45879A6A62"><span class="RefLink">71.9-3</span></a>)– would make sense also for groups but are in fact <em>not</em> used for groups. This is because the values depend on the ordering of conjugacy classes stored as the value of <code class="func">ConjugacyClasses</code> (<a href="chap71.html#X849A38F887F6EC86"><span class="RefLink">71.6-2</span></a>), and this value may differ for a group and its character table (see <a href="chap71.html#X793E0EBF84B07313"><span class="RefLink">71.6</span></a>). Note that for character tables, the consistency of attribute values must be guaranteed, whereas for groups, there is no need to impose such a consistency rule.</p>

<p>The other attributes introduced in this section apply only to character tables, not to groups.</p>

<p><a id="X86F455DA7A9C30EE" name="X86F455DA7A9C30EE"></a></p>

<h5>71.9-1 OrdersClassRepresentatives</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OrdersClassRepresentatives</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>is a list of orders of representatives of conjugacy classes of the character table <var class="Arg">tbl</var>, in the same ordering as the conjugacy classes of <var class="Arg">tbl</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( "A5" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrdersClassRepresentatives( tbl );</span>
[ 1, 2, 3, 5, 5 ]
</pre></div>

<p><a id="X7CF7907F790A5DE6" name="X7CF7907F790A5DE6"></a></p>

<h5>71.9-2 SizesCentralizers</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SizesCentralizers</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SizesCentralisers</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>is a list that stores at position <span class="SimpleMath">i</span> the size of the centralizer of any element in the <span class="SimpleMath">i</span>-th conjugacy class of the character table <var class="Arg">tbl</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( "A5" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizesCentralizers( tbl );</span>
[ 60, 4, 3, 5, 5 ]
</pre></div>

<p><a id="X7D9D2A45879A6A62" name="X7D9D2A45879A6A62"></a></p>

<h5>71.9-3 SizesConjugacyClasses</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SizesConjugacyClasses</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>is a list that stores at position <span class="SimpleMath">i</span> the size of the <span class="SimpleMath">i</span>-th conjugacy class of the character table <var class="Arg">tbl</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( "A5" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizesConjugacyClasses( tbl );</span>
[ 1, 15, 20, 12, 12 ]
</pre></div>

<p><a id="X7C2753DE8094F4BA" name="X7C2753DE8094F4BA"></a></p>

<h5>71.9-4 AutomorphismsOfTable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AutomorphismsOfTable</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>is the permutation group of all column permutations of the character table <var class="Arg">tbl</var> that leave the set of irreducibles and each power map of <var class="Arg">tbl</var> invariant (see also <code class="func">TableAutomorphisms</code> (<a href="chap71.html#X8082DD827C673138"><span class="RefLink">71.22-2</span></a>)).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( "Dihedral", 8 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AutomorphismsOfTable( tbl );</span>
Group([ (4,5) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrdersClassRepresentatives( tbl );</span>
[ 1, 4, 2, 2, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizesConjugacyClasses( tbl );</span>
[ 1, 2, 1, 2, 2 ]
</pre></div>

<p><a id="X7F58A82F7D88000A" name="X7F58A82F7D88000A"></a></p>

<h5>71.9-5 <span class="Heading">UnderlyingCharacteristic</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingCharacteristic</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingCharacteristic</code>( <var class="Arg">psi</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For an ordinary character table <var class="Arg">tbl</var>, the result is <code class="code">0</code>, for a <span class="SimpleMath">p</span>-modular Brauer table <var class="Arg">tbl</var>, it is <span class="SimpleMath">p</span>. The underlying characteristic of a class function <var class="Arg">psi</var> is equal to that of its underlying character table.</p>

<p>The underlying characteristic must be stored when the table is constructed, there is no method to compute it.</p>

<p>We cannot use the attribute <code class="func">Characteristic</code> (<a href="chap31.html#X81278E53800BF64D"><span class="RefLink">31.10-1</span></a>) to denote this, since of course each Brauer character is an element of characteristic zero in the sense of <strong class="pkg">GAP</strong> (see Chapter <a href="chap72.html#X7C91D0D17850E564"><span class="RefLink">72</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( "A5" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingCharacteristic( tbl );</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingCharacteristic( tbl mod 17 );</span>
17
</pre></div>

<p><a id="X804CFD597C795801" name="X804CFD597C795801"></a></p>

<h5>71.9-6 <span class="Heading">Class Names and Character Names</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassNames</code>( <var class="Arg">tbl</var>[, <var class="Arg">"ATLAS"</var>] )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CharacterNames</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><code class="func">ClassNames</code> and <code class="func">CharacterNames</code> return lists of strings, one for each conjugacy class or irreducible character, respectively, of the character table <var class="Arg">tbl</var>. These names are used when <var class="Arg">tbl</var> is displayed.</p>

<p>The default method for <code class="func">ClassNames</code> computes class names consisting of the order of an element in the class and at least one distinguishing letter.</p>

<p>The default method for <code class="func">CharacterNames</code> returns the list <code class="code">[ "X.1", "X.2", ... ]</code>, whose length is the number of irreducible characters of <var class="Arg">tbl</var>.</p>

<p>The position of the class with name <var class="Arg">name</var> in <var class="Arg">tbl</var> can be accessed as <code class="code"><var class="Arg">tbl</var>.<var class="Arg">name</var></code>.</p>

<p>When <code class="func">ClassNames</code> is called with two arguments, the second being the string <code class="code">"ATLAS"</code>, the class names returned obey the convention used in the <strong class="pkg">Atlas</strong> of Finite Groups <a href="chapBib.html#biBCCN85">[CCN+85, Chapter 7, Section 5]</a>. If one is interested in "relative" class names of almost simple <strong class="pkg">Atlas</strong> groups, one can use the function <code class="func">AtlasClassNames</code> (<a href="../../pkg/atlasrep/doc/chap3.html#X78166D1D7D18EFBF"><span class="RefLink">AtlasRep: AtlasClassNames</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( "A5" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassNames( tbl );</span>
[ "1a", "2a", "3a", "5a", "5b" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl.2a;</span>
2
</pre></div>

<p><a id="X8333E8038308947E" name="X8333E8038308947E"></a></p>

<h5>71.9-7 <span class="Heading">Class Parameters and Character Parameters</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassParameters</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CharacterParameters</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The values of these attributes are lists containing a parameter for each conjugacy class or irreducible character, respectively, of the character table <var class="Arg">tbl</var>.</p>

<p>It depends on <var class="Arg">tbl</var> what these parameters are, so there is no default to compute class and character parameters.</p>

<p>For example, the classes of symmetric groups can be parametrized by partitions, corresponding to the cycle structures of permutations. Character tables constructed from generic character tables (see the manual of the <strong class="pkg">GAP</strong> Character Table Library) usually have class and character parameters stored.</p>

<p>If <var class="Arg">tbl</var> is a <span class="SimpleMath">p</span>-modular Brauer table such that class parameters are stored in the underlying ordinary table (see <code class="func">OrdinaryCharacterTable</code> (<a href="chap71.html#X8011EEB684848039"><span class="RefLink">71.8-4</span></a>)) of <var class="Arg">tbl</var> then <code class="func">ClassParameters</code> returns the sublist of class parameters of the ordinary table, for <span class="SimpleMath">p</span>-regular classes.</p>

<p><a id="X79C40EE97890202F" name="X79C40EE97890202F"></a></p>

<h5>71.9-8 Identifier</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Identifier</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>is a string that identifies the character table <var class="Arg">tbl</var> in the current <strong class="pkg">GAP</strong> session. It is used mainly for class fusions into <var class="Arg">tbl</var> that are stored on other character tables. For character tables without group, the identifier is also used to print the table; this is the case for library tables, but also for tables that are constructed as direct products, factors etc. involving tables that may or may not store their groups.</p>

<p>The default method for ordinary tables constructs strings of the form <code class="code">"CT<var class="Arg">n</var>"</code>, where <var class="Arg">n</var> is a positive integer. <code class="code">LARGEST_IDENTIFIER_NUMBER</code> is a list containing the largest integer <var class="Arg">n</var> used in the current <strong class="pkg">GAP</strong> session.</p>

<p>The default method for Brauer tables returns the concatenation of the identifier of the ordinary table, the string <code class="code">"mod"</code>, and the (string of the) underlying characteristic.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Identifier( CharacterTable( "A5" ) );</span>
"A5"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( Group( () ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Identifier( tbl );  Identifier( tbl mod 2 );</span>
"CT8"
"CT8mod2"
</pre></div>

<p><a id="X7932C35180C80953" name="X7932C35180C80953"></a></p>

<h5>71.9-9 InfoText</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InfoText</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>is a mutable string with information about the character table <var class="Arg">tbl</var>. There is no default method to create an info text.</p>

<p>This attribute is used mainly for library tables (see the manual of the <strong class="pkg">GAP</strong> Character Table Library). Usual parts of the information are the origin of the table, tests it has passed (<code class="code">1.o.r.</code> for the test of orthogonality, <code class="code">pow[<var class="Arg">p</var>]</code> for the construction of the <var class="Arg">p</var>-th power map, <code class="code">DEC</code> for the decomposition of ordinary into Brauer characters, <code class="code">TENS</code> for the decomposition of tensor products of irreducibles), and choices made without loss of generality.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Print( InfoText( CharacterTable( "A5" ) ), "\n" );</span>
origin: ATLAS of finite groups, tests: 1.o.r., pow[2,3,5]
</pre></div>

<p><a id="X7919E2897BE8234A" name="X7919E2897BE8234A"></a></p>

<h5>71.9-10 InverseClasses</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InverseClasses</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For a character table <var class="Arg">tbl</var>, <code class="func">InverseClasses</code> returns the list mapping each conjugacy class to its inverse class. This list can be regarded as <span class="SimpleMath">(-1)</span>-st power map of <var class="Arg">tbl</var> (see <code class="func">PowerMap</code> (<a href="chap73.html#X781FAA497E3B4D1A"><span class="RefLink">73.1-1</span></a>)).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InverseClasses( CharacterTable( "A5" ) );</span>
[ 1, 2, 3, 4, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InverseClasses( CharacterTable( "Cyclic", 3 ) );</span>
[ 1, 3, 2 ]
</pre></div>

<p><a id="X87FF547981456932" name="X87FF547981456932"></a></p>

<h5>71.9-11 RealClasses</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RealClasses</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For a character table <var class="Arg">tbl</var>, <code class="func">RealClasses</code> returns the strictly sorted list of positions of classes in <var class="Arg">tbl</var> that consist of real elements.</p>

<p>An element <span class="SimpleMath">x</span> is <em>real</em> iff it is conjugate to its inverse <span class="SimpleMath">x^{-1} = x^{o(x)-1}</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RealClasses( CharacterTable( "A5" ) );</span>
[ 1, 2, 3, 4, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RealClasses( CharacterTable( "Cyclic", 3 ) );</span>
[ 1 ]
</pre></div>

<p><a id="X7ABB007C799F7C49" name="X7ABB007C799F7C49"></a></p>

<h5>71.9-12 ClassOrbit</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassOrbit</code>( <var class="Arg">tbl</var>, <var class="Arg">cc</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>is the list of positions of those conjugacy classes of the character table <var class="Arg">tbl</var> that are Galois conjugate to the <var class="Arg">cc</var>-th class. That is, exactly the classes at positions given by the list returned by <code class="func">ClassOrbit</code> contain generators of the cyclic group generated by an element in the <var class="Arg">cc</var>-th class.</p>

<p>This information is computed from the power maps of <var class="Arg">tbl</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassOrbit( CharacterTable( "A5" ), 4 );</span>
[ 4, 5 ]
</pre></div>

<p><a id="X7F863B15804E0835" name="X7F863B15804E0835"></a></p>

<h5>71.9-13 ClassRoots</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassRoots</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For a character table <var class="Arg">tbl</var>, <code class="func">ClassRoots</code> returns a list containing at position <span class="SimpleMath">i</span> the list of positions of the classes of all nontrivial <span class="SimpleMath">p</span>-th roots, where <span class="SimpleMath">p</span> runs over the prime divisors of the <code class="func">Size</code> (<a href="chap71.html#X81EFD9FE804AC6EE"><span class="RefLink">71.8-5</span></a>) value of <var class="Arg">tbl</var>.</p>

<p>This information is computed from the power maps of <var class="Arg">tbl</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassRoots( CharacterTable( "A5" ) );</span>
[ [ 2, 3, 4, 5 ], [  ], [  ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassRoots( CharacterTable( "Cyclic", 6 ) );</span>
[ [ 3, 4, 5 ], [  ], [ 2 ], [ 2, 6 ], [ 6 ], [  ] ]
</pre></div>

<p><a id="X79CEBC3C7E0E63DF" name="X79CEBC3C7E0E63DF"></a></p>

<h4>71.10 <span class="Heading">Normal Subgroups Represented by Lists of Class Positions</span></h4>

<p>The following attributes for a character table <var class="Arg">tbl</var> correspond to attributes for the group <span class="SimpleMath">G</span> of <var class="Arg">tbl</var>. But instead of a normal subgroup (or a list of normal subgroups) of <span class="SimpleMath">G</span>, they return a strictly sorted list of positive integers (or a list of such lists) which are the positions –relative to the <code class="func">ConjugacyClasses</code> (<a href="chap71.html#X849A38F887F6EC86"><span class="RefLink">71.6-2</span></a>) value of <var class="Arg">tbl</var>– of those classes forming the normal subgroup in question.</p>

<p><a id="X850C7D947B3DBFA2" name="X850C7D947B3DBFA2"></a></p>

<h5>71.10-1 ClassPositionsOfNormalSubgroups</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassPositionsOfNormalSubgroups</code>( <var class="Arg">ordtbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassPositionsOfMaximalNormalSubgroups</code>( <var class="Arg">ordtbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassPositionsOfMinimalNormalSubgroups</code>( <var class="Arg">ordtbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>correspond to <code class="func">NormalSubgroups</code> (<a href="chap39.html#X80237A847E24E6CF"><span class="RefLink">39.19-9</span></a>), <code class="func">MaximalNormalSubgroups</code> (<a href="chap39.html#X82ECAA427C987318"><span class="RefLink">39.19-10</span></a>), <code class="func">MinimalNormalSubgroups</code> (<a href="chap39.html#X86FDD9BA819F5644"><span class="RefLink">39.19-11</span></a>) for the group of the ordinary character table <var class="Arg">ordtbl</var>.</p>

<p>The entries of the result lists are sorted according to increasing length. (So this total order respects the partial order of normal subgroups given by inclusion.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbls4:= CharacterTable( "Symmetric", 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassPositionsOfNormalSubgroups( tbls4 );</span>
[ [ 1 ], [ 1, 3 ], [ 1, 3, 4 ], [ 1 .. 5 ] ]
</pre></div>

<p><a id="X8491DA0981D6F264" name="X8491DA0981D6F264"></a></p>

<h5>71.10-2 ClassPositionsOfAgemo</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassPositionsOfAgemo</code>( <var class="Arg">ordtbl</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>corresponds to <code class="func">Agemo</code> (<a href="chap39.html#X83DB33747F069ACC"><span class="RefLink">39.14-2</span></a>) for the group of the ordinary character table <var class="Arg">ordtbl</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbls4:= CharacterTable( "Symmetric", 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassPositionsOfAgemo( tbls4, 2 );</span>
[ 1, 3, 4 ]
</pre></div>

<p><a id="X7A6B1F8A84A495DC" name="X7A6B1F8A84A495DC"></a></p>

<h5>71.10-3 ClassPositionsOfCentre</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassPositionsOfCentre</code>( <var class="Arg">ordtbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassPositionsOfCenter</code>( <var class="Arg">ordtbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>corresponds to <code class="func">Centre</code> (<a href="chap35.html#X847ABE6F781C7FE8"><span class="RefLink">35.4-5</span></a>) for the group of the ordinary character table <var class="Arg">ordtbl</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbld8:= CharacterTable( "Dihedral", 8 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassPositionsOfCentre( tbld8 );</span>
[ 1, 3 ]
</pre></div>

<p><a id="X7D53F60785AB22B1" name="X7D53F60785AB22B1"></a></p>

<h5>71.10-4 ClassPositionsOfDirectProductDecompositions</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassPositionsOfDirectProductDecompositions</code>( <var class="Arg">tbl</var>[, <var class="Arg">nclasses</var>] )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">tbl</var> be the ordinary character table of the group <span class="SimpleMath">G</span>, say. Called with the only argument <var class="Arg">tbl</var>, <code class="func">ClassPositionsOfDirectProductDecompositions</code> returns the list of all those pairs <span class="SimpleMath">[ l_1, l_2 ]</span> where <span class="SimpleMath">l_1</span> and <span class="SimpleMath">l_2</span> are lists of class positions of normal subgroups <span class="SimpleMath">N_1</span>, <span class="SimpleMath">N_2</span> of <span class="SimpleMath">G</span> such that <span class="SimpleMath">G</span> is their direct product and <span class="SimpleMath">|N_1| ≤ |N_2|</span> holds. Called with second argument a list <var class="Arg">nclasses</var> of class positions of a normal subgroup <span class="SimpleMath">N</span> of <span class="SimpleMath">G</span>, <code class="func">ClassPositionsOfDirectProductDecompositions</code> returns the list of pairs describing the decomposition of <span class="SimpleMath">N</span> as a direct product of two normal subgroups of <span class="SimpleMath">G</span>.</p>

<p><a id="X79EE7BE17BD343D5" name="X79EE7BE17BD343D5"></a></p>

<h5>71.10-5 ClassPositionsOfDerivedSubgroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassPositionsOfDerivedSubgroup</code>( <var class="Arg">ordtbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>corresponds to <code class="func">DerivedSubgroup</code> (<a href="chap39.html#X7CC17CF179ED7EF2"><span class="RefLink">39.12-3</span></a>) for the group of the ordinary character table <var class="Arg">ordtbl</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbld8:= CharacterTable( "Dihedral", 8 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassPositionsOfDerivedSubgroup( tbld8 );</span>
[ 1, 3 ]
</pre></div>

<p><a id="X86ABB2E179D7F6E1" name="X86ABB2E179D7F6E1"></a></p>

<h5>71.10-6 ClassPositionsOfElementaryAbelianSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassPositionsOfElementaryAbelianSeries</code>( <var class="Arg">ordtbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>corresponds to <code class="func">ElementaryAbelianSeries</code> (<a href="chap39.html#X83F057E5791944D6"><span class="RefLink">39.17-9</span></a>) for the group of the ordinary character table <var class="Arg">ordtbl</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbls4:= CharacterTable( "Symmetric", 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbla5:= CharacterTable( "A5" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassPositionsOfElementaryAbelianSeries( tbls4 );</span>
[ [ 1 .. 5 ], [ 1, 3, 4 ], [ 1, 3 ], [ 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassPositionsOfElementaryAbelianSeries( tbla5 );</span>
fail
</pre></div>

<p><a id="X7D2A55A584F955DB" name="X7D2A55A584F955DB"></a></p>

<h5>71.10-7 ClassPositionsOfFittingSubgroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassPositionsOfFittingSubgroup</code>( <var class="Arg">ordtbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>corresponds to <code class="func">FittingSubgroup</code> (<a href="chap39.html#X780552B57C30DD8F"><span class="RefLink">39.12-5</span></a>) for the group of the ordinary character table <var class="Arg">ordtbl</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbls4:= CharacterTable( "Symmetric", 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassPositionsOfFittingSubgroup( tbls4 );</span>
[ 1, 3 ]
</pre></div>

<p><a id="X79AEFC4384769B72" name="X79AEFC4384769B72"></a></p>

<h5>71.10-8 ClassPositionsOfLowerCentralSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassPositionsOfLowerCentralSeries</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>corresponds to <code class="func">LowerCentralSeriesOfGroup</code> (<a href="chap39.html#X879D55A67DB42676"><span class="RefLink">39.17-11</span></a>) for the group of the ordinary character table <var class="Arg">ordtbl</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbls4:= CharacterTable( "Symmetric", 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbld8:= CharacterTable( "Dihedral", 8 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassPositionsOfLowerCentralSeries( tbls4 );</span>
[ [ 1 .. 5 ], [ 1, 3, 4 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassPositionsOfLowerCentralSeries( tbld8 );</span>
[ [ 1 .. 5 ], [ 1, 3 ], [ 1 ] ]
</pre></div>

<p><a id="X86065D217A36CD9B" name="X86065D217A36CD9B"></a></p>

<h5>71.10-9 ClassPositionsOfUpperCentralSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassPositionsOfUpperCentralSeries</code>( <var class="Arg">ordtbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>corresponds to <code class="func">UpperCentralSeriesOfGroup</code> (<a href="chap39.html#X8428592E8773CD7B"><span class="RefLink">39.17-12</span></a>) for the group of the ordinary character table <var class="Arg">ordtbl</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbls4:= CharacterTable( "Symmetric", 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbld8:= CharacterTable( "Dihedral", 8 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassPositionsOfUpperCentralSeries( tbls4 );</span>
[ [ 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassPositionsOfUpperCentralSeries( tbld8 );</span>
[ [ 1, 3 ], [ 1, 2, 3, 4, 5 ] ]
</pre></div>

<p><a id="X877FDE8A84A9F52C" name="X877FDE8A84A9F52C"></a></p>

<h5>71.10-10 ClassPositionsOfSolvableRadical</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassPositionsOfSolvableRadical</code>( <var class="Arg">ordtbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>corresponds to <code class="func">RadicalGroup</code> (<a href="chap39.html#X787F5F14844FAACE"><span class="RefLink">39.12-9</span></a>) for the group of the ordinary character table <var class="Arg">ordtbl</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassPositionsOfSolvableRadical( CharacterTable( "2.A5" ) );</span>
[ 1, 2 ]
</pre></div>

<p><a id="X8392DD5B813250A4" name="X8392DD5B813250A4"></a></p>

<h5>71.10-11 ClassPositionsOfSupersolvableResiduum</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassPositionsOfSupersolvableResiduum</code>( <var class="Arg">ordtbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>corresponds to <code class="func">SupersolvableResiduum</code> (<a href="chap39.html#X8440C61080CDAA14"><span class="RefLink">39.12-11</span></a>) for the group of the ordinary character table <var class="Arg">ordtbl</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbls4:= CharacterTable( "Symmetric", 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassPositionsOfSupersolvableResiduum( tbls4 );</span>
[ 1, 3 ]
</pre></div>

<p><a id="X7BBE7EBA7A64A6B0" name="X7BBE7EBA7A64A6B0"></a></p>

<h5>71.10-12 ClassPositionsOfPCore</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassPositionsOfPCore</code>( <var class="Arg">ordtbl</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>corresponds to <code class="func">PCore</code> (<a href="chap39.html#X7CF497C77B1E8938"><span class="RefLink">39.11-3</span></a>) for the group of the ordinary character table <var class="Arg">ordtbl</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbls4:= CharacterTable( "Symmetric", 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassPositionsOfPCore( tbls4, 2 );</span>
[ 1, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassPositionsOfPCore( tbls4, 3 );</span>
[ 1 ]
</pre></div>

<p><a id="X7FCF905D7FD7CC40" name="X7FCF905D7FD7CC40"></a></p>

<h5>71.10-13 ClassPositionsOfNormalClosure</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassPositionsOfNormalClosure</code>( <var class="Arg">ordtbl</var>, <var class="Arg">classes</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>is the sorted list of the positions of all conjugacy classes of the ordinary character table <var class="Arg">ordtbl</var> that form the normal closure (see <code class="func">NormalClosure</code> (<a href="chap39.html#X7BDEA0A98720D1BB"><span class="RefLink">39.11-4</span></a>)) of the conjugacy classes at positions in the list <var class="Arg">classes</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbls4:= CharacterTable( "Symmetric", 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassPositionsOfNormalClosure( tbls4, [ 1, 4 ] );</span>
[ 1, 3, 4 ]
</pre></div>

<p><a id="X8733F0EA801785D4" name="X8733F0EA801785D4"></a></p>

<h4>71.11 <span class="Heading">Operations Concerning Blocks</span></h4>

<p><a id="X7ACB9306804F4E3F" name="X7ACB9306804F4E3F"></a></p>

<h5>71.11-1 PrimeBlocks</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PrimeBlocks</code>( <var class="Arg">ordtbl</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PrimeBlocksOp</code>( <var class="Arg">ordtbl</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ComputedPrimeBlockss</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For an ordinary character table <var class="Arg">ordtbl</var> and a prime integer <var class="Arg">p</var>, <code class="func">PrimeBlocks</code> returns a record with the following components.</p>


<dl>
<dt><strong class="Mark"><code class="code">block</code></strong></dt>
<dd><p>a list, the value <span class="SimpleMath">j</span> at position <span class="SimpleMath">i</span> means that the <span class="SimpleMath">i</span>-th irreducible character of <var class="Arg">ordtbl</var> lies in the <span class="SimpleMath">j</span>-th <var class="Arg">p</var>-block of <var class="Arg">ordtbl</var>,</p>

</dd>
<dt><strong class="Mark"><code class="code">defect</code></strong></dt>
<dd><p>a list containing at position <span class="SimpleMath">i</span> the defect of the <span class="SimpleMath">i</span>-th block,</p>

</dd>
<dt><strong class="Mark"><code class="code">height</code></strong></dt>
<dd><p>a list containing at position <span class="SimpleMath">i</span> the height of the <span class="SimpleMath">i</span>-th irreducible character of <var class="Arg">ordtbl</var> in its block,</p>

</dd>
<dt><strong class="Mark"><code class="code">relevant</code></strong></dt>
<dd><p>a list of class positions such that only the restriction to these classes need be checked for deciding whether two characters lie in the same block, and</p>

</dd>
<dt><strong class="Mark"><code class="code">centralcharacter</code></strong></dt>
<dd><p>a list containing at position <span class="SimpleMath">i</span> a list whose values at the positions stored in the component <code class="code">relevant</code> are the values of a central character in the <span class="SimpleMath">i</span>-th block.</p>

</dd>
</dl>
<p>The components <code class="code">relevant</code> and <code class="code">centralcharacters</code> are used by <code class="func">SameBlock</code> (<a href="chap71.html#X7E80E35985275F35"><span class="RefLink">71.11-2</span></a>).</p>

<p>If <code class="func">InfoCharacterTable</code> (<a href="chap71.html#X7C6F3D947E5188D1"><span class="RefLink">71.4-2</span></a>) has level at least 2, the defects of the blocks and the heights of the characters are printed.</p>

<p>The default method uses the attribute <code class="func">ComputedPrimeBlockss</code> for storing the computed value at position <var class="Arg">p</var>, and calls the operation <code class="func">PrimeBlocksOp</code> for computing values that are not yet known.</p>

<p>Two ordinary irreducible characters <span class="SimpleMath">χ, ψ</span> of a group <span class="SimpleMath">G</span> are said to lie in the same <span class="SimpleMath">p</span>-<em>block</em> if the images of their central characters <span class="SimpleMath">ω_χ, ω_ψ</span> (see <code class="func">CentralCharacter</code> (<a href="chap72.html#X7DD8FDCF7FB7834A"><span class="RefLink">72.8-17</span></a>)) under the natural ring epimorphism <span class="SimpleMath">R → R / M</span> are equal, where <span class="SimpleMath">R</span> denotes the ring of algebraic integers in the complex number field, and <span class="SimpleMath">M</span> is a maximal ideal in <span class="SimpleMath">R</span> with <span class="SimpleMath">pR ⊆ M</span>. (The distribution to <span class="SimpleMath">p</span>-blocks is in fact independent of the choice of <span class="SimpleMath">M</span>, see <a href="chapBib.html#biBIsa76">[Isa76]</a>.)</p>

<p>For <span class="SimpleMath">|G| = p^a m</span> where <span class="SimpleMath">p</span> does not divide <span class="SimpleMath">m</span>, the <em>defect</em> of a block is the integer <span class="SimpleMath">d</span> such that <span class="SimpleMath">p^{a-d}</span> is the largest power of <span class="SimpleMath">p</span> that divides the degrees of all characters in the block.</p>

<p>The <em>height</em> of a character <span class="SimpleMath">χ</span> in the block is defined as the largest exponent <span class="SimpleMath">h</span> for which <span class="SimpleMath">p^h</span> divides <span class="SimpleMath">χ(1) / p^{a-d}</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( "L3(2)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pbl:= PrimeBlocks( tbl, 2 );</span>
rec( block := [ 1, 1, 1, 1, 1, 2 ], 
  centralcharacter := [ [ ,, 56,, 24 ], [ ,, -7,, 3 ] ], 
  defect := [ 3, 0 ], height := [ 0, 0, 0, 1, 0, 0 ], 
  relevant := [ 3, 5 ] )
</pre></div>

<p><a id="X7E80E35985275F35" name="X7E80E35985275F35"></a></p>

<h5>71.11-2 SameBlock</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SameBlock</code>( <var class="Arg">p</var>, <var class="Arg">omega1</var>, <var class="Arg">omega2</var>, <var class="Arg">relevant</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">p</var> be a prime integer, <var class="Arg">omega1</var> and <var class="Arg">omega2</var> be two central characters (or their values lists) of a character table, and <var class="Arg">relevant</var> be a list of positions as is stored in the component <code class="code">relevant</code> of a record returned by <code class="func">PrimeBlocks</code> (<a href="chap71.html#X7ACB9306804F4E3F"><span class="RefLink">71.11-1</span></a>).</p>

<p><code class="func">SameBlock</code> returns <code class="keyw">true</code> if <var class="Arg">omega1</var> and <var class="Arg">omega2</var> are equal modulo any maximal ideal in the ring of complex algebraic integers containing the ideal spanned by <var class="Arg">p</var>, and <code class="keyw">false</code> otherwise.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">omega:= List( Irr( tbl ), CentralCharacter );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SameBlock( 2, omega[1], omega[2], pbl.relevant );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SameBlock( 2, omega[1], omega[6], pbl.relevant );</span>
false
</pre></div>

<p><a id="X7FF4CE4A7A272F88" name="X7FF4CE4A7A272F88"></a></p>

<h5>71.11-3 BlocksInfo</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BlocksInfo</code>( <var class="Arg">modtbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For a Brauer character table <var class="Arg">modtbl</var>, the value of <code class="func">BlocksInfo</code> is a list of (mutable) records, the <span class="SimpleMath">i</span>-th entry containing information about the <span class="SimpleMath">i</span>-th block. Each record has the following components.</p>


<dl>
<dt><strong class="Mark"><code class="code">defect</code></strong></dt>
<dd><p>the defect of the block,</p>

</dd>
<dt><strong class="Mark"><code class="code">ordchars</code></strong></dt>
<dd><p>the list of positions of the ordinary characters that belong to the block, relative to <code class="code">Irr( OrdinaryCharacterTable( <var class="Arg">modtbl</var> ) )</code>,</p>

</dd>
<dt><strong class="Mark"><code class="code">modchars</code></strong></dt>
<dd><p>the list of positions of the Brauer characters that belong to the block, relative to <code class="code">IBr( <var class="Arg">modtbl</var> )</code>.</p>

</dd>
</dl>
<p>Optional components are</p>


<dl>
<dt><strong class="Mark"><code class="code">basicset</code></strong></dt>
<dd><p>a list of positions of ordinary characters in the block whose restriction to <var class="Arg">modtbl</var> is maximally linearly independent, relative to <code class="code">Irr( OrdinaryCharacterTable( <var class="Arg">modtbl</var> ) )</code>,</p>

</dd>
<dt><strong class="Mark"><code class="code">decmat</code></strong></dt>
<dd><p>the decomposition matrix of the block, it is stored automatically when <code class="func">DecompositionMatrix</code> (<a href="chap71.html#X84701640811D2345"><span class="RefLink">71.11-4</span></a>) is called for the block,</p>

</dd>
<dt><strong class="Mark"><code class="code">decinv</code></strong></dt>
<dd><p>inverse of the decomposition matrix of the block, restricted to the ordinary characters described by <code class="code">basicset</code>,</p>

</dd>
<dt><strong class="Mark"><code class="code">brauertree</code></strong></dt>
<dd><p>a list that describes the Brauer tree of the block, in the case that the block is of defect <span class="SimpleMath">1</span>.</p>

</dd>
</dl>

<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BlocksInfo( CharacterTable( "L3(2)" ) mod 2 );</span>
[ rec( basicset := [ 1, 2, 3 ], 
      decinv := [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ], 
      defect := 3, modchars := [ 1, 2, 3 ], 
      ordchars := [ 1, 2, 3, 4, 5 ] ), 
  rec( basicset := [ 6 ], decinv := [ [ 1 ] ], defect := 0, 
      modchars := [ 4 ], ordchars := [ 6 ] ) ]
</pre></div>

<p><a id="X84701640811D2345" name="X84701640811D2345"></a></p>

<h5>71.11-4 DecompositionMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DecompositionMatrix</code>( <var class="Arg">modtbl</var>[, <var class="Arg">blocknr</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">modtbl</var> be a Brauer character table.</p>

<p>Called with one argument, <code class="func">DecompositionMatrix</code> returns the decomposition matrix of <var class="Arg">modtbl</var>, where the rows and columns are indexed by the irreducible characters of the ordinary character table of <var class="Arg">modtbl</var> and the irreducible characters of <var class="Arg">modtbl</var>, respectively,</p>

<p>Called with two arguments, <code class="func">DecompositionMatrix</code> returns the decomposition matrix of the block of <var class="Arg">modtbl</var> with number <var class="Arg">blocknr</var>; the matrix is stored as value of the <code class="code">decmat</code> component of the <var class="Arg">blocknr</var>-th entry of the <code class="func">BlocksInfo</code> (<a href="chap71.html#X7FF4CE4A7A272F88"><span class="RefLink">71.11-3</span></a>) list of <var class="Arg">modtbl</var>.</p>

<p>An ordinary irreducible character is in block <span class="SimpleMath">i</span> if and only if all characters before the first character of the same block lie in <span class="SimpleMath">i-1</span> different blocks. An irreducible Brauer character is in block <span class="SimpleMath">i</span> if it has nonzero scalar product with an ordinary irreducible character in block <span class="SimpleMath">i</span>.</p>

<p><code class="func">DecompositionMatrix</code> is based on the more general function <code class="func">Decomposition</code> (<a href="chap25.html#X7911A60384C511AB"><span class="RefLink">25.4-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">modtbl:= CharacterTable( "L3(2)" ) mod 2;</span>
BrauerTable( "L3(2)", 2 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DecompositionMatrix( modtbl );</span>
[ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 1, 1, 0 ], 
  [ 1, 1, 1, 0 ], [ 0, 0, 0, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DecompositionMatrix( modtbl, 1 );</span>
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ], [ 0, 1, 1 ], [ 1, 1, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DecompositionMatrix( modtbl, 2 );</span>
[ [ 1 ] ]
</pre></div>

<p><a id="X83EC921380AF9B3B" name="X83EC921380AF9B3B"></a></p>

<h5>71.11-5 LaTeXStringDecompositionMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LaTeXStringDecompositionMatrix</code>( <var class="Arg">modtbl</var>[, <var class="Arg">blocknr</var>][, <var class="Arg">options</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>is a string that contains LaTeX code to print a decomposition matrix (see <code class="func">DecompositionMatrix</code> (<a href="chap71.html#X84701640811D2345"><span class="RefLink">71.11-4</span></a>)) nicely.</p>

<p>The optional argument <var class="Arg">options</var>, if present, must be a record with components <code class="code">phi</code>, <code class="code">chi</code> (strings used in each label for columns and rows), <code class="code">collabels</code>, <code class="code">rowlabels</code> (subscripts for the labels). The defaults for <code class="code">phi</code> and <code class="code">chi</code> are <code class="code">"{\\tt Y}"</code> and <code class="code">"{\\tt X}"</code>, the defaults for <code class="code">collabels</code> and <code class="code">rowlabels</code> are the lists of positions of the Brauer characters and ordinary characters in the respective lists of irreducibles in the character tables.</p>

<p>The optional components <code class="code">nrows</code> and <code class="code">ncols</code> denote the maximal number of rows and columns per array; if they are present then each portion of <code class="code">nrows</code> rows and <code class="code">ncols</code> columns forms an array of its own which is enclosed in <code class="code">\[</code>, <code class="code">\]</code>.</p>

<p>If the component <code class="code">decmat</code> is bound in <var class="Arg">options</var> then it must be the decomposition matrix in question, in this case the matrix is not computed from the information in <var class="Arg">modtbl</var>.</p>

<p>For those character tables from the <strong class="pkg">GAP</strong> table library that belong to the <strong class="pkg">Atlas</strong> of Finite Groups <a href="chapBib.html#biBCCN85">[CCN+85]</a>, <code class="func">AtlasLabelsOfIrreducibles</code> (<a href="../../pkg/ctbllib/doc/chap4.html#X7ADC9DC980CF0685"><span class="RefLink">CTblLib: AtlasLabelsOfIrreducibles</span></a>) constructs character labels that are compatible with those used in the <strong class="pkg">Atlas</strong> (see <a href="../../pkg/ctbllib/doc/chap4.html#X81FE89697EAAB1EA"><span class="RefLink">CTblLib: Atlas Tables</span></a> in the manual of the <strong class="pkg">GAP</strong> Character Table Library).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">modtbl:= CharacterTable( "L3(2)" ) mod 2;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Print( LaTeXStringDecompositionMatrix( modtbl, 1 ) );</span>
\[
\begin{array}{r|rrr} \hline
 &amp; {\tt Y}_{1}
 &amp; {\tt Y}_{2}
 &amp; {\tt Y}_{3}
 \rule[-7pt]{0pt}{20pt} \\ \hline
{\tt X}_{1} &amp; 1 &amp; . &amp; . \rule[0pt]{0pt}{13pt} \\
{\tt X}_{2} &amp; . &amp; 1 &amp; . \\
{\tt X}_{3} &amp; . &amp; . &amp; 1 \\
{\tt X}_{4} &amp; . &amp; 1 &amp; 1 \\
{\tt X}_{5} &amp; 1 &amp; 1 &amp; 1 \rule[-7pt]{0pt}{5pt} \\
\hline
\end{array}
\]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">options:= rec( phi:= "\\varphi", chi:= "\\chi" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Print( LaTeXStringDecompositionMatrix( modtbl, 1, options ) );</span>
\[
\begin{array}{r|rrr} \hline
 &amp; \varphi_{1}
 &amp; \varphi_{2}
 &amp; \varphi_{3}
 \rule[-7pt]{0pt}{20pt} \\ \hline
\chi_{1} &amp; 1 &amp; . &amp; . \rule[0pt]{0pt}{13pt} \\
\chi_{2} &amp; . &amp; 1 &amp; . \\
\chi_{3} &amp; . &amp; . &amp; 1 \\
\chi_{4} &amp; . &amp; 1 &amp; 1 \\
\chi_{5} &amp; 1 &amp; 1 &amp; 1 \rule[-7pt]{0pt}{5pt} \\
\hline
\end{array}
\]
</pre></div>

<p><a id="X873211618402ACF7" name="X873211618402ACF7"></a></p>

<h4>71.12 <span class="Heading">Other Operations for Character Tables</span></h4>

<p>In the following, we list operations for character tables that are not attributes.</p>

<p><a id="X8441983C845F2176" name="X8441983C845F2176"></a></p>

<h5>71.12-1 Index</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Index</code>( <var class="Arg">tbl</var>, <var class="Arg">subtbl</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>For two character tables <var class="Arg">tbl</var> and <var class="Arg">subtbl</var>, <code class="func">Index</code> returns the quotient of the <code class="func">Size</code> (<a href="chap71.html#X81EFD9FE804AC6EE"><span class="RefLink">71.8-5</span></a>) values of <var class="Arg">tbl</var> and <var class="Arg">subtbl</var>. The containment of the underlying groups of <var class="Arg">subtbl</var> and <var class="Arg">tbl</var> is <em>not</em> checked; so the distinction between <code class="func">Index</code> (<a href="chap39.html#X842AD37E79CE953E"><span class="RefLink">39.3-2</span></a>) and <code class="func">IndexNC</code> (<a href="chap39.html#X842AD37E79CE953E"><span class="RefLink">39.3-2</span></a>) is not made for character tables.</p>

<p><a id="X8123650E817926FC" name="X8123650E817926FC"></a></p>

<h5>71.12-2 IsInternallyConsistent</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsInternallyConsistent</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>For an <em>ordinary</em> character table <var class="Arg">tbl</var>, <code class="func">IsInternallyConsistent</code> (<a href="chap12.html#X7F6C5C3287E8B816"><span class="RefLink">12.8-4</span></a>) checks the consistency of the following attribute values (if stored).</p>


<ul>
<li><p><code class="func">Size</code> (<a href="chap30.html#X858ADA3B7A684421"><span class="RefLink">30.4-6</span></a>), <code class="func">SizesCentralizers</code> (<a href="chap71.html#X7CF7907F790A5DE6"><span class="RefLink">71.9-2</span></a>), and <code class="func">SizesConjugacyClasses</code> (<a href="chap71.html#X7D9D2A45879A6A62"><span class="RefLink">71.9-3</span></a>).</p>

</li>
<li><p><code class="func">SizesCentralizers</code> (<a href="chap71.html#X7CF7907F790A5DE6"><span class="RefLink">71.9-2</span></a>) and <code class="func">OrdersClassRepresentatives</code> (<a href="chap71.html#X86F455DA7A9C30EE"><span class="RefLink">71.9-1</span></a>).</p>

</li>
<li><p><code class="func">ComputedPowerMaps</code> (<a href="chap73.html#X781FAA497E3B4D1A"><span class="RefLink">73.1-1</span></a>) and <code class="func">OrdersClassRepresentatives</code> (<a href="chap71.html#X86F455DA7A9C30EE"><span class="RefLink">71.9-1</span></a>).</p>

</li>
<li><p><code class="func">SizesCentralizers</code> (<a href="chap71.html#X7CF7907F790A5DE6"><span class="RefLink">71.9-2</span></a>) and <code class="func">Irr</code> (<a href="chap71.html#X873B3CC57E9A5492"><span class="RefLink">71.8-2</span></a>).</p>

</li>
<li><p><code class="func">Irr</code> (<a href="chap71.html#X873B3CC57E9A5492"><span class="RefLink">71.8-2</span></a>) (first orthogonality relation).</p>

</li>
</ul>
<p>For a <em>Brauer</em> table <var class="Arg">tbl</var>, <code class="func">IsInternallyConsistent</code> checks the consistency of the following attribute values (if stored).</p>


<ul>
<li><p><code class="func">Size</code> (<a href="chap30.html#X858ADA3B7A684421"><span class="RefLink">30.4-6</span></a>), <code class="func">SizesCentralizers</code> (<a href="chap71.html#X7CF7907F790A5DE6"><span class="RefLink">71.9-2</span></a>), and <code class="func">SizesConjugacyClasses</code> (<a href="chap71.html#X7D9D2A45879A6A62"><span class="RefLink">71.9-3</span></a>).</p>

</li>
<li><p><code class="func">SizesCentralizers</code> (<a href="chap71.html#X7CF7907F790A5DE6"><span class="RefLink">71.9-2</span></a>) and <code class="func">OrdersClassRepresentatives</code> (<a href="chap71.html#X86F455DA7A9C30EE"><span class="RefLink">71.9-1</span></a>).</p>

</li>
<li><p><code class="func">ComputedPowerMaps</code> (<a href="chap73.html#X781FAA497E3B4D1A"><span class="RefLink">73.1-1</span></a>) and <code class="func">OrdersClassRepresentatives</code> (<a href="chap71.html#X86F455DA7A9C30EE"><span class="RefLink">71.9-1</span></a>).</p>

</li>
<li><p><code class="func">Irr</code> (<a href="chap71.html#X873B3CC57E9A5492"><span class="RefLink">71.8-2</span></a>) (closure under complex conjugation and Frobenius map).</p>

</li>
</ul>
<p>If no inconsistency occurs, <code class="keyw">true</code> is returned, otherwise each inconsistency is printed to the screen if the level of <code class="func">InfoWarning</code> (<a href="chap7.html#X7A28F77C82D6A3E0"><span class="RefLink">7.4-8</span></a>) is at least <span class="SimpleMath">1</span> (see <a href="chap7.html#X7A9C902479CB6F7C"><span class="RefLink">7.4</span></a>), and <code class="keyw">false</code> is returned at the end.</p>

<p><a id="X7A0CBD1884276882" name="X7A0CBD1884276882"></a></p>

<h5>71.12-3 IsPSolvableCharacterTable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPSolvableCharacterTable</code>( <var class="Arg">tbl</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPSolubleCharacterTable</code>( <var class="Arg">tbl</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPSolvableCharacterTableOp</code>( <var class="Arg">tbl</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPSolubleCharacterTableOp</code>( <var class="Arg">tbl</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ComputedIsPSolvableCharacterTables</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ComputedIsPSolubleCharacterTables</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><code class="func">IsPSolvableCharacterTable</code> for the ordinary character table <var class="Arg">tbl</var> corresponds to <code class="func">IsPSolvable</code> (<a href="chap39.html#X81130F9A7CFCF6BF"><span class="RefLink">39.15-24</span></a>) for the group of <var class="Arg">tbl</var>, <var class="Arg">p</var> must be either a prime integer or <code class="code">0</code>.</p>

<p>The default method uses the attribute <code class="func">ComputedIsPSolvableCharacterTables</code> for storing the computed value at position <var class="Arg">p</var>, and calls the operation <code class="func">IsPSolvableCharacterTableOp</code> for computing values that are not yet known.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( "Sz(8)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPSolvableCharacterTable( tbl, 2 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPSolvableCharacterTable( tbl, 3 );</span>
true
</pre></div>

<p><a id="X82F523E8784B3752" name="X82F523E8784B3752"></a></p>

<h5>71.12-4 IsClassFusionOfNormalSubgroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsClassFusionOfNormalSubgroup</code>( <var class="Arg">subtbl</var>, <var class="Arg">fus</var>, <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>For two ordinary character tables <var class="Arg">tbl</var> and <var class="Arg">subtbl</var> of a group <span class="SimpleMath">G</span> and its subgroup <span class="SimpleMath">U</span>, say, and a list <var class="Arg">fus</var> of positive integers that describes the class fusion of <span class="SimpleMath">U</span> into <span class="SimpleMath">G</span>, <code class="func">IsClassFusionOfNormalSubgroup</code> returns <code class="keyw">true</code> if <span class="SimpleMath">U</span> is a normal subgroup of <span class="SimpleMath">G</span>, and <code class="keyw">false</code> otherwise.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblc2:= CharacterTable( "Cyclic", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbld8:= CharacterTable( "Dihedral", 8 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= PossibleClassFusions( tblc2, tbld8 );</span>
[ [ 1, 3 ], [ 1, 4 ], [ 1, 5 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(fus, map -&gt; IsClassFusionOfNormalSubgroup(tblc2, map, tbld8));</span>
[ true, false, false ]
</pre></div>

<p><a id="X7FD3D3047DE6381E" name="X7FD3D3047DE6381E"></a></p>

<h5>71.12-5 Indicator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Indicator</code>( <var class="Arg">tbl</var>[, <var class="Arg">characters</var>], <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IndicatorOp</code>( <var class="Arg">tbl</var>, <var class="Arg">characters</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ComputedIndicators</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>If <var class="Arg">tbl</var> is an ordinary character table then <code class="func">Indicator</code> returns the list of <var class="Arg">n</var>-th Frobenius-Schur indicators of the characters in the list <var class="Arg">characters</var>; the default of <var class="Arg">characters</var> is <code class="code">Irr( <var class="Arg">tbl</var> )</code>.</p>

<p>The <span class="SimpleMath">n</span>-th Frobenius-Schur indicator <span class="SimpleMath">ν_n(χ)</span> of an ordinary character <span class="SimpleMath">χ</span> of the group <span class="SimpleMath">G</span> is given by <span class="SimpleMath">ν_n(χ) = ( ∑_{g ∈ G} χ(g^n) ) / |G|</span>.</p>

<p>If <var class="Arg">tbl</var> is a Brauer table in characteristic <span class="SimpleMath">≠ 2</span> and <span class="SimpleMath"><var class="Arg">n</var> = 2</span> then <code class="func">Indicator</code> returns the second indicator.</p>

<p>The default method uses the attribute <code class="func">ComputedIndicators</code> for storing the computed value at position <var class="Arg">n</var>, and calls the operation <code class="func">IndicatorOp</code> for computing values that are not yet known.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( "L3(2)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Indicator( tbl, 2 );</span>
[ 1, 0, 0, 1, 1, 1 ]
</pre></div>

<p><a id="X83AE05BF8085B3C8" name="X83AE05BF8085B3C8"></a></p>

<h5>71.12-6 NrPolyhedralSubgroups</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NrPolyhedralSubgroups</code>( <var class="Arg">tbl</var>, <var class="Arg">c1</var>, <var class="Arg">c2</var>, <var class="Arg">c3</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns the number and isomorphism type of polyhedral subgroups of the group with ordinary character table <var class="Arg">tbl</var> which are generated by an element <span class="SimpleMath">g</span> of class <var class="Arg">c1</var> and an element <span class="SimpleMath">h</span> of class <var class="Arg">c2</var> with the property that the product <span class="SimpleMath">gh</span> lies in class <var class="Arg">c3</var>.</p>

<p>According to <a href="chapBib.html#biBNPP84">[NPP84, p. 233]</a>, the number of polyhedral subgroups of isomorphism type <span class="SimpleMath">V_4</span>, <span class="SimpleMath">D_2n</span>, <span class="SimpleMath">A_4</span>, <span class="SimpleMath">S_4</span>, and <span class="SimpleMath">A_5</span> can be derived from the class multiplication coefficient (see <code class="func">ClassMultiplicationCoefficient</code> (<a href="chap71.html#X7E2EA9FE7D3062D3"><span class="RefLink">71.12-7</span></a>)) and the number of Galois conjugates of a class (see <code class="func">ClassOrbit</code> (<a href="chap71.html#X7ABB007C799F7C49"><span class="RefLink">71.9-12</span></a>)).</p>

<p>The classes <var class="Arg">c1</var>, <var class="Arg">c2</var> and <var class="Arg">c3</var> in the parameter list must be ordered according to the order of the elements in these classes. If elements in class <var class="Arg">c1</var> and <var class="Arg">c2</var> do not generate a polyhedral group then <code class="keyw">fail</code> is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrPolyhedralSubgroups( tbl, 2, 2, 4 );</span>
rec( number := 21, type := "D8" )
</pre></div>

<p><a id="X7E2EA9FE7D3062D3" name="X7E2EA9FE7D3062D3"></a></p>

<h5>71.12-7 ClassMultiplicationCoefficient</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassMultiplicationCoefficient</code>( <var class="Arg">tbl</var>, <var class="Arg">i</var>, <var class="Arg">j</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns the class multiplication coefficient of the classes <var class="Arg">i</var>, <var class="Arg">j</var>, and <var class="Arg">k</var> of the group <span class="SimpleMath">G</span> with ordinary character table <var class="Arg">tbl</var>.</p>

<p>The class multiplication coefficient <span class="SimpleMath">c_{i,j,k}</span> of the classes <var class="Arg">i</var>, <var class="Arg">j</var>, <var class="Arg">k</var> equals the number of pairs <span class="SimpleMath">(x,y)</span> of elements <span class="SimpleMath">x, y ∈ G</span> such that <span class="SimpleMath">x</span> lies in class <var class="Arg">i</var>, <span class="SimpleMath">y</span> lies in class <var class="Arg">j</var>, and their product <span class="SimpleMath">xy</span> is a fixed element of class <var class="Arg">k</var>.</p>

<p>In the center of the group algebra of <span class="SimpleMath">G</span>, these numbers are found as coefficients of the decomposition of the product of two class sums <span class="SimpleMath">K_i</span> and <span class="SimpleMath">K_j</span> into class sums:</p>

<p class="pcenter">K_i K_j = ∑_k c_ijk K_k .</p>

<p>Given the character table of a finite group <span class="SimpleMath">G</span>, whose classes are <span class="SimpleMath">C_1, ..., C_r</span> with representatives <span class="SimpleMath">g_i ∈ C_i</span>, the class multiplication coefficient <span class="SimpleMath">c_ijk</span> can be computed with the following formula:</p>

<p class="pcenter">c_ijk = |C_i| ⋅ |C_j| / |G| ⋅ ∑_{χ ∈ Irr(G)} χ(g_i) χ(g_j) χ(g_k^{-1}) / χ(1).</p>

<p>On the other hand the knowledge of the class multiplication coefficients admits the computation of the irreducible characters of <span class="SimpleMath">G</span>, see <code class="func">IrrDixonSchneider</code> (<a href="chap71.html#X7ED39DB680BFEA96"><span class="RefLink">71.14-1</span></a>).</p>

<p><a id="X7A19F56C7FD5EFC7" name="X7A19F56C7FD5EFC7"></a></p>

<h5>71.12-8 ClassStructureCharTable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassStructureCharTable</code>( <var class="Arg">tbl</var>, <var class="Arg">classes</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns the so-called class structure of the classes in the list <var class="Arg">classes</var>, for the character table <var class="Arg">tbl</var> of the group <span class="SimpleMath">G</span>. The length of <var class="Arg">classes</var> must be at least 2.</p>

<p>Let <span class="SimpleMath">C = (C_1, C_2, ..., C_n)</span> denote the <span class="SimpleMath">n</span>-tuple of conjugacy classes of <span class="SimpleMath">G</span> that are indexed by <var class="Arg">classes</var>. The class structure <span class="SimpleMath">n(C)</span> equals the number of <span class="SimpleMath">n</span>-tuples <span class="SimpleMath">(g_1, g_2, ..., g_n)</span> of elements <span class="SimpleMath">g_i ∈ C_i</span> with <span class="SimpleMath">g_1 g_2 ⋯ g_n = 1</span>. Note the difference to the definition of the class multiplication coefficients in <code class="func">ClassMultiplicationCoefficient</code> (<a href="chap71.html#X7E2EA9FE7D3062D3"><span class="RefLink">71.12-7</span></a>).</p>

<p><span class="SimpleMath">n(C_1, C_2, ..., C_n)</span> is computed using the formula</p>

<p class="pcenter">n(C_1, C_2, ..., C_n) = |C_1| |C_2| ⋯ |C_n| / |G| ⋅ ∑_{χ ∈ Irr(G)} χ(g_1) χ(g_2) ⋯ χ(g_n) / χ(1)^{n-2} .</p>

<p><a id="X809E67E57D4933B3" name="X809E67E57D4933B3"></a></p>

<h5>71.12-9 MatClassMultCoeffsCharTable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MatClassMultCoeffsCharTable</code>( <var class="Arg">tbl</var>, <var class="Arg">i</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>For an ordinary character table <var class="Arg">tbl</var> and a class position <var class="Arg">i</var>, <code class="code">MatClassMultCoeffsCharTable</code> returns the matrix <span class="SimpleMath">[ a_ijk ]_{j,k}</span> of structure constants (see <code class="func">ClassMultiplicationCoefficient</code> (<a href="chap71.html#X7E2EA9FE7D3062D3"><span class="RefLink">71.12-7</span></a>)).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( "L3(2)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassMultiplicationCoefficient( tbl, 2, 2, 4 );</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassStructureCharTable( tbl, [ 2, 2, 4 ] );</span>
168
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassStructureCharTable( tbl, [ 2, 2, 2, 4 ] );</span>
1848
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MatClassMultCoeffsCharTable( tbl, 2 );</span>
[ [ 0, 1, 0, 0, 0, 0 ], [ 21, 4, 3, 4, 0, 0 ], [ 0, 8, 6, 8, 7, 7 ], 
  [ 0, 8, 6, 1, 7, 7 ], [ 0, 0, 3, 4, 0, 7 ], [ 0, 0, 3, 4, 7, 0 ] ]
</pre></div>

<p><a id="X7C1941F17BE9FC21" name="X7C1941F17BE9FC21"></a></p>

<h4>71.13 <span class="Heading">Printing Character Tables</span></h4>

<p><a id="X7D45224B86D802E5" name="X7D45224B86D802E5"></a></p>

<h5>71.13-1 ViewObj</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ViewObj</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>The default <code class="func">ViewObj</code> (<a href="chap6.html#X815BF22186FD43C9"><span class="RefLink">6.3-5</span></a>) method for ordinary character tables prints the string <code class="code">"CharacterTable"</code>, followed by the identifier (see <code class="func">Identifier</code> (<a href="chap71.html#X79C40EE97890202F"><span class="RefLink">71.9-8</span></a>)) or, if known, the group of the character table enclosed in brackets. <code class="func">ViewObj</code> (<a href="chap6.html#X815BF22186FD43C9"><span class="RefLink">6.3-5</span></a>) for Brauer tables does the same, except that the first string is replaced by <code class="code">"BrauerTable"</code>, and that the characteristic is also shown.</p>

<p><a id="X836554207C678D41" name="X836554207C678D41"></a></p>

<h5>71.13-2 PrintObj</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PrintObj</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>The default <code class="func">PrintObj</code> (<a href="chap6.html#X815BF22186FD43C9"><span class="RefLink">6.3-5</span></a>) method for character tables does the same as <code class="func">ViewObj</code> (<a href="chap6.html#X815BF22186FD43C9"><span class="RefLink">6.3-5</span></a>), except that <code class="func">PrintObj</code> (<a href="chap6.html#X815BF22186FD43C9"><span class="RefLink">6.3-5</span></a>) is used for the group instead of <code class="func">ViewObj</code> (<a href="chap6.html#X815BF22186FD43C9"><span class="RefLink">6.3-5</span></a>).</p>

<p><a id="X7B41F36478C47364" name="X7B41F36478C47364"></a></p>

<h5>71.13-3 Display</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Display</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>There are various ways to customize the <code class="func">Display</code> (<a href="chap6.html#X83A5C59278E13248"><span class="RefLink">6.3-6</span></a>) output for character tables. First we describe the default behaviour, alternatives are then described below.</p>

<p>The default <code class="func">Display</code> (<a href="chap6.html#X83A5C59278E13248"><span class="RefLink">6.3-6</span></a>) method prepares the data in <var class="Arg">tbl</var> for a columnwise output. The number of columns printed at one time depends on the actual line length, which can be accessed and changed by the function <code class="func">SizeScreen</code> (<a href="chap6.html#X8723E0A1837894F3"><span class="RefLink">6.12-1</span></a>).</p>

<p>An interesting variant of <code class="func">Display</code> (<a href="chap6.html#X83A5C59278E13248"><span class="RefLink">6.3-6</span></a>) is the function <code class="func">PageDisplay</code> (<a href="../../pkg/GAPDoc-1.6.3/doc/chap6.html#X7BB6731F7E3AAA98"><span class="RefLink">GAPDoc: PageDisplay</span></a>). Convenient ways to print the <code class="func">Display</code> (<a href="chap6.html#X83A5C59278E13248"><span class="RefLink">6.3-6</span></a>) format to a file are given by the function <code class="func">PrintTo1</code> (<a href="../../pkg/GAPDoc-1.6.3/doc/chap6.html#X8603B90C7C3F0AB1"><span class="RefLink">GAPDoc: PrintTo1</span></a>) or by using <code class="func">PageDisplay</code> (<a href="../../pkg/GAPDoc-1.6.3/doc/chap6.html#X7BB6731F7E3AAA98"><span class="RefLink">GAPDoc: PageDisplay</span></a>) and the facilities of the pager used, cf. <code class="func">Pager</code> (<a href="chap2.html#X7ED03E41792C3840"><span class="RefLink">2.4-1</span></a>).</p>

<p>An interactive variant of <code class="func">Display</code> (<a href="chap6.html#X83A5C59278E13248"><span class="RefLink">6.3-6</span></a>) is the <code class="func">Browse</code> (<a href="../../pkg/Browse/doc/chap6.html#X7FDD696B7DD54A6E"><span class="RefLink">Browse: Browse</span></a>) method for character tables that is provided by the <strong class="pkg">GAP</strong> package <strong class="pkg">Browse</strong>, see <code class="func">Browse</code> (<a href="../../pkg/Browse/doc/chap6.html#X870C744182073CF6"><span class="RefLink">Browse: Browse for character tables</span></a>).</p>

<p><code class="func">Display</code> (<a href="chap6.html#X83A5C59278E13248"><span class="RefLink">6.3-6</span></a>) shows certain characters (by default all irreducible characters) of <var class="Arg">tbl</var>, together with the orders of the centralizers in factorized form and the available power maps (see <code class="func">ComputedPowerMaps</code> (<a href="chap73.html#X781FAA497E3B4D1A"><span class="RefLink">73.1-1</span></a>)). The <var class="Arg">n</var>-th displayed character is given the name <code class="code">X.<var class="Arg">n</var></code>.</p>

<p>The first lines of the output describe the order of the centralizer of an element of the class factorized into its prime divisors.</p>

<p>The next line gives the name of each class. If no class names are stored on <var class="Arg">tbl</var>, <code class="func">ClassNames</code> (<a href="chap71.html#X804CFD597C795801"><span class="RefLink">71.9-6</span></a>) is called.</p>

<p>Preceded by a name <code class="code">P<var class="Arg">n</var></code>, the next lines show the <var class="Arg">n</var>th power maps of <var class="Arg">tbl</var> in terms of the former shown class names.</p>

<p>Every ambiguous or unknown (see Chapter <a href="chap74.html#X7C1FAB6280A02CCB"><span class="RefLink">74</span></a>) value of the table is displayed as a question mark <code class="code">?</code>.</p>

<p>Irrational character values are not printed explicitly because the lengths of their printed representation might disturb the layout. Instead of that every irrational value is indicated by a name, which is a string of at least one capital letter.</p>

<p>Once a name for an irrational value is found, it is used all over the printed table. Moreover the complex conjugate (see <code class="func">ComplexConjugate</code> (<a href="chap18.html#X7BE001A0811CD599"><span class="RefLink">18.5-2</span></a>), <code class="func">GaloisCyc</code> (<a href="chap18.html#X79EE9097783128C4"><span class="RefLink">18.5-1</span></a>)) and the star of an irrationality (see <code class="func">StarCyc</code> (<a href="chap18.html#X7E361C057E97CA66"><span class="RefLink">18.5-3</span></a>)) are represented by that very name preceded by a <code class="code">/</code> and a <code class="code">*</code>, respectively.</p>

<p>The printed character table is then followed by a legend, a list identifying the occurring symbols with their actual values. Occasionally this identification is supplemented by a quadratic representation of the irrationality (see <code class="func">Quadratic</code> (<a href="chap18.html#X84438F867B0CC299"><span class="RefLink">18.5-4</span></a>)) together with the corresponding <strong class="pkg">Atlas</strong> notation (see <a href="chapBib.html#biBCCN85">[CCN+85]</a>).</p>

<p>This default style can be changed by prescribing a record <var class="Arg">arec</var> of options, which can be given</p>

<ol>
<li><p>as an optional argument in the call to <code class="func">Display</code> (<a href="chap6.html#X83A5C59278E13248"><span class="RefLink">6.3-6</span></a>),</p>

</li>
<li><p>as the value of the attribute <code class="func">DisplayOptions</code> (<a href="chap71.html#X85E883A87A190AA4"><span class="RefLink">71.13-4</span></a>) if this value is stored in the table,</p>

</li>
<li><p>as the value of the global variable <code class="code">CharacterTableDisplayDefaults.User</code>, or</p>

</li>
<li><p>as the value of the global variable <code class="code">CharacterTableDisplayDefaults.Global</code></p>

</li>
</ol>
<p>(in this order of precedence).</p>

<p>The following components of <var class="Arg">arec</var> are supported.</p>


<dl>
<dt><strong class="Mark"><code class="code">centralizers</code></strong></dt>
<dd><p><code class="keyw">false</code> to suppress the printing of the orders of the centralizers, or the string <code class="code">"ATLAS"</code> to force the printing of non-factorized centralizer orders in a style similar to that used in the <strong class="pkg">Atlas</strong> of Finite Groups <a href="chapBib.html#biBCCN85">[CCN+85]</a>,</p>

</dd>
<dt><strong class="Mark"><code class="code">chars</code></strong></dt>
<dd><p>an integer or a list of integers to select a sublist of the irreducible characters of <var class="Arg">tbl</var>, or a list of characters of <var class="Arg">tbl</var> (in the latter case, the default letter <code class="code">"X"</code> in the character names is replaced by <code class="code">"Y"</code>),</p>

</dd>
<dt><strong class="Mark"><code class="code">charnames</code></strong></dt>
<dd><p>a list of strings of length equal to the number of characters that shall be shown; they are used as labels for the characters,</p>

</dd>
<dt><strong class="Mark"><code class="code">classes</code></strong></dt>
<dd><p>an integer or a list of integers to select a sublist of the classes of <var class="Arg">tbl</var>,</p>

</dd>
<dt><strong class="Mark"><code class="code">classnames</code></strong></dt>
<dd><p>a list of strings of length equal to the number of classes that shall be shown; they are used as labels for the classes,</p>

</dd>
<dt><strong class="Mark"><code class="code">indicator</code></strong></dt>
<dd><p><code class="keyw">true</code> enables the printing of the second Frobenius Schur indicator, a list of integers enables the printing of the corresponding indicators (see <code class="func">Indicator</code> (<a href="chap71.html#X7FD3D3047DE6381E"><span class="RefLink">71.12-5</span></a>)),</p>

</dd>
<dt><strong class="Mark"><code class="code">letter</code></strong></dt>
<dd><p>a single capital letter (e. g. <code class="code">"P"</code> for permutation characters) to replace the default <code class="code">"X"</code> in character names,</p>

</dd>
<dt><strong class="Mark"><code class="code">powermap</code></strong></dt>
<dd><p>an integer or a list of integers to select a subset of the available power maps, <code class="keyw">false</code> to suppress the printing of power maps, or the string <code class="code">"ATLAS"</code> to force a printing of class names and power maps in a style similar to that used in the <strong class="pkg">Atlas</strong> of Finite Groups <a href="chapBib.html#biBCCN85">[CCN+85]</a> (the <code class="code">"ATLAS"</code> variant works only if the function <code class="func">CambridgeMaps</code> (<a href="../../pkg/ctbllib/doc/chap6.html#X78A84889878D98BB"><span class="RefLink">CTblLib: CambridgeMaps</span></a>) is available, which belongs to the <strong class="pkg">CTblLib</strong> package),</p>

</dd>
<dt><strong class="Mark"><code class="code">Display</code></strong></dt>
<dd><p>the function that is actually called in order to display the table; the arguments are the table and the optional record, whose components can be used inside the <code class="code">Display</code> function,</p>

</dd>
<dt><strong class="Mark"><code class="code">StringEntry</code></strong></dt>
<dd><p>a function that takes either a character value or a character value and the return value of <code class="code">StringEntryData</code> (see below), and returns the string that is actually displayed; it is called for all character values to be displayed, and also for the displayed indicator values (see above),</p>

</dd>
<dt><strong class="Mark"><code class="code">StringEntryData</code></strong></dt>
<dd><p>a unary function that is called once with argument <var class="Arg">tbl</var> before the character values are displayed; it returns an object that is used as second argument of the function <code class="code">StringEntry</code>,</p>

</dd>
<dt><strong class="Mark"><code class="code">Legend</code></strong></dt>
<dd><p>a function that takes the result of the <code class="code">StringEntryData</code> call as its only argument, after the character table has been displayed; the return value is a string that describes the symbols used in the displayed table in a formatted way, it is printed below the displayed table.</p>

</dd>
</dl>
<p><a id="X85E883A87A190AA4" name="X85E883A87A190AA4"></a></p>

<h5>71.13-4 DisplayOptions</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DisplayOptions</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>There is no default method to compute a value, one can set a value with <code class="code">SetDisplayOptions</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( "A5" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( tbl );</span>
A5

     2  2  2  .  .  .
     3  1  .  1  .  .
     5  1  .  .  1  1

       1a 2a 3a 5a 5b
    2P 1a 1a 3a 5b 5a
    3P 1a 2a 1a 5b 5a
    5P 1a 2a 3a 1a 1a

X.1     1  1  1  1  1
X.2     3 -1  .  A *A
X.3     3 -1  . *A  A
X.4     4  .  1 -1 -1
X.5     5  1 -1  .  .

A = -E(5)-E(5)^4
  = (1-Sqrt(5))/2 = -b5
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacterTableDisplayDefaults.User:= rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       powermap:= "ATLAS", centralizers:= "ATLAS", chars:= false );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CharacterTable( "A5" ) );</span>
A5

    60  4  3  5  5

 p      A  A  A  A
 p'     A  A  A  A
    1A 2A 3A 5A B*

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">options:= rec( chars:= 4, classes:= [ tbl.3a .. tbl.5a ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  centralizers:= false, indicator:= true,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  powermap:= [ 2 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( tbl, options );</span>
A5

          3a 5a
       2P 3a 5b
       2
X.4    +   1 -1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetDisplayOptions( tbl, options );  Display( tbl );</span>
A5

          3a 5a
       2P 3a 5b
       2
X.4    +   1 -1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Unbind( CharacterTableDisplayDefaults.User );</span>
</pre></div>

<p><a id="X79EC9603833AA2AB" name="X79EC9603833AA2AB"></a></p>

<h5>71.13-5 PrintCharacterTable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PrintCharacterTable</code>( <var class="Arg">tbl</var>, <var class="Arg">varname</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">tbl</var> be a nearly character table, and <var class="Arg">varname</var> a string. <code class="func">PrintCharacterTable</code> prints those values of the supported attributes (see <code class="func">SupportedCharacterTableInfo</code> (<a href="chap71.html#X7DBEF4BF87F10CD6"><span class="RefLink">71.3-4</span></a>)) that are known for <var class="Arg">tbl</var>.</p>

<p>The output of <code class="func">PrintCharacterTable</code> is <strong class="pkg">GAP</strong> readable; actually reading it into <strong class="pkg">GAP</strong> will bind the variable with name <var class="Arg">varname</var> to a character table that coincides with <var class="Arg">tbl</var> for all printed components.</p>

<p>This is used mainly for saving character tables to files. A more human readable form is produced by <code class="func">Display</code> (<a href="chap6.html#X83A5C59278E13248"><span class="RefLink">6.3-6</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintCharacterTable( CharacterTable( "Cyclic", 2 ), "tbl" );</span>
tbl:= function()
local tbl, i;
tbl:=rec();
tbl.Irr:=
[ [ 1, 1 ], [ 1, -1 ] ];
tbl.IsFinite:=
true;
tbl.NrConjugacyClasses:=
2;
tbl.Size:=
2;
tbl.OrdersClassRepresentatives:=
[ 1, 2 ];
tbl.SizesCentralizers:=
[ 2, 2 ];
tbl.UnderlyingCharacteristic:=
0;
tbl.ClassParameters:=
[ [ 1, 0 ], [ 1, 1 ] ];
tbl.CharacterParameters:=
[ [ 1, 0 ], [ 1, 1 ] ];
tbl.Identifier:=
"C2";
tbl.InfoText:=
"computed using generic character table for cyclic groups";
tbl.ComputedPowerMaps:=
[ , [ 1, 1 ] ];
ConvertToLibraryCharacterTableNC(tbl);
return tbl;
end;
tbl:= tbl();
</pre></div>

<p><a id="X79BC08C6846718D9" name="X79BC08C6846718D9"></a></p>

<h4>71.14 <span class="Heading">Computing the Irreducible Characters of a Group</span></h4>

<p>Several algorithms are available for computing the irreducible characters of a finite group <span class="SimpleMath">G</span>. The default method for arbitrary finite groups is to use the Dixon-Schneider algorithm (see <code class="func">IrrDixonSchneider</code> (<a href="chap71.html#X7ED39DB680BFEA96"><span class="RefLink">71.14-1</span></a>)). For supersolvable groups, Conlon's algorithm can be used (see <code class="func">IrrConlon</code> (<a href="chap71.html#X7E81BCD686561DF0"><span class="RefLink">71.14-2</span></a>)). For abelian-by-supersolvable groups, the Baum-Clausen algorithm for computing the irreducible representations (see <code class="func">IrreducibleRepresentations</code> (<a href="chap71.html#X7F29C5447B5DC102"><span class="RefLink">71.14-4</span></a>)) can be used to compute the irreducible characters (see <code class="func">IrrBaumClausen</code> (<a href="chap71.html#X7BF15729839203FC"><span class="RefLink">71.14-3</span></a>)).</p>

<p>These functions are installed in methods for <code class="func">Irr</code> (<a href="chap71.html#X873B3CC57E9A5492"><span class="RefLink">71.8-2</span></a>), but explicitly calling one of them will <em>not</em> set the <code class="func">Irr</code> (<a href="chap71.html#X873B3CC57E9A5492"><span class="RefLink">71.8-2</span></a>) value of <span class="SimpleMath">G</span>.</p>

<p><a id="X7ED39DB680BFEA96" name="X7ED39DB680BFEA96"></a></p>

<h5>71.14-1 IrrDixonSchneider</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IrrDixonSchneider</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>computes the irreducible characters of the finite group <var class="Arg">G</var>, using the Dixon-Schneider method (see <a href="chap71.html#X86CDA4007A5EF704"><span class="RefLink">71.16</span></a>). It calls <code class="func">DixonInit</code> (<a href="chap71.html#X7E33C03E7BDDC9B0"><span class="RefLink">71.17-2</span></a>) and <code class="func">DixonSplit</code> (<a href="chap71.html#X87ABE0B081DAD476"><span class="RefLink">71.17-4</span></a>), and finally returns the list returned by <code class="func">DixontinI</code> (<a href="chap71.html#X868476037907918F"><span class="RefLink">71.17-3</span></a>). See also the sections <a href="chap71.html#X7C1153637E7D2133"><span class="RefLink">71.18</span></a> and <a href="chap71.html#X782B5E37848786BC"><span class="RefLink">71.19</span></a>.</p>

<p><a id="X7E81BCD686561DF0" name="X7E81BCD686561DF0"></a></p>

<h5>71.14-2 IrrConlon</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IrrConlon</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For a finite solvable group <var class="Arg">G</var>, <code class="func">IrrConlon</code> returns a list of certain irreducible characters of <var class="Arg">G</var>, among those all irreducibles that have the supersolvable residuum of <var class="Arg">G</var> in their kernels; so if <var class="Arg">G</var> is supersolvable, all irreducible characters of <var class="Arg">G</var> are returned. An error is signalled if <var class="Arg">G</var> is not solvable.</p>

<p>The characters are computed using Conlon's algorithm (see <a href="chapBib.html#biBCon90a">[Con90a]</a> and <a href="chapBib.html#biBCon90b">[Con90b]</a>). For each irreducible character in the returned list, the monomiality information (see <code class="func">TestMonomial</code> (<a href="chap75.html#X84EB92B57DAF5C93"><span class="RefLink">75.4-1</span></a>)) is stored.</p>

<p><a id="X7BF15729839203FC" name="X7BF15729839203FC"></a></p>

<h5>71.14-3 IrrBaumClausen</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IrrBaumClausen</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><code class="func">IrrBaumClausen</code> returns the absolutely irreducible ordinary characters of the factor group of the finite solvable group <var class="Arg">G</var> by the derived subgroup of its supersolvable residuum.</p>

<p>The characters are computed using the algorithm by Baum and Clausen (see <a href="chapBib.html#biBBC94">[BC94]</a>). An error is signalled if <var class="Arg">G</var> is not solvable.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= SL(2,3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irr1:= IrrDixonSchneider( g );</span>
[ Character( CharacterTable( SL(2,3) ), [ 1, 1, 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( SL(2,3) ), 
    [ 1, E(3)^2, E(3), 1, E(3), E(3)^2, 1 ] ), 
  Character( CharacterTable( SL(2,3) ), 
    [ 1, E(3), E(3)^2, 1, E(3)^2, E(3), 1 ] ), 
  Character( CharacterTable( SL(2,3) ), [ 2, 1, 1, -2, -1, -1, 0 ] ), 
  Character( CharacterTable( SL(2,3) ), 
    [ 2, E(3)^2, E(3), -2, -E(3), -E(3)^2, 0 ] ), 
  Character( CharacterTable( SL(2,3) ), 
    [ 2, E(3), E(3)^2, -2, -E(3)^2, -E(3), 0 ] ), 
  Character( CharacterTable( SL(2,3) ), [ 3, 0, 0, 3, 0, 0, -1 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irr2:= IrrConlon( g );</span>
[ Character( CharacterTable( SL(2,3) ), [ 1, 1, 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( SL(2,3) ), 
    [ 1, E(3), E(3)^2, 1, E(3)^2, E(3), 1 ] ), 
  Character( CharacterTable( SL(2,3) ), 
    [ 1, E(3)^2, E(3), 1, E(3), E(3)^2, 1 ] ), 
  Character( CharacterTable( SL(2,3) ), [ 3, 0, 0, 3, 0, 0, -1 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irr3:= IrrBaumClausen( g );</span>
[ Character( CharacterTable( SL(2,3) ), [ 1, 1, 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( SL(2,3) ), 
    [ 1, E(3), E(3)^2, 1, E(3)^2, E(3), 1 ] ), 
  Character( CharacterTable( SL(2,3) ), 
    [ 1, E(3)^2, E(3), 1, E(3), E(3)^2, 1 ] ), 
  Character( CharacterTable( SL(2,3) ), [ 3, 0, 0, 3, 0, 0, -1 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chi:= irr2[4];;  HasTestMonomial( chi );</span>
true
</pre></div>

<p><a id="X7F29C5447B5DC102" name="X7F29C5447B5DC102"></a></p>

<h5>71.14-4 IrreducibleRepresentations</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IrreducibleRepresentations</code>( <var class="Arg">G</var>[, <var class="Arg">F</var>] )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Called with a finite group <var class="Arg">G</var> and a field <var class="Arg">F</var>, <code class="func">IrreducibleRepresentations</code> returns a list of representatives of the irreducible matrix representations of <var class="Arg">G</var> over <var class="Arg">F</var>, up to equivalence.</p>

<p>If <var class="Arg">G</var> is the only argument then <code class="func">IrreducibleRepresentations</code> returns a list of representatives of the absolutely irreducible complex representations of <var class="Arg">G</var>, up to equivalence.</p>

<p>At the moment, methods are available for the following cases: If <var class="Arg">G</var> is abelian by supersolvable the method of <a href="chapBib.html#biBBC94">[BC94]</a> is used.</p>

<p>Otherwise, if <var class="Arg">F</var> and <var class="Arg">G</var> are both finite, the regular module of <var class="Arg">G</var> is split by MeatAxe methods which can make this an expensive operation.</p>

<p>Finally, if <var class="Arg">F</var> is not given (i.e. it defaults to the cyclotomic numbers) and <var class="Arg">G</var> is a finite group, the method of <a href="chapBib.html#biBDix93">[Dix93]</a> (see <code class="func">IrreducibleRepresentationsDixon</code> (<a href="chap71.html#X8493ED7A86FFCB8A"><span class="RefLink">71.14-5</span></a>)) is used.</p>

<p>For other cases no methods are implemented yet.</p>

<p>The representations obtained are <em>not</em> guaranteed to be "nice" (for example preserving a unitary form) in any way.</p>

<p>See also <code class="func">IrreducibleModules</code> (<a href="chap71.html#X87E82F8085745523"><span class="RefLink">71.15-1</span></a>), which provides efficient methods for solvable groups.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= AlternatingGroup( 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repr:= IrreducibleRepresentations( g );</span>
[ Pcgs([ (2,4,3), (1,3)(2,4), (1,2)(3,4) ]) -&gt; 
    [ [ [ 1 ] ], [ [ 1 ] ], [ [ 1 ] ] ], 
  Pcgs([ (2,4,3), (1,3)(2,4), (1,2)(3,4) ]) -&gt; 
    [ [ [ E(3) ] ], [ [ 1 ] ], [ [ 1 ] ] ], 
  Pcgs([ (2,4,3), (1,3)(2,4), (1,2)(3,4) ]) -&gt; 
    [ [ [ E(3)^2 ] ], [ [ 1 ] ], [ [ 1 ] ] ], 
  Pcgs([ (2,4,3), (1,3)(2,4), (1,2)(3,4) ]) -&gt; 
    [ [ [ 0, 0, 1 ], [ 1, 0, 0 ], [ 0, 1, 0 ] ], 
      [ [ -1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, -1 ] ], 
      [ [ 1, 0, 0 ], [ 0, -1, 0 ], [ 0, 0, -1 ] ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll( repr, IsGroupHomomorphism );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( repr );</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens:= GeneratorsOfGroup( g );</span>
[ (1,2,3), (2,3,4) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( gens, x -&gt; x^repr[1] );</span>
[ [ [ 1 ] ], [ [ 1 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"> List( gens, x -&gt; x^repr[4] );</span>
[ [ [ 0, 0, -1 ], [ 1, 0, 0 ], [ 0, -1, 0 ] ], 
  [ [ 0, 1, 0 ], [ 0, 0, 1 ], [ 1, 0, 0 ] ] ]
</pre></div>

<p><a id="X8493ED7A86FFCB8A" name="X8493ED7A86FFCB8A"></a></p>

<h5>71.14-5 IrreducibleRepresentationsDixon</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IrreducibleRepresentationsDixon</code>( <var class="Arg">G</var>[, <var class="Arg">chi</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Called with one argument, a group <var class="Arg">G</var>, <code class="func">IrreducibleRepresentationsDixon</code> computes (representatives of) all irreducible complex representations for the finite group <var class="Arg">G</var>, using the method of <a href="chapBib.html#biBDix93">[Dix93]</a>, which computes the character table and computes the representation as constituent of an induced monomial representation of a subgroup.</p>

<p>This method can be quite expensive for larger groups, for example it might involve calculation of the subgroup lattice of <var class="Arg">G</var>.</p>

<p>A character <var class="Arg">chi</var> of <var class="Arg">G</var> can be given as the second argument, in this case only a representation affording <var class="Arg">chi</var> is returned.</p>

<p>The second argument can also be a list of characters of <var class="Arg">G</var>, in this case only representations for characters in this list are computed.</p>

<p>Note that this method might fail if for an irreducible representation there is no subgroup in which its reduction has a linear constituent with multiplicity one.</p>

<p>If the option <var class="Arg">unitary</var> is given, <strong class="pkg">GAP</strong> tries, at extra cost, to find a unitary representation (and will issue an error if it cannot do so).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a5:= AlternatingGroup( 5 );</span>
Alt( [ 1 .. 5 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">char:= First( Irr( a5 ), x -&gt; x[1] = 4 );</span>
Character( CharacterTable( Alt( [ 1 .. 5 ] ) ), [ 4, 0, 1, -1, -1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom:=IrreducibleRepresentationsDixon( a5, char: unitary );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order( a5.1*a5.2 ) = Order( Image( hom, a5.1 )*Image( hom, a5.2 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">reps:= List( ConjugacyClasses( a5 ), Representative );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( reps, g -&gt; TraceMat( Image( hom, g ) ) );</span>
[ 4, 0, 1, -1, -1 ]
</pre></div>

<p><a id="X7E51AACD79CE0BC8" name="X7E51AACD79CE0BC8"></a></p>

<h4>71.15 <span class="Heading">Representations Given by Modules</span></h4>

<p>This section describes functions that return certain modules of a given group. (Extensions by modules can be formed by the command <code class="func">Extensions</code> (<a href="chap46.html#X8236AD927A5A0E5A"><span class="RefLink">46.8-4</span></a>).)</p>

<p><a id="X87E82F8085745523" name="X87E82F8085745523"></a></p>

<h5>71.15-1 IrreducibleModules</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IrreducibleModules</code>( <var class="Arg">G</var>, <var class="Arg">F</var>, <var class="Arg">dim</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns a list of length 2. The first entry is a generating system of <var class="Arg">G</var>. The second entry is a list of all irreducible modules of <var class="Arg">G</var> over the field <var class="Arg">F</var> in dimension <var class="Arg">dim</var>, given as MeatAxe modules (see <code class="func">GModuleByMats</code> (<a href="chap69.html#X801022027B066497"><span class="RefLink">69.1-1</span></a>)).</p>

<p><a id="X7D0BD5337D1C069B" name="X7D0BD5337D1C069B"></a></p>

<h5>71.15-2 AbsolutelyIrreducibleModules</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AbsolutelyIrreducibleModules</code>( <var class="Arg">G</var>, <var class="Arg">F</var>, <var class="Arg">dim</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AbsoluteIrreducibleModules</code>( <var class="Arg">G</var>, <var class="Arg">F</var>, <var class="Arg">dim</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AbsolutIrreducibleModules</code>( <var class="Arg">G</var>, <var class="Arg">F</var>, <var class="Arg">dim</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns a list of length 2. The first entry is a generating system of <var class="Arg">G</var>. The second entry is a list of all absolute irreducible modules of <var class="Arg">G</var> over the field <var class="Arg">F</var> in dimension <var class="Arg">dim</var>, given as MeatAxe modules (see <code class="func">GModuleByMats</code> (<a href="chap69.html#X801022027B066497"><span class="RefLink">69.1-1</span></a>)). The other two names are just synonyms.</p>

<p><a id="X7EB88B2E87AF5556" name="X7EB88B2E87AF5556"></a></p>

<h5>71.15-3 RegularModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RegularModule</code>( <var class="Arg">G</var>, <var class="Arg">F</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns a list of length 2. The first entry is a generating system of <var class="Arg">G</var>. The second entry is the regular module of <var class="Arg">G</var> over <var class="Arg">F</var>, given as a MeatAxe module (see <code class="func">GModuleByMats</code> (<a href="chap69.html#X801022027B066497"><span class="RefLink">69.1-1</span></a>)).</p>

<p><a id="X86CDA4007A5EF704" name="X86CDA4007A5EF704"></a></p>

<h4>71.16 <span class="Heading">The Dixon-Schneider Algorithm</span></h4>

<p>The <strong class="pkg">GAP</strong> library implementation of the Dixon-Schneider algorithm first computes the linear characters, using the commutator factor group. If irreducible characters are missing afterwards, they are computed using the techniques described in <a href="chapBib.html#biBDix67">[Dix67]</a>, <a href="chapBib.html#biBSch90">[Sch90]</a> and <a href="chapBib.html#biBHulpke93">[Hul93]</a>.</p>

<p>Called with a group <span class="SimpleMath">G</span>, the function <code class="func">CharacterTable</code> (<a href="chap71.html#X7FCA7A7A822BDA33"><span class="RefLink">71.3-1</span></a>) returns a character table object that stores already information such as class lengths, but not the irreducible characters. The routines that compute the irreducibles may use the information that is already contained in this table object. In particular the ordering of classes in the computed characters coincides with the ordering of classes in the character table of <var class="Arg">G</var> (see <a href="chap71.html#X793E0EBF84B07313"><span class="RefLink">71.6</span></a>). Thus it is possible to combine computations using the group with character theoretic computations (see <a href="chap71.html#X7C083207868066C1"><span class="RefLink">71.17</span></a> for details), for example one can enter known characters. Note that the user is responsible for the correctness of the characters. (There is little use in providing the trivial character to the routine.)</p>

<p>The computation of irreducible characters from the group needs to identify the classes of group elements very often, so it can be helpful to store a class list of all group elements. Since this is obviously limited by the group order, it is controlled by the global function <code class="func">IsDxLargeGroup</code> (<a href="chap71.html#X8089009E7EA85BC8"><span class="RefLink">71.17-8</span></a>).</p>

<p>The routines compute in a prime field of size <span class="SimpleMath">p</span>, such that the exponent of the group divides <span class="SimpleMath">(p-1)</span> and such that <span class="SimpleMath">2 sqrt{|G|} &lt; p</span>. Currently prime fields of size smaller than <span class="SimpleMath">65536</span> are handled more efficiently than larger prime fields, so the runtime of the character calculation depends on how large the chosen prime is.</p>

<p>The routine stores a Dixon record (see <code class="func">DixonRecord</code> (<a href="chap71.html#X7C398F2680C8616B"><span class="RefLink">71.17-1</span></a>)) in the group that helps routines that identify classes, for example <code class="func">FusionConjugacyClasses</code> (<a href="chap73.html#X86CE53B681F13C63"><span class="RefLink">73.3-1</span></a>), to work much faster. Note that interrupting Dixon-Schneider calculations will prevent <strong class="pkg">GAP</strong> from cleaning up the Dixon record; when the computation by <code class="func">IrrDixonSchneider</code> (<a href="chap71.html#X7ED39DB680BFEA96"><span class="RefLink">71.14-1</span></a>) is complete, the possibly large record is shrunk to an acceptable size.</p>

<p><a id="X7C083207868066C1" name="X7C083207868066C1"></a></p>

<h4>71.17 <span class="Heading">Advanced Methods for Dixon-Schneider Calculations</span></h4>

<p>The computation of irreducible characters of very large groups may take quite some time. On the other hand, for the expert only a few irreducible characters may be needed, since the other ones can be computed using character theoretic methods such as tensoring, induction, and restriction. Thus <strong class="pkg">GAP</strong> provides also step-by-step routines for doing the calculations. These routines allow one to compute some characters and to stop before all are calculated. Note that there is no "safety net": The routines (being somehow internal) do no error checking, and assume the information given is correct.</p>

<p>When the info level of <code class="func">InfoCharacterTable</code> (<a href="chap71.html#X7C6F3D947E5188D1"><span class="RefLink">71.4-2</span></a>) if positive, information about the progress of splitting is printed. (The default value is zero.)</p>

<p><a id="X7C398F2680C8616B" name="X7C398F2680C8616B"></a></p>

<h5>71.17-1 DixonRecord</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DixonRecord</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The <code class="func">DixonRecord</code> of a group contains information used by the routines to compute the irreducible characters and related information via the Dixon-Schneider algorithm such as class arrangement and character spaces split obtained so far. Usually this record is passed as argument to all subfunctions to avoid a long argument list. It has a component <code class="code">conjugacyClasses</code> which contains the classes of <var class="Arg">G</var> <em>ordered as the algorithm needs them</em>.</p>

<p><a id="X7E33C03E7BDDC9B0" name="X7E33C03E7BDDC9B0"></a></p>

<h5>71.17-2 DixonInit</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DixonInit</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function does all the initializations for the Dixon-Schneider algorithm. This includes calculation of conjugacy classes, power maps, linear characters and character morphisms. It returns a record (see <code class="func">DixonRecord</code> (<a href="chap71.html#X7C398F2680C8616B"><span class="RefLink">71.17-1</span></a>) and Section <a href="chap71.html#X7C1153637E7D2133"><span class="RefLink">71.18</span></a>) that can be used when calculating the irreducible characters of <var class="Arg">G</var> interactively.</p>

<p><a id="X868476037907918F" name="X868476037907918F"></a></p>

<h5>71.17-3 DixontinI</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DixontinI</code>( <var class="Arg">D</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function ends a Dixon-Schneider calculation. It sorts the characters according to the degree and unbinds components in the Dixon record that are not of use any longer. It returns a list of irreducible characters.</p>

<p><a id="X87ABE0B081DAD476" name="X87ABE0B081DAD476"></a></p>

<h5>71.17-4 DixonSplit</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DixonSplit</code>( <var class="Arg">D</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function performs one splitting step in the Dixon-Schneider algorithm. It selects a class, computes the (partial) class sum matrix, uses it to split character spaces and stores all the irreducible characters obtained that way.</p>

<p>The class to use for splitting is chosen via <code class="func">BestSplittingMatrix</code> (<a href="chap71.html#X7BFD4C1A821731FB"><span class="RefLink">71.17-5</span></a>) and the options described for this function apply here.</p>

<p><code class="func">DixonSplit</code> returns the number of the class that was used for splitting if a split was performed, and <code class="keyw">fail</code> otherwise.</p>

<p><a id="X7BFD4C1A821731FB" name="X7BFD4C1A821731FB"></a></p>

<h5>71.17-5 BestSplittingMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BestSplittingMatrix</code>( <var class="Arg">D</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns the number of the class sum matrix that is assumed to yield the best (cost/earning ration) split. This matrix then will be the next one computed and used.</p>

<p>The global option <code class="code">maxclasslen</code> (defaulting to <code class="func">infinity</code> (<a href="chap18.html#X8511B8DF83324C27"><span class="RefLink">18.2-1</span></a>)) is recognized by <code class="func">BestSplittingMatrix</code>: Only classes whose length is limited by the value of this option will be considered for splitting. If no usable class remains, <code class="keyw">fail</code> is returned.</p>

<p><a id="X7C85B56C80BFA2E3" name="X7C85B56C80BFA2E3"></a></p>

<h5>71.17-6 DxIncludeIrreducibles</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DxIncludeIrreducibles</code>( <var class="Arg">D</var>, <var class="Arg">new</var>[, <var class="Arg">newmod</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function takes a list of irreducible characters <var class="Arg">new</var>, each given as a list of values (corresponding to the class arrangement in <var class="Arg">D</var>), and adds these to a partial computed list of irreducibles as maintained by the Dixon record <var class="Arg">D</var>. This permits one to add characters in interactive use obtained from other sources and to continue the Dixon-Schneider calculation afterwards. If the optional argument <var class="Arg">newmod</var> is given, it must be a list of reduced characters, corresponding to <var class="Arg">new</var>. (Otherwise the function has to reduce the characters itself.)</p>

<p>The function closes the new characters under the action of Galois automorphisms and tensor products with linear characters.</p>

<p><a id="X87A5B5C77F7F348E" name="X87A5B5C77F7F348E"></a></p>

<h5>71.17-7 SplitCharacters</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SplitCharacters</code>( <var class="Arg">D</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This routine decomposes the characters given in <var class="Arg">list</var> according to the character spaces found up to this point. By applying this routine to tensor products etc., it may result in characters with smaller norm, even irreducible ones. Since the recalculation of characters is only possible if the degree is small enough, the splitting process is applied only to characters of sufficiently small degree.</p>

<p><a id="X8089009E7EA85BC8" name="X8089009E7EA85BC8"></a></p>

<h5>71.17-8 IsDxLargeGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDxLargeGroup</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns <code class="keyw">true</code> if the order of the group <var class="Arg">G</var> is smaller than the current value of the global variable <code class="code">DXLARGEGROUPORDER</code>, and <code class="keyw">false</code> otherwise. In Dixon-Schneider calculations, for small groups in the above sense a class map is stored, whereas for large groups, each occurring element is identified individually.</p>

<p><a id="X7C1153637E7D2133" name="X7C1153637E7D2133"></a></p>

<h4>71.18 <span class="Heading">Components of a Dixon Record</span></h4>

<p>The "Dixon record" <var class="Arg">D</var> returned by <code class="func">DixonInit</code> (<a href="chap71.html#X7E33C03E7BDDC9B0"><span class="RefLink">71.17-2</span></a>) stores all the information that is used by the Dixon-Schneider routines while computing the irreducible characters of a group. Some entries, however, may be useful to know about when using the algorithm interactively, see <a href="chap71.html#X782B5E37848786BC"><span class="RefLink">71.19</span></a>.</p>


<dl>
<dt><strong class="Mark"><code class="code">group</code></strong></dt>
<dd><p>the group <span class="SimpleMath">G</span> of which the character table is to be computed,</p>

</dd>
<dt><strong class="Mark"><code class="code">conjugacyClasses</code></strong></dt>
<dd><p>classes of <span class="SimpleMath">G</span> (all characters stored in the Dixon record correspond to this arrangement of classes),</p>

</dd>
<dt><strong class="Mark"><code class="code">irreducibles</code></strong></dt>
<dd><p>the already known irreducible characters (given as lists of their values on the conjugacy classes),</p>

</dd>
<dt><strong class="Mark"><code class="code">characterTable</code></strong></dt>
<dd><p>the <code class="func">CharacterTable</code> (<a href="chap71.html#X7FCA7A7A822BDA33"><span class="RefLink">71.3-1</span></a>) value of <span class="SimpleMath">G</span> (whose irreducible characters are not yet known),</p>

</dd>
<dt><strong class="Mark"><code class="code">ClassElement( <var class="Arg">D</var>, <var class="Arg">el</var> )</code></strong></dt>
<dd><p>a function that returns the number of the class of <span class="SimpleMath">G</span> that contains the element <var class="Arg">el</var>.</p>

</dd>
</dl>
<p><a id="X782B5E37848786BC" name="X782B5E37848786BC"></a></p>

<h4>71.19 <span class="Heading">An Example of Advanced Dixon-Schneider Calculations</span></h4>

<p>First, we set the appropriate info level higher.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetInfoLevel( InfoCharacterTable, 1 );</span>
</pre></div>

<p>for printout of some internal results. We now define our group, which is isomorphic to PSL<span class="SimpleMath">_4(3)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= PrimitiveGroup(40,5);</span>
PSL(4, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(g);</span>
6065280
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d:= DixonInit( g );;</span>
#I  29 classes
#I  choosing prime 65521
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c:= d.characterTable;;</span>
</pre></div>

<p>After the initialisation, one structure matrix is evaluated, yielding smaller spaces and several irreducible characters.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DixonSplit( d );</span>
#I  Matrix 2,Representative of Order 3,Centralizer: 5832
#I  Dimensions: [ 1, 2, 1, 4, 12, 1, 1, 2, 1, 2, 1 ]
#I  Two-dim space split
#I  Two-dim space split
#I  Two-dim space split
2
</pre></div>

<p>In this case spaces of the listed dimensions are a result of the splitting process. The three two dimensional spaces are split successfully by combinatoric means.</p>

<p>We obtain several irreducible characters by tensor products and notify them to the Dixon record.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">asp:= AntiSymmetricParts( c, d.irreducibles, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ro:= ReducedCharacters( c, d.irreducibles, asp );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( ro.irreducibles );</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DxIncludeIrreducibles( d, ro.irreducibles );</span>
</pre></div>

<p>The tensor products of the nonlinear characters among each other are reduced with the irreducible characters. The result is split according to the spaces found, which yields characters of smaller norms, but no new irreducibles.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nlc:= Filtered( d.irreducibles, i -&gt; i[1] &gt; 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= Tensored( nlc, nlc );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ro:= ReducedCharacters( c, d.irreducibles, t );;  ro.irreducibles;</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ro.remainders, i -&gt; ScalarProduct( c, i, i) );</span>
[ 2, 2, 4, 4, 4, 4, 13, 13, 18, 18, 19, 21, 21, 36, 36, 29, 34, 34, 
  42, 34, 48, 54, 62, 68, 68, 78, 84, 84, 88, 90, 159, 169, 169, 172, 
  172, 266, 271, 271, 268, 274, 274, 280, 328, 373, 373, 456, 532, 
  576, 679, 683, 683, 754, 768, 768, 890, 912, 962, 1453, 1453, 1601, 
  1601, 1728, 1739, 1739, 1802, 2058, 2379, 2414, 2543, 2744, 2744, 
  2920, 3078, 3078, 4275, 4275, 4494, 4760, 5112, 5115, 5115, 5414, 
  6080, 6318, 7100, 7369, 7369, 7798, 8644, 10392, 12373, 12922, 
  14122, 14122, 18948, 21886, 24641, 24641, 25056, 38942, 44950, 
  78778 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= SplitCharacters( d, ro.remainders );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( t, i -&gt; ScalarProduct( c, i, i ) );</span>
[ 2, 2, 4, 2, 2, 4, 4, 3, 6, 5, 5, 9, 9, 4, 12, 13, 18, 18, 20, 18, 
  20, 24, 26, 32, 32, 16, 42, 59, 69, 69, 72, 72, 36, 72, 78, 78, 84, 
  122, 117, 127, 117, 127, 64, 132, 100, 144, 196, 256, 456, 532, 
  576, 679, 683, 683, 754, 768, 768, 890, 912, 962, 1453, 1453, 1601, 
  1601, 1728, 1739, 1739, 1802, 2058, 2379, 2414, 2543, 2744, 2744, 
  2920, 3078, 3078, 4275, 4275, 4494, 4760, 5112, 5115, 5115, 5414, 
  6080, 6318, 7100, 7369, 7369, 7798, 8644, 10392, 12373, 12922, 
  14122, 14122, 18948, 21886, 24641, 24641, 25056, 38942, 44950, 
  78778 ]
</pre></div>

<p>Finally we calculate the characters induced from all cyclic subgroups and obtain the missing irreducibles by applying the LLL-algorithm to them.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ic:= InducedCyclic( c, "all" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ro:= ReducedCharacters( c, d.irreducibles, ic );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( ro.irreducibles );</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l:= LLL( c, ro.remainders );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( l.irreducibles );</span>
13
</pre></div>

<p>The LLL returns class function objects (see Chapter <a href="chap72.html#X7C91D0D17850E564"><span class="RefLink">72</span></a>), and the Dixon record works with character values lists. So we convert them to a list of values before feeding them in the machinery of the Dixon-algorithm.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l.irreducibles[1];</span>
Character( CharacterTable( PSL(4, 3) ),
 [ 640, -8, -8, -8, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, E(13)^7+E(13)^8+E(13)^11, E(13)^4+E(13)^10+E(13)^12, 
  E(13)^2+E(13)^5+E(13)^6, E(13)+E(13)^3+E(13)^9, 0 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l:=List(l.irreducibles,ValuesOfClassFunction);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DxIncludeIrreducibles( d, l );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( d.irreducibles );</span>
29
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( d.classes );</span>
29
</pre></div>

<p>It turns out we have found all irreducible characters. As the last step, we obtain the irreducible characters and tell them to the group. This makes them available also to the character table.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irrs:= DixontinI( d );;</span>
#I  Total:1 matrices,[ 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetIrr(g,irrs);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length(Irr(c));</span>
29
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetInfoLevel( InfoCharacterTable, 0 );</span>
</pre></div>

<p><a id="X7C38C5067941D496" name="X7C38C5067941D496"></a></p>

<h4>71.20 <span class="Heading">Constructing Character Tables from Others</span></h4>

<p>The following operations take one or more character table arguments, and return a character table. This holds also for <code class="func">BrauerTable</code> (<a href="chap71.html#X8476B25A79D7A7FC"><span class="RefLink">71.3-2</span></a>). Note that the return value of <code class="func">BrauerTable</code> (<a href="chap71.html#X8476B25A79D7A7FC"><span class="RefLink">71.3-2</span></a>) will in general not know the irreducible Brauer characters, and <strong class="pkg">GAP</strong> might be unable to compute these characters.</p>

<p><em>Note</em> that whenever fusions between input and output tables occur in these operations, they are stored on the concerned tables, and the <code class="func">NamesOfFusionSources</code> (<a href="chap73.html#X7F6569D5786A9D49"><span class="RefLink">73.3-5</span></a>) values are updated.</p>

<p>(The interactive construction of character tables using character theoretic methods and incomplete tables is not described here.) <em>Currently it is not supported and will be described in a chapter of its own when it becomes available</em>.</p>

<p><a id="X7BE1572D7BBC6AC8" name="X7BE1572D7BBC6AC8"></a></p>

<h5>71.20-1 CharacterTableDirectProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CharacterTableDirectProduct</code>( <var class="Arg">tbl1</var>, <var class="Arg">tbl2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>is the table of the direct product of the character tables <var class="Arg">tbl1</var> and <var class="Arg">tbl2</var>.</p>

<p>The matrix of irreducibles of this table is the Kronecker product (see <code class="func">KroneckerProduct</code> (<a href="chap24.html#X8634C79E7DB22934"><span class="RefLink">24.5-8</span></a>)) of the irreducibles of <var class="Arg">tbl1</var> and <var class="Arg">tbl2</var>.</p>

<p>Products of ordinary and Brauer character tables are supported.</p>

<p>In general, the result will not know an underlying group, so missing power maps (for prime divisors of the result) and irreducibles of the input tables may be computed in order to construct the table of the direct product.</p>

<p>The embeddings of the input tables into the direct product are stored, they can be fetched with <code class="func">GetFusionMap</code> (<a href="chap73.html#X8464DD23879431D9"><span class="RefLink">73.3-3</span></a>); if <var class="Arg">tbl1</var> is equal to <var class="Arg">tbl2</var> then the two embeddings are distinguished by their <code class="code">specification</code> components <code class="code">"1"</code> and <code class="code">"2"</code>, respectively.</p>

<p>Analogously, the projections from the direct product onto the input tables are stored, and can be distinguished by the <code class="code">specification</code> components.</p>

<p>The attribute <code class="func">FactorsOfDirectProduct</code> (<a href="chap71.html#X7C97CF727FBDFCAB"><span class="RefLink">71.20-2</span></a>) is set to the lists of arguments.</p>

<p>The <code class="code">*</code> operator for two character tables (see <a href="chap71.html#X7CADCBC9824CB624"><span class="RefLink">71.7</span></a>) delegates to <code class="func">CharacterTableDirectProduct</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c2:= CharacterTable( "Cyclic", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s3:= CharacterTable( "Symmetric", 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CharacterTableDirectProduct( c2, s3 ) );</span>
C2xSym(3)

     2  2  2  1  2  2  1
     3  1  .  1  1  .  1

       1a 2a 3a 2b 2c 6a
    2P 1a 1a 3a 1a 1a 3a
    3P 1a 2a 1a 2b 2c 2b

X.1     1 -1  1  1 -1  1
X.2     2  . -1  2  . -1
X.3     1  1  1  1  1  1
X.4     1 -1  1 -1  1 -1
X.5     2  . -1 -2  .  1
X.6     1  1  1 -1 -1 -1
</pre></div>

<p><a id="X7C97CF727FBDFCAB" name="X7C97CF727FBDFCAB"></a></p>

<h5>71.20-2 FactorsOfDirectProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FactorsOfDirectProduct</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For an ordinary character table that has been constructed via <code class="func">CharacterTableDirectProduct</code> (<a href="chap71.html#X7BE1572D7BBC6AC8"><span class="RefLink">71.20-1</span></a>), the value of <code class="func">FactorsOfDirectProduct</code> is the list of arguments in the <code class="func">CharacterTableDirectProduct</code> (<a href="chap71.html#X7BE1572D7BBC6AC8"><span class="RefLink">71.20-1</span></a>) call.</p>

<p>Note that there is no default method for <em>computing</em> the value of <code class="func">FactorsOfDirectProduct</code>.</p>

<p><a id="X7C3A4E5283B240BE" name="X7C3A4E5283B240BE"></a></p>

<h5>71.20-3 CharacterTableFactorGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CharacterTableFactorGroup</code>( <var class="Arg">tbl</var>, <var class="Arg">classes</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>is the character table of the factor group of the ordinary character table <var class="Arg">tbl</var> by the normal closure of the classes whose positions are contained in the list <var class="Arg">classes</var>.</p>

<p>The <code class="code">/</code> operator for a character table and a list of class positions (see <a href="chap71.html#X7CADCBC9824CB624"><span class="RefLink">71.7</span></a>) delegates to <code class="func">CharacterTableFactorGroup</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s4:= CharacterTable( "Symmetric", 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassPositionsOfNormalSubgroups( s4 );</span>
[ [ 1 ], [ 1, 3 ], [ 1, 3, 4 ], [ 1 .. 5 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f:= CharacterTableFactorGroup( s4, [ 3 ] );</span>
CharacterTable( "Sym(4)/[ 1, 3 ]" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( f );</span>
Sym(4)/[ 1, 3 ]

     2  1  1  .
     3  1  .  1

       1a 2a 3a
    2P 1a 1a 3a
    3P 1a 2a 1a

X.1     1 -1  1
X.2     2  . -1
X.3     1  1  1
</pre></div>

<p><a id="X85BE46F784B83938" name="X85BE46F784B83938"></a></p>

<h5>71.20-4 CharacterTableIsoclinic</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CharacterTableIsoclinic</code>( <var class="Arg">tbl</var>[, <var class="Arg">arec</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CharacterTableIsoclinic</code>( <var class="Arg">tbl</var>[, <var class="Arg">classes</var>][, <var class="Arg">centre</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CharacterTableIsoclinic</code>( <var class="Arg">modtbl</var>, <var class="Arg">ordiso</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SourceOfIsoclinicTable</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">tbl</var> be the (ordinary or modular) character table of a group <span class="SimpleMath">H</span>, say, with the structure <span class="SimpleMath">p.G.p</span> for some prime <span class="SimpleMath">p</span>, that is, <span class="SimpleMath">H/Z</span> has a normal subgroup <span class="SimpleMath">N</span> of index <span class="SimpleMath">p</span> and a central subgroup <span class="SimpleMath">Z</span> of order <span class="SimpleMath">p</span> contained in <span class="SimpleMath">N</span>.</p>

<p>Then <code class="func">CharacterTableIsoclinic</code> returns the table of an isoclinic group in the sense of the <strong class="pkg">Atlas</strong> of Finite Groups <a href="chapBib.html#biBCCN85">[CCN+85, Chapter 6, Section 7]</a>.</p>

<p>If <span class="SimpleMath">p = 2</span> then also the case <span class="SimpleMath">H = 4.G.2</span> is supported, that is, <span class="SimpleMath">Z</span> has order four and <span class="SimpleMath">N</span> has index two in <span class="SimpleMath">H</span>.</p>

<p>The optional arguments are needed if <var class="Arg">tbl</var> does not determine the class positions of <span class="SimpleMath">N</span> or <span class="SimpleMath">Z</span> uniquely, and in the case <span class="SimpleMath">p &gt; 2</span> if one wants to specify a "variant number" for the result.</p>


<ul>
<li><p>In general, the values can be specified via a record <var class="Arg">arec</var>. If <span class="SimpleMath">N</span> is not uniquely determined then the positions of the classes forming <span class="SimpleMath">N</span> must be entered as the value of the component <code class="code">normalSubgroup</code>. If <span class="SimpleMath">Z</span> is not unique inside <span class="SimpleMath">N</span> then the class position of a generator of <span class="SimpleMath">Z</span> must be entered as the value of the component <code class="code">centralElement</code>.</p>

</li>
<li><p>If <span class="SimpleMath">p = 2</span> then one may specify the positions of the classes forming <span class="SimpleMath">N</span> via a list <var class="Arg">classes</var>, and the positions of the classes in <span class="SimpleMath">Z</span> as a list <var class="Arg">centre</var>; if <span class="SimpleMath">Z</span> has order <span class="SimpleMath">2</span> then <var class="Arg">centre</var> can be also the position of the involution in <span class="SimpleMath">Z</span>.</p>

</li>
</ul>
<p>Note that also if <var class="Arg">tbl</var> is a Brauer table then <code class="code">normalSubgroup</code> and <code class="code">centralElement</code>, resp.  <var class="Arg">classes</var> and <var class="Arg">centre</var>, denote class numbers w.r.t. the <em>ordinary</em> character table.</p>

<p>If <span class="SimpleMath">p</span> is odd then the <strong class="pkg">Atlas</strong> construction describes <span class="SimpleMath">p</span> isoclinic variants that arise from <span class="SimpleMath">p.G.p</span>. (These groups need not be pairwise nonisomorphic.) Entering an integer <span class="SimpleMath">k ∈ { 1, 2, ..., k-1 }</span> as the value of the component <code class="code">k</code> of <var class="Arg">arec</var> yields the <span class="SimpleMath">k</span>-th of the corresponding character tables; the default for <code class="code">k</code> is <span class="SimpleMath">1</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d8:= CharacterTable( "Dihedral", 8 );</span>
CharacterTable( "Dihedral(8)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nsg:= ClassPositionsOfNormalSubgroups( d8 );</span>
[ [ 1 ], [ 1, 3 ], [ 1 .. 3 ], [ 1, 3, 4 ], [ 1, 3 .. 5 ], [ 1 .. 5 ] 
 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">isod8:= CharacterTableIsoclinic( d8, nsg[3] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( isod8 );</span>
Isoclinic(Dihedral(8))

     2  3  2  3  2  2

       1a 4a 2a 4b 4c
    2P 1a 2a 1a 2a 2a

X.1     1  1  1  1  1
X.2     1  1  1 -1 -1
X.3     1 -1  1  1 -1
X.4     1 -1  1 -1  1
X.5     2  . -2  .  .
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t1:= CharacterTable( SmallGroup( 27, 3 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t2:= CharacterTable( SmallGroup( 27, 4 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nsg:= ClassPositionsOfNormalSubgroups( t1 );</span>
[ [ 1 ], [ 1, 4, 8 ], [ 1, 2, 4, 5, 8 ], [ 1, 3, 4, 7, 8 ], 
  [ 1, 4, 6, 8, 11 ], [ 1, 4, 8, 9, 10 ], [ 1 .. 11 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso1:= CharacterTableIsoclinic( t1, rec( k:= 1,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              normalSubgroup:= nsg[3] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso2:= CharacterTableIsoclinic( t1, rec( k:= 2,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              normalSubgroup:= nsg[3] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransformingPermutationsCharacterTables( iso1, t1 ) &lt;&gt; fail;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransformingPermutationsCharacterTables( iso1, t2 ) &lt;&gt; fail;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransformingPermutationsCharacterTables( iso2, t2 ) &lt;&gt; fail;</span>
true
</pre></div>

<p>For an ordinary character table that has been constructed via <code class="func">CharacterTableIsoclinic</code>, the value of <code class="func">SourceOfIsoclinicTable</code> encodes this construction, and is defined as follows. If <span class="SimpleMath">p = 2</span> then the value is the list with entries <var class="Arg">tbl</var>, <var class="Arg">classes</var>, the list of class positions of the nonidentity elements in <span class="SimpleMath">Z</span>, and the class position of a generator of <span class="SimpleMath">Z</span>. If <span class="SimpleMath">p</span> is an odd prime then the value is a record with the following components.</p>


<dl>
<dt><strong class="Mark"><code class="code">table</code></strong></dt>
<dd><p>the character table <var class="Arg">tbl</var>,</p>

</dd>
<dt><strong class="Mark"><code class="code">p</code></strong></dt>
<dd><p>the prime <span class="SimpleMath">p</span>,</p>

</dd>
<dt><strong class="Mark"><code class="code">k</code></strong></dt>
<dd><p>the variant number <span class="SimpleMath">k</span>,</p>

</dd>
<dt><strong class="Mark"><code class="code">outerClasses</code></strong></dt>
<dd><p>the list of length <span class="SimpleMath">p-1</span> that contains at position <span class="SimpleMath">i</span> the sorted list of class positions of the <span class="SimpleMath">i</span>-th coset of the normal subgroup <span class="SimpleMath">N</span></p>

</dd>
<dt><strong class="Mark"><code class="code">centralElement</code></strong></dt>
<dd><p>the class position of a generator of the central subgroup <span class="SimpleMath">Z</span>.</p>

</dd>
</dl>
<p>There is no default method for <em>computing</em> the value of <code class="func">SourceOfIsoclinicTable</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SourceOfIsoclinicTable( isod8 );</span>
[ CharacterTable( "Dihedral(8)" ), [ 1 .. 3 ], [ 3 ], 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SourceOfIsoclinicTable( iso1 );</span>
rec( centralElement := 4, k := 1, 
  outerClasses := [ [ 3, 6, 9 ], [ 7, 10, 11 ] ], p := 3, 
  table := CharacterTable( &lt;pc group of size 27 with 3 generators&gt; ) )
</pre></div>

<p>If the arguments of <code class="func">CharacterTableIsoclinic</code> are a Brauer table <var class="Arg">modtbl</var> and an ordinary table <var class="Arg">ordiso</var> then the <code class="func">SourceOfIsoclinicTable</code> value of <var class="Arg">ordiso</var> is assumed to be identical with the <code class="func">OrdinaryCharacterTable</code> (<a href="chap71.html#X8011EEB684848039"><span class="RefLink">71.8-4</span></a>) value of <var class="Arg">modtbl</var>, and the specified isoclinic table of <var class="Arg">modtbl</var> is returned. This variant is useful if one has already constructed <var class="Arg">ordiso</var> in advance.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= GL(2,3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( g );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso:= CharacterTableIsoclinic( t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t3:= t mod 3;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso3:= CharacterTableIsoclinic( t3, iso );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransformingPermutationsCharacterTables( iso3,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       CharacterTableIsoclinic( t3 ) ) &lt;&gt; fail;</span>
true
</pre></div>

<p><em>Theoretical background:</em> Consider the central product <span class="SimpleMath">K</span> of <span class="SimpleMath">H</span> with a cyclic group <span class="SimpleMath">C</span> of order <span class="SimpleMath">p^2</span>. That is, <span class="SimpleMath">K = H C</span>, <span class="SimpleMath">C ≤ Z(K)</span>, and the central subgroup <span class="SimpleMath">Z</span> of order <span class="SimpleMath">p</span> in <span class="SimpleMath">H</span> lies in <span class="SimpleMath">C</span>. There are <span class="SimpleMath">p+1</span> subgroups of <span class="SimpleMath">K</span> that contain the normal subgroup <span class="SimpleMath">N</span> of index <span class="SimpleMath">p</span> in <span class="SimpleMath">H</span>. One of them is the central product of <span class="SimpleMath">C</span> with <span class="SimpleMath">N</span>, the others are <span class="SimpleMath">H_0 = H</span> and its isoclinic variants <span class="SimpleMath">H_1, H_2, ..., H_{p-1}</span>. We fix <span class="SimpleMath">g ∈ H ∖ N</span> and a generator <span class="SimpleMath">z</span> of <span class="SimpleMath">C</span>, and get <span class="SimpleMath">H = N ∪ N g ∪ N g^2 ∪ ⋯ ∪ N g^{p-1}</span>. Then <span class="SimpleMath">H_k</span>, <span class="SimpleMath">0 ≤ k ≤ p-1</span>, is given by <span class="SimpleMath">N ∪ N gz^k ∪ N (gz^k)^2 ∪ ⋯ ∪ N (gz^k)^{p-1}</span>. The conjugacy classes of all <span class="SimpleMath">H_k</span> are in bijection via multiplying the elements with suitable powers of <span class="SimpleMath">z</span>, and the irreducible characters of all <span class="SimpleMath">H_k</span> extend to <span class="SimpleMath">K</span> and are in bijection via multiplying the character values with suitable <span class="SimpleMath">p^2</span>-th roots of unity.</p>

<p><a id="X806E55A58397B11B" name="X806E55A58397B11B"></a></p>

<h5>71.20-5 CharacterTableOfNormalSubgroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CharacterTableOfNormalSubgroup</code>( <var class="Arg">ordtbl</var>, <var class="Arg">classes</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">ordtbl</var> be the ordinary character table of a group <span class="SimpleMath">G</span>, say, and <var class="Arg">classes</var> be a list of class positions for this table. If the classes given by <var class="Arg">classes</var> form a normal subgroup <span class="SimpleMath">N</span>, say, of <span class="SimpleMath">G</span> and if these classes are conjugacy classes of <span class="SimpleMath">N</span> then this function returns the character table of <span class="SimpleMath">N</span>. In all other cases, the function returns <code class="keyw">fail</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "Symmetric", 4 );</span>
CharacterTable( "Sym(4)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nsg:= ClassPositionsOfNormalSubgroups( t );</span>
[ [ 1 ], [ 1, 3 ], [ 1, 3, 4 ], [ 1 .. 5 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rest:= List( nsg, c -&gt; CharacterTableOfNormalSubgroup( t, c ) );</span>
[ CharacterTable( "Rest(Sym(4),[ 1 ])" ), fail, fail, 
  CharacterTable( "Rest(Sym(4),[ 1 .. 5 ])" ) ]
</pre></div>

<p>Here is a nontrivial example. We use <code class="func">CharacterTableOfNormalSubgroup</code> for computing the two isoclinic variants of <span class="SimpleMath">2.A_5.2</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= SchurCoverOfSymmetricGroup( 5, 3, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c:= CyclicGroup( 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">dp:= DirectProduct( g, c );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">diag:= First( Elements( Centre( dp ) ), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 x -&gt; Order( x ) = 2 and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                      not x in Image( Embedding( dp, 1 ) ) and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                      not x in Image( Embedding( dp, 2 ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fact:= Image( NaturalHomomorphismByNormalSubgroup( dp, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                     Subgroup( dp, [ diag ] ) ));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( fact );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( t );</span>
480
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nsg:= ClassPositionsOfNormalSubgroups( t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rest:= List( nsg, c -&gt; CharacterTableOfNormalSubgroup( t, c ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">index2:= Filtered( rest, x -&gt; x &lt;&gt; fail and Size( x ) = 240 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( index2 );</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tg:= CharacterTable( g );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       TransformingPermutationsCharacterTables( index2[1], tg ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       TransformingPermutationsCharacterTables( index2[2], tg ) );</span>
false
</pre></div>

<p>Alternatively, we could construct the character table of the central product with character theoretic methods. Or we could use <code class="func">CharacterTableIsoclinic</code> (<a href="chap71.html#X85BE46F784B83938"><span class="RefLink">71.20-4</span></a>).</p>

<p><a id="X79B75C8582426BC5" name="X79B75C8582426BC5"></a></p>

<h5>71.20-6 CharacterTableWreathSymmetric</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CharacterTableWreathSymmetric</code>( <var class="Arg">tbl</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns the character table of the wreath product of a group <span class="SimpleMath">G</span> with the full symmetric group on <var class="Arg">n</var> points, where <var class="Arg">tbl</var> is the character table of <span class="SimpleMath">G</span>.</p>

<p>The result has values for <code class="func">ClassParameters</code> (<a href="chap71.html#X8333E8038308947E"><span class="RefLink">71.9-7</span></a>) and <code class="func">CharacterParameters</code> (<a href="chap71.html#X8333E8038308947E"><span class="RefLink">71.9-7</span></a>) stored, the entries in these lists are sequences of partitions. Note that this parametrization prevents the principal character from being the first one in the list of irreducibles.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c3:= CharacterTable( "Cyclic", 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">wr:= CharacterTableWreathSymmetric( c3, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( wr );</span>
C3wrS2

     2  1   .   .   1  .   1  1   1   1
     3  2   2   2   2  2   2  1   1   1

       1a  3a  3b  3c 3d  3e 2a  6a  6b
    2P 1a  3b  3a  3e 3d  3c 1a  3c  3e
    3P 1a  1a  1a  1a 1a  1a 2a  2a  2a

X.1     1   1   1   1  1   1 -1  -1  -1
X.2     2   A  /A   B -1  /B  .   .   .
X.3     2  /A   A  /B -1   B  .   .   .
X.4     1 -/A  -A  -A  1 -/A -1  /A   A
X.5     2  -1  -1   2 -1   2  .   .   .
X.6     1  -A -/A -/A  1  -A -1   A  /A
X.7     1   1   1   1  1   1  1   1   1
X.8     1 -/A  -A  -A  1 -/A  1 -/A  -A
X.9     1  -A -/A -/A  1  -A  1  -A -/A

A = -E(3)^2
  = (1+Sqrt(-3))/2 = 1+b3
B = 2*E(3)
  = -1+Sqrt(-3) = 2b3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacterParameters( wr )[1];</span>
[ [ 1, 1 ], [  ], [  ] ]
</pre></div>

<p><a id="X83E71B1F7FA70134" name="X83E71B1F7FA70134"></a></p>

<h5>71.20-7 CharacterValueWreathSymmetric</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CharacterValueWreathSymmetric</code>( <var class="Arg">tbl</var>, <var class="Arg">n</var>, <var class="Arg">beta</var>, <var class="Arg">pi</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">tbl</var> be the ordinary character table of a group <span class="SimpleMath">G</span>, say. The aim of this function is to compute a single character value from the character table of the wreath product of <span class="SimpleMath">G</span> with the full symmetric group on <var class="Arg">n</var> points.</p>

<p>The conjugacy classes and the irreducible characters of this wreath product are parametrized by <span class="SimpleMath">r</span>-tuples of partitions which together form a partition of <var class="Arg">n</var> (see <code class="func">PartitionTuples</code> (<a href="chap16.html#X877D997B7F66A119"><span class="RefLink">16.2-30</span></a>)), where <span class="SimpleMath">r</span> is the number of conjugacy classes of <span class="SimpleMath">G</span>.</p>

<p>We describe the conjugacy class for which we want to compute the value by the <span class="SimpleMath">r</span>-tuple <var class="Arg">pi</var> of partitions in question, and describe the character for which we want to compute the value by the <span class="SimpleMath">r</span>-tuple <var class="Arg">beta</var> of <code class="func">BetaSet</code> (<a href="chap16.html#X8796C1D783ED9CB4"><span class="RefLink">16.2-32</span></a>) values of the <span class="SimpleMath">r</span>-tuple of partitions in question.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">n:= 4;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">classpara:= [ [], [ 2, 1, 1 ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">charpara:= [ [ 2, 1 ], [ 1 ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">betas:= List( charpara, BetaSet );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c2:= CharacterTable( "Cyclic", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacterValueWreathSymmetric( c2, n, betas, classpara );</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">wr:= CharacterTableWreathSymmetric( c2, n );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">classpos:= Position( ClassParameters( wr ), classpara );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">charpos:= Position( CharacterParameters( wr ), charpara );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Irr( wr )[ charpos, classpos ];</span>
0
</pre></div>

<p>This function can be useful if one is interested in only a few character values. If many character values are needed then it is probably faster to compute the whole character table of the wreath product using <code class="func">CharacterTableWreathSymmetric</code> (<a href="chap71.html#X79B75C8582426BC5"><span class="RefLink">71.20-6</span></a>), which uses intermediate results of recursive computations and therefore can avoid repetitions.</p>

<p><a id="X816FCD5A805F9FE8" name="X816FCD5A805F9FE8"></a></p>

<h4>71.21 <span class="Heading">Sorted Character Tables</span></h4>

<p><a id="X7D9C4A7F8086F671" name="X7D9C4A7F8086F671"></a></p>

<h5>71.21-1 CharacterTableWithSortedCharacters</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CharacterTableWithSortedCharacters</code>( <var class="Arg">tbl</var>[, <var class="Arg">perm</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>is a character table that differs from <var class="Arg">tbl</var> only by the succession of its irreducible characters. This affects the values of the attributes <code class="func">Irr</code> (<a href="chap71.html#X873B3CC57E9A5492"><span class="RefLink">71.8-2</span></a>) and <code class="func">CharacterParameters</code> (<a href="chap71.html#X8333E8038308947E"><span class="RefLink">71.9-7</span></a>). Namely, these lists are permuted by the permutation <var class="Arg">perm</var>.</p>

<p>If no second argument is given then a permutation is used that yields irreducible characters of increasing degree for the result. For the succession of characters in the result, see <code class="func">SortedCharacters</code> (<a href="chap71.html#X87E3CF317D8E4EC7"><span class="RefLink">71.21-2</span></a>).</p>

<p>The result has all those attributes and properties of <var class="Arg">tbl</var> that are stored in <code class="func">SupportedCharacterTableInfo</code> (<a href="chap71.html#X7DBEF4BF87F10CD6"><span class="RefLink">71.3-4</span></a>) and do not depend on the ordering of characters.</p>

<p><a id="X87E3CF317D8E4EC7" name="X87E3CF317D8E4EC7"></a></p>

<h5>71.21-2 SortedCharacters</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SortedCharacters</code>( <var class="Arg">tbl</var>, <var class="Arg">chars</var>[, <var class="Arg">flag</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>is a list containing the characters <var class="Arg">chars</var>, ordered as specified by the other arguments.</p>

<p>There are three possibilities to sort characters: They can be sorted according to ascending norms (<var class="Arg">flag</var> is the string <code class="code">"norm"</code>), to ascending degree (<var class="Arg">flag</var> is the string <code class="code">"degree"</code>), or both (no third argument is given), i.e., characters with same norm are sorted according to ascending degree, and characters with smaller norm precede those with bigger norm.</p>

<p>Rational characters in the result precede other ones with same norm and/or same degree.</p>

<p>The trivial character, if contained in <var class="Arg">chars</var>, will always be sorted to the first position.</p>

<p><a id="X7E3DE0A47E62BE6B" name="X7E3DE0A47E62BE6B"></a></p>

<h5>71.21-3 CharacterTableWithSortedClasses</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CharacterTableWithSortedClasses</code>( <var class="Arg">tbl</var>[, <var class="Arg">flag</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>is a character table obtained by permutation of the classes of <var class="Arg">tbl</var>. If the second argument <var class="Arg">flag</var> is the string <code class="code">"centralizers"</code> then the classes of the result are sorted according to descending centralizer orders. If the second argument is the string <code class="code">"representatives"</code> then the classes of the result are sorted according to ascending representative orders. If no second argument is given then the classes of the result are sorted according to ascending representative orders, and classes with equal representative orders are sorted according to descending centralizer orders.</p>

<p>If the second argument is a permutation then the classes of the result are sorted by application of this permutation.</p>

<p>The result has all those attributes and properties of <var class="Arg">tbl</var> that are stored in <code class="func">SupportedCharacterTableInfo</code> (<a href="chap71.html#X7DBEF4BF87F10CD6"><span class="RefLink">71.3-4</span></a>) and do not depend on the ordering of classes.</p>

<p><a id="X82DCAAA882416E24" name="X82DCAAA882416E24"></a></p>

<h5>71.21-4 SortedCharacterTable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SortedCharacterTable</code>( <var class="Arg">tbl</var>, <var class="Arg">kernel</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SortedCharacterTable</code>( <var class="Arg">tbl</var>, <var class="Arg">normalseries</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SortedCharacterTable</code>( <var class="Arg">tbl</var>, <var class="Arg">facttbl</var>, <var class="Arg">kernel</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>is a character table obtained on permutation of the classes and the irreducibles characters of <var class="Arg">tbl</var>.</p>

<p>The first form sorts the classes at positions contained in the list <var class="Arg">kernel</var> to the beginning, and sorts all characters in <code class="code">Irr( <var class="Arg">tbl</var> )</code> such that the first characters are those that contain <var class="Arg">kernel</var> in their kernel.</p>

<p>The second form does the same successively for all kernels <span class="SimpleMath">k_i</span> in the list <span class="SimpleMath"><var class="Arg">normalseries</var> = [ k_1, k_2, ..., k_n ]</span> where <span class="SimpleMath">k_i</span> must be a sublist of <span class="SimpleMath">k_{i+1}</span> for <span class="SimpleMath">1 ≤ i ≤ n-1</span>.</p>

<p>The third form computes the table <span class="SimpleMath">F</span> of the factor group of <var class="Arg">tbl</var> modulo the normal subgroup formed by the classes whose positions are contained in the list <var class="Arg">kernel</var>; <span class="SimpleMath">F</span> must be permutation equivalent to the table <var class="Arg">facttbl</var>, in the sense of <code class="func">TransformingPermutationsCharacterTables</code> (<a href="chap71.html#X849731AA7EC9FA73"><span class="RefLink">71.22-4</span></a>), otherwise <code class="keyw">fail</code> is returned. The classes of <var class="Arg">tbl</var> are sorted such that the preimages of a class of <span class="SimpleMath">F</span> are consecutive, and that the succession of preimages is that of <var class="Arg">facttbl</var>. The <code class="func">Irr</code> (<a href="chap71.html#X873B3CC57E9A5492"><span class="RefLink">71.8-2</span></a>) value of <var class="Arg">tbl</var> is sorted as with <code class="code">SortCharTable( <var class="Arg">tbl</var>, <var class="Arg">kernel</var> )</code>.</p>

<p>(<em>Note</em> that the transformation is only unique up to table automorphisms of <span class="SimpleMath">F</span>, and this need not be unique up to table automorphisms of <var class="Arg">tbl</var>.)</p>

<p>All rearrangements of classes and characters are stable, i.e., the relative positions of classes and characters that are not distinguished by any relevant property is not changed.</p>

<p>The result has all those attributes and properties of <var class="Arg">tbl</var> that are stored in <code class="func">SupportedCharacterTableInfo</code> (<a href="chap71.html#X7DBEF4BF87F10CD6"><span class="RefLink">71.3-4</span></a>) and do not depend on the ordering of classes and characters.</p>

<p>The <code class="func">ClassPermutation</code> (<a href="chap71.html#X8099FEDC7DE03AEE"><span class="RefLink">71.21-5</span></a>) value of <var class="Arg">tbl</var> is changed if necessary, see <a href="chap71.html#X829C4B6E83998F40"><span class="RefLink">71.5</span></a>.</p>

<p><code class="func">SortedCharacterTable</code> uses <code class="func">CharacterTableWithSortedClasses</code> (<a href="chap71.html#X7E3DE0A47E62BE6B"><span class="RefLink">71.21-3</span></a>) and <code class="func">CharacterTableWithSortedCharacters</code> (<a href="chap71.html#X7D9C4A7F8086F671"><span class="RefLink">71.21-1</span></a>).</p>

<p><a id="X8099FEDC7DE03AEE" name="X8099FEDC7DE03AEE"></a></p>

<h5>71.21-5 ClassPermutation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassPermutation</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>is a permutation <span class="SimpleMath">π</span> of classes of the character table <var class="Arg">tbl</var>. If it is stored then class fusions into <var class="Arg">tbl</var> that are stored on other tables must be followed by <span class="SimpleMath">π</span> in order to describe the correct fusion.</p>

<p>This attribute value is bound only if <var class="Arg">tbl</var> was obtained from another table by permuting the classes, using <code class="func">CharacterTableWithSortedClasses</code> (<a href="chap71.html#X7E3DE0A47E62BE6B"><span class="RefLink">71.21-3</span></a>) or <code class="func">SortedCharacterTable</code> (<a href="chap71.html#X82DCAAA882416E24"><span class="RefLink">71.21-4</span></a>).</p>

<p>It is necessary because the original table and the sorted table have the same identifier (and the same group if known), and hence the same fusions are valid for the two tables.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( "Symmetric", 4 );</span>
CharacterTable( "Sym(4)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( tbl );</span>
Sym(4)

     2  3  2  3  .  2
     3  1  .  .  1  .

       1a 2a 2b 3a 4a
    2P 1a 1a 1a 3a 2b
    3P 1a 2a 2b 1a 4a

X.1     1 -1  1  1 -1
X.2     3 -1 -1  .  1
X.3     2  .  2 -1  .
X.4     3  1 -1  . -1
X.5     1  1  1  1  1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">srt1:= CharacterTableWithSortedCharacters( tbl );</span>
CharacterTable( "Sym(4)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( Irr( srt1 ), Degree );</span>
[ 1, 1, 2, 3, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">srt2:= CharacterTableWithSortedClasses( tbl );</span>
CharacterTable( "Sym(4)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizesCentralizers( tbl );</span>
[ 24, 4, 8, 3, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizesCentralizers( srt2 );</span>
[ 24, 8, 4, 3, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nsg:= ClassPositionsOfNormalSubgroups( tbl );</span>
[ [ 1 ], [ 1, 3 ], [ 1, 3, 4 ], [ 1 .. 5 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">srt3:= SortedCharacterTable( tbl, nsg );</span>
CharacterTable( "Sym(4)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nsg:= ClassPositionsOfNormalSubgroups( srt3 );</span>
[ [ 1 ], [ 1, 2 ], [ 1 .. 3 ], [ 1 .. 5 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( srt3 );</span>
Sym(4)

     2  3  3  .  2  2
     3  1  .  1  .  .

       1a 2a 3a 2b 4a
    2P 1a 1a 3a 1a 2a
    3P 1a 2a 1a 2b 4a

X.1     1  1  1  1  1
X.2     1  1  1 -1 -1
X.3     2  2 -1  .  .
X.4     3 -1  . -1  1
X.5     3 -1  .  1 -1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassPermutation( srt3 );</span>
(2,4,3)
</pre></div>

<p><a id="X7B0A669484470D09" name="X7B0A669484470D09"></a></p>

<h4>71.22 <span class="Heading">Automorphisms and Equivalence of Character Tables</span></h4>

<p><a id="X84353BB884AF0365" name="X84353BB884AF0365"></a></p>

<h5>71.22-1 MatrixAutomorphisms</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MatrixAutomorphisms</code>( <var class="Arg">mat</var>[, <var class="Arg">maps</var>, <var class="Arg">subgroup</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>For a matrix <var class="Arg">mat</var>, <code class="func">MatrixAutomorphisms</code> returns the group of those permutations of the columns of <var class="Arg">mat</var> that leave the set of rows of <var class="Arg">mat</var> invariant.</p>

<p>If the arguments <var class="Arg">maps</var> and <var class="Arg">subgroup</var> are given, only the group of those permutations is constructed that additionally fix each list in the list <var class="Arg">maps</var> under pointwise action <code class="func">OnTuples</code> (<a href="chap41.html#X832CC5F87EEA4A7E"><span class="RefLink">41.2-5</span></a>), and <var class="Arg">subgroup</var> is a permutation group that is known to be a subgroup of this group of automorphisms.</p>

<p>Each entry in <var class="Arg">maps</var> must be a list of same length as the rows of <var class="Arg">mat</var>. For example, if <var class="Arg">mat</var> is a list of irreducible characters of a group then the list of element orders of the conjugacy classes (see <code class="func">OrdersClassRepresentatives</code> (<a href="chap71.html#X86F455DA7A9C30EE"><span class="RefLink">71.9-1</span></a>)) may be an entry in <var class="Arg">maps</var>.</p>

<p><a id="X8082DD827C673138" name="X8082DD827C673138"></a></p>

<h5>71.22-2 TableAutomorphisms</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TableAutomorphisms</code>( <var class="Arg">tbl</var>, <var class="Arg">characters</var>[, <var class="Arg">info</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p><code class="func">TableAutomorphisms</code> returns the permutation group of those matrix automorphisms (see <code class="func">MatrixAutomorphisms</code> (<a href="chap71.html#X84353BB884AF0365"><span class="RefLink">71.22-1</span></a>)) of the list <var class="Arg">characters</var> that leave the element orders (see <code class="func">OrdersClassRepresentatives</code> (<a href="chap71.html#X86F455DA7A9C30EE"><span class="RefLink">71.9-1</span></a>)) and all stored power maps (see <code class="func">ComputedPowerMaps</code> (<a href="chap73.html#X781FAA497E3B4D1A"><span class="RefLink">73.1-1</span></a>)) of the character table <var class="Arg">tbl</var> invariant.</p>

<p>If <var class="Arg">characters</var> is closed under Galois conjugacy –this is always fulfilled for the list of all irreducible characters of ordinary character tables– the string <code class="code">"closed"</code> may be entered as the third argument <var class="Arg">info</var>. Alternatively, a known subgroup of the table automorphisms can be entered as the third argument <var class="Arg">info</var>.</p>

<p>The attribute <code class="func">AutomorphismsOfTable</code> (<a href="chap71.html#X7C2753DE8094F4BA"><span class="RefLink">71.9-4</span></a>) can be used to compute and store the table automorphisms for the case that <var class="Arg">characters</var> equals the <code class="func">Irr</code> (<a href="chap71.html#X873B3CC57E9A5492"><span class="RefLink">71.8-2</span></a>) value of <var class="Arg">tbl</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbld8:= CharacterTable( "Dihedral", 8 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irrd8:= Irr( tbld8 );</span>
[ Character( CharacterTable( "Dihedral(8)" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "Dihedral(8)" ), [ 1, 1, 1, -1, -1 ] ), 
  Character( CharacterTable( "Dihedral(8)" ), [ 1, -1, 1, 1, -1 ] ), 
  Character( CharacterTable( "Dihedral(8)" ), [ 1, -1, 1, -1, 1 ] ), 
  Character( CharacterTable( "Dihedral(8)" ), [ 2, 0, -2, 0, 0 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orders:= OrdersClassRepresentatives( tbld8 );</span>
[ 1, 4, 2, 2, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MatrixAutomorphisms( irrd8 );</span>
Group([ (4,5), (2,4) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MatrixAutomorphisms( irrd8, [ orders ], Group( () ) );</span>
Group([ (4,5) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TableAutomorphisms( tbld8, irrd8 );</span>
Group([ (4,5) ])
</pre></div>

<p><a id="X7D721E3D7AA319F5" name="X7D721E3D7AA319F5"></a></p>

<h5>71.22-3 TransformingPermutations</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TransformingPermutations</code>( <var class="Arg">mat1</var>, <var class="Arg">mat2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">mat1</var> and <var class="Arg">mat2</var> be matrices. <code class="func">TransformingPermutations</code> tries to construct a permutation <span class="SimpleMath">π</span> that transforms the set of rows of the matrix <var class="Arg">mat1</var> to the set of rows of the matrix <var class="Arg">mat2</var> by permuting the columns.</p>

<p>If such a permutation exists, a record with the components <code class="code">columns</code>, <code class="code">rows</code>, and <code class="code">group</code> is returned, otherwise <code class="keyw">fail</code>. For <code class="code">TransformingPermutations( <var class="Arg">mat1</var>, <var class="Arg">mat2</var> ) = <var class="Arg">r</var></code> <span class="SimpleMath">≠</span> <code class="keyw">fail</code>, we have <code class="code"><var class="Arg">mat2</var> = Permuted( List( <var class="Arg">mat1</var>, x -&gt; Permuted( x, <var class="Arg">r</var>.columns ) ), <var class="Arg">r</var>.rows )</code>.</p>

<p><var class="Arg">r</var><code class="code">.group</code> is the group of matrix automorphisms of <var class="Arg">mat2</var> (see <code class="func">MatrixAutomorphisms</code> (<a href="chap71.html#X84353BB884AF0365"><span class="RefLink">71.22-1</span></a>)). This group stabilizes the transformation in the sense that applying any of its elements to the columns of <var class="Arg">mat2</var> preserves the set of rows of <var class="Arg">mat2</var>.</p>

<p><a id="X849731AA7EC9FA73" name="X849731AA7EC9FA73"></a></p>

<h5>71.22-4 TransformingPermutationsCharacterTables</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TransformingPermutationsCharacterTables</code>( <var class="Arg">tbl1</var>, <var class="Arg">tbl2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">tbl1</var> and <var class="Arg">tbl2</var> be character tables. <code class="func">TransformingPermutationsCharacterTables</code> tries to construct a permutation <span class="SimpleMath">π</span> that transforms the set of rows of the matrix <code class="code">Irr( <var class="Arg">tbl1</var> )</code> to the set of rows of the matrix <code class="code">Irr( <var class="Arg">tbl2</var> )</code> by permuting the columns (see <code class="func">TransformingPermutations</code> (<a href="chap71.html#X7D721E3D7AA319F5"><span class="RefLink">71.22-3</span></a>)), such that <span class="SimpleMath">π</span> transforms also the power maps and the element orders.</p>

<p>If such a permutation <span class="SimpleMath">π</span> exists then a record with the components <code class="code">columns</code> (<span class="SimpleMath">π</span>), <code class="code">rows</code> (the permutation of <code class="code">Irr( <var class="Arg">tbl1</var> )</code> corresponding to <span class="SimpleMath">π</span>), and <code class="code">group</code> (the permutation group of table automorphisms of <var class="Arg">tbl2</var>, see <code class="func">AutomorphismsOfTable</code> (<a href="chap71.html#X7C2753DE8094F4BA"><span class="RefLink">71.9-4</span></a>)) is returned. If no such permutation exists, <code class="keyw">fail</code> is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblq8:= CharacterTable( "Quaternionic", 8 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irrq8:= Irr( tblq8 );</span>
[ Character( CharacterTable( "Q8" ), [ 1, 1, 1, 1, 1 ] ), 
  Character( CharacterTable( "Q8" ), [ 1, 1, 1, -1, -1 ] ), 
  Character( CharacterTable( "Q8" ), [ 1, -1, 1, 1, -1 ] ), 
  Character( CharacterTable( "Q8" ), [ 1, -1, 1, -1, 1 ] ), 
  Character( CharacterTable( "Q8" ), [ 2, 0, -2, 0, 0 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrdersClassRepresentatives( tblq8 );</span>
[ 1, 4, 2, 4, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransformingPermutations( irrd8, irrq8 );</span>
rec( columns := (), group := Group([ (4,5), (2,4) ]), rows := () )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransformingPermutationsCharacterTables( tbld8, tblq8 );</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbld6:= CharacterTable( "Dihedral", 6 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbls3:= CharacterTable( "Symmetric", 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransformingPermutationsCharacterTables( tbld6, tbls3 );</span>
rec( columns := (2,3), group := Group(()), rows := (1,3,2) )
</pre></div>

<p><a id="X8117D940835B0B47" name="X8117D940835B0B47"></a></p>

<h5>71.22-5 FamiliesOfRows</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FamiliesOfRows</code>( <var class="Arg">mat</var>, <var class="Arg">maps</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>distributes the rows of the matrix <var class="Arg">mat</var> into families, as follows. Two rows of <var class="Arg">mat</var> belong to the same family if there is a permutation of columns that maps one row to the other row. Each entry in the list <var class="Arg">maps</var> is regarded to form a family of length 1.</p>

<p><code class="func">FamiliesOfRows</code> returns a record with the components</p>


<dl>
<dt><strong class="Mark"><code class="code">famreps</code></strong></dt>
<dd><p>the list of representatives for each family,</p>

</dd>
<dt><strong class="Mark"><code class="code">permutations</code></strong></dt>
<dd><p>the list that contains at position <span class="SimpleMath">i</span> a list of permutations that map the members of the family with representative <code class="code">famreps</code><span class="SimpleMath">[i]</span> to that representative,</p>

</dd>
<dt><strong class="Mark"><code class="code">families</code></strong></dt>
<dd><p>the list that contains at position <span class="SimpleMath">i</span> the list of positions of members of the family of representative <code class="code">famreps</code><span class="SimpleMath">[i]</span>; (for the element <var class="Arg">maps</var><span class="SimpleMath">[i]</span> the only member of the family will get the number <code class="code">Length( <var class="Arg">mat</var> ) + </code><span class="SimpleMath">i</span>).</p>

</dd>
</dl>
<p><a id="X81272CEE79F13E7B" name="X81272CEE79F13E7B"></a></p>

<h4>71.23 <span class="Heading">Storing Normal Subgroup Information</span></h4>

<p><a id="X7E66174C7C7A8C0C" name="X7E66174C7C7A8C0C"></a></p>

<h5>71.23-1 NormalSubgroupClassesInfo</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NormalSubgroupClassesInfo</code>( <var class="Arg">tbl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">tbl</var> be the ordinary character table of the group <span class="SimpleMath">G</span>. Many computations for group characters of <span class="SimpleMath">G</span> involve computations in normal subgroups or factor groups of <span class="SimpleMath">G</span>.</p>

<p>In some cases the character table <var class="Arg">tbl</var> is sufficient; for example questions about a normal subgroup <span class="SimpleMath">N</span> of <span class="SimpleMath">G</span> can be answered if one knows the conjugacy classes that form <span class="SimpleMath">N</span>, e.g., the question whether a character of <span class="SimpleMath">G</span> restricts irreducibly to <span class="SimpleMath">N</span>. But other questions require the computation of <span class="SimpleMath">N</span> or even more information, like the character table of <span class="SimpleMath">N</span>.</p>

<p>In order to do these computations only once, one stores in the group a record with components to store normal subgroups, the corresponding lists of conjugacy classes, and (if necessary) the factor groups, namely</p>


<dl>
<dt><strong class="Mark"><code class="code">nsg</code></strong></dt>
<dd><p>list of normal subgroups of <span class="SimpleMath">G</span>, may be incomplete,</p>

</dd>
<dt><strong class="Mark"><code class="code">nsgclasses</code></strong></dt>
<dd><p>at position <span class="SimpleMath">i</span>, the list of positions of conjugacy classes of <var class="Arg">tbl</var> forming the <span class="SimpleMath">i</span>-th entry of the <code class="code">nsg</code> component,</p>

</dd>
<dt><strong class="Mark"><code class="code">nsgfactors</code></strong></dt>
<dd><p>at position <span class="SimpleMath">i</span>, if bound, the factor group modulo the <span class="SimpleMath">i</span>-th entry of the <code class="code">nsg</code> component.</p>

</dd>
</dl>
<p><code class="func">NormalSubgroupClasses</code> (<a href="chap71.html#X87E7391F7F92377C"><span class="RefLink">71.23-3</span></a>), <code class="func">FactorGroupNormalSubgroupClasses</code> (<a href="chap71.html#X79D451F0808EB252"><span class="RefLink">71.23-4</span></a>), and <code class="func">ClassPositionsOfNormalSubgroup</code> (<a href="chap71.html#X7C2A87E085111090"><span class="RefLink">71.23-2</span></a>) each use these components, and they are the only functions to do so.</p>

<p>So if you need information about a normal subgroup for that you know the conjugacy classes, you should get it using <code class="func">NormalSubgroupClasses</code> (<a href="chap71.html#X87E7391F7F92377C"><span class="RefLink">71.23-3</span></a>). If the normal subgroup was already used it is just returned, with all the knowledge it contains. Otherwise the normal subgroup is added to the lists, and will be available for the next call.</p>

<p>For example, if you are dealing with kernels of characters using the <code class="func">KernelOfCharacter</code> (<a href="chap72.html#X7E0A24498710F12B"><span class="RefLink">72.8-9</span></a>) function you make use of this feature because <code class="func">KernelOfCharacter</code> (<a href="chap72.html#X7E0A24498710F12B"><span class="RefLink">72.8-9</span></a>) calls <code class="func">NormalSubgroupClasses</code> (<a href="chap71.html#X87E7391F7F92377C"><span class="RefLink">71.23-3</span></a>).</p>

<p><a id="X7C2A87E085111090" name="X7C2A87E085111090"></a></p>

<h5>71.23-2 ClassPositionsOfNormalSubgroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassPositionsOfNormalSubgroup</code>( <var class="Arg">tbl</var>, <var class="Arg">N</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>is the list of positions of conjugacy classes of the character table <var class="Arg">tbl</var> that are contained in the normal subgroup <var class="Arg">N</var> of the underlying group of <var class="Arg">tbl</var>.</p>

<p><a id="X87E7391F7F92377C" name="X87E7391F7F92377C"></a></p>

<h5>71.23-3 NormalSubgroupClasses</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NormalSubgroupClasses</code>( <var class="Arg">tbl</var>, <var class="Arg">classes</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns the normal subgroup of the underlying group <span class="SimpleMath">G</span> of the ordinary character table <var class="Arg">tbl</var> that consists of those conjugacy classes of <var class="Arg">tbl</var> whose positions are in the list <var class="Arg">classes</var>.</p>

<p>If <code class="code">NormalSubgroupClassesInfo( <var class="Arg">tbl</var> ).nsg</code> does not yet contain the required normal subgroup, and if <code class="code">NormalSubgroupClassesInfo( <var class="Arg">tbl</var> ).normalSubgroups</code> is bound then the result will be identical to the group in <code class="code">NormalSubgroupClassesInfo( <var class="Arg">tbl</var> ).normalSubgroups</code>.</p>

<p><a id="X79D451F0808EB252" name="X79D451F0808EB252"></a></p>

<h5>71.23-4 FactorGroupNormalSubgroupClasses</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FactorGroupNormalSubgroupClasses</code>( <var class="Arg">tbl</var>, <var class="Arg">classes</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>is the factor group of the underlying group <span class="SimpleMath">G</span> of the ordinary character table <var class="Arg">tbl</var> modulo the normal subgroup of <span class="SimpleMath">G</span> that consists of those conjugacy classes of <var class="Arg">tbl</var> whose positions are in the list <var class="Arg">classes</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= SymmetricGroup( 4 );</span>
Sym( [ 1 .. 4 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( g, "S4" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( g );</span>
CharacterTable( S4 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irr:= Irr( g );</span>
[ Character( CharacterTable( S4 ), [ 1, -1, 1, 1, -1 ] ), 
  Character( CharacterTable( S4 ), [ 3, -1, -1, 0, 1 ] ), 
  Character( CharacterTable( S4 ), [ 2, 0, 2, -1, 0 ] ), 
  Character( CharacterTable( S4 ), [ 3, 1, -1, 0, -1 ] ), 
  Character( CharacterTable( S4 ), [ 1, 1, 1, 1, 1 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">kernel:= KernelOfCharacter( irr[3] );</span>
Group([ (1,2)(3,4), (1,4)(2,3) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HasNormalSubgroupClassesInfo( tbl );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NormalSubgroupClassesInfo( tbl );</span>
rec( nsg := [ Group([ (1,2)(3,4), (1,4)(2,3) ]) ],
  nsgclasses := [ [ 1, 3 ] ], nsgfactors := [  ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassPositionsOfNormalSubgroup( tbl, kernel );</span>
[ 1, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := FactorGroupNormalSubgroupClasses( tbl, [ 1, 3 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NormalSubgroupClassesInfo( tbl ).nsgfactors[1] = G;</span>
true
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap70.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap72.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chap16.html">16</a>  <a href="chap17.html">17</a>  <a href="chap18.html">18</a>  <a href="chap19.html">19</a>  <a href="chap20.html">20</a>  <a href="chap21.html">21</a>  <a href="chap22.html">22</a>  <a href="chap23.html">23</a>  <a href="chap24.html">24</a>  <a href="chap25.html">25</a>  <a href="chap26.html">26</a>  <a href="chap27.html">27</a>  <a href="chap28.html">28</a>  <a href="chap29.html">29</a>  <a href="chap30.html">30</a>  <a href="chap31.html">31</a>  <a href="chap32.html">32</a>  <a href="chap33.html">33</a>  <a href="chap34.html">34</a>  <a href="chap35.html">35</a>  <a href="chap36.html">36</a>  <a href="chap37.html">37</a>  <a href="chap38.html">38</a>  <a href="chap39.html">39</a>  <a href="chap40.html">40</a>  <a href="chap41.html">41</a>  <a href="chap42.html">42</a>  <a href="chap43.html">43</a>  <a href="chap44.html">44</a>  <a href="chap45.html">45</a>  <a href="chap46.html">46</a>  <a href="chap47.html">47</a>  <a href="chap48.html">48</a>  <a href="chap49.html">49</a>  <a href="chap50.html">50</a>  <a href="chap51.html">51</a>  <a href="chap52.html">52</a>  <a href="chap53.html">53</a>  <a href="chap54.html">54</a>  <a href="chap55.html">55</a>  <a href="chap56.html">56</a>  <a href="chap57.html">57</a>  <a href="chap58.html">58</a>  <a href="chap59.html">59</a>  <a href="chap60.html">60</a>  <a href="chap61.html">61</a>  <a href="chap62.html">62</a>  <a href="chap63.html">63</a>  <a href="chap64.html">64</a>  <a href="chap65.html">65</a>  <a href="chap66.html">66</a>  <a href="chap67.html">67</a>  <a href="chap68.html">68</a>  <a href="chap69.html">69</a>  <a href="chap70.html">70</a>  <a href="chap71.html">71</a>  <a href="chap72.html">72</a>  <a href="chap73.html">73</a>  <a href="chap74.html">74</a>  <a href="chap75.html">75</a>  <a href="chap76.html">76</a>  <a href="chap77.html">77</a>  <a href="chap78.html">78</a>  <a href="chap79.html">79</a>  <a href="chap80.html">80</a>  <a href="chap81.html">81</a>  <a href="chap82.html">82</a>  <a href="chap83.html">83</a>  <a href="chap84.html">84</a>  <a href="chap85.html">85</a>  <a href="chap86.html">86</a>  <a href="chap87.html">87</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
