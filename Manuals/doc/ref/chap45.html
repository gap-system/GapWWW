<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (ref) - Chapter 45: Polycyclic Groups</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap45"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chap16.html">16</a>  <a href="chap17.html">17</a>  <a href="chap18.html">18</a>  <a href="chap19.html">19</a>  <a href="chap20.html">20</a>  <a href="chap21.html">21</a>  <a href="chap22.html">22</a>  <a href="chap23.html">23</a>  <a href="chap24.html">24</a>  <a href="chap25.html">25</a>  <a href="chap26.html">26</a>  <a href="chap27.html">27</a>  <a href="chap28.html">28</a>  <a href="chap29.html">29</a>  <a href="chap30.html">30</a>  <a href="chap31.html">31</a>  <a href="chap32.html">32</a>  <a href="chap33.html">33</a>  <a href="chap34.html">34</a>  <a href="chap35.html">35</a>  <a href="chap36.html">36</a>  <a href="chap37.html">37</a>  <a href="chap38.html">38</a>  <a href="chap39.html">39</a>  <a href="chap40.html">40</a>  <a href="chap41.html">41</a>  <a href="chap42.html">42</a>  <a href="chap43.html">43</a>  <a href="chap44.html">44</a>  <a href="chap45.html">45</a>  <a href="chap46.html">46</a>  <a href="chap47.html">47</a>  <a href="chap48.html">48</a>  <a href="chap49.html">49</a>  <a href="chap50.html">50</a>  <a href="chap51.html">51</a>  <a href="chap52.html">52</a>  <a href="chap53.html">53</a>  <a href="chap54.html">54</a>  <a href="chap55.html">55</a>  <a href="chap56.html">56</a>  <a href="chap57.html">57</a>  <a href="chap58.html">58</a>  <a href="chap59.html">59</a>  <a href="chap60.html">60</a>  <a href="chap61.html">61</a>  <a href="chap62.html">62</a>  <a href="chap63.html">63</a>  <a href="chap64.html">64</a>  <a href="chap65.html">65</a>  <a href="chap66.html">66</a>  <a href="chap67.html">67</a>  <a href="chap68.html">68</a>  <a href="chap69.html">69</a>  <a href="chap70.html">70</a>  <a href="chap71.html">71</a>  <a href="chap72.html">72</a>  <a href="chap73.html">73</a>  <a href="chap74.html">74</a>  <a href="chap75.html">75</a>  <a href="chap76.html">76</a>  <a href="chap77.html">77</a>  <a href="chap78.html">78</a>  <a href="chap79.html">79</a>  <a href="chap80.html">80</a>  <a href="chap81.html">81</a>  <a href="chap82.html">82</a>  <a href="chap83.html">83</a>  <a href="chap84.html">84</a>  <a href="chap85.html">85</a>  <a href="chap86.html">86</a>  <a href="chap87.html">87</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap44.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap46.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap45_mj.html">[MathJax on]</a></p>
<p><a id="X86007B0083F60470" name="X86007B0083F60470"></a></p>
<div class="ChapSects"><a href="chap45.html#X86007B0083F60470">45 <span class="Heading">Polycyclic Groups</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap45.html#X7F18A01785DBAC4E">45.1 <span class="Heading">Polycyclic Generating Systems</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap45.html#X87F7E31879AFA06C">45.2 <span class="Heading">Computing a Pcgs</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X84C3750C7A4EEC34">45.2-1 Pcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X8635E61A7DB73BA6">45.2-2 IsPcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7B561B1685CEC2AB">45.2-3 CanEasilyComputePcgs</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap45.html#X7CAAD6D2838354D9">45.3 <span class="Heading">Defining a Pcgs Yourself</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7E139C3D80847D76">45.3-1 PcgsByPcSequence</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap45.html#X816C5E8E7F71C9D8">45.4 <span class="Heading">Elementary Operations for a Pcgs</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7DD0DF677AC1CF10">45.4-1 RelativeOrders</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X80D526848427A5C6">45.4-2 IsFiniteOrdersPcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X866C3A5382FF231A">45.4-3 IsPrimeOrdersPcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X827A7B097A959579">45.4-4 PcSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7903702E8194EF29">45.4-5 GroupOfPcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X878FB11887524E2C">45.4-6 OneOfPcgs</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap45.html#X84243AA07DA5A827">45.5 <span class="Heading">Elementary Operations for a Pcgs and an Element</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7B941D4A7CAFCD73">45.5-1 RelativeOrderOfPcElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X78134914842E2F5F">45.5-2 ExponentOfPcElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X848DAEBF7DC448A5">45.5-3 ExponentsOfPcElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X829BCB267CDBC5C0">45.5-4 DepthOfPcElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7D47966479EA2890">45.5-5 LeadingExponentOfPcElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X87AF746B8328F5D0">45.5-6 PcElementByExponents</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7F8BD7A87DB3933A">45.5-7 LinearCombinationPcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X8066B66D8069BAB4">45.5-8 SiftedPcElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7B52ADE7878A749A">45.5-9 CanonicalPcElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7A94AA357DB2F86C">45.5-10 ReducedPcElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X8702D76D8284CF3E">45.5-11 CleanedTailPcElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X830A0D037DBEAA97">45.5-12 HeadPcElementByNumber</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap45.html#X7EF61EA4822870E7">45.6 <span class="Heading">Exponents of Special Products</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X868D6DB07D349460">45.6-1 ExponentsConjugateLayer</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X874F70697FE7B6DF">45.6-2 ExponentsOfRelativePower</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X78CAF32F864EF656">45.6-3 ExponentsOfConjugate</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X875689897DD0CAFC">45.6-4 ExponentsOfCommutator</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap45.html#X8676397383093D1E">45.7 <span class="Heading">Subgroups of Polycyclic Groups – Induced Pcgs</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X81FA878C854D63F8">45.7-1 IsInducedPcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X83F6759184937F1B">45.7-2 InducedPcgsByPcSequence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X86308E80843BF9E5">45.7-3 ParentPcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7F0EB20080590B23">45.7-4 InducedPcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X8332F1197DF6FEDE">45.7-5 InducedPcgsByGenerators</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7AF82BD079D811E5">45.7-6 InducedPcgsByPcSequenceAndGenerators</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X845FF8CA783D6CB3">45.7-7 LeadCoeffsIGS</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X800287C680C5DEC3">45.7-8 ExtendedPcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X817E16D67B31389B">45.7-9 SubgroupByPcgs</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap45.html#X84068D2478C134C1">45.8 <span class="Heading">Subgroups of Polycyclic Groups – Canonical Pcgs</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X80D122B986B42F80">45.8-1 IsCanonicalPcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X816F6B4187032A10">45.8-2 CanonicalPcgs</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap45.html#X8294F5EF81B7ABA0">45.9 <span class="Heading">Factor Groups of Polycyclic Groups – Modulo Pcgs</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7FE689A37E559F66">45.9-1 ModuloPcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X868207D77D09D915">45.9-2 IsModuloPcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X8027CC9878031D74">45.9-3 NumeratorOfModuloPcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X87DBE2797D51B2F1">45.9-4 DenominatorOfModuloPcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7E923519832F2D08"><code>45.9-5 \mod</code></a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X876A41F97FBA7754">45.9-6 CorrespondingGeneratorsByModuloPcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X8480852A7D49BC3F">45.9-7 CanonicalPcgsByGeneratorsWithImages</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap45.html#X8254C0F485F945BD">45.10 <span class="Heading">Factor Groups of Polycyclic Groups in their Own Representation</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X806C2D827E04ACF3">45.10-1 ProjectedPcElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X82F39CCE7C928D3A">45.10-2 ProjectedInducedPcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X816813A078B93A6B">45.10-3 LiftedPcElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X83C60F1587577D65">45.10-4 LiftedInducedPcgs</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap45.html#X83FE235E7B208EC0">45.11 <span class="Heading">Pcgs and Normal Series</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7E7E89C278DDE20D">45.11-1 IsPcgsElementaryAbelianSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X863A20B57EA37BAC">45.11-2 PcgsElementaryAbelianSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7BCC1E2A80544CC7">45.11-3 IndicesEANormalSteps</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7FCE308887F621FC">45.11-4 EANormalSeriesByPcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X79675266796D7254">45.11-5 IsPcgsCentralSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X8187FCF483659E69">45.11-6 PcgsCentralSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7FB73FEB7BED5BFA">45.11-7 IndicesCentralNormalSteps</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X82266ADA86B2A689">45.11-8 CentralNormalSeriesByPcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X786E60AF7B61BF9E">45.11-9 IsPcgsPCentralSeriesPGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X86F19DBD7D346E7F">45.11-10 PcgsPCentralSeriesPGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X863968F08509E7D4">45.11-11 IndicesPCentralNormalStepsPGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7A92C9EA7BAF60CA">45.11-12 PCentralNormalSeriesByPcgsPGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7EA5BC3B7FE9D98D">45.11-13 IsPcgsChiefSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7E7326947EAE4BC9">45.11-14 PcgsChiefSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7C05E84A78CA405E">45.11-15 IndicesChiefNormalSteps</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X83C5ABC587074B14">45.11-16 ChiefNormalSeriesByPcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7A954E3887189842">45.11-17 IndicesNormalSteps</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7947B0FB87F44042">45.11-18 NormalSeriesByPcgs</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap45.html#X7E624B4E8224DE2D">45.12 <span class="Heading">Sum and Intersection of Pcgs</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7833DAAA7C07CFD7">45.12-1 SumFactorizationFunctionPcgs</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap45.html#X83039CF97D27D819">45.13 <span class="Heading">Special Pcgs</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7C8A82FA786AC021">45.13-1 IsSpecialPcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X827EB7767BACD023">45.13-2 <span class="Heading">SpecialPcgs</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X82DC7CE682140588">45.13-3 LGWeights</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X824645C97E347EEE">45.13-4 LGLayers</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7A655F4C7D9AE130">45.13-5 LGFirst</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7C3912F77B12C8B6">45.13-6 LGLength</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X814C35BF7C9A8DEF">45.13-7 IsInducedPcgsWrtSpecialPcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7C14AE5C82FB0771">45.13-8 InducedPcgsWrtSpecialPcgs</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap45.html#X7E86EB517DC08809">45.14 <span class="Heading">Action on Subfactors Defined by a Pcgs</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7A9BB9D0817CA949">45.14-1 VectorSpaceByPcgsOfElementaryAbelianGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X81FC09DD7FC06C6E">45.14-2 LinearAction</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7C2135B98732BBC3">45.14-3 LinearActionLayer</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X79C2D6BF7DD69ED6">45.14-4 AffineAction</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7E4CB1358524497B">45.14-5 AffineActionLayer</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap45.html#X7EEA8D638492F432">45.15 <span class="Heading">Orbit Stabilizer Methods for Polycyclic Groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7CFCCF607A30B5EE">45.15-1 StabilizerPcgs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7A87E72F86813132">45.15-2 Pcgs_OrbitStabilizer</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap45.html#X7A19DF1E7E841074">45.16 <span class="Heading">Operations which have Special Methods for Groups with Pcgs</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap45.html#X79DCCF6D80351859">45.17 <span class="Heading">Conjugacy Classes in Solvable Groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X79593F667A68A21D">45.17-1 ClassesSolvableGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap45.html#X7B358D3B7E236973">45.17-2 CentralizerSizeLimitConsiderFunction</a></span>
</div></div>
</div>

<h3>45 <span class="Heading">Polycyclic Groups</span></h3>

<p>A group <var class="Arg">G</var> is <em>polycyclic</em> if there exists a subnormal series <span class="SimpleMath">G = C_1 &gt; C_2 &gt; ... &gt; C_n &gt; C_{n+1} = { 1 }</span> with cyclic factors. Such a series is called <em>pc series</em> of <var class="Arg">G</var>.</p>

<p>Every polycyclic group is solvable and every finite solvable group is polycyclic. However, there are infinite solvable groups which are not polycyclic.</p>

<p>In <strong class="pkg">GAP</strong> there exists a large number of methods for polycyclic groups which are based upon the polycyclic structure of these groups. These methods are usually very efficient, especially for groups which are given by a pc-presentation (see chapter <a href="chap46.html#X7EAD57C97EBF7E67"><span class="RefLink">46</span></a>), and can be applied to many types of groups. Hence <strong class="pkg">GAP</strong> tries to use them whenever possible, for example, for permutation groups and matrix groups over finite fields that are known to be polycyclic (the only exception is the representation as finitely presented group for which the polycyclic methods cannot be used in general).</p>

<p>At the current state of implementations the <strong class="pkg">GAP</strong> library contains methods to compute with finite polycyclic groups, while the <strong class="pkg">GAP</strong> package <strong class="pkg">Polycyclic</strong> by Bettina Eick and Werner Nickel allows also computations with infinite polycyclic groups which are given by a pc-presentation.</p>

<p><a id="X7F18A01785DBAC4E" name="X7F18A01785DBAC4E"></a></p>

<h4>45.1 <span class="Heading">Polycyclic Generating Systems</span></h4>

<p>Let <var class="Arg">G</var> be a polycyclic group with a pc series as above. A <em>polycyclic generating sequence</em> (<em>pcgs</em> for short) of <var class="Arg">G</var> is a sequence <span class="SimpleMath">P := (g_1, ..., g_n)</span> of elements of <var class="Arg">G</var> such that <span class="SimpleMath">C_i = ⟨ C_{i+1}, g_i ⟩</span> for <span class="SimpleMath">1 ≤ i ≤ n</span>. Note that each polycyclic group has a pcgs, but except for very small groups, a pcgs is not unique.</p>

<p>For each index <span class="SimpleMath">i</span> the subsequence of elements <span class="SimpleMath">(g_i, ..., g_n)</span> forms a pcgs of the subgroup <span class="SimpleMath">C_i</span>. In particular, these <em>tails</em> generate the subgroups of the pc series and hence we say that the pc series is <em>determined</em> by <span class="SimpleMath">P</span>.</p>

<p>Let <span class="SimpleMath">r_i</span> be the index of <span class="SimpleMath">C_{i+1}</span> in <span class="SimpleMath">C_i</span> which is either a finite positive number or infinity. Then <span class="SimpleMath">r_i</span> is the order of <span class="SimpleMath">g_i C_{i+1}</span> and we call the resulting list of indices the <em>relative orders</em> of the pcgs <var class="Arg">P</var>.</p>

<p>Moreover, with respect to a given pcgs <span class="SimpleMath">(g_1, ..., g_n)</span> each element <var class="Arg">g</var> of <var class="Arg">G</var> can be represented in a unique way as a product <span class="SimpleMath">g = g_1^{e_1} ⋅ g_2^{e_2} ⋯ g_n^{e_n}</span> with exponents <span class="SimpleMath">e_i ∈ {0, ..., r_i-1}</span>, if <span class="SimpleMath">r_i</span> is finite, and <span class="SimpleMath">e_i ∈ ℤ</span> otherwise. Words of this form are called <em>normal words</em> or <em>words in normal form</em>. Then the integer vector <span class="SimpleMath">[ e_1, ..., e_n ]</span> is called the <em>exponent vector</em> of the element <span class="SimpleMath">g</span>. Furthermore, the smallest index <span class="SimpleMath">k</span> such that <span class="SimpleMath">e_k ≠ 0</span> is called the <em>depth</em> of <var class="Arg">g</var> and <span class="SimpleMath">e_k</span> is the <em>leading exponent</em> of <var class="Arg">g</var>.</p>

<p>For many applications we have to assume that each of the relative orders <span class="SimpleMath">r_i</span> is either a prime or infinity. This is equivalent to saying that there are no trivial factors in the pc series and the finite factors of the pc series are maximal refined. Then we obtain that <span class="SimpleMath">r_i</span> is the order of <span class="SimpleMath">g C_{i+1}</span> for all elements <span class="SimpleMath">g</span> in <span class="SimpleMath">C_i ∖ C_{i+1}</span> and we call <span class="SimpleMath">r_i</span> the <em>relative order</em> of the element <span class="SimpleMath">g</span>.</p>

<p><a id="X87F7E31879AFA06C" name="X87F7E31879AFA06C"></a></p>

<h4>45.2 <span class="Heading">Computing a Pcgs</span></h4>

<p>Suppose a group <var class="Arg">G</var> is given; for example, let <var class="Arg">G</var> be a permutation or matrix group. Then we can ask <strong class="pkg">GAP</strong> to compute a pcgs of this group. If <var class="Arg">G</var> is not polycyclic, the result will be <code class="keyw">fail</code>.</p>

<p>Note that these methods can only be applied if <var class="Arg">G</var> is not given as finitely presented group. For finitely presented groups one can try to compute a pcgs via the polycyclic quotient methods, see <a href="chap47.html#X846072F779B51087"><span class="RefLink">47.14</span></a>.</p>

<p>Note also that a pcgs behaves like a list.</p>

<p><a id="X84C3750C7A4EEC34" name="X84C3750C7A4EEC34"></a></p>

<h5>45.2-1 Pcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Pcgs</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns a pcgs for the group <var class="Arg">G</var>. If <var class="Arg">grp</var> is not polycyclic it returns <code class="keyw">fail</code> <em>and this result is not stored as attribute value</em>, in particular in this case the filter <code class="code">HasPcgs</code> is <em>not</em> set for <var class="Arg">G</var>!</p>

<p><a id="X8635E61A7DB73BA6" name="X8635E61A7DB73BA6"></a></p>

<h5>45.2-2 IsPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPcgs</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>The category of pcgs.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := Group((1,2,3,4),(1,2));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := Pcgs(G);</span>
Pcgs([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPcgs( p );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p[1];</span>
(3,4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := Group((1,2,3,4,5),(1,2));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Pcgs(G);</span>
fail
</pre></div>

<p><a id="X7B561B1685CEC2AB" name="X7B561B1685CEC2AB"></a></p>

<h5>45.2-3 CanEasilyComputePcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CanEasilyComputePcgs</code>( <var class="Arg">grp</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>This filter indicates whether it is possible to compute a pcgs for <var class="Arg">grp</var> cheaply. Clearly, <var class="Arg">grp</var> must be polycyclic in this case. However, not for every polycyclic group there is a method to compute a pcgs at low costs. This filter is used in the method selection mainly. Note that this filter may change its value from <code class="keyw">false</code> to <code class="keyw">true</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := Group( (1,2,3,4),(1,2) );</span>
Group([ (1,2,3,4), (1,2) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CanEasilyComputePcgs(G);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Pcgs(G);</span>
Pcgs([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CanEasilyComputePcgs(G);</span>
true
</pre></div>

<p><a id="X7CAAD6D2838354D9" name="X7CAAD6D2838354D9"></a></p>

<h4>45.3 <span class="Heading">Defining a Pcgs Yourself</span></h4>

<p>In a number of situations it might be useful to supply a pcgs to a group.</p>

<p>Note that the elementary operations for such a pcgs might be rather inefficient, since <strong class="pkg">GAP</strong> has to use generic methods in this case. It might be helpful to supply the relative orders of the self-defined pcgs as well by <code class="code">SetRelativeOrder</code>. See also <code class="func">IsPrimeOrdersPcgs</code> (<a href="chap45.html#X866C3A5382FF231A"><span class="RefLink">45.4-3</span></a>).</p>

<p><a id="X7E139C3D80847D76" name="X7E139C3D80847D76"></a></p>

<h5>45.3-1 PcgsByPcSequence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PcgsByPcSequence</code>( <var class="Arg">fam</var>, <var class="Arg">pcs</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PcgsByPcSequenceNC</code>( <var class="Arg">fam</var>, <var class="Arg">pcs</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>constructs a pcgs for the elements family <var class="Arg">fam</var> from the elements in the list <var class="Arg">pcs</var>. The elements must lie in the family <var class="Arg">fam</var>. <code class="func">PcgsByPcSequence</code> and its <code class="code">NC</code> variant will always create a new pcgs which is not induced by any other pcgs (cf. <code class="func">InducedPcgsByPcSequence</code> (<a href="chap45.html#X83F6759184937F1B"><span class="RefLink">45.7-2</span></a>)).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fam := FamilyObj( (1,2) );; # the family of permutations</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := PcgsByPcSequence( fam, [(1,2),(1,2,3)] );</span>
Pcgs([ (1,2), (1,2,3) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RelativeOrders(p);</span>
[ 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExponentsOfPcElement( p, (1,3,2) );</span>
[ 0, 2 ]
</pre></div>

<p><a id="X816C5E8E7F71C9D8" name="X816C5E8E7F71C9D8"></a></p>

<h4>45.4 <span class="Heading">Elementary Operations for a Pcgs</span></h4>

<p><a id="X7DD0DF677AC1CF10" name="X7DD0DF677AC1CF10"></a></p>

<h5>45.4-1 RelativeOrders</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RelativeOrders</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns the list of relative orders of the pcgs <var class="Arg">pcgs</var>.</p>

<p><a id="X80D526848427A5C6" name="X80D526848427A5C6"></a></p>

<h5>45.4-2 IsFiniteOrdersPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFiniteOrdersPcgs</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>tests whether the relative orders of <var class="Arg">pcgs</var> are all finite.</p>

<p><a id="X866C3A5382FF231A" name="X866C3A5382FF231A"></a></p>

<h5>45.4-3 IsPrimeOrdersPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPrimeOrdersPcgs</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>tests whether the relative orders of <var class="Arg">pcgs</var> are prime numbers. Many algorithms require a pcgs to have this property. The operation <code class="func">IsomorphismRefinedPcGroup</code> (<a href="chap46.html#X7E6226597DFE5F8F"><span class="RefLink">46.4-8</span></a>) can be of help here.</p>

<p><a id="X827A7B097A959579" name="X827A7B097A959579"></a></p>

<h5>45.4-4 PcSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PcSeries</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns the subnormal series determined by <var class="Arg">pcgs</var>.</p>

<p><a id="X7903702E8194EF29" name="X7903702E8194EF29"></a></p>

<h5>45.4-5 GroupOfPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GroupOfPcgs</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The group generated by <var class="Arg">pcgs</var>.</p>

<p><a id="X878FB11887524E2C" name="X878FB11887524E2C"></a></p>

<h5>45.4-6 OneOfPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OneOfPcgs</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The identity of the group generated by <var class="Arg">pcgs</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := Group( (1,2,3,4),(1,2) );; p := Pcgs(G);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RelativeOrders(p);</span>
[ 2, 3, 2, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsFiniteOrdersPcgs(p);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPrimeOrdersPcgs(p);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PcSeries(p);</span>
[ Group([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ]), 
  Group([ (2,4,3), (1,4)(2,3), (1,3)(2,4) ]), 
  Group([ (1,4)(2,3), (1,3)(2,4) ]), Group([ (1,3)(2,4) ]), Group(()) 
 ]
</pre></div>

<p><a id="X84243AA07DA5A827" name="X84243AA07DA5A827"></a></p>

<h4>45.5 <span class="Heading">Elementary Operations for a Pcgs and an Element</span></h4>

<p><a id="X7B941D4A7CAFCD73" name="X7B941D4A7CAFCD73"></a></p>

<h5>45.5-1 RelativeOrderOfPcElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RelativeOrderOfPcElement</code>( <var class="Arg">pcgs</var>, <var class="Arg">elm</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The relative order of <var class="Arg">elm</var> with respect to the prime order pcgs <var class="Arg">pcgs</var>.</p>

<p><a id="X78134914842E2F5F" name="X78134914842E2F5F"></a></p>

<h5>45.5-2 ExponentOfPcElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExponentOfPcElement</code>( <var class="Arg">pcgs</var>, <var class="Arg">elm</var>, <var class="Arg">pos</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns the <var class="Arg">pos</var>-th exponent of <var class="Arg">elm</var> with respect to <var class="Arg">pcgs</var>.</p>

<p><a id="X848DAEBF7DC448A5" name="X848DAEBF7DC448A5"></a></p>

<h5>45.5-3 ExponentsOfPcElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExponentsOfPcElement</code>( <var class="Arg">pcgs</var>, <var class="Arg">elm</var>[, <var class="Arg">posran</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns the exponents of <var class="Arg">elm</var> with respect to <var class="Arg">pcgs</var>. The three argument version returns the exponents in the positions given in <var class="Arg">posran</var>.</p>

<p><a id="X829BCB267CDBC5C0" name="X829BCB267CDBC5C0"></a></p>

<h5>45.5-4 DepthOfPcElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DepthOfPcElement</code>( <var class="Arg">pcgs</var>, <var class="Arg">elm</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns the depth of the element <var class="Arg">elm</var> with respect to <var class="Arg">pcgs</var>.</p>

<p><a id="X7D47966479EA2890" name="X7D47966479EA2890"></a></p>

<h5>45.5-5 LeadingExponentOfPcElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LeadingExponentOfPcElement</code>( <var class="Arg">pcgs</var>, <var class="Arg">elm</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns the leading exponent of <var class="Arg">elm</var> with respect to <var class="Arg">pcgs</var>.</p>

<p><a id="X87AF746B8328F5D0" name="X87AF746B8328F5D0"></a></p>

<h5>45.5-6 PcElementByExponents</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PcElementByExponents</code>( <var class="Arg">pcgs</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PcElementByExponentsNC</code>( <var class="Arg">pcgs</var>[, <var class="Arg">basisind</var>], <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns the element corresponding to the exponent vector <var class="Arg">list</var> with respect to <var class="Arg">pcgs</var>. The exponents in <var class="Arg">list</var> must be in the range of permissible exponents for <var class="Arg">pcgs</var>. <em>It is not guaranteed that <code class="func">PcElementByExponents</code> will reduce the exponents modulo the relative orders</em>. (You should use the operation <code class="func">LinearCombinationPcgs</code> (<a href="chap45.html#X7F8BD7A87DB3933A"><span class="RefLink">45.5-7</span></a>) for this purpose.) The <code class="code">NC</code> version does not check that the lengths of the lists fit together and does not check the exponent range.</p>

<p>The three argument version gives exponents only w.r.t. the generators in <var class="Arg">pcgs</var> indexed by <var class="Arg">basisind</var>.</p>

<p><a id="X7F8BD7A87DB3933A" name="X7F8BD7A87DB3933A"></a></p>

<h5>45.5-7 LinearCombinationPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LinearCombinationPcgs</code>( <var class="Arg">pcgs</var>, <var class="Arg">list</var>[, <var class="Arg">one</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns the product <span class="SimpleMath">∏_i <var class="Arg">pcgs</var>[i]^{<var class="Arg">list</var>[i]}</span>. In contrast to <code class="func">PcElementByExponents</code> (<a href="chap45.html#X87AF746B8328F5D0"><span class="RefLink">45.5-6</span></a>) this permits negative exponents. <var class="Arg">pcgs</var> might be a list of group elements. In this case, an appropriate identity element <var class="Arg">one</var> must be given. <var class="Arg">list</var> can be empty.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := Group( (1,2,3,4),(1,2) );; P := Pcgs(G);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := PcElementByExponents(P, [0,1,1,1]);</span>
(1,2,3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExponentsOfPcElement(P, g);</span>
[ 0, 1, 1, 1 ]
</pre></div>

<p><a id="X8066B66D8069BAB4" name="X8066B66D8069BAB4"></a></p>

<h5>45.5-8 SiftedPcElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SiftedPcElement</code>( <var class="Arg">pcgs</var>, <var class="Arg">elm</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>sifts <var class="Arg">elm</var> through <var class="Arg">pcgs</var>, reducing it if the depth is the same as the depth of one of the generators in <var class="Arg">pcgs</var>. Thus the identity is returned if <var class="Arg">elm</var> lies in the group generated by <var class="Arg">pcgs</var>. <var class="Arg">pcgs</var> must be an induced pcgs (see section <a href="chap45.html#X8676397383093D1E"><span class="RefLink">45.7</span></a>) and <var class="Arg">elm</var> must lie in the span of the parent of <var class="Arg">pcgs</var>.</p>

<p><a id="X7B52ADE7878A749A" name="X7B52ADE7878A749A"></a></p>

<h5>45.5-9 CanonicalPcElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CanonicalPcElement</code>( <var class="Arg">ipcgs</var>, <var class="Arg">elm</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>reduces <var class="Arg">elm</var> at the induces pcgs <var class="Arg">ipcgs</var> such that the exponents of the reduced result <var class="Arg">r</var> are zero at the depths for which there are generators in <var class="Arg">ipcgs</var>. Elements, whose quotient lies in the group generated by <var class="Arg">ipcgs</var> yield the same canonical element.</p>

<p><a id="X7A94AA357DB2F86C" name="X7A94AA357DB2F86C"></a></p>

<h5>45.5-10 ReducedPcElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ReducedPcElement</code>( <var class="Arg">pcgs</var>, <var class="Arg">x</var>, <var class="Arg">y</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>reduces the element <var class="Arg">x</var> by dividing off (from the left) a power of <var class="Arg">y</var> such that the leading coefficient of the result with respect to <var class="Arg">pcgs</var> becomes zero. The elements <var class="Arg">x</var> and <var class="Arg">y</var> therefore have to have the same depth.</p>

<p><a id="X8702D76D8284CF3E" name="X8702D76D8284CF3E"></a></p>

<h5>45.5-11 CleanedTailPcElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CleanedTailPcElement</code>( <var class="Arg">pcgs</var>, <var class="Arg">elm</var>, <var class="Arg">dep</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns an element in the span of <var class="Arg">pcgs</var> whose exponents for indices <span class="SimpleMath">1</span> to <span class="SimpleMath"><var class="Arg">dep</var>-1</span> with respect to <var class="Arg">pcgs</var> are the same as those of <var class="Arg">elm</var>, the remaining exponents are undefined. This can be used to obtain more "simple" elements if only representatives in a factor are required, see <a href="chap45.html#X8294F5EF81B7ABA0"><span class="RefLink">45.9</span></a>.</p>

<p>The difference to <code class="func">HeadPcElementByNumber</code> (<a href="chap45.html#X830A0D037DBEAA97"><span class="RefLink">45.5-12</span></a>) is that this function is guaranteed to zero out trailing coefficients while <code class="func">CleanedTailPcElement</code> will only do this if it can be done cheaply.</p>

<p><a id="X830A0D037DBEAA97" name="X830A0D037DBEAA97"></a></p>

<h5>45.5-12 HeadPcElementByNumber</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeadPcElementByNumber</code>( <var class="Arg">pcgs</var>, <var class="Arg">elm</var>, <var class="Arg">dep</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns an element in the span of <var class="Arg">pcgs</var> whose exponents for indices <span class="SimpleMath">1</span> to <var class="Arg">dep</var><span class="SimpleMath">-1</span> with respect to <var class="Arg">pcgs</var> are the same as those of <var class="Arg">elm</var>, the remaining exponents are zero. This can be used to obtain more "simple" elements if only representatives in a factor are required.</p>

<p><a id="X7EF61EA4822870E7" name="X7EF61EA4822870E7"></a></p>

<h4>45.6 <span class="Heading">Exponents of Special Products</span></h4>

<p>There are certain products of elements whose exponents are used often within algorithms, and which might be obtained more easily than by computing the product first and to obtain its exponents afterwards. The operations in this section provide a way to obtain such exponent vectors directly.</p>

<p>(The circumstances under which these operations give a speedup depend very much on the pcgs and the representation of elements that is used. So the following operations are not guaranteed to give a speedup in every case, however the default methods are not slower than to compute the exponents of a product and thus these operations should <em>always</em> be used if applicable.)</p>

<p>The second class are exponents of products of the generators which make up the pcgs. If the pcgs used is a family pcgs (see <code class="func">FamilyPcgs</code> (<a href="chap46.html#X79EDB35E82C99304"><span class="RefLink">46.1-1</span></a>)) then these exponents can be looked up and do not need to be computed.</p>

<p><a id="X868D6DB07D349460" name="X868D6DB07D349460"></a></p>

<h5>45.6-1 ExponentsConjugateLayer</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExponentsConjugateLayer</code>( <var class="Arg">mpcgs</var>, <var class="Arg">elm</var>, <var class="Arg">e</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Computes the exponents of <var class="Arg">elm</var><code class="code">^</code><var class="Arg">e</var> with respect to <var class="Arg">mpcgs</var>; <var class="Arg">elm</var> must be in the span of <var class="Arg">mpcgs</var>, <var class="Arg">e</var> a pc element in the span of the parent pcgs of <var class="Arg">mpcgs</var> and <var class="Arg">mpcgs</var> must be the modulo pcgs for an abelian layer. (This is the usual case when acting on a chief factor). In this case if <var class="Arg">mpcgs</var> is induced by the family pcgs (see section <a href="chap45.html#X8676397383093D1E"><span class="RefLink">45.7</span></a>), the exponents can be computed directly by looking up exponents without having to compute in the group and having to collect a potential tail.</p>

<p><a id="X874F70697FE7B6DF" name="X874F70697FE7B6DF"></a></p>

<h5>45.6-2 ExponentsOfRelativePower</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExponentsOfRelativePower</code>( <var class="Arg">pcgs</var>, <var class="Arg">i</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>For <span class="SimpleMath">p = <var class="Arg">pcgs</var>[<var class="Arg">i</var>]</span> this function returns the exponent vector with respect to <var class="Arg">pcgs</var> of the element <span class="SimpleMath">p^e</span> where <span class="SimpleMath">e</span> is the relative order of <var class="Arg">p</var> in <var class="Arg">pcgs</var>. For the family pcgs or pcgs induced by it (see section <a href="chap45.html#X8676397383093D1E"><span class="RefLink">45.7</span></a>), this might be faster than computing the element and computing its exponent vector.</p>

<p><a id="X78CAF32F864EF656" name="X78CAF32F864EF656"></a></p>

<h5>45.6-3 ExponentsOfConjugate</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExponentsOfConjugate</code>( <var class="Arg">pcgs</var>, <var class="Arg">i</var>, <var class="Arg">j</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns the exponents of <code class="code"><var class="Arg">pcgs</var>[<var class="Arg">i</var>]^<var class="Arg">pcgs</var>[<var class="Arg">j</var>]</code> with respect to <var class="Arg">pcgs</var>. For the family pcgs or pcgs induced by it (see section <a href="chap45.html#X8676397383093D1E"><span class="RefLink">45.7</span></a>), this might be faster than computing the element and computing its exponent vector.</p>

<p><a id="X875689897DD0CAFC" name="X875689897DD0CAFC"></a></p>

<h5>45.6-4 ExponentsOfCommutator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExponentsOfCommutator</code>( <var class="Arg">pcgs</var>, <var class="Arg">i</var>, <var class="Arg">j</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns the exponents of the commutator <code class="code">Comm( </code><span class="SimpleMath"><var class="Arg">pcgs</var>[<var class="Arg">i</var>], <var class="Arg">pcgs</var>[<var class="Arg">j</var>]</span><code class="code"> )</code> with respect to <var class="Arg">pcgs</var>. For the family pcgs or pcgs induced by it, (see section <a href="chap45.html#X8676397383093D1E"><span class="RefLink">45.7</span></a>), this might be faster than computing the element and computing its exponent vector.</p>

<p><a id="X8676397383093D1E" name="X8676397383093D1E"></a></p>

<h4>45.7 <span class="Heading">Subgroups of Polycyclic Groups – Induced Pcgs</span></h4>

<p>Let <var class="Arg">U</var> be a subgroup of <var class="Arg">G</var> and let <var class="Arg">P</var> be a pcgs of <var class="Arg">G</var> as above such that <var class="Arg">P</var> determines the subnormal series <span class="SimpleMath">G = C_1 &gt; ... &gt; C_{n+1} = { 1 }</span>. Then the series of subgroups <span class="SimpleMath">U ∩ C_i</span> is a subnormal series of <var class="Arg">U</var> with cyclic or trivial factors. Hence, if we choose an element <span class="SimpleMath">u_{i_j} ∈ (U ∩ C_{i_j}) ∖ (U ∩ C_{i_j+1})</span> whenever this factor is non-trivial, then we obtain a pcgs <span class="SimpleMath">Q = (u_{i_1}, ..., u_{i_m})</span> of <span class="SimpleMath">U</span>. We say that <span class="SimpleMath">Q</span> is an <em>induced pcgs</em> with respect to <var class="Arg">P</var>. The pcgs <var class="Arg">P</var> is the <em>parent pcgs</em> to the induced pcgs <var class="Arg">Q</var>.</p>

<p>Note that the pcgs <span class="SimpleMath">Q</span> is induced with respect to <var class="Arg">P</var> if and only if the matrix of exponent vectors of the elements <span class="SimpleMath">u_{i_j}</span> with respect to <var class="Arg">P</var> is in upper triangular form. Thus <span class="SimpleMath">Q</span> is not unique in general.</p>

<p>In particular, the elements of an induced pcgs do <em>not necessarily</em> have leading coefficient 1 relative to the inducing pcgs. The attribute <code class="func">LeadCoeffsIGS</code> (<a href="chap45.html#X845FF8CA783D6CB3"><span class="RefLink">45.7-7</span></a>) holds the leading coefficients in case they have to be renormed in an algorithm.</p>

<p>Each induced pcgs is a pcgs and hence allows all elementary operations for pcgs. On the other hand each pcgs could be transformed into an induced pcgs for the group defined by the pcgs, but note that an arbitrary pcgs is in general not an induced pcgs for technical reasons.</p>

<p>An induced pcgs is "compatible" with its parent, see <code class="func">ParentPcgs</code> (<a href="chap45.html#X86308E80843BF9E5"><span class="RefLink">45.7-3</span></a>).</p>

<p>In <a href="chapBib.html#biBSOGOS">[LNS84]</a> a "non-commutative Gauss" algorithm is described to compute an induced pcgs of a subgroup <var class="Arg">U</var> from a generating set of <var class="Arg">U</var>. For calling this in <strong class="pkg">GAP</strong>, see <a href="chap45.html#X7F0EB20080590B23"><span class="RefLink">45.7-4</span></a> to <a href="chap45.html#X800287C680C5DEC3"><span class="RefLink">45.7-8</span></a>.</p>

<p>To create a subgroup generated by an induced pcgs such that the induced pcgs gets stored automatically, use <code class="func">SubgroupByPcgs</code> (<a href="chap45.html#X817E16D67B31389B"><span class="RefLink">45.7-9</span></a>).</p>

<p><a id="X81FA878C854D63F8" name="X81FA878C854D63F8"></a></p>

<h5>45.7-1 IsInducedPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsInducedPcgs</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>The category of induced pcgs. This a subcategory of pcgs.</p>

<p><a id="X83F6759184937F1B" name="X83F6759184937F1B"></a></p>

<h5>45.7-2 InducedPcgsByPcSequence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InducedPcgsByPcSequence</code>( <var class="Arg">pcgs</var>, <var class="Arg">pcs</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InducedPcgsByPcSequenceNC</code>( <var class="Arg">pcgs</var>, <var class="Arg">pcs</var>[, <var class="Arg">depths</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>If <var class="Arg">pcs</var> is a list of elements that form an induced pcgs with respect to <var class="Arg">pcgs</var> this operation returns an induced pcgs with these elements.</p>

<p>In the third version, the depths of <var class="Arg">pcs</var> with respect to <var class="Arg">pcgs</var> can be given (they are computed anew otherwise).</p>

<p><a id="X86308E80843BF9E5" name="X86308E80843BF9E5"></a></p>

<h5>45.7-3 ParentPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ParentPcgs</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns the pcgs by which <var class="Arg">pcgs</var> was induced. If <var class="Arg">pcgs</var> was not induced, it simply returns <var class="Arg">pcgs</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := Group( (1,2,3,4),(1,2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P := Pcgs(G);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K := InducedPcgsByPcSequence( P, [(1,2,3,4),(1,3)(2,4)] );</span>
Pcgs([ (1,2,3,4), (1,3)(2,4) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ParentPcgs( K );</span>
Pcgs([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsInducedPcgs( K );</span>
true
</pre></div>

<p><a id="X7F0EB20080590B23" name="X7F0EB20080590B23"></a></p>

<h5>45.7-4 InducedPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InducedPcgs</code>( <var class="Arg">pcgs</var>, <var class="Arg">grp</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>computes a pcgs for <var class="Arg">grp</var> which is induced by <var class="Arg">pcgs</var>. If <var class="Arg">pcgs</var> has a parent pcgs, then the result is induced with respect to this parent pcgs.</p>

<p><code class="func">InducedPcgs</code> is a wrapper function only. Therefore, methods for computing computing an induced pcgs should be installed for the operation <code class="code">InducedPcgsOp</code>.</p>

<p><a id="X8332F1197DF6FEDE" name="X8332F1197DF6FEDE"></a></p>

<h5>45.7-5 InducedPcgsByGenerators</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InducedPcgsByGenerators</code>( <var class="Arg">pcgs</var>, <var class="Arg">gens</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InducedPcgsByGeneratorsNC</code>( <var class="Arg">pcgs</var>, <var class="Arg">gens</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns an induced pcgs with respect to <var class="Arg">pcgs</var> for the subgroup generated by <var class="Arg">gens</var>.</p>

<p><a id="X7AF82BD079D811E5" name="X7AF82BD079D811E5"></a></p>

<h5>45.7-6 InducedPcgsByPcSequenceAndGenerators</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InducedPcgsByPcSequenceAndGenerators</code>( <var class="Arg">pcgs</var>, <var class="Arg">ind</var>, <var class="Arg">gens</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns an induced pcgs with respect to <var class="Arg">pcgs</var> of the subgroup generated by <var class="Arg">ind</var> and <var class="Arg">gens</var>. Here <var class="Arg">ind</var> must be an induced pcgs with respect to <var class="Arg">pcgs</var> (or a list of group elements that form such an igs) and it will be used as initial sequence for the computation.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := Group( (1,2,3,4),(1,2) );;  P := Pcgs(G);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">I := InducedPcgsByGenerators( P, [(1,2,3,4)] );</span>
Pcgs([ (1,2,3,4), (1,3)(2,4) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">J := InducedPcgsByPcSequenceAndGenerators( P, I, [(1,2)] );</span>
Pcgs([ (1,2,3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ])
</pre></div>

<p><a id="X845FF8CA783D6CB3" name="X845FF8CA783D6CB3"></a></p>

<h5>45.7-7 LeadCoeffsIGS</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LeadCoeffsIGS</code>( <var class="Arg">igs</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>This attribute is used to store leading coefficients with respect to the parent pcgs. the <var class="Arg">i</var>-th entry –if bound– is the leading exponent of the element of <var class="Arg">igs</var> that has depth <var class="Arg">i</var> in the parent. (It cannot be assigned to a component in the object created by <code class="func">InducedPcgsByPcSequenceNC</code> (<a href="chap45.html#X83F6759184937F1B"><span class="RefLink">45.7-2</span></a>) as the permutation group methods call it from within the postprocessing, before this postprocessing however no coefficients may be computed.)</p>

<p><a id="X800287C680C5DEC3" name="X800287C680C5DEC3"></a></p>

<h5>45.7-8 ExtendedPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExtendedPcgs</code>( <var class="Arg">N</var>, <var class="Arg">gens</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>extends the pcgs <var class="Arg">N</var> (induced w.r.t. <var class="Arg">home</var>) to a new induced pcgs by prepending <var class="Arg">gens</var>. No checks are performed that this really yields an induced pcgs.</p>

<p><a id="X817E16D67B31389B" name="X817E16D67B31389B"></a></p>

<h5>45.7-9 SubgroupByPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SubgroupByPcgs</code>( <var class="Arg">G</var>, <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns a subgroup of <var class="Arg">G</var> generated by the elements of <var class="Arg">pcgs</var>.</p>

<p><a id="X84068D2478C134C1" name="X84068D2478C134C1"></a></p>

<h4>45.8 <span class="Heading">Subgroups of Polycyclic Groups – Canonical Pcgs</span></h4>

<p>The induced pcgs <var class="Arg">Q</var> of <var class="Arg">U</var> is called <em>canonical</em> if the matrix of exponent vectors contains normed vectors only and above each leading entry in the matrix there are 0's only. The canonical pcgs of <var class="Arg">U</var> with respect to <var class="Arg">P</var> is unique and hence such pcgs can be used to compare subgroups.</p>

<p><a id="X80D122B986B42F80" name="X80D122B986B42F80"></a></p>

<h5>45.8-1 IsCanonicalPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCanonicalPcgs</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>An induced pcgs is canonical if the matrix of the exponent vectors of the elements of <var class="Arg">pcgs</var> with respect to the <code class="func">ParentPcgs</code> (<a href="chap45.html#X86308E80843BF9E5"><span class="RefLink">45.7-3</span></a>) value of <var class="Arg">pcgs</var> is in Hermite normal form (see <a href="chapBib.html#biBSOGOS">[LNS84]</a>). While a subgroup can have various induced pcgs with respect to a parent pcgs a canonical pcgs is unique.</p>

<p><a id="X816F6B4187032A10" name="X816F6B4187032A10"></a></p>

<h5>45.8-2 CanonicalPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CanonicalPcgs</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns the canonical pcgs corresponding to the induced pcgs <var class="Arg">pcgs</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := Group((1,2,3,4),(5,6,7));</span>
Group([ (1,2,3,4), (5,6,7) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P := Pcgs(G);</span>
Pcgs([ (5,6,7), (1,2,3,4), (1,3)(2,4) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">I := InducedPcgsByPcSequence(P, [(5,6,7)*(1,3)(2,4),(1,3)(2,4)] );</span>
Pcgs([ (1,3)(2,4)(5,6,7), (1,3)(2,4) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CanonicalPcgs(I);</span>
Pcgs([ (5,6,7), (1,3)(2,4) ])
</pre></div>

<p><a id="X8294F5EF81B7ABA0" name="X8294F5EF81B7ABA0"></a></p>

<h4>45.9 <span class="Heading">Factor Groups of Polycyclic Groups – Modulo Pcgs</span></h4>

<p>Let <var class="Arg">N</var> be a normal subgroup of <var class="Arg">G</var> such that <var class="Arg">G/N</var> is polycyclic with pcgs <span class="SimpleMath">(h_1 N, ..., h_r N)</span>. Then we call the sequence of preimages <span class="SimpleMath">(h_1, ... h_r)</span> a <em>modulo pcgs</em> of <var class="Arg">G/N</var>. <var class="Arg">G</var> is called the <em>numerator</em> of the modulo pcgs and <var class="Arg">N</var> is the <em>denominator</em> of the modulo pcgs.</p>

<p>Modulo pcgs are often used to facilitate efficient computations with factor groups, since they allow computations with factor groups without formally defining the factor group at all.</p>

<p>All elementary operations of pcgs, see Sections <a href="chap45.html#X816C5E8E7F71C9D8"><span class="RefLink">45.4</span></a> and <a href="chap45.html#X84243AA07DA5A827"><span class="RefLink">45.5</span></a>, apply to modulo pcgs as well. However, it is in general not possible to compute induced pcgs with respect to a modulo pcgs.</p>

<p>Two more elementary operations for modulo pcgs are <code class="func">NumeratorOfModuloPcgs</code> (<a href="chap45.html#X8027CC9878031D74"><span class="RefLink">45.9-3</span></a>) and <code class="func">DenominatorOfModuloPcgs</code> (<a href="chap45.html#X87DBE2797D51B2F1"><span class="RefLink">45.9-4</span></a>).</p>

<p><a id="X7FE689A37E559F66" name="X7FE689A37E559F66"></a></p>

<h5>45.9-1 ModuloPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ModuloPcgs</code>( <var class="Arg">G</var>, <var class="Arg">N</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns a modulo pcgs for the factor <span class="SimpleMath"><var class="Arg">G</var>/<var class="Arg">N</var></span> which must be solvable, while <var class="Arg">N</var> may be non-solvable. <code class="func">ModuloPcgs</code> will return <em>a</em> pcgs for the factor, there is no guarantee that it will be "compatible" with any other pcgs. If this is required, the <code class="keyw">mod</code> operator must be used on induced pcgs, see <code class="func">\mod</code> (<a href="chap45.html#X7E923519832F2D08"><span class="RefLink">45.9-5</span></a>).</p>

<p><a id="X868207D77D09D915" name="X868207D77D09D915"></a></p>

<h5>45.9-2 IsModuloPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsModuloPcgs</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>The category of modulo pcgs. Note that each pcgs is a modulo pcgs for the trivial subgroup.</p>

<p><a id="X8027CC9878031D74" name="X8027CC9878031D74"></a></p>

<h5>45.9-3 NumeratorOfModuloPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NumeratorOfModuloPcgs</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns a generating set for the numerator of the modulo pcgs <var class="Arg">pcgs</var>.</p>

<p><a id="X87DBE2797D51B2F1" name="X87DBE2797D51B2F1"></a></p>

<h5>45.9-4 DenominatorOfModuloPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DenominatorOfModuloPcgs</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns a generating set for the denominator of the modulo pcgs <var class="Arg">pcgs</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := Group( (1,2,3,4,5),(1,2) );</span>
Group([ (1,2,3,4,5), (1,2) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P := ModuloPcgs(G, DerivedSubgroup(G) );</span>
Pcgs([ (4,5) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NumeratorOfModuloPcgs(P);</span>
[ (1,2,3,4,5), (1,2) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DenominatorOfModuloPcgs(P);</span>
[ (1,3,2), (1,4,3), (2,5,4) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RelativeOrders(P);</span>
[ 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExponentsOfPcElement( P, (1,2,3,4,5) );</span>
[ 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExponentsOfPcElement( P, (4,5) );</span>
[ 1 ]
</pre></div>

<p><a id="X7E923519832F2D08" name="X7E923519832F2D08"></a></p>

<h5><code>45.9-5 \mod</code></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; \mod</code>( <var class="Arg">P</var>, <var class="Arg">I</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Modulo Pcgs can also be built from compatible induced pcgs. Let <span class="SimpleMath">G</span> be a group with pcgs <var class="Arg">P</var> and let <var class="Arg">I</var> be an induced pcgs of a normal subgroup <span class="SimpleMath">N</span> of <span class="SimpleMath">G</span>. (Respectively: <var class="Arg">P</var> and <var class="Arg">I</var> are both induced with respect to the <em>same</em> Pcgs.) Then we can compute a modulo pcgs of <span class="SimpleMath">G</span> mod <span class="SimpleMath">N</span> by</p>

<p><var class="Arg">P</var> <code class="keyw">mod</code> <var class="Arg">I</var></p>

<p>Note that in this case we obtain the advantage that the values of <code class="func">NumeratorOfModuloPcgs</code> (<a href="chap45.html#X8027CC9878031D74"><span class="RefLink">45.9-3</span></a>) and <code class="func">DenominatorOfModuloPcgs</code> (<a href="chap45.html#X87DBE2797D51B2F1"><span class="RefLink">45.9-4</span></a>) are just <var class="Arg">P</var> and <var class="Arg">I</var>, respectively, and hence are unique.</p>

<p>The resulting modulo pcgs will consist of a subset of <var class="Arg">P</var> and will be "compatible" with <var class="Arg">P</var> (or its parent).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := Group((1,2,3,4));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P := Pcgs(G);</span>
Pcgs([ (1,2,3,4), (1,3)(2,4) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">I := InducedPcgsByGenerators(P, [(1,3)(2,4)]);</span>
Pcgs([ (1,3)(2,4) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := P mod I;</span>
[ (1,2,3,4) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NumeratorOfModuloPcgs(M);</span>
Pcgs([ (1,2,3,4), (1,3)(2,4) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DenominatorOfModuloPcgs(M);</span>
Pcgs([ (1,3)(2,4) ])
</pre></div>

<p><a id="X876A41F97FBA7754" name="X876A41F97FBA7754"></a></p>

<h5>45.9-6 CorrespondingGeneratorsByModuloPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CorrespondingGeneratorsByModuloPcgs</code>( <var class="Arg">mpcgs</var>, <var class="Arg">imgs</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">mpcgs</var> be a modulo pcgs for a factor of a group <span class="SimpleMath">G</span> and let <span class="SimpleMath">U</span> be a subgroup of <span class="SimpleMath">G</span> generated by <var class="Arg">imgs</var> such that <span class="SimpleMath">U</span> covers the factor for the modulo pcgs. Then this function computes elements in <span class="SimpleMath">U</span> corresponding to the generators of the modulo pcgs.</p>

<p>Note that the computation of induced generating sets is not possible for some modulo pcgs.</p>

<p><a id="X8480852A7D49BC3F" name="X8480852A7D49BC3F"></a></p>

<h5>45.9-7 CanonicalPcgsByGeneratorsWithImages</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CanonicalPcgsByGeneratorsWithImages</code>( <var class="Arg">pcgs</var>, <var class="Arg">gens</var>, <var class="Arg">imgs</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>computes a canonical, <var class="Arg">pcgs</var>-induced pcgs for the span of <var class="Arg">gens</var> and simultaneously does the same transformations on <var class="Arg">imgs</var>, preserving thus a correspondence between <var class="Arg">gens</var> and <var class="Arg">imgs</var>. This operation is used to represent homomorphisms from a pc group.</p>

<p><a id="X8254C0F485F945BD" name="X8254C0F485F945BD"></a></p>

<h4>45.10 <span class="Heading">Factor Groups of Polycyclic Groups in their Own Representation</span></h4>

<p>If substantial calculations are done in a factor it might be worth still to construct the factor group in its own representation (for example by calling <code class="func">PcGroupWithPcgs</code> (<a href="chap46.html#X81C55D4F825C36D4"><span class="RefLink">46.5-1</span></a>) on a modulo pcgs.</p>

<p>The following functions are intended for working with factor groups obtained by factoring out the tail of a pcgs. They provide a way to map elements or induced pcgs quickly in the factor (respectively to take preimages) without the need to construct a homomorphism.</p>

<p>The setup is always a pcgs <var class="Arg">pcgs</var> of <var class="Arg">G</var> and a pcgs <var class="Arg">fpcgs</var> of a factor group <span class="SimpleMath">H = <var class="Arg">G</var>/<var class="Arg">N</var></span> which corresponds to a head of <var class="Arg">pcgs</var>.</p>

<p>No tests for validity of the input are performed.</p>

<p><a id="X806C2D827E04ACF3" name="X806C2D827E04ACF3"></a></p>

<h5>45.10-1 ProjectedPcElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ProjectedPcElement</code>( <var class="Arg">pcgs</var>, <var class="Arg">fpcgs</var>, <var class="Arg">elm</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns the image in <var class="Arg">H</var> of an element <var class="Arg">elm</var> of <var class="Arg">G</var>.</p>

<p><a id="X82F39CCE7C928D3A" name="X82F39CCE7C928D3A"></a></p>

<h5>45.10-2 ProjectedInducedPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ProjectedInducedPcgs</code>( <var class="Arg">pcgs</var>, <var class="Arg">fpcgs</var>, <var class="Arg">ipcgs</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><var class="Arg">ipcgs</var> must be an induced pcgs with respect to <var class="Arg">pcgs</var>. This operation returns an induced pcgs with respect to <var class="Arg">fpcgs</var> consisting of the nontrivial images of <var class="Arg">ipcgs</var>.</p>

<p><a id="X816813A078B93A6B" name="X816813A078B93A6B"></a></p>

<h5>45.10-3 LiftedPcElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LiftedPcElement</code>( <var class="Arg">pcgs</var>, <var class="Arg">fpcgs</var>, <var class="Arg">elm</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns a preimage in <var class="Arg">G</var> of an element <var class="Arg">elm</var> of <var class="Arg">H</var>.</p>

<p><a id="X83C60F1587577D65" name="X83C60F1587577D65"></a></p>

<h5>45.10-4 LiftedInducedPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LiftedInducedPcgs</code>( <var class="Arg">pcgs</var>, <var class="Arg">fpcgs</var>, <var class="Arg">ipcgs</var>, <var class="Arg">ker</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><var class="Arg">ipcgs</var> must be an induced pcgs with respect to <var class="Arg">fpcgs</var>. This operation returns an induced pcgs with respect to <var class="Arg">pcgs</var> consisting of the preimages of <var class="Arg">ipcgs</var>, appended by the elements in <var class="Arg">ker</var> (assuming there is a bijection of <var class="Arg">pcgs</var> mod <var class="Arg">ker</var> to <var class="Arg">fpcgs</var>). <var class="Arg">ker</var> might be a simple element list.</p>

<p><a id="X83FE235E7B208EC0" name="X83FE235E7B208EC0"></a></p>

<h4>45.11 <span class="Heading">Pcgs and Normal Series</span></h4>

<p>By definition, a pcgs determines a pc series of its underlying group. However, in many applications it will be necessary that this pc series refines a normal series with certain properties; for example, a normal series with abelian factors.</p>

<p>There are functions in <strong class="pkg">GAP</strong> to compute a pcgs through a normal series with elementary abelian factors, a central series or the lower p-central series. See also Section <a href="chap45.html#X83039CF97D27D819"><span class="RefLink">45.13</span></a> for a more explicit possibility.</p>

<p><a id="X7E7E89C278DDE20D" name="X7E7E89C278DDE20D"></a></p>

<h5>45.11-1 IsPcgsElementaryAbelianSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPcgsElementaryAbelianSeries</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>returns <code class="keyw">true</code> if the pcgs <var class="Arg">pcgs</var> refines an elementary abelian series. <code class="func">IndicesEANormalSteps</code> (<a href="chap45.html#X7BCC1E2A80544CC7"><span class="RefLink">45.11-3</span></a>) then gives the indices in the Pcgs, at which the subgroups of this series start.</p>

<p><a id="X863A20B57EA37BAC" name="X863A20B57EA37BAC"></a></p>

<h5>45.11-2 PcgsElementaryAbelianSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PcgsElementaryAbelianSeries</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PcgsElementaryAbelianSeries</code>( <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>computes a pcgs for <var class="Arg">G</var> that refines an elementary abelian series. <code class="func">IndicesEANormalSteps</code> (<a href="chap45.html#X7BCC1E2A80544CC7"><span class="RefLink">45.11-3</span></a>) gives the indices in the pcgs, at which the normal subgroups of this series start. The second variant returns a pcgs that runs through the normal subgroups in the list <var class="Arg">list</var>.</p>

<p><a id="X7BCC1E2A80544CC7" name="X7BCC1E2A80544CC7"></a></p>

<h5>45.11-3 IndicesEANormalSteps</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IndicesEANormalSteps</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IndicesEANormalStepsBounded</code>( <var class="Arg">pcgs</var>, <var class="Arg">bound</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">pcgs</var> be a pcgs obtained as corresponding to a series of normal subgroups with elementary abelian factors (for example from calling <code class="func">PcgsElementaryAbelianSeries</code> (<a href="chap45.html#X863A20B57EA37BAC"><span class="RefLink">45.11-2</span></a>)) Then <code class="func">IndicesEANormalSteps</code> returns a sorted list of integers, indicating the tails of <var class="Arg">pcgs</var> which generate these normal subgroup of <var class="Arg">G</var>. If <span class="SimpleMath">i</span> is an element of this list, <span class="SimpleMath">(g_i, ..., g_n)</span> is a normal subgroup of <var class="Arg">G</var>. The list always starts with <span class="SimpleMath">1</span> and ends with <span class="SimpleMath">n+1</span>. (These indices form <em>one</em> series with elementary abelian subfactors, not necessarily the most refined one.)</p>

<p>The attribute <code class="func">EANormalSeriesByPcgs</code> (<a href="chap45.html#X7FCE308887F621FC"><span class="RefLink">45.11-4</span></a>) returns the actual series of subgroups.</p>

<p>For arbitrary pcgs not obtained as belonging to a special series such a set of indices not necessarily exists, and <code class="func">IndicesEANormalSteps</code> is not guaranteed to work in this situation.</p>

<p>Typically, <code class="func">IndicesEANormalSteps</code> is set by <code class="func">PcgsElementaryAbelianSeries</code> (<a href="chap45.html#X863A20B57EA37BAC"><span class="RefLink">45.11-2</span></a>).</p>

<p>The variant <code class="func">IndicesEANormalStepsBounded</code> will aim to ensure that no factor will be larger than the given bound.</p>

<p><a id="X7FCE308887F621FC" name="X7FCE308887F621FC"></a></p>

<h5>45.11-4 EANormalSeriesByPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EANormalSeriesByPcgs</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">pcgs</var> be a pcgs obtained as corresponding to a series of normal subgroups with elementary abelian factors (for example from calling <code class="func">PcgsElementaryAbelianSeries</code> (<a href="chap45.html#X863A20B57EA37BAC"><span class="RefLink">45.11-2</span></a>)). This attribute returns the actual series of normal subgroups, corresponding to <code class="func">IndicesEANormalSteps</code> (<a href="chap45.html#X7BCC1E2A80544CC7"><span class="RefLink">45.11-3</span></a>).</p>

<p><a id="X79675266796D7254" name="X79675266796D7254"></a></p>

<h5>45.11-5 IsPcgsCentralSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPcgsCentralSeries</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>returns <code class="keyw">true</code> if the pcgs <var class="Arg">pcgs</var> refines an central elementary abelian series. <code class="func">IndicesCentralNormalSteps</code> (<a href="chap45.html#X7FB73FEB7BED5BFA"><span class="RefLink">45.11-7</span></a>) then gives the indices in the pcgs, at which the subgroups of this series start.</p>

<p><a id="X8187FCF483659E69" name="X8187FCF483659E69"></a></p>

<h5>45.11-6 PcgsCentralSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PcgsCentralSeries</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>computes a pcgs for <var class="Arg">G</var> that refines a central elementary abelian series. <code class="func">IndicesCentralNormalSteps</code> (<a href="chap45.html#X7FB73FEB7BED5BFA"><span class="RefLink">45.11-7</span></a>) gives the indices in the pcgs, at which the normal subgroups of this series start.</p>

<p><a id="X7FB73FEB7BED5BFA" name="X7FB73FEB7BED5BFA"></a></p>

<h5>45.11-7 IndicesCentralNormalSteps</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IndicesCentralNormalSteps</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">pcgs</var> be a pcgs obtained as corresponding to a series of normal subgroups with central elementary abelian factors (for example from calling <code class="func">PcgsCentralSeries</code> (<a href="chap45.html#X8187FCF483659E69"><span class="RefLink">45.11-6</span></a>)). Then <code class="func">IndicesCentralNormalSteps</code> returns a sorted list of integers, indicating the tails of <var class="Arg">pcgs</var> which generate these normal subgroups of <var class="Arg">G</var>. If <span class="SimpleMath">i</span> is an element of this list, <span class="SimpleMath">(g_i, ..., g_n)</span> is a normal subgroup of <var class="Arg">G</var>. The list always starts with <span class="SimpleMath">1</span> and ends with <span class="SimpleMath">n+1</span>. (These indices form <em>one</em> series with central elementary abelian subfactors, not necessarily the most refined one.)</p>

<p>The attribute <code class="func">CentralNormalSeriesByPcgs</code> (<a href="chap45.html#X82266ADA86B2A689"><span class="RefLink">45.11-8</span></a>) returns the actual series of subgroups.</p>

<p>For arbitrary pcgs not obtained as belonging to a special series such a set of indices not necessarily exists, and <code class="func">IndicesCentralNormalSteps</code> is not guaranteed to work in this situation.</p>

<p>Typically, <code class="func">IndicesCentralNormalSteps</code> is set by <code class="func">PcgsCentralSeries</code> (<a href="chap45.html#X8187FCF483659E69"><span class="RefLink">45.11-6</span></a>).</p>

<p><a id="X82266ADA86B2A689" name="X82266ADA86B2A689"></a></p>

<h5>45.11-8 CentralNormalSeriesByPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CentralNormalSeriesByPcgs</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">pcgs</var> be a pcgs obtained as corresponding to a series of normal subgroups with central elementary abelian factors (for example from calling <code class="func">PcgsCentralSeries</code> (<a href="chap45.html#X8187FCF483659E69"><span class="RefLink">45.11-6</span></a>)). This attribute returns the actual series of normal subgroups, corresponding to <code class="func">IndicesCentralNormalSteps</code> (<a href="chap45.html#X7FB73FEB7BED5BFA"><span class="RefLink">45.11-7</span></a>).</p>

<p><a id="X786E60AF7B61BF9E" name="X786E60AF7B61BF9E"></a></p>

<h5>45.11-9 IsPcgsPCentralSeriesPGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPcgsPCentralSeriesPGroup</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>returns <code class="keyw">true</code> if the pcgs <var class="Arg">pcgs</var> refines a <span class="SimpleMath">p</span>-central elementary abelian series for a <span class="SimpleMath">p</span>-group. <code class="func">IndicesPCentralNormalStepsPGroup</code> (<a href="chap45.html#X863968F08509E7D4"><span class="RefLink">45.11-11</span></a>) then gives the indices in the pcgs, at which the subgroups of this series start.</p>

<p><a id="X86F19DBD7D346E7F" name="X86F19DBD7D346E7F"></a></p>

<h5>45.11-10 PcgsPCentralSeriesPGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PcgsPCentralSeriesPGroup</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>computes a pcgs for the <span class="SimpleMath">p</span>-group <var class="Arg">G</var> that refines a <span class="SimpleMath">p</span>-central elementary abelian series. <code class="func">IndicesPCentralNormalStepsPGroup</code> (<a href="chap45.html#X863968F08509E7D4"><span class="RefLink">45.11-11</span></a>) gives the indices in the pcgs, at which the normal subgroups of this series start.</p>

<p><a id="X863968F08509E7D4" name="X863968F08509E7D4"></a></p>

<h5>45.11-11 IndicesPCentralNormalStepsPGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IndicesPCentralNormalStepsPGroup</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">pcgs</var> be a pcgs obtained as corresponding to a series of normal subgroups with <span class="SimpleMath">p</span>-central elementary abelian factors (for example from calling <code class="func">PcgsPCentralSeriesPGroup</code> (<a href="chap45.html#X86F19DBD7D346E7F"><span class="RefLink">45.11-10</span></a>)). Then <code class="func">IndicesPCentralNormalStepsPGroup</code> returns a sorted list of integers, indicating the tails of <var class="Arg">pcgs</var> which generate these normal subgroups of <var class="Arg">G</var>. If <span class="SimpleMath">i</span> is an element of this list, <span class="SimpleMath">(g_i, ..., g_n)</span> is a normal subgroup of <var class="Arg">G</var>. The list always starts with <span class="SimpleMath">1</span> and ends with <span class="SimpleMath">n+1</span>. (These indices form <em>one</em> series with central elementary abelian subfactors, not necessarily the most refined one.)</p>

<p>The attribute <code class="func">PCentralNormalSeriesByPcgsPGroup</code> (<a href="chap45.html#X7A92C9EA7BAF60CA"><span class="RefLink">45.11-12</span></a>) returns the actual series of subgroups.</p>

<p>For arbitrary pcgs not obtained as belonging to a special series such a set of indices not necessarily exists, and <code class="func">IndicesPCentralNormalStepsPGroup</code> is not guaranteed to work in this situation.</p>

<p>Typically, <code class="func">IndicesPCentralNormalStepsPGroup</code> is set by <code class="func">PcgsPCentralSeriesPGroup</code> (<a href="chap45.html#X86F19DBD7D346E7F"><span class="RefLink">45.11-10</span></a>).</p>

<p><a id="X7A92C9EA7BAF60CA" name="X7A92C9EA7BAF60CA"></a></p>

<h5>45.11-12 PCentralNormalSeriesByPcgsPGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PCentralNormalSeriesByPcgsPGroup</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">pcgs</var> be a pcgs obtained as corresponding to a series of normal subgroups with <span class="SimpleMath">p</span>-central elementary abelian factors (for example from calling <code class="func">PcgsPCentralSeriesPGroup</code> (<a href="chap45.html#X86F19DBD7D346E7F"><span class="RefLink">45.11-10</span></a>)). This attribute returns the actual series of normal subgroups, corresponding to <code class="func">IndicesPCentralNormalStepsPGroup</code> (<a href="chap45.html#X863968F08509E7D4"><span class="RefLink">45.11-11</span></a>).</p>

<p><a id="X7EA5BC3B7FE9D98D" name="X7EA5BC3B7FE9D98D"></a></p>

<h5>45.11-13 IsPcgsChiefSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPcgsChiefSeries</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>returns <code class="keyw">true</code> if the pcgs <var class="Arg">pcgs</var> refines a chief series. <code class="func">IndicesChiefNormalSteps</code> (<a href="chap45.html#X7C05E84A78CA405E"><span class="RefLink">45.11-15</span></a>) then gives the indices in the pcgs, at which the subgroups of this series start.</p>

<p><a id="X7E7326947EAE4BC9" name="X7E7326947EAE4BC9"></a></p>

<h5>45.11-14 PcgsChiefSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PcgsChiefSeries</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>computes a pcgs for <var class="Arg">G</var> that refines a chief series. <code class="func">IndicesChiefNormalSteps</code> (<a href="chap45.html#X7C05E84A78CA405E"><span class="RefLink">45.11-15</span></a>) gives the indices in the pcgs, at which the normal subgroups of this series start.</p>

<p><a id="X7C05E84A78CA405E" name="X7C05E84A78CA405E"></a></p>

<h5>45.11-15 IndicesChiefNormalSteps</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IndicesChiefNormalSteps</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">pcgs</var> be a pcgs obtained as corresponding to a chief series for example from calling <code class="func">PcgsChiefSeries</code> (<a href="chap45.html#X7E7326947EAE4BC9"><span class="RefLink">45.11-14</span></a>)). Then <code class="func">IndicesChiefNormalSteps</code> returns a sorted list of integers, indicating the tails of <var class="Arg">pcgs</var> which generate these normal subgroups of <var class="Arg">G</var>. If <span class="SimpleMath">i</span> is an element of this list, <span class="SimpleMath">(g_i, ..., g_n)</span> is a normal subgroup of <var class="Arg">G</var>. The list always starts with <span class="SimpleMath">1</span> and ends with <span class="SimpleMath">n+1</span>. (These indices form <em>one</em> series with elementary abelian subfactors, not necessarily the most refined one.)</p>

<p>The attribute <code class="func">ChiefNormalSeriesByPcgs</code> (<a href="chap45.html#X83C5ABC587074B14"><span class="RefLink">45.11-16</span></a>) returns the actual series of subgroups.</p>

<p>For arbitrary pcgs not obtained as belonging to a special series such a set of indices not necessarily exists, and <code class="func">IndicesChiefNormalSteps</code> is not guaranteed to work in this situation.</p>

<p>Typically, <code class="func">IndicesChiefNormalSteps</code> is set by <code class="func">PcgsChiefSeries</code> (<a href="chap45.html#X7E7326947EAE4BC9"><span class="RefLink">45.11-14</span></a>).</p>

<p><a id="X83C5ABC587074B14" name="X83C5ABC587074B14"></a></p>

<h5>45.11-16 ChiefNormalSeriesByPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ChiefNormalSeriesByPcgs</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">pcgs</var> be a pcgs obtained as corresponding to a chief series (for example from calling <code class="func">PcgsChiefSeries</code> (<a href="chap45.html#X7E7326947EAE4BC9"><span class="RefLink">45.11-14</span></a>)). This attribute returns the actual series of normal subgroups, corresponding to <code class="func">IndicesChiefNormalSteps</code> (<a href="chap45.html#X7C05E84A78CA405E"><span class="RefLink">45.11-15</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=Group((1,2,3,4),(1,2));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p:=PcgsElementaryAbelianSeries(g);</span>
Pcgs([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IndicesEANormalSteps(p);</span>
[ 1, 2, 3, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=Group((1,2,3,4),(1,5)(2,6)(3,7)(4,8));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p:=PcgsCentralSeries(g);</span>
Pcgs([ (1,5)(2,6)(3,7)(4,8), (5,6,7,8), (5,7)(6,8), 
  (1,4,3,2)(5,6,7,8), (1,3)(2,4)(5,7)(6,8) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IndicesCentralNormalSteps(p);</span>
[ 1, 2, 4, 5, 6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q:=PcgsPCentralSeriesPGroup(g);</span>
Pcgs([ (1,5)(2,6)(3,7)(4,8), (5,6,7,8), (5,7)(6,8), 
  (1,4,3,2)(5,6,7,8), (1,3)(2,4)(5,7)(6,8) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IndicesPCentralNormalStepsPGroup(q);</span>
[ 1, 3, 5, 6 ]
</pre></div>

<p><a id="X7A954E3887189842" name="X7A954E3887189842"></a></p>

<h5>45.11-17 IndicesNormalSteps</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IndicesNormalSteps</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns the indices of <em>all</em> steps in the pc series, which are normal in the group defined by the pcgs.</p>

<p>(In general, this function yields a slower performance than the more specialized index functions for elementary abelian series etc.)</p>

<p><a id="X7947B0FB87F44042" name="X7947B0FB87F44042"></a></p>

<h5>45.11-18 NormalSeriesByPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NormalSeriesByPcgs</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns the subgroups the pc series, which are normal in the group defined by the pcgs.</p>

<p>(In general, this function yields a slower performance than the more specialized index functions for elementary abelian series etc.)</p>

<p><a id="X7E624B4E8224DE2D" name="X7E624B4E8224DE2D"></a></p>

<h4>45.12 <span class="Heading">Sum and Intersection of Pcgs</span></h4>

<p><a id="X7833DAAA7C07CFD7" name="X7833DAAA7C07CFD7"></a></p>

<h5>45.12-1 SumFactorizationFunctionPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SumFactorizationFunctionPcgs</code>( <var class="Arg">parentpcgs</var>, <var class="Arg">n</var>, <var class="Arg">u</var>, <var class="Arg">kerpcgs</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>computes the sum and intersection of the lists <var class="Arg">n</var> and <var class="Arg">u</var> whose elements form modulo pcgs induced by <var class="Arg">parentpcgs</var> for two subgroups modulo a kernel given by <var class="Arg">kerpcgs</var>. If <var class="Arg">kerpcgs</var> is a tail if the <var class="Arg">parent-pcgs</var> it is sufficient to give the starting depth, this can be more efficient than to construct an explicit pcgs. The factor group modulo <var class="Arg">kerpcgs</var> generated by <var class="Arg">n</var> must be elementary abelian and normal under <var class="Arg">u</var>.</p>

<p>The function returns a record with components</p>


<dl>
<dt><strong class="Mark"><code class="code">sum</code></strong></dt>
<dd><p>elements that form a modulo pcgs for the span of both subgroups.</p>

</dd>
<dt><strong class="Mark"><code class="code">intersection</code></strong></dt>
<dd><p>elements that form a modulo pcgs for the intersection of both subgroups.</p>

</dd>
<dt><strong class="Mark"><code class="code">factorization</code></strong></dt>
<dd><p>a function that returns for an element <var class="Arg">x</var> in the span of <code class="code">sum</code> a record with components <code class="code">u</code> and <code class="code">n</code> that give its decomposition.</p>

</dd>
</dl>
<p>The record components <code class="code">sum</code> and <code class="code">intersection</code> are <em>not</em> pcgs but only lists of pc elements (to avoid unnecessary creation of induced pcgs).</p>

<p><a id="X83039CF97D27D819" name="X83039CF97D27D819"></a></p>

<h4>45.13 <span class="Heading">Special Pcgs</span></h4>

<p>In short, a special pcgs is a pcgs which has particularly nice properties, for example it always refines an elementary abelian series, for <span class="SimpleMath">p</span>-groups it even refines a central series. These nice properties permit particularly efficient algorithms.</p>

<p>Let <var class="Arg">G</var> be a finite polycyclic group. A <em>special pcgs</em> of <var class="Arg">G</var> is a pcgs which is closely related to a Hall system and the maximal subgroups of <var class="Arg">G</var>. These pcgs have been introduced by C. R. Leedham-Green who also gave an algorithm to compute them. Improvements to this algorithm are due to Bettina Eick. For a more detailed account of their definition the reader is referred to <a href="chapBib.html#biBEick97">[Eic97]</a></p>

<p>To introduce the definition of special pcgs we first need to define the <em>LG-series</em> and <em>head complements</em> of a finite polycyclic group <var class="Arg">G</var>. Let <span class="SimpleMath">G = G_1 &gt; G_2 &gt; ... G_m &gt; G_{m+1} = { 1 }</span> be the lower nilpotent series of <span class="SimpleMath">G</span>; that is, <span class="SimpleMath">G_i</span> is the smallest normal subgroup of <span class="SimpleMath">G_{i-1}</span> with nilpotent factor. To obtain the LG-series of <var class="Arg">G</var> we need to refine this series. Thus consider a factor <span class="SimpleMath">F_i := G_i / G_{i+1}</span>. Since <span class="SimpleMath">F_i</span> is finite nilpotent, it is a direct product of its Sylow subgroups, say <span class="SimpleMath">F_i = P_{i,1} ⋯ P_{i,r_i}</span>. For each Sylow <span class="SimpleMath">p_j</span>-subgroup <span class="SimpleMath">P_{i,j}</span> we can consider its lower <span class="SimpleMath">p_j</span>-central series. To obtain a characteristic central series with elementary abelian factors of <span class="SimpleMath">F_i</span> we loop over its Sylow subgroups. Each time we consider <span class="SimpleMath">P_{i,j}</span> in this process we take the next step of its lower <span class="SimpleMath">p_j</span>-central series into the series of <span class="SimpleMath">F_i</span>. If there is no next step, then we just skip the consideration of <span class="SimpleMath">P_{i,j}</span>. Note that the second term of the lower <span class="SimpleMath">p</span>-central series of a <span class="SimpleMath">p</span>-group is in fact its Frattini subgroup. Thus the Frattini subgroup of <span class="SimpleMath">F_i</span> is contained in the computed series of this group. We denote the Frattini subgroup of <span class="SimpleMath">F_i = G_i / G_{i+1}</span> by <span class="SimpleMath">G_i^* / G_{i+1}</span>.</p>

<p>The factors <span class="SimpleMath">G_i / G_i^*</span> are called the heads of <span class="SimpleMath">G</span>, while the (possibly trivial) factors <span class="SimpleMath">G_i^* / G_{i+1}</span> are the tails of <span class="SimpleMath">G</span>. A head complement of <span class="SimpleMath">G</span> is a subgroup <span class="SimpleMath">U</span> of <span class="SimpleMath">G</span> such that <span class="SimpleMath">U / G_i^*</span> is a complement to the head <span class="SimpleMath">G_i / G_i^*</span> in <span class="SimpleMath">G / G_i^*</span> for some <span class="SimpleMath">i</span>.</p>

<p>Now we are able to define a special pcgs of <var class="Arg">G</var>. It is a pcgs of <var class="Arg">G</var> with three additional properties. First, the pc series determined by the pcgs refines the LG-series of <var class="Arg">G</var>. Second, a special pcgs <em>exhibits</em> a Hall system of the group <var class="Arg">G</var>; that is, for each set of primes <span class="SimpleMath">π</span> the elements of the pcgs with relative order in <span class="SimpleMath">π</span> form a pcgs of a Hall <span class="SimpleMath">π</span>-subgroup in a Hall system of <var class="Arg">G</var>. Third, a special pcgs exhibits a head complement for each head of <var class="Arg">G</var>.</p>

<p>To record information about the LG-series with the special pcgs we define the <em>LGWeights</em> of the special pcgs. These weights are a list which contains a weight <span class="SimpleMath">w</span> for each elements <span class="SimpleMath">g</span> of the special pcgs. Such a weight <span class="SimpleMath">w</span> represents the smallest subgroup of the LG-series containing <span class="SimpleMath">g</span>.</p>

<p>Since the LG-series is defined in terms of the lower nilpotent series, Sylow subgroups of the factors and lower <span class="SimpleMath">p</span>-central series of the Sylow subgroup, the weight <span class="SimpleMath">w</span> is a triple. More precisely, <span class="SimpleMath">g</span> is contained in the <span class="SimpleMath">w[1]</span>th term <span class="SimpleMath">U</span> of the lower nilpotent series of <var class="Arg">G</var>, but not in the next smaller one <span class="SimpleMath">V</span>. Then <span class="SimpleMath">w[3]</span> is a prime such that <span class="SimpleMath">g V</span> is contained in the Sylow <span class="SimpleMath">w[3]</span>-subgroup <span class="SimpleMath">P/V</span> of <span class="SimpleMath">U/V</span>. Moreover, <span class="SimpleMath">gV</span> is contained in the <span class="SimpleMath">w[2]</span>th term of the lower <span class="SimpleMath">p</span>-central series of <span class="SimpleMath">P/V</span>.</p>

<p>There are two more attributes of a special pcgs containing information about the LG-series: the list <em>LGLayers</em> and the list <em>LGFirst</em>. The list of layers corresponds to the elements of the special pcgs and denotes the layer of the LG-series in which an element lies. The list LGFirst corresponds to the LG-series and gives the number of the first element in the special pcgs of the corresponding subgroup.</p>

<p><a id="X7C8A82FA786AC021" name="X7C8A82FA786AC021"></a></p>

<h5>45.13-1 IsSpecialPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSpecialPcgs</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>tests whether <var class="Arg">obj</var> is a special pcgs.</p>

<p><a id="X827EB7767BACD023" name="X827EB7767BACD023"></a></p>

<h5>45.13-2 <span class="Heading">SpecialPcgs</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpecialPcgs</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpecialPcgs</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>computes a special pcgs for the group defined by <var class="Arg">pcgs</var> or for <var class="Arg">G</var>.</p>

<p><a id="X82DC7CE682140588" name="X82DC7CE682140588"></a></p>

<h5>45.13-3 LGWeights</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LGWeights</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns the LGWeights of the special pcgs <var class="Arg">pcgs</var>.</p>

<p><a id="X824645C97E347EEE" name="X824645C97E347EEE"></a></p>

<h5>45.13-4 LGLayers</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LGLayers</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns the layers of the special pcgs <var class="Arg">pcgs</var>.</p>

<p><a id="X7A655F4C7D9AE130" name="X7A655F4C7D9AE130"></a></p>

<h5>45.13-5 LGFirst</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LGFirst</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns the first indices for each layer of the special pcgs <var class="Arg">pcgs</var>.</p>

<p><a id="X7C3912F77B12C8B6" name="X7C3912F77B12C8B6"></a></p>

<h5>45.13-6 LGLength</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LGLength</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns the length of the LG-series of the group <var class="Arg">G</var>, if <var class="Arg">G</var> is solvable, and <code class="keyw">fail</code> otherwise.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SmallGroup( 96, 220 );</span>
&lt;pc group of size 96 with 6 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spec := SpecialPcgs( G );</span>
Pcgs([ f1, f2, f3, f4, f5, f6 ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LGWeights(spec);</span>
[ [ 1, 1, 2 ], [ 1, 1, 2 ], [ 1, 1, 2 ], [ 1, 1, 2 ], [ 1, 1, 3 ], 
  [ 1, 2, 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LGLayers(spec);</span>
[ 1, 1, 1, 1, 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LGFirst(spec);</span>
[ 1, 5, 6, 7 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LGLength( G );</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := SpecialPcgs( Pcgs( SmallGroup( 96, 120 ) ) );</span>
Pcgs([ f1, f2, f3, f4, f5, f6 ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LGWeights(p);</span>
[ [ 1, 1, 2 ], [ 1, 1, 2 ], [ 1, 1, 2 ], [ 1, 2, 2 ], [ 1, 3, 2 ], 
  [ 2, 1, 3 ] ]
</pre></div>

<p>Thus the first group, <code class="code">SmallGroup(96, 220)</code>, has a lower nilpotent series of length <span class="SimpleMath">1</span>; that is, the group is nilpotent. It is a direct product of its Sylow subgroups. Moreover the Sylow <span class="SimpleMath">2</span>-subgroup is generated by the elements <code class="code">f1, f2, f3, f4, f6</code>, and the Sylow <span class="SimpleMath">3</span>-subgroup is generated by <code class="code">f5</code>. The lower <span class="SimpleMath">2</span>-central series of the Sylow <span class="SimpleMath">2</span>-subgroup has length <span class="SimpleMath">2</span> and the second subgroup in this series is generated by <code class="code">f6</code>.</p>

<p>The second group, <code class="code">SmallGroup(96, 120)</code>, has a lower nilpotent series of length <span class="SimpleMath">2</span> and hence is not nilpotent. The second subgroup in this series is just the Sylow <span class="SimpleMath">3</span>-subgroup and it is generated by <code class="code">f6</code>. The subgroup generated by <code class="code">f1</code>, <span class="SimpleMath">...</span>, <code class="code">f5</code> is a Sylow <span class="SimpleMath">2</span>-subgroup of the group and also a head complement to the second head of the group. Its lower <span class="SimpleMath">2</span>-central series has length <span class="SimpleMath">2</span>.</p>

<p>In this example the <code class="func">FamilyPcgs</code> (<a href="chap46.html#X79EDB35E82C99304"><span class="RefLink">46.1-1</span></a>) value of the groups used was a special pcgs, but this is not necessarily the case. For performance reasons it can be worth to enforce this, see <code class="func">IsomorphismSpecialPcGroup</code> (<a href="chap46.html#X82BE14A986FA6882"><span class="RefLink">46.5-3</span></a>).</p>

<p><a id="X814C35BF7C9A8DEF" name="X814C35BF7C9A8DEF"></a></p>

<h5>45.13-7 IsInducedPcgsWrtSpecialPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsInducedPcgsWrtSpecialPcgs</code>( <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>tests whether <var class="Arg">pcgs</var> is induced with respect to a special pcgs.</p>

<p><a id="X7C14AE5C82FB0771" name="X7C14AE5C82FB0771"></a></p>

<h5>45.13-8 InducedPcgsWrtSpecialPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InducedPcgsWrtSpecialPcgs</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>computes an induced pcgs with respect to the special pcgs of the parent of <var class="Arg">G</var>.</p>

<p><code class="func">InducedPcgsWrtSpecialPcgs</code> will return a pcgs induced by <em>a</em> special pcgs (which might differ from the one you had in mind). If you need an induced pcgs compatible with a <em>given</em> special pcgs use <code class="func">InducedPcgs</code> (<a href="chap45.html#X7F0EB20080590B23"><span class="RefLink">45.7-4</span></a>) for this special pcgs.</p>

<p><a id="X7E86EB517DC08809" name="X7E86EB517DC08809"></a></p>

<h4>45.14 <span class="Heading">Action on Subfactors Defined by a Pcgs</span></h4>

<p>When working with a polycyclic group, one often needs to compute matrix operations of the group on a factor of the group. For this purpose there are the functions described in <a href="chap45.html#X7A9BB9D0817CA949"><span class="RefLink">45.14-1</span></a> to <a href="chap45.html#X7C2135B98732BBC3"><span class="RefLink">45.14-3</span></a>.</p>

<p>In certain situations, for example within the computation of conjugacy classes of finite soluble groups as described in <a href="chapBib.html#biBMeckyNeubueser89">[MN89]</a>, affine actions of groups are required. For this purpose we introduce the functions <code class="func">AffineAction</code> (<a href="chap45.html#X79C2D6BF7DD69ED6"><span class="RefLink">45.14-4</span></a>) and <code class="func">AffineActionLayer</code> (<a href="chap45.html#X7E4CB1358524497B"><span class="RefLink">45.14-5</span></a>).</p>

<p><a id="X7A9BB9D0817CA949" name="X7A9BB9D0817CA949"></a></p>

<h5>45.14-1 VectorSpaceByPcgsOfElementaryAbelianGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VectorSpaceByPcgsOfElementaryAbelianGroup</code>( <var class="Arg">mpcgs</var>, <var class="Arg">fld</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns the vector space over <var class="Arg">fld</var> corresponding to the modulo pcgs <var class="Arg">mpcgs</var>. Note that <var class="Arg">mpcgs</var> has to define an elementary abelian <span class="SimpleMath">p</span>-group where <span class="SimpleMath">p</span> is the characteristic of <var class="Arg">fld</var>.</p>

<p><a id="X81FC09DD7FC06C6E" name="X81FC09DD7FC06C6E"></a></p>

<h5>45.14-2 LinearAction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LinearAction</code>( <var class="Arg">gens</var>, <var class="Arg">basisvectors</var>, <var class="Arg">linear</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LinearOperation</code>( <var class="Arg">gens</var>, <var class="Arg">basisvectors</var>, <var class="Arg">linear</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns a list of matrices, one for each element of <var class="Arg">gens</var>, which corresponds to the matrix action of the elements in <var class="Arg">gens</var> on the basis <var class="Arg">basisvectors</var> via <var class="Arg">linear</var>.</p>

<p><a id="X7C2135B98732BBC3" name="X7C2135B98732BBC3"></a></p>

<h5>45.14-3 LinearActionLayer</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LinearActionLayer</code>( <var class="Arg">G</var>, <var class="Arg">gens</var>, <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LinearOperationLayer</code>( <var class="Arg">G</var>, <var class="Arg">gens</var>, <var class="Arg">pcgs</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns a list of matrices, one for each element of <var class="Arg">gens</var>, which corresponds to the matrix action of <var class="Arg">G</var> on the vector space corresponding to the modulo pcgs <var class="Arg">pcgs</var>.</p>

<p><a id="X79C2D6BF7DD69ED6" name="X79C2D6BF7DD69ED6"></a></p>

<h5>45.14-4 AffineAction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AffineAction</code>( <var class="Arg">gens</var>, <var class="Arg">basisvectors</var>, <var class="Arg">linear</var>, <var class="Arg">transl</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>return a list of matrices, one for each element of <var class="Arg">gens</var>, which corresponds to the affine action of the elements in <var class="Arg">gens</var> on the basis <var class="Arg">basisvectors</var> via <var class="Arg">linear</var> with translation <var class="Arg">transl</var>.</p>

<p><a id="X7E4CB1358524497B" name="X7E4CB1358524497B"></a></p>

<h5>45.14-5 AffineActionLayer</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AffineActionLayer</code>( <var class="Arg">G</var>, <var class="Arg">gens</var>, <var class="Arg">pcgs</var>, <var class="Arg">transl</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns a list of matrices, one for each element of <var class="Arg">gens</var>, which corresponds to the affine action of <var class="Arg">G</var> on the vector space corresponding to the modulo pcgs <var class="Arg">pcgs</var> with translation <var class="Arg">transl</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SmallGroup( 96, 51 );</span>
&lt;pc group of size 96 with 6 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spec := SpecialPcgs( G );</span>
Pcgs([ f1, f2, f3, f4, f5, f6 ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LGWeights( spec );</span>
[ [ 1, 1, 2 ], [ 1, 1, 2 ], [ 1, 1, 3 ], [ 1, 2, 2 ], [ 1, 2, 2 ], 
  [ 1, 3, 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mpcgs := InducedPcgsByPcSequence( spec, spec{[4,5,6]} );</span>
Pcgs([ f4, f5, f6 ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">npcgs := InducedPcgsByPcSequence( spec, spec{[6]} );</span>
Pcgs([ f6 ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">modu := mpcgs mod npcgs;</span>
[ f4, f5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat:=LinearActionLayer( G, spec{[1,2,3]}, modu );</span>
[ &lt;an immutable 2x2 matrix over GF2&gt;, 
  &lt;an immutable 2x2 matrix over GF2&gt;, 
  &lt;an immutable 2x2 matrix over GF2&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Print( mat, "\n" );</span>
[ [ [ Z(2)^0, 0*Z(2) ], [ 0*Z(2), Z(2)^0 ] ], 
  [ [ Z(2)^0, 0*Z(2) ], [ 0*Z(2), Z(2)^0 ] ], 
  [ [ Z(2)^0, 0*Z(2) ], [ 0*Z(2), Z(2)^0 ] ] ]
</pre></div>

<p><a id="X7EEA8D638492F432" name="X7EEA8D638492F432"></a></p>

<h4>45.15 <span class="Heading">Orbit Stabilizer Methods for Polycyclic Groups</span></h4>

<p>If a pcgs <var class="Arg">pcgs</var> is known for a group <var class="Arg">G</var>, then orbits and stabilizers can be computed by a special method which is particularly efficient. Note that within this function only the elements in <var class="Arg">pcgs</var> and the relative orders of <var class="Arg">pcgs</var> are needed. Hence this function works effectively even if the elementary operations for <var class="Arg">pcgs</var> are slow.</p>

<p><a id="X7CFCCF607A30B5EE" name="X7CFCCF607A30B5EE"></a></p>

<h5>45.15-1 StabilizerPcgs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StabilizerPcgs</code>( <var class="Arg">pcgs</var>, <var class="Arg">pnt</var>[, <var class="Arg">acts</var>][, <var class="Arg">act</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>computes the stabilizer in the group generated by <var class="Arg">pcgs</var> of the point <var class="Arg">pnt</var>. If given, <var class="Arg">acts</var> are elements by which <var class="Arg">pcgs</var> acts, <var class="Arg">act</var> is the acting function. This function returns a pcgs for the stabilizer which is induced by the <code class="code">ParentPcgs</code> of <var class="Arg">pcgs</var>, that is it is compatible with <var class="Arg">pcgs</var>.</p>

<p><a id="X7A87E72F86813132" name="X7A87E72F86813132"></a></p>

<h5>45.15-2 Pcgs_OrbitStabilizer</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Pcgs_OrbitStabilizer</code>( <var class="Arg">pcgs</var>, <var class="Arg">domain</var>, <var class="Arg">pnt</var>, <var class="Arg">oprs</var>, <var class="Arg">opr</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>runs a solvable group orbit-stabilizer algorithm on <var class="Arg">pnt</var> with <var class="Arg">pcgs</var> acting via the images <var class="Arg">oprs</var> and the operation function <var class="Arg">opr</var>. The domain <var class="Arg">domain</var> can be used to speed up search, if it is not known, <code class="keyw">false</code> can be given instead. The function returns a record with components <code class="code">orbit</code>, <code class="code">stabpcgs</code> and <code class="code">lengths</code>, the latter indicating the lengths of the orbit whenever it got extended. This can be used to recompute transversal elements. This function should be used only inside algorithms when speed is essential.</p>

<p><a id="X7A19DF1E7E841074" name="X7A19DF1E7E841074"></a></p>

<h4>45.16 <span class="Heading">Operations which have Special Methods for Groups with Pcgs</span></h4>

<p>For the following operations there are special methods for groups with pcgs installed:</p>

<p><code class="func">IsNilpotentGroup</code> (<a href="chap39.html#X87D062608719F2CD"><span class="RefLink">39.15-3</span></a>), <code class="func">IsSupersolvableGroup</code> (<a href="chap39.html#X7AADF2E88501B9FF"><span class="RefLink">39.15-8</span></a>), <code class="func">Size</code> (<a href="chap30.html#X858ADA3B7A684421"><span class="RefLink">30.4-6</span></a>), <code class="func">CompositionSeries</code> (<a href="chap39.html#X81CDCBD67BC98A5A"><span class="RefLink">39.17-5</span></a>), <code class="func">ConjugacyClasses</code> (<a href="chap39.html#X871B570284BBA685"><span class="RefLink">39.10-2</span></a>), <code class="func">Centralizer</code> (<a href="chap35.html#X7DE33AFC823C7873"><span class="RefLink">35.4-4</span></a>), <code class="func">FrattiniSubgroup</code> (<a href="chap39.html#X788C856C82243274"><span class="RefLink">39.12-6</span></a>), <code class="func">PrefrattiniSubgroup</code> (<a href="chap39.html#X81D86CCE84193E4F"><span class="RefLink">39.12-7</span></a>), <code class="func">MaximalSubgroups</code> (<a href="chap39.html#X861CD8DA790D81C2"><span class="RefLink">39.19-8</span></a>) and related operations, <code class="func">HallSystem</code> (<a href="chap39.html#X82FE5DFD84F8A3C6"><span class="RefLink">39.13-6</span></a>) and related operations, <code class="func">MinimalGeneratingSet</code> (<a href="chap39.html#X81D15723804771E2"><span class="RefLink">39.22-3</span></a>), <code class="func">Centre</code> (<a href="chap35.html#X847ABE6F781C7FE8"><span class="RefLink">35.4-5</span></a>), <code class="func">Intersection</code> (<a href="chap30.html#X851069107CACF98E"><span class="RefLink">30.5-2</span></a>), <code class="func">AutomorphismGroup</code> (<a href="chap40.html#X87677B0787B4461A"><span class="RefLink">40.7-1</span></a>), <code class="func">IrreducibleModules</code> (<a href="chap71.html#X87E82F8085745523"><span class="RefLink">71.15-1</span></a>).</p>

<p><a id="X79DCCF6D80351859" name="X79DCCF6D80351859"></a></p>

<h4>45.17 <span class="Heading">Conjugacy Classes in Solvable Groups</span></h4>

<p>There are a variety of algorithms to compute conjugacy classes and centralizers in solvable groups via epimorphic images (<a href="chapBib.html#biBFelschNeubueser79">[FN79]</a>, <a href="chapBib.html#biBMeckyNeubueser89">[MN89]</a>, <a href="chapBib.html#biBTheissen93">[The93]</a>). Usually these are only invoked as methods, but it is possible to access the algorithm directly.</p>

<p><a id="X79593F667A68A21D" name="X79593F667A68A21D"></a></p>

<h5>45.17-1 ClassesSolvableGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassesSolvableGroup</code>( <var class="Arg">G</var>, <var class="Arg">mode</var>[, <var class="Arg">opt</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>computes conjugacy classes and centralizers in solvable groups. <var class="Arg">G</var> is the acting group. <var class="Arg">mode</var> indicates the type of the calculation:</p>

<p>0 Conjugacy classes</p>

<p>4 Conjugacy test for the two elements in <var class="Arg">opt</var><code class="code">.candidates</code></p>

<p>In mode 0 the function returns a list of records containing components <var class="Arg">representative</var> and <var class="Arg">centralizer</var>. In mode 4 it returns a conjugating element.</p>

<p>The optional record <var class="Arg">opt</var> may contain the following components that will affect the algorithm's behaviour:</p>


<dl>
<dt><strong class="Mark"><code class="code">pcgs</code></strong></dt>
<dd><p>is a pcgs that will be used for the calculation. The attribute <code class="func">EANormalSeriesByPcgs</code> (<a href="chap45.html#X7FCE308887F621FC"><span class="RefLink">45.11-4</span></a>) must return an appropriate series of normal subgroups with elementary abelian factors among them. The algorithm will step down this series. In the case of the calculation of rational classes, it must be a pcgs refining a central series.</p>

</dd>
<dt><strong class="Mark"><code class="code">candidates</code></strong></dt>
<dd><p>is a list of elements for which canonical representatives are to be computed or for which a conjugacy test is performed. Both elements must lie in <var class="Arg">G</var>, but this is not tested. In mode 4 these elements must be given. In mode 0 a list of classes corresponding to <code class="code">candidates</code> is returned (which may contain duplicates). The <code class="code">representative</code>s chosen are canonical with respect to <code class="code">pcgs</code>. The records returned also contain components <code class="code">operator</code> such that <code class="code">candidate ^ operator = representative</code>.</p>

</dd>
<dt><strong class="Mark"><code class="code">consider</code></strong></dt>
<dd><p>is a function <code class="code">consider( fhome, rep, cenp, K, L )</code>. Here <code class="code">fhome</code> is a home pcgs for the factor group <span class="SimpleMath">F</span> in which the calculation currently takes place, <code class="code">rep</code> is an element of the factor and <code class="code">cenp</code> is a pcgs for the centralizer of <code class="code">rep</code> modulo <code class="code">K</code>. In mode 0, when lifting from <span class="SimpleMath">F</span>/<code class="code">K</code> to <span class="SimpleMath">F</span>/<code class="code">L</code> (note: for efficiency reasons, <span class="SimpleMath">F</span> can be different from <var class="Arg">G</var> or <code class="code">L</code> might be not trivial) this function is called before performing the actual lifting and only those representatives for which it returns <code class="keyw">true</code> are passed to the next level. This permits for example the calculation of only those classes with small centralizers or classes of restricted orders.</p>

</dd>
</dl>
<p><a id="X7B358D3B7E236973" name="X7B358D3B7E236973"></a></p>

<h5>45.17-2 CentralizerSizeLimitConsiderFunction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CentralizerSizeLimitConsiderFunction</code>( <var class="Arg">sz</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns a function (with arguments <code class="code">fhome</code>, <code class="code">rep</code>, <code class="code">cen</code>, <code class="code">K</code>, <code class="code">L</code>) that can be used in <code class="func">ClassesSolvableGroup</code> (<a href="chap45.html#X79593F667A68A21D"><span class="RefLink">45.17-1</span></a>) as the <code class="code">consider</code> component of the options record. It will restrict the lifting to those classes, for which the size of the centralizer (in the factor) is at most <var class="Arg">sz</var>.</p>

<p>See also <code class="func">SubgroupsSolvableGroup</code> (<a href="chap39.html#X7AD7804A803910AC"><span class="RefLink">39.21-3</span></a>).</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap44.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap46.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chap16.html">16</a>  <a href="chap17.html">17</a>  <a href="chap18.html">18</a>  <a href="chap19.html">19</a>  <a href="chap20.html">20</a>  <a href="chap21.html">21</a>  <a href="chap22.html">22</a>  <a href="chap23.html">23</a>  <a href="chap24.html">24</a>  <a href="chap25.html">25</a>  <a href="chap26.html">26</a>  <a href="chap27.html">27</a>  <a href="chap28.html">28</a>  <a href="chap29.html">29</a>  <a href="chap30.html">30</a>  <a href="chap31.html">31</a>  <a href="chap32.html">32</a>  <a href="chap33.html">33</a>  <a href="chap34.html">34</a>  <a href="chap35.html">35</a>  <a href="chap36.html">36</a>  <a href="chap37.html">37</a>  <a href="chap38.html">38</a>  <a href="chap39.html">39</a>  <a href="chap40.html">40</a>  <a href="chap41.html">41</a>  <a href="chap42.html">42</a>  <a href="chap43.html">43</a>  <a href="chap44.html">44</a>  <a href="chap45.html">45</a>  <a href="chap46.html">46</a>  <a href="chap47.html">47</a>  <a href="chap48.html">48</a>  <a href="chap49.html">49</a>  <a href="chap50.html">50</a>  <a href="chap51.html">51</a>  <a href="chap52.html">52</a>  <a href="chap53.html">53</a>  <a href="chap54.html">54</a>  <a href="chap55.html">55</a>  <a href="chap56.html">56</a>  <a href="chap57.html">57</a>  <a href="chap58.html">58</a>  <a href="chap59.html">59</a>  <a href="chap60.html">60</a>  <a href="chap61.html">61</a>  <a href="chap62.html">62</a>  <a href="chap63.html">63</a>  <a href="chap64.html">64</a>  <a href="chap65.html">65</a>  <a href="chap66.html">66</a>  <a href="chap67.html">67</a>  <a href="chap68.html">68</a>  <a href="chap69.html">69</a>  <a href="chap70.html">70</a>  <a href="chap71.html">71</a>  <a href="chap72.html">72</a>  <a href="chap73.html">73</a>  <a href="chap74.html">74</a>  <a href="chap75.html">75</a>  <a href="chap76.html">76</a>  <a href="chap77.html">77</a>  <a href="chap78.html">78</a>  <a href="chap79.html">79</a>  <a href="chap80.html">80</a>  <a href="chap81.html">81</a>  <a href="chap82.html">82</a>  <a href="chap83.html">83</a>  <a href="chap84.html">84</a>  <a href="chap85.html">85</a>  <a href="chap86.html">86</a>  <a href="chap87.html">87</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
