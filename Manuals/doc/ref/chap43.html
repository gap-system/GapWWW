<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (ref) - Chapter 43: Permutation Groups</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap43"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chap16.html">16</a>  <a href="chap17.html">17</a>  <a href="chap18.html">18</a>  <a href="chap19.html">19</a>  <a href="chap20.html">20</a>  <a href="chap21.html">21</a>  <a href="chap22.html">22</a>  <a href="chap23.html">23</a>  <a href="chap24.html">24</a>  <a href="chap25.html">25</a>  <a href="chap26.html">26</a>  <a href="chap27.html">27</a>  <a href="chap28.html">28</a>  <a href="chap29.html">29</a>  <a href="chap30.html">30</a>  <a href="chap31.html">31</a>  <a href="chap32.html">32</a>  <a href="chap33.html">33</a>  <a href="chap34.html">34</a>  <a href="chap35.html">35</a>  <a href="chap36.html">36</a>  <a href="chap37.html">37</a>  <a href="chap38.html">38</a>  <a href="chap39.html">39</a>  <a href="chap40.html">40</a>  <a href="chap41.html">41</a>  <a href="chap42.html">42</a>  <a href="chap43.html">43</a>  <a href="chap44.html">44</a>  <a href="chap45.html">45</a>  <a href="chap46.html">46</a>  <a href="chap47.html">47</a>  <a href="chap48.html">48</a>  <a href="chap49.html">49</a>  <a href="chap50.html">50</a>  <a href="chap51.html">51</a>  <a href="chap52.html">52</a>  <a href="chap53.html">53</a>  <a href="chap54.html">54</a>  <a href="chap55.html">55</a>  <a href="chap56.html">56</a>  <a href="chap57.html">57</a>  <a href="chap58.html">58</a>  <a href="chap59.html">59</a>  <a href="chap60.html">60</a>  <a href="chap61.html">61</a>  <a href="chap62.html">62</a>  <a href="chap63.html">63</a>  <a href="chap64.html">64</a>  <a href="chap65.html">65</a>  <a href="chap66.html">66</a>  <a href="chap67.html">67</a>  <a href="chap68.html">68</a>  <a href="chap69.html">69</a>  <a href="chap70.html">70</a>  <a href="chap71.html">71</a>  <a href="chap72.html">72</a>  <a href="chap73.html">73</a>  <a href="chap74.html">74</a>  <a href="chap75.html">75</a>  <a href="chap76.html">76</a>  <a href="chap77.html">77</a>  <a href="chap78.html">78</a>  <a href="chap79.html">79</a>  <a href="chap80.html">80</a>  <a href="chap81.html">81</a>  <a href="chap82.html">82</a>  <a href="chap83.html">83</a>  <a href="chap84.html">84</a>  <a href="chap85.html">85</a>  <a href="chap86.html">86</a>  <a href="chap87.html">87</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap42.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap44.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap43_mj.html">[MathJax on]</a></p>
<p><a id="X85ED46007CED6191" name="X85ED46007CED6191"></a></p>
<div class="ChapSects"><a href="chap43.html#X85ED46007CED6191">43 <span class="Heading">Permutation Groups</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap43.html#X7F38777E7BBE12AE">43.1 <span class="Heading">IsPermGroup (Filter)</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X7879877482F59676">43.1-1 IsPermGroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap43.html#X85D769FF85545AAB">43.2 <span class="Heading">The Natural Action</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X84CFA16D858B00B8">43.2-1 OrbitPerms</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X81F98222818DA35B">43.2-2 OrbitsPerms</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap43.html#X7E468B64860D5604">43.3 <span class="Heading">Computing a Permutation Representation</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X80B7B1C783AA1567">43.3-1 IsomorphismPermGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X8086628878AFD3EA">43.3-2 SmallerDegreePermutationRepresentation</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap43.html#X834208CD7C2956A3">43.4 <span class="Heading">Symmetric and Alternating Groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X8129BE59781478E1">43.4-1 IsNaturalSymmetricGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X85CA6AD17BE90C95">43.4-2 IsSymmetricGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X8514BE9E79C608E0">43.4-3 IsAlternatingGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X7ED60F7E81F1B614">43.4-4 SymmetricParentGroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap43.html#X83F8D3B578A7BEEB">43.5 <span class="Heading">Primitive Groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X7E50211A7B92455F">43.5-1 ONanScottType</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X7E89A46A86A3F4A2">43.5-2 SocleTypePrimitiveGroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap43.html#X7FA58C3A8283F3BD">43.6 <span class="Heading">Stabilizer Chains</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap43.html#X7C2406B97E057196">43.7 <span class="Heading">Randomized Methods for Permutation Groups</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap43.html#X7C7EA55C80E457FA">43.8 <span class="Heading">Construction of Stabilizer Chains</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X80B5CF78829495C2">43.8-1 StabChain</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X790C27B8783EDE68">43.8-2 StabChainOptions</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X87E1292E85A5D31C">43.8-3 DefaultStabChainOptions</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X86D64D2B81D58431">43.8-4 StabChainBaseStrongGenerators</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X7BEC5F5A7851CAAB">43.8-5 MinimalStabChain</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap43.html#X81D7FCE47AC7F942">43.9 <span class="Heading">Stabilizer Chain Records</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap43.html#X7ECF8A4586346FD4">43.10 <span class="Heading">Operations for Stabilizer Chains</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X7FBE6EB57EBE8B7D">43.10-1 BaseStabChain</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X7D2A190D8308ED39">43.10-2 BaseOfGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X7EF36DC78465026A">43.10-3 SizeStabChain</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X8384170881B9B531">43.10-4 StrongGeneratorsStabChain</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X87F473777EFDE867">43.10-5 GroupStabChain</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X87FB6DED80692D3F">43.10-6 OrbitStabChain</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X7AC8F165875906DE">43.10-7 IndicesStabChain</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X7CF607BC82C2C202">43.10-8 ListStabChain</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X7F40E52D7B0438BF">43.10-9 ElementsStabChain</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X780875477CD2A57D">43.10-10 IteratorStabChain</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X861062AE87ACF340">43.10-11 InverseRepresentative</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X79D2248C8787EAF2">43.10-12 SiftedPermutation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X7B870C217D0B9997">43.10-13 MinimalElementCosetStabChain</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X87435B7884D9B353">43.10-14 LargestElementStabChain</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X809B2C3B7C5F77AB">43.10-15 ApproximateSuborbitsStabilizerPermGroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap43.html#X8188051F79E72A95">43.11 <span class="Heading">Low Level Routines to Modify and Create Stabilizer Chains</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X86B31E6A81AE5FCB">43.11-1 CopyStabChain</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X7E167E557B567C6A">43.11-2 CopyOptionsDefaults</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X87FF64AB87BFC779">43.11-3 ChangeStabChain</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X8778B4657D3FD97B">43.11-4 ExtendStabChain</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X7E5E9F727D0B19D9">43.11-5 ReduceStabChain</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X85BF290D848C4091">43.11-6 RemoveStabChain</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X84E4906B86E5C089">43.11-7 EmptyStabChain</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X80C7D2E87E6EE357">43.11-8 InsertTrivialStabilizer</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X7B47B379824F6150">43.11-9 IsFixedStabilizer</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X8373007880EBF736">43.11-10 AddGeneratorsExtendSchreierTree</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap43.html#X86C78160854C7F30">43.12 <span class="Heading">Backtrack</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X7BE3F03C80BF8B08">43.12-1 SubgroupProperty</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X7EE7DDCC87C4BC31">43.12-2 ElementProperty</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X7A2D046B83DD5F5F">43.12-3 TwoClosure</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap43.html#X861461AB7964DC64">43.12-4 InfoBckt</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap43.html#X78A68F5A80ADD1B6">43.13 <span class="Heading">Working with large degree permutation groups</span></a>
</span>
</div>
</div>

<h3>43 <span class="Heading">Permutation Groups</span></h3>

<p><a id="X7F38777E7BBE12AE" name="X7F38777E7BBE12AE"></a></p>

<h4>43.1 <span class="Heading">IsPermGroup (Filter)</span></h4>

<p><a id="X7879877482F59676" name="X7879877482F59676"></a></p>

<h5>43.1-1 IsPermGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPermGroup</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>A permutation group is a group of permutations on a finite set <span class="SimpleMath">Ω</span> of positive integers. <strong class="pkg">GAP</strong> does <em>not</em> require the user to specify the operation domain <span class="SimpleMath">Ω</span> when a permutation group is defined.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=Group((1,2,3,4),(1,2));</span>
Group([ (1,2,3,4), (1,2) ])
</pre></div>

<p>Permutation groups are groups and therefore all operations for groups (see Chapter <a href="chap39.html#X8716635F7951801B"><span class="RefLink">39</span></a>) can be applied to them. In many cases special methods are installed for permutation groups that make computations more effective.</p>

<p><a id="X85D769FF85545AAB" name="X85D769FF85545AAB"></a></p>

<h4>43.2 <span class="Heading">The Natural Action</span></h4>

<p>The functions <code class="func">MovedPoints</code> (<a href="chap42.html#X85E61B9C7A6B0CCA"><span class="RefLink">42.3-3</span></a>), <code class="func">NrMovedPoints</code> (<a href="chap42.html#X85E7B1E28430F49E"><span class="RefLink">42.3-4</span></a>), <code class="func">LargestMovedPoint</code> (<a href="chap42.html#X84AA603987C94AC0"><span class="RefLink">42.3-2</span></a>), and <code class="func">SmallestMovedPoint</code> (<a href="chap42.html#X84EF0A697F7A87DC"><span class="RefLink">42.3-1</span></a>) are defined for arbitrary collections of permutations (see <a href="chap42.html#X82C255E2821C0721"><span class="RefLink">42.3</span></a>), in particular they can be applied to permutation groups.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Group( (2,3,5,6), (2,3) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MovedPoints( g );  NrMovedPoints( g );</span>
[ 2, 3, 5, 6 ]
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LargestMovedPoint( g );  SmallestMovedPoint( g );</span>
6
2
</pre></div>

<p>The action of a permutation group on the positive integers is a group action (via the acting function <code class="func">OnPoints</code> (<a href="chap41.html#X7FE417DD837987B4"><span class="RefLink">41.2-1</span></a>)). Therefore all action functions can be applied (see the Chapter <a href="chap41.html#X87115591851FB7F4"><span class="RefLink">41</span></a>), for example <code class="func">Orbit</code> (<a href="chap41.html#X80E0234E7BD79409"><span class="RefLink">41.4-1</span></a>), <code class="func">Stabilizer</code> (<a href="chap41.html#X86FB962786397E02"><span class="RefLink">41.5-2</span></a>), <code class="func">Blocks</code> (<a href="chap41.html#X84FE699F85371643"><span class="RefLink">41.11-1</span></a>), <code class="func">IsTransitive</code> (<a href="chap41.html#X79B15750851828CB"><span class="RefLink">41.10-1</span></a>), <code class="func">IsPrimitive</code> (<a href="chap41.html#X84C19AD68247B760"><span class="RefLink">41.10-7</span></a>).</p>

<p>If one has a list of group generators and is interested in the moved points (see above) or orbits, it may be useful to avoid the explicit construction of the group for efficiency reasons. For the special case of the action of permutations on positive integers via <code class="code">^</code>, the functions <code class="func">OrbitPerms</code> (<a href="chap43.html#X84CFA16D858B00B8"><span class="RefLink">43.2-1</span></a>) and <code class="func">OrbitsPerms</code> (<a href="chap43.html#X81F98222818DA35B"><span class="RefLink">43.2-2</span></a>) are provided for this purpose.</p>

<p>Similarly, several functions concerning the natural action of permutation groups address stabilizer chains (see <a href="chap43.html#X7FA58C3A8283F3BD"><span class="RefLink">43.6</span></a>) rather than permutation groups themselves, for example <code class="func">BaseStabChain</code> (<a href="chap43.html#X7FBE6EB57EBE8B7D"><span class="RefLink">43.10-1</span></a>).</p>

<p><a id="X84CFA16D858B00B8" name="X84CFA16D858B00B8"></a></p>

<h5>43.2-1 OrbitPerms</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OrbitPerms</code>( <var class="Arg">perms</var>, <var class="Arg">pnt</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns the orbit of the positive integer <var class="Arg">pnt</var> under the group generated by the permutations in the list <var class="Arg">perms</var>.</p>

<p><a id="X81F98222818DA35B" name="X81F98222818DA35B"></a></p>

<h5>43.2-2 OrbitsPerms</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OrbitsPerms</code>( <var class="Arg">perms</var>, <var class="Arg">D</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns the list of orbits of the positive integers in the list <var class="Arg">D</var> under the group generated by the permutations in the list <var class="Arg">perms</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrbitPerms( [ (1,2,3)(4,5), (3,6) ], 1 );</span>
[ 1, 2, 3, 6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrbitsPerms( [ (1,2,3)(4,5), (3,6) ], [ 1 .. 6 ] );</span>
[ [ 1, 2, 3, 6 ], [ 4, 5 ] ]
</pre></div>

<p><a id="X7E468B64860D5604" name="X7E468B64860D5604"></a></p>

<h4>43.3 <span class="Heading">Computing a Permutation Representation</span></h4>

<p><a id="X80B7B1C783AA1567" name="X80B7B1C783AA1567"></a></p>

<h5>43.3-1 IsomorphismPermGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismPermGroup</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns an isomorphism from the group <var class="Arg">G</var> onto a permutation group which is isomorphic to <var class="Arg">G</var>. The method will select a suitable permutation representation.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=SmallGroup(24,12);</span>
&lt;pc group of size 24 with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso:=IsomorphismPermGroup(g);</span>
&lt;action isomorphism&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Image(iso,g.3*g.4);</span>
(1,12)(2,16)(3,19)(4,5)(6,22)(7,8)(9,23)(10,11)(13,24)(14,15)(17,
18)(20,21)
</pre></div>

<p>In many cases the permutation representation constructed by <code class="func">IsomorphismPermGroup</code> is regular.</p>

<p><a id="X8086628878AFD3EA" name="X8086628878AFD3EA"></a></p>

<h5>43.3-2 SmallerDegreePermutationRepresentation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SmallerDegreePermutationRepresentation</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">G</var> be a permutation group that acts transitively on its moved points. <code class="func">SmallerDegreePermutationRepresentation</code> tries to find a faithful permutation representation of smaller degree. The result is a group homomorphism onto a permutation group, in the worst case this is the identity mapping on <var class="Arg">G</var>.</p>

<p>If the <code class="code">cheap</code> option is given, the function only tries to reduce to orbits or actions on blocks, otherwise also actions on cosets of random subgroups are tried.</p>

<p>Note that the result is not guaranteed to be a faithful permutation representation of smallest degree, or of smallest degree among the transitive permutation representations of <var class="Arg">G</var>. Using <strong class="pkg">GAP</strong> interactively, one might be able to choose subgroups of small index for which the cores intersect trivially; in this case, the actions on the cosets of these subgroups give rise to an intransitive permutation representation the degree of which may be smaller than the original degree.</p>

<p>The methods used might involve the use of random elements and the permutation representation (or even the degree of the representation) is not guaranteed to be the same for different calls of <code class="func">SmallerDegreePermutationRepresentation</code>.</p>

<p>If the option cheap is given less work is spent on trying to get a small degree representation, if the value of this option is set to the string "skip" the identity mapping is returned. (This is useful if a function called internally might try a degree reduction.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">image:= Image( iso );;  NrMovedPoints( image );</span>
24
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">small:= SmallerDegreePermutationRepresentation( image );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Image( small );</span>
Group([ (2,3), (2,3,4), (1,2)(3,4), (1,3)(2,4) ])
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p:=Group((1,2,3,4,5,6),(1,2));;p:=Action(p,AsList(p),OnRight);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length(MovedPoints(p));</span>
720
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q:=SmallerDegreePermutationRepresentation(p);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrMovedPoints(Image(q));</span>
6
</pre></div>

<p><a id="X834208CD7C2956A3" name="X834208CD7C2956A3"></a></p>

<h4>43.4 <span class="Heading">Symmetric and Alternating Groups</span></h4>

<p>The commands <code class="func">SymmetricGroup</code> (<a href="chap50.html#X858666F97BD85ABB"><span class="RefLink">50.1-12</span></a>) and <code class="func">AlternatingGroup</code> (<a href="chap50.html#X7E54D3E778E6A53E"><span class="RefLink">50.1-11</span></a>) (see Section <a href="chap50.html#X839981CC7D9B671B"><span class="RefLink">50.1</span></a>) construct symmetric and alternating permutation groups. <strong class="pkg">GAP</strong> can also detect whether a given permutation group is a symmetric or alternating group on the set of its moved points; if so then the group is called a <em>natural</em> symmetric or alternating group, respectively.</p>

<p>The functions <code class="func">IsSymmetricGroup</code> (<a href="chap43.html#X85CA6AD17BE90C95"><span class="RefLink">43.4-2</span></a>) and <code class="func">IsAlternatingGroup</code> (<a href="chap43.html#X8514BE9E79C608E0"><span class="RefLink">43.4-3</span></a>) can be used to check whether a given group (not necessarily a permutation group) is isomorphic to a symmetric or alternating group.</p>

<p><a id="X8129BE59781478E1" name="X8129BE59781478E1"></a></p>

<h5>43.4-1 IsNaturalSymmetricGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsNaturalSymmetricGroup</code>( <var class="Arg">group</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsNaturalAlternatingGroup</code>( <var class="Arg">group</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>A group is a natural symmetric or alternating group if it is a permutation group acting as symmetric or alternating group, respectively, on its moved points.</p>

<p>For groups that are known to be natural symmetric or natural alternating groups, very efficient methods for computing membership, conjugacy classes, Sylow subgroups etc. are used.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=Group((1,5,7,8,99),(1,99,13,72));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsNaturalSymmetricGroup(g);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g;</span>
Sym( [ 1, 5, 7, 8, 13, 72, 99 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsNaturalSymmetricGroup( Group( (1,2)(4,5), (1,2,3)(4,5,6) ) );</span>
false
</pre></div>

<p><a id="X85CA6AD17BE90C95" name="X85CA6AD17BE90C95"></a></p>

<h5>43.4-2 IsSymmetricGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSymmetricGroup</code>( <var class="Arg">group</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>is <code class="keyw">true</code> if the group <var class="Arg">group</var> is isomorphic to a symmetric group.</p>

<p><a id="X8514BE9E79C608E0" name="X8514BE9E79C608E0"></a></p>

<h5>43.4-3 IsAlternatingGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsAlternatingGroup</code>( <var class="Arg">group</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>is <code class="keyw">true</code> if the group <var class="Arg">group</var> is isomorphic to a alternating group.</p>

<p><a id="X7ED60F7E81F1B614" name="X7ED60F7E81F1B614"></a></p>

<h5>43.4-4 SymmetricParentGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SymmetricParentGroup</code>( <var class="Arg">grp</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For a permutation group <var class="Arg">grp</var> this function returns the symmetric group that moves the same points as <var class="Arg">grp</var> does.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SymmetricParentGroup( Group( (1,2), (4,5), (7,8,9) ) );</span>
Sym( [ 1, 2, 4, 5, 7, 8, 9 ] )
</pre></div>

<p><a id="X83F8D3B578A7BEEB" name="X83F8D3B578A7BEEB"></a></p>

<h4>43.5 <span class="Heading">Primitive Groups</span></h4>

<p><a id="X7E50211A7B92455F" name="X7E50211A7B92455F"></a></p>

<h5>43.5-1 ONanScottType</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ONanScottType</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns the type of a primitive permutation group <var class="Arg">G</var>, according to the O'Nan-Scott classification. The labelling of the different types is not consistent in the literature, we use the following identifications. The two-letter code given is the name of the type as used by Praeger.</p>


<dl>
<dt><strong class="Mark">1</strong></dt>
<dd><p>Affine. (HA)</p>

</dd>
<dt><strong class="Mark">2</strong></dt>
<dd><p>Almost simple. (AS)</p>

</dd>
<dt><strong class="Mark">3a</strong></dt>
<dd><p>Diagonal, Socle consists of two normal subgroups. (HS)</p>

</dd>
<dt><strong class="Mark">3b</strong></dt>
<dd><p>Diagonal, Socle is minimal normal. (SD)</p>

</dd>
<dt><strong class="Mark">4a</strong></dt>
<dd><p>Product action with the first factor primitive of type 3a. (HC)</p>

</dd>
<dt><strong class="Mark">4b</strong></dt>
<dd><p>Product action with the first factor primitive of type 3b. (CD)</p>

</dd>
<dt><strong class="Mark">4c</strong></dt>
<dd><p>Product action with the first factor primitive of type 2. (PA)</p>

</dd>
<dt><strong class="Mark">5</strong></dt>
<dd><p>Twisted wreath product (TW)</p>

</dd>
</dl>
<p>See <a href="chapBib.html#biBEickHulpke01">[EH01]</a> for correspondence to other labellings used in the literature. As it can contain letters, the type is returned as a string.</p>

<p>If <var class="Arg">G</var> is not a permutation group or does not act primitively on the points moved by it, the result is undefined.</p>

<p><a id="X7E89A46A86A3F4A2" name="X7E89A46A86A3F4A2"></a></p>

<h5>43.5-2 SocleTypePrimitiveGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SocleTypePrimitiveGroup</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns the socle type of the primitive permutation group <var class="Arg">G</var>. The socle of a primitive group is the direct product of isomorphic simple groups, therefore the type is indicated by a record with components <code class="code">series</code>, <code class="code">parameter</code> (both as described under <code class="func">IsomorphismTypeInfoFiniteSimpleGroup</code> (<a href="chap39.html#X7C6AA6897C4409AC"><span class="RefLink">39.15-12</span></a>)), and <code class="code">width</code> for the number of direct factors.</p>

<p>If <var class="Arg">G</var> does not have a faithful primitive action, the result is undefined.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=AlternatingGroup(5);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h:=DirectProduct(g,g);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p:=List([1,2],i-&gt;Projection(h,i));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ac:=Action(h,AsList(g),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">function(g,h) return Image(p[1],h)^-1*g*Image(p[2],h);end);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(ac);NrMovedPoints(ac);IsPrimitive(ac,[1..60]);</span>
3600
60
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ONanScottType(ac);</span>
"3a"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SocleTypePrimitiveGroup(ac);</span>
rec( 
  name := "A(5) ~ A(1,4) = L(2,4) ~ B(1,4) = O(3,4) ~ C(1,4) = S(2,4) \
~ 2A(1,4) = U(2,4) ~ A(1,5) = L(2,5) ~ B(1,5) = O(3,5) ~ C(1,5) = S(2,\
5) ~ 2A(1,5) = U(2,5)", parameter := 5, series := "A", width := 2 )
</pre></div>

<p><a id="X7FA58C3A8283F3BD" name="X7FA58C3A8283F3BD"></a></p>

<h4>43.6 <span class="Heading">Stabilizer Chains</span></h4>

<p>Many of the algorithms for permutation groups use a <em>stabilizer chain</em> of the group. The concepts of stabilizer chains, <em>bases</em>, and <em>strong generating sets</em> were introduced by Charles Sims in <a href="chapBib.html#biBSim70">[Sim70]</a>. An extensive account of basic algorithms together with asymptotic runtime analysis can be found in reference <a href="chapBib.html#biBSeress2003">[Ser03, Chapter 4]</a>. A further discussion of base change is given in section <a href="chap87.html#X870717BA831A0365"><span class="RefLink">87.1</span></a>.</p>

<p>Let <span class="SimpleMath">B = [ b_1, ..., b_n ]</span> be a list of points, <span class="SimpleMath">G^(1) = G</span> and <span class="SimpleMath">G^{(i+1)} = Stab_{G^(i)}(b_i)</span>, such that <span class="SimpleMath">G^(n+1) = { () }</span>. Then the list <span class="SimpleMath">[ b_1, ..., b_n ]</span> is called a <em>base</em> of <span class="SimpleMath">G</span>, the points <span class="SimpleMath">b_i</span> are called <em>base points</em>. A set <span class="SimpleMath">S</span> of generators for <span class="SimpleMath">G</span> satisfying the condition <span class="SimpleMath">⟨ S ∩ G^(i) ⟩ = G^(i)</span> for each <span class="SimpleMath">1 ≤ i ≤ n</span>, is called a <em>strong generating set</em> (SGS) of <span class="SimpleMath">G</span>. (More precisely we ought to say that it is a SGS of <span class="SimpleMath">G</span> <em>relative</em> to <span class="SimpleMath">B</span>). The chain of subgroups <span class="SimpleMath">G^(i)</span> of <span class="SimpleMath">G</span> itself is called the <em>stabilizer chain</em> of <span class="SimpleMath">G</span> relative to <span class="SimpleMath">B</span>.</p>

<p>Since <span class="SimpleMath">[ b_1, ..., b_n ]</span>, where <span class="SimpleMath">n</span> is the degree of <span class="SimpleMath">G</span> and <span class="SimpleMath">b_i</span> are the moved points of <span class="SimpleMath">G</span>, certainly is a base for <span class="SimpleMath">G</span> there exists a base for each permutation group. The number of points in a base is called the <em>length</em> of the base. A base <span class="SimpleMath">B</span> is called <em>reduced</em> if there exists no <span class="SimpleMath">i</span> such that <span class="SimpleMath">G^(i) = G^(i+1)</span>. (This however does not imply that no subset of <span class="SimpleMath">B</span> could also serve as a base.) Note that different reduced bases for one permutation group <span class="SimpleMath">G</span> may have different lengths. For example, the irreducible degree <span class="SimpleMath">416</span> permutation representation of the Chevalley Group <span class="SimpleMath">G_2(4)</span> possesses reduced bases of lengths <span class="SimpleMath">5</span> and <span class="SimpleMath">7</span>.</p>

<p>Let <span class="SimpleMath">R^(i)</span> be a right transversal of <span class="SimpleMath">G^(i+1)</span> in <span class="SimpleMath">G^(i)</span>, i.e. a set of right coset representatives of the cosets of <span class="SimpleMath">G^(i+1)</span> in <span class="SimpleMath">G^(i)</span>. Then each element <span class="SimpleMath">g</span> of <span class="SimpleMath">G</span> has a unique representation as a product of the form <span class="SimpleMath">g = r_n ... r_1</span> with <span class="SimpleMath">r_i ∈ R^(i)</span>. The cosets of <span class="SimpleMath">G^(i+1)</span> in <span class="SimpleMath">G^(i)</span> are in bijective correspondence with the points in <span class="SimpleMath">O^(i) := b_i^{G^(i)}</span>. So we could represent a transversal as a list <span class="SimpleMath">T</span> such that <span class="SimpleMath">T[p]</span> is a representative of the coset corresponding to the point <span class="SimpleMath">p ∈ O^(i)</span>, i.e., an element of <span class="SimpleMath">G^(i)</span> that takes <span class="SimpleMath">b_i</span> to <span class="SimpleMath">p</span>. (Note that such a list has holes in all positions corresponding to points not contained in <span class="SimpleMath">O^(i)</span>.)</p>

<p>This approach however will store many different permutations as coset representatives which can be a problem if the degree <span class="SimpleMath">n</span> gets bigger. Our goal therefore is to store as few different permutations as possible such that we can still reconstruct each representative in <span class="SimpleMath">R^(i)</span>, and from them the elements in <span class="SimpleMath">G</span>. A <em>factorized inverse transversal</em> <span class="SimpleMath">T</span> is a list where <span class="SimpleMath">T[p]</span> is a generator of <span class="SimpleMath">G^(i)</span> such that <span class="SimpleMath">p^{T[p]}</span> is a point that lies earlier in <span class="SimpleMath">O^(i)</span> than <span class="SimpleMath">p</span> (note that we consider <span class="SimpleMath">O^(i)</span> as a list, not as a set). If we assume inductively that we know an element <span class="SimpleMath">r ∈ G^(i)</span> that takes <span class="SimpleMath">b_i</span> to <span class="SimpleMath">p^{T[p]}</span>, then <span class="SimpleMath">r T[p]^{-1}</span> is an element in <span class="SimpleMath">G^(i)</span> that takes <span class="SimpleMath">b_i</span> to <span class="SimpleMath">p</span>. <strong class="pkg">GAP</strong> uses such factorized inverse transversals.</p>

<p>Another name for a factorized inverse transversal is a <em>Schreier tree</em>. The vertices of the tree are the points in <span class="SimpleMath">O^(i)</span>, and the root of the tree is <span class="SimpleMath">b_i</span>. The edges are defined as the ordered pairs <span class="SimpleMath">(p, p^{T[p]})</span>, for <span class="SimpleMath">p ∈ O^(i) ∖ { b_i }</span>. The edge <span class="SimpleMath">(p, p^{T[p]})</span> is labelled with the generator <span class="SimpleMath">T[p]</span>, and the product of edge labels along the unique path from <span class="SimpleMath">p</span> to <span class="SimpleMath">b_i</span> is the inverse of the transversal element carrying <span class="SimpleMath">b_i</span> to <span class="SimpleMath">p</span>.</p>

<p>Before we describe the construction of stabilizer chains in <a href="chap43.html#X7C7EA55C80E457FA"><span class="RefLink">43.8</span></a>, we explain in <a href="chap43.html#X7C2406B97E057196"><span class="RefLink">43.7</span></a> the idea of using non-deterministic algorithms; this is necessary for understanding the options available for the construction of stabilizer chains. After that, in <a href="chap43.html#X81D7FCE47AC7F942"><span class="RefLink">43.9</span></a> it is explained how a stabilizer chain is stored in <strong class="pkg">GAP</strong>, <a href="chap43.html#X7ECF8A4586346FD4"><span class="RefLink">43.10</span></a> lists operations for stabilizer chains, and <a href="chap43.html#X8188051F79E72A95"><span class="RefLink">43.11</span></a> lists low level routines for manipulating stabilizer chains.</p>

<p><a id="X7C2406B97E057196" name="X7C2406B97E057196"></a></p>

<h4>43.7 <span class="Heading">Randomized Methods for Permutation Groups</span></h4>

<p>For most computations with permutation groups, it is crucial to construct stabilizer chains efficiently. Sims's original construction in <a href="chapBib.html#biBSim70">[Sim70]</a> is deterministic, and is called the Schreier-Sims algorithm, because it is based on Schreier's Lemma (<a href="chapBib.html#biBHall">[HJ59, p. 96]</a>): given <span class="SimpleMath">K = ⟨ S ⟩</span> and a transversal <span class="SimpleMath">T</span> for <span class="SimpleMath">K</span> mod <span class="SimpleMath">L</span>, one can obtain <span class="SimpleMath">|S||T|</span> generators for <span class="SimpleMath">L</span>. This lemma is applied recursively, with consecutive point stabilizers <span class="SimpleMath">G^(i)</span> and <span class="SimpleMath">G^(i+1)</span> playing the role of <span class="SimpleMath">K</span> and <span class="SimpleMath">L</span>.</p>

<p>In permutation groups of large degree, the number of Schreier generators to be processed becomes too large, and the deterministic Schreier-Sims algorithm becomes impractical. Therefore, <strong class="pkg">GAP</strong> uses randomized algorithms. The method selection process, which is quite different from Version 3, works the following way.</p>

<p>If a group acts on not more than a hundred points, Sims's original deterministic algorithm is applied. In groups of degree greater than hundred, a heuristic algorithm based on ideas in <a href="chapBib.html#biBBCFS91">[BCFS91]</a> constructs a stabilizer chain. This construction is complemented by a verify-routine that either proves the correctness of the stabilizer chain or causes the extension of the chain to a correct one. The user can influence the verification process by setting the value of the record component <code class="code">random</code> (cf. <a href="chap43.html#X7C7EA55C80E457FA"><span class="RefLink">43.8</span></a>).</p>

<p>If the <code class="code">random</code> value equals <span class="SimpleMath">1000</span> then a slight extension of an unpublished method of Sims is used. The outcome of this verification process is always correct. The user also can prescribe any integer <span class="SimpleMath">x</span>, <span class="SimpleMath">1 ≤ x ≤ 999</span> as the value of <code class="code">random</code>. In this case, a randomized verification process from <a href="chapBib.html#biBBCFS91">[BCFS91]</a> is applied, and the result of the stabilizer chain construction is guaranteed to be correct with probability at least <span class="SimpleMath">x/1000</span>. The practical performance of the algorithm is much better than the theoretical guarantee.</p>

<p>If the stabilizer chain is not correct then the elements in the product of transversals <span class="SimpleMath">R^(m) R^(m-1) ⋯ R^(1)</span> constitute a proper subset of the group <span class="SimpleMath">G</span> in question. This means that a membership test with this stabilizer chain returns <code class="keyw">false</code> for all elements that are not in <span class="SimpleMath">G</span>, but it may also return <code class="keyw">false</code> for some elements of <span class="SimpleMath">G</span>; in other words, the result <code class="keyw">true</code> of a membership test is always correct, whereas the result <code class="keyw">false</code> may be incorrect.</p>

<p>The construction and verification phases are separated because there are situations where the verification step can be omitted; if one happens to know the order of the group in advance then the randomized construction of the stabilizer chain stops as soon as the product of the lengths of the basic orbits of the chain equals the group order, and the chain will be correct (see the <code class="code">size</code> option of the <code class="func">StabChain</code> (<a href="chap43.html#X80B5CF78829495C2"><span class="RefLink">43.8-1</span></a>) command).</p>

<p>Although the worst case running time is roughly quadratic for Sims's verification and roughly linear for the randomized one, in most examples the running time of the stabilizer chain construction with <code class="code">random</code> value <span class="SimpleMath">1000</span> (i.e., guaranteed correct output) is about the same as the running time of randomized verification with guarantee of at least <span class="SimpleMath">90</span> percent correctness. Therefore, we suggest to use the default value <code class="code">random</code> <span class="SimpleMath">= 1000</span>. Possible uses of <code class="code">random</code> values less than <span class="SimpleMath">1000</span> are when one has to run through a large collection of subgroups, and a low value of random is used to choose quickly a candidate for more thorough examination; another use is when the user suspects that the quadratic bottleneck of the guaranteed correct verification is hit.</p>

<p>We will give two examples to illustrate these ideas.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h:= SL(4,7);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">o:= Orbit( h, [1,0,0,0]*Z(7)^0, OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">op:= Action( h, o, OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrMovedPoints( op );</span>
400
</pre></div>

<p>We created a permutation group on <span class="SimpleMath">400</span> points. First we compute a guaranteed correct stabilizer chain (see <code class="func">StabChain</code> (<a href="chap43.html#X80B5CF78829495C2"><span class="RefLink">43.8-1</span></a>)).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h:= Group( GeneratorsOfGroup( op ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StabChain( h );;  time;</span>
1120
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( h );</span>
2317591180800
</pre></div>

<p>Now randomized verification will be used. We require that the result is guaranteed correct with probability <span class="SimpleMath">90</span> percent. This means that if we would do this calculation many times over, <strong class="pkg">GAP</strong> would <em>guarantee</em> that in least <span class="SimpleMath">90</span> percent of all calculations the result is correct. In fact the results are much better than the guarantee, but we cannot promise that this will really happen. (For the meaning of the <code class="code">random</code> component in the second argument of <code class="func">StabChain</code> (<a href="chap43.html#X80B5CF78829495C2"><span class="RefLink">43.8-1</span></a>).)</p>

<p>First the group is created anew.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h:= Group( GeneratorsOfGroup( op ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StabChain( h, rec( random:= 900 ) );;  time;</span>
1410
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( h );</span>
2317591180800
</pre></div>

<p>The result is still correct, and the running time is actually somewhat slower. If you give the algorithm additional information so that it can check its results, things become faster and the result is guaranteed to be correct.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h:=Group( GeneratorsOfGroup( op ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetSize( h, 2317591180800 );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StabChain( h );;  time;</span>
170
</pre></div>

<p>The second example gives a typical group when the verification with <code class="code">random</code> value <span class="SimpleMath">1000</span> is slow. The problem is that the group has a stabilizer subgroup <span class="SimpleMath">G^(i)</span> such that the fundamental orbit <span class="SimpleMath">O^(i)</span> is split into a lot of orbits when we stabilize <span class="SimpleMath">b_i</span> and one additional point of <span class="SimpleMath">O^(i)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p1:=PermList(Concatenation([401],[1..400]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p2:=PermList(List([1..400],i-&gt;(i*20 mod 401)));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d:=DirectProduct(Group(p1,p2),SymmetricGroup(5));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h:=Group(GeneratorsOfGroup(d));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StabChain(h);;time;Size(h);</span>
1030
192480
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h:=Group(GeneratorsOfGroup(d));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StabChain(h,rec(random:=900));;time;Size(h);</span>
570
192480
</pre></div>

<p>When stabilizer chains of a group <span class="SimpleMath">G</span> are created with <code class="code">random</code> value less than <span class="SimpleMath">1000</span>, this is noted in the group <span class="SimpleMath">G</span>, by setting of the record component <code class="code">random</code> in the value of the attribute <code class="func">StabChainOptions</code> (<a href="chap43.html#X790C27B8783EDE68"><span class="RefLink">43.8-2</span></a>) for <span class="SimpleMath">G</span>. As errors induced by the random methods might propagate, any group or homomorphism created from <span class="SimpleMath">G</span> inherits a <code class="code">random</code> component in its <code class="func">StabChainOptions</code> (<a href="chap43.html#X790C27B8783EDE68"><span class="RefLink">43.8-2</span></a>) value from the corresponding component for <span class="SimpleMath">G</span>.</p>

<p>A lot of algorithms dealing with permutation groups use randomized methods; however, if the initial stabilizer chain construction for a group is correct, these further methods will provide guaranteed correct output.</p>

<p><a id="X7C7EA55C80E457FA" name="X7C7EA55C80E457FA"></a></p>

<h4>43.8 <span class="Heading">Construction of Stabilizer Chains</span></h4>

<p><a id="X80B5CF78829495C2" name="X80B5CF78829495C2"></a></p>

<h5>43.8-1 StabChain</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StabChain</code>( <var class="Arg">G</var>[, <var class="Arg">options</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StabChain</code>( <var class="Arg">G</var>, <var class="Arg">base</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StabChainOp</code>( <var class="Arg">G</var>, <var class="Arg">options</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StabChainMutable</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StabChainMutable</code>( <var class="Arg">permhomom</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StabChainImmutable</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>These commands compute a stabilizer chain for the permutation group <var class="Arg">G</var>; additionally, <code class="func">StabChainMutable</code> is also an attribute for the group homomorphism <var class="Arg">permhomom</var> whose source is a permutation group.</p>

<p>(The mathematical background of stabilizer chains is sketched in <a href="chap43.html#X7FA58C3A8283F3BD"><span class="RefLink">43.6</span></a>, more information about the objects representing stabilizer chains in <strong class="pkg">GAP</strong> can be found in <a href="chap43.html#X81D7FCE47AC7F942"><span class="RefLink">43.9</span></a>.)</p>

<p><code class="func">StabChainOp</code> is an operation with two arguments <var class="Arg">G</var> and <var class="Arg">options</var>, the latter being a record which controls some aspects of the computation of a stabilizer chain (see below); <code class="func">StabChainOp</code> returns a <em>mutable</em> stabilizer chain. <code class="func">StabChainMutable</code> is a <em>mutable</em> attribute for groups or homomorphisms, its default method for groups is to call <code class="func">StabChainOp</code> with empty options record. <code class="func">StabChainImmutable</code> is an attribute with <em>immutable</em> values; its default method dispatches to <code class="func">StabChainMutable</code>.</p>

<p><code class="func">StabChain</code> is a function with first argument a permutation group <var class="Arg">G</var>, and optionally a record <var class="Arg">options</var> as second argument. If the value of <code class="func">StabChainImmutable</code> for <var class="Arg">G</var> is already known and if this stabilizer chain matches the requirements of <var class="Arg">options</var>, <code class="func">StabChain</code> simply returns this stored stabilizer chain. Otherwise <code class="func">StabChain</code> calls <code class="func">StabChainOp</code> and returns an immutable copy of the result; additionally, this chain is stored as <code class="func">StabChainImmutable</code> value for <var class="Arg">G</var>. If no <var class="Arg">options</var> argument is given, its components default to the global variable <code class="func">DefaultStabChainOptions</code> (<a href="chap43.html#X87E1292E85A5D31C"><span class="RefLink">43.8-3</span></a>). If <var class="Arg">base</var> is a list of positive integers, the version <code class="code">StabChain( <var class="Arg">G</var>, <var class="Arg">base</var> )</code> defaults to <code class="code">StabChain( <var class="Arg">G</var>, rec( base:= <var class="Arg">base</var> ) )</code>.</p>

<p>If given, <var class="Arg">options</var> is a record whose components specify properties of the desired stabilizer chain or which may help the algorithm. Default values for all of them can be given in the global variable <code class="func">DefaultStabChainOptions</code> (<a href="chap43.html#X87E1292E85A5D31C"><span class="RefLink">43.8-3</span></a>). The following options are supported.</p>


<dl>
<dt><strong class="Mark"><code class="code">base</code> (default an empty list)</strong></dt>
<dd><p>A list of points, through which the resulting stabilizer chain shall run. For the base <span class="SimpleMath">B</span> of the resulting stabilizer chain <var class="Arg">S</var> this means the following. If the <code class="code">reduced</code> component of <var class="Arg">options</var> is <code class="keyw">true</code> then those points of <code class="code">base</code> with nontrivial basic orbits form the initial segment of <span class="SimpleMath">B</span>, if the <code class="code">reduced</code> component is <code class="keyw">false</code> then <code class="code">base</code> itself is the initial segment of <span class="SimpleMath">B</span>. Repeated occurrences of points in <code class="code">base</code> are ignored. If a stabilizer chain for <var class="Arg">G</var> is already known then the stabilizer chain is computed via a base change.</p>

</dd>
<dt><strong class="Mark"><code class="code">knownBase</code> (no default value)</strong></dt>
<dd><p>A list of points which is known to be a base for the group. Such a known base makes it easier to test whether a permutation given as a word in terms of a set of generators is the identity, since it suffices to map the known base with each factor consecutively, rather than multiplying the whole permutations (which would mean to map every point). This speeds up the Schreier-Sims algorithm which is used when a new stabilizer chain is constructed; it will not affect a base change, however. The component <code class="code">knownBase</code> bears no relation to the <code class="code">base</code> component, you may specify a known base <code class="code">knownBase</code> and a desired base <code class="code">base</code> independently.</p>

</dd>
<dt><strong class="Mark"><code class="code">reduced</code> (default <code class="keyw">true</code>)</strong></dt>
<dd><p>If this is <code class="keyw">true</code> the resulting stabilizer chain <var class="Arg">S</var> is reduced, i.e., the case <span class="SimpleMath">G^(i) = G^(i+1)</span> does not occur. Setting <code class="code">reduced</code> to <code class="keyw">false</code> makes sense only if the component <code class="code">base</code> (see above) is also set; in this case all points of <code class="code">base</code> will occur in the base <span class="SimpleMath">B</span> of <var class="Arg">S</var>, even if they have trivial basic orbits. Note that if <code class="code">base</code> is just an initial segment of <span class="SimpleMath">B</span>, the basic orbits of the points in <span class="SimpleMath">B ∖</span><code class="code">base</code> are always nontrivial.</p>

</dd>
<dt><strong class="Mark"><code class="code">tryPcgs</code> (default <code class="keyw">true</code>)</strong></dt>
<dd><p>If this is <code class="keyw">true</code> and either the degree is at most <span class="SimpleMath">100</span> or the group is known to be solvable, <strong class="pkg">GAP</strong> will first try to construct a pcgs (see Chapter <a href="chap45.html#X86007B0083F60470"><span class="RefLink">45</span></a>) for <var class="Arg">G</var> which will succeed and implicitly construct a stabilizer chain if <var class="Arg">G</var> is solvable. If <var class="Arg">G</var> turns out non-solvable, one of the other methods will be used. This solvability check is comparatively fast, even if it fails, and it can save a lot of time if <var class="Arg">G</var> is solvable.</p>

</dd>
<dt><strong class="Mark"><code class="code">random</code> (default <code class="code">1000</code>)</strong></dt>
<dd><p>If the value is less than <span class="SimpleMath">1000</span>, the resulting chain is correct with probability at least <code class="code">random</code><span class="SimpleMath">/ 1000</span>. The <code class="code">random</code> option is explained in more detail in <a href="chap43.html#X7C2406B97E057196"><span class="RefLink">43.7</span></a>.</p>

</dd>
<dt><strong class="Mark"><code class="code">size</code> (default <code class="code">Size(<var class="Arg">G</var>)</code> if this is known,
        i.e., if <code class="code">HasSize(<var class="Arg">G</var>)</code> is <code class="keyw">true</code>)</strong></dt>
<dd><p>If this component is present, its value is assumed to be the order of the group <var class="Arg">G</var>. This information can be used to prove that a non-deterministically constructed stabilizer chain is correct. In this case, <strong class="pkg">GAP</strong> does a non-deterministic construction until the size is correct.</p>

</dd>
<dt><strong class="Mark"><code class="code">limit</code> (default <code class="code">Size(Parent(<var class="Arg">G</var>))</code> or
         <code class="code">StabChainOptions(Parent(<var class="Arg">G</var>)).limit</code>
         if it is present)</strong></dt>
<dd><p>If this component is present, it must be greater than or equal to the order of <var class="Arg">G</var>. The stabilizer chain construction stops if size <code class="code">limit</code> is reached.</p>

</dd>
</dl>
<p><a id="X790C27B8783EDE68" name="X790C27B8783EDE68"></a></p>

<h5>43.8-2 StabChainOptions</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StabChainOptions</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>is a record that stores the options with which the stabilizer chain stored in <code class="func">StabChainImmutable</code> (<a href="chap43.html#X80B5CF78829495C2"><span class="RefLink">43.8-1</span></a>) has been computed (see <code class="func">StabChain</code> (<a href="chap43.html#X80B5CF78829495C2"><span class="RefLink">43.8-1</span></a>) for the options that are supported).</p>

<p><a id="X87E1292E85A5D31C" name="X87E1292E85A5D31C"></a></p>

<h5>43.8-3 DefaultStabChainOptions</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DefaultStabChainOptions</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>are the options for <code class="func">StabChain</code> (<a href="chap43.html#X80B5CF78829495C2"><span class="RefLink">43.8-1</span></a>) which are set as default.</p>

<p><a id="X86D64D2B81D58431" name="X86D64D2B81D58431"></a></p>

<h5>43.8-4 StabChainBaseStrongGenerators</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StabChainBaseStrongGenerators</code>( <var class="Arg">base</var>, <var class="Arg">sgs</var>, <var class="Arg">one</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">base</var> be a base for a permutation group <span class="SimpleMath">G</span>, and let <var class="Arg">sgs</var> be a strong generating set for <span class="SimpleMath">G</span> with respect to <var class="Arg">base</var>; <var class="Arg">one</var> must be the appropriate identity element of <span class="SimpleMath">G</span> (see <code class="func">One</code> (<a href="chap31.html#X8046262384895B2A"><span class="RefLink">31.10-2</span></a>), in most cases this will be <code class="code">()</code>). This function constructs a stabilizer chain without the need to find Schreier generators; so this is much faster than the other algorithms.</p>

<p><a id="X7BEC5F5A7851CAAB" name="X7BEC5F5A7851CAAB"></a></p>

<h5>43.8-5 MinimalStabChain</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MinimalStabChain</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns the reduced stabilizer chain corresponding to the base <span class="SimpleMath">[ 1, 2, 3, 4, ... ]</span>.</p>

<p><a id="X81D7FCE47AC7F942" name="X81D7FCE47AC7F942"></a></p>

<h4>43.9 <span class="Heading">Stabilizer Chain Records</span></h4>

<p>If a permutation group has a stabilizer chain, this is stored as a recursive structure. This structure is itself a record <var class="Arg">S</var> and it has</p>


<dl>
<dt><strong class="Mark">(1)</strong></dt>
<dd><p>components that provide information about one level <span class="SimpleMath">G^(i)</span> of the stabilizer chain (which we call the "current stabilizer") and</p>

</dd>
<dt><strong class="Mark">(2)</strong></dt>
<dd><p>a component <code class="code">stabilizer</code> that holds another such record, namely the stabilizer chain of the next stabilizer <span class="SimpleMath">G^(i+1)</span>.</p>

</dd>
</dl>
<p>This gives a recursive structure where the "outermost" record representing the "topmost" stabilizer is bound to the group record component <code class="code">stabChain</code> and has the components explained below. Note: Since the structure is recursive, <em>never print a stabilizer chain!</em> (Unless you want to exercise the scrolling capabilities of your terminal.)</p>


<dl>
<dt><strong class="Mark"><code class="code">identity</code> </strong></dt>
<dd><p>the identity element of the current stabilizer.</p>

</dd>
<dt><strong class="Mark"><code class="code">labels</code> </strong></dt>
<dd><p>a list of permutations which contains labels for the Schreier tree of the current stabilizer, i.e., it contains elements for the factorized inverse transversal. The first entry in this list is always the <code class="code">identity</code>. Note that <strong class="pkg">GAP</strong> tries to arrange things so that the <code class="code">labels</code> components are identical (i.e., the same <strong class="pkg">GAP</strong> object) in every stabilizer of the chain; thus the <code class="code">labels</code> of a stabilizer do not necessarily all lie in the this stabilizer (but see <code class="code">genlabels</code> below).</p>

</dd>
<dt><strong class="Mark"><code class="code">genlabels</code> </strong></dt>
<dd><p>a list of integers indexing some of the permutations in the <code class="code">labels</code> component. The <code class="code">labels</code> addressed in this way form a generating set for the current stabilizer. If the <code class="code">genlabels</code> component is empty, the rest of the stabilizer chain represents the trivial subgroup, and can be ignored, e.g., when calculating the size.</p>

</dd>
<dt><strong class="Mark"><code class="code">generators</code> </strong></dt>
<dd><p>a list of generators for the current stabilizer. Usually, it is <code class="code">labels{ genlabels }</code>.</p>

</dd>
<dt><strong class="Mark"><code class="code">orbit</code> </strong></dt>
<dd><p>the vertices of the Schreier tree, which form the basic orbit <span class="SimpleMath">b_i^{G^(i)}</span>, ordered in such a way that the base point <span class="SimpleMath">b_i</span> is in the first position in the orbit.</p>

</dd>
<dt><strong class="Mark"><code class="code">transversal</code></strong></dt>
<dd><p>The factorized inverse transversal found during the orbit algorithm. The element <span class="SimpleMath">g</span> stored at <code class="code">transversal</code><span class="SimpleMath">[i]</span> will map <span class="SimpleMath">i</span> to another point <span class="SimpleMath">j</span> that in the Schreier tree is closer to the base point. By iterated application (<code class="code">transversal</code><span class="SimpleMath">[j]</span> and so on) eventually the base point is reached and an element that maps <span class="SimpleMath">i</span> to the base point found as product.</p>

</dd>
<dt><strong class="Mark"><code class="code">translabels</code></strong></dt>
<dd><p>An index list such that <code class="code">transversal</code><span class="SimpleMath">[j] =</span> <code class="code">labels</code><span class="SimpleMath">[</span> <code class="code">translabels</code><span class="SimpleMath">[j] ]</span>. This list takes up comparatively little memory and is used to speed up base changes.</p>

</dd>
<dt><strong class="Mark"><code class="code">stabilizer</code> </strong></dt>
<dd><p>If the current stabilizer is not yet the trivial group, the stabilizer chain continues with the stabilizer of the current base point, which is again represented as a record with components <code class="code">labels</code>, <code class="code">identity</code>, <code class="code">genlabels</code>, <code class="code">generators</code>, <code class="code">orbit</code>, <code class="code">translabels</code>, <code class="code">transversal</code> (and perhaps <code class="code">stabilizer</code>). This record is bound to the <code class="code">stabilizer</code> component of the current stabilizer. The last member of a stabilizer chain is recognized by the fact that it has no <code class="code">stabilizer</code> component bound.</p>

</dd>
</dl>
<p>It is possible that different stabilizer chains share the same record as one of their iterated <code class="code">stabilizer</code> components.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=Group((1,2,3,4),(1,2));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StabChain(g);</span>
&lt;stabilizer chain record, Base [ 1, 2, 3 ], Orbit length 4, Size: 24&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BaseOfGroup(g);</span>
[ 1, 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StabChainOptions(g);</span>
rec( random := 1000 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DefaultStabChainOptions;</span>
rec( random := 1000, reduced := true, tryPcgs := true )
</pre></div>

<p><a id="X7ECF8A4586346FD4" name="X7ECF8A4586346FD4"></a></p>

<h4>43.10 <span class="Heading">Operations for Stabilizer Chains</span></h4>

<p><a id="X7FBE6EB57EBE8B7D" name="X7FBE6EB57EBE8B7D"></a></p>

<h5>43.10-1 BaseStabChain</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BaseStabChain</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns the base belonging to the stabilizer chain <var class="Arg">S</var>.</p>

<p><a id="X7D2A190D8308ED39" name="X7D2A190D8308ED39"></a></p>

<h5>43.10-2 BaseOfGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BaseOfGroup</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns a base of the permutation group <var class="Arg">G</var>. There is <em>no</em> guarantee that a stabilizer chain stored in <var class="Arg">G</var> corresponds to this base!</p>

<p><a id="X7EF36DC78465026A" name="X7EF36DC78465026A"></a></p>

<h5>43.10-3 SizeStabChain</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SizeStabChain</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns the product of the orbit lengths in the stabilizer chain <var class="Arg">S</var>, that is, the order of the group described by <var class="Arg">S</var>.</p>

<p><a id="X8384170881B9B531" name="X8384170881B9B531"></a></p>

<h5>43.10-4 StrongGeneratorsStabChain</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StrongGeneratorsStabChain</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns a strong generating set corresponding to the stabilizer chain <var class="Arg">S</var>.</p>

<p><a id="X87F473777EFDE867" name="X87F473777EFDE867"></a></p>

<h5>43.10-5 GroupStabChain</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GroupStabChain</code>( [<var class="Arg">G</var>, ]<var class="Arg">S</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>constructs a permutation group with stabilizer chain <var class="Arg">S</var>, i.e., a group with generators <code class="code">Generators( <var class="Arg">S</var> )</code> to which <var class="Arg">S</var> is assigned as component <code class="code">stabChain</code>. If the optional argument <var class="Arg">G</var> is given, the result will have the parent <var class="Arg">G</var>.</p>

<p><a id="X87FB6DED80692D3F" name="X87FB6DED80692D3F"></a></p>

<h5>43.10-6 OrbitStabChain</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OrbitStabChain</code>( <var class="Arg">S</var>, <var class="Arg">pnt</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns the orbit of <var class="Arg">pnt</var> under the group described by the stabilizer chain <var class="Arg">S</var>.</p>

<p><a id="X7AC8F165875906DE" name="X7AC8F165875906DE"></a></p>

<h5>43.10-7 IndicesStabChain</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IndicesStabChain</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns a list of the indices of the stabilizers in the stabilizer chain <var class="Arg">S</var>.</p>

<p><a id="X7CF607BC82C2C202" name="X7CF607BC82C2C202"></a></p>

<h5>43.10-8 ListStabChain</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ListStabChain</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns a list that contains at position <span class="SimpleMath">i</span> the stabilizer of the first <span class="SimpleMath">i-1</span> base points in the stabilizer chain <var class="Arg">S</var>.</p>

<p><a id="X7F40E52D7B0438BF" name="X7F40E52D7B0438BF"></a></p>

<h5>43.10-9 ElementsStabChain</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementsStabChain</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns a list of all elements of the group described by the stabilizer chain <var class="Arg">S</var>.</p>

<p><a id="X780875477CD2A57D" name="X780875477CD2A57D"></a></p>

<h5>43.10-10 IteratorStabChain</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IteratorStabChain</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns an iterator for the elments of the group described by the stabilizer chain <var class="Arg">S</var>. The elements of the group <var class="Arg">G</var> are produced by iterating through all base images in turn, and in the ordering induced by the base. For more details see <a href="chap43.html#X7FA58C3A8283F3BD"><span class="RefLink">43.6</span></a></p>

<p><a id="X861062AE87ACF340" name="X861062AE87ACF340"></a></p>

<h5>43.10-11 InverseRepresentative</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InverseRepresentative</code>( <var class="Arg">S</var>, <var class="Arg">pnt</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>calculates the transversal element which maps <var class="Arg">pnt</var> back to the base point of <var class="Arg">S</var>. It just runs back through the Schreier tree from <var class="Arg">pnt</var> to the root and multiplies the labels along the way.</p>

<p><a id="X79D2248C8787EAF2" name="X79D2248C8787EAF2"></a></p>

<h5>43.10-12 SiftedPermutation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SiftedPermutation</code>( <var class="Arg">S</var>, <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>sifts the permutation <var class="Arg">g</var> through the stabilizer chain <var class="Arg">S</var> and returns the result after the last step.</p>

<p>The element <var class="Arg">g</var> is sifted as follows: <var class="Arg">g</var> is replaced by <code class="code"><var class="Arg">g</var> * InverseRepresentative( <var class="Arg">S</var>, <var class="Arg">S</var>.orbit[1]^<var class="Arg">g</var> )</code>, then <var class="Arg">S</var> is replaced by <code class="code"><var class="Arg">S</var>.stabilizer</code> and this process is repeated until <var class="Arg">S</var> is trivial or <code class="code"><var class="Arg">S</var>.orbit[1]^<var class="Arg">g</var></code> is not in the basic orbit <code class="code"><var class="Arg">S</var>.orbit</code>. The remainder <var class="Arg">g</var> is returned, it is the identity permutation if and only if the original <var class="Arg">g</var> is in the group <span class="SimpleMath">G</span> described by the original <var class="Arg">S</var>.</p>

<p><a id="X7B870C217D0B9997" name="X7B870C217D0B9997"></a></p>

<h5>43.10-13 MinimalElementCosetStabChain</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MinimalElementCosetStabChain</code>( <var class="Arg">S</var>, <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Let <span class="SimpleMath">G</span> be the group described by the stabilizer chain <var class="Arg">S</var>. This function returns a permutation <span class="SimpleMath">h</span> such that <span class="SimpleMath">G <var class="Arg">g</var> = G h</span> (that is, <span class="SimpleMath"><var class="Arg">g</var> / h ∈ G</span>) and with the additional property that the list of images under <span class="SimpleMath">h</span> of the base belonging to <var class="Arg">S</var> is minimal w.r.t. lexicographical ordering.</p>

<p><a id="X87435B7884D9B353" name="X87435B7884D9B353"></a></p>

<h5>43.10-14 LargestElementStabChain</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LargestElementStabChain</code>( <var class="Arg">S</var>, <var class="Arg">id</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Let <span class="SimpleMath">G</span> be the group described by the stabilizer chain <var class="Arg">S</var>. This function returns the element <span class="SimpleMath">h ∈ G</span> with the property that the list of images under <span class="SimpleMath">h</span> of the base belonging to <var class="Arg">S</var> is maximal w.r.t. lexicographical ordering. The second argument must be an identity element (used to start the recursion).</p>

<p><a id="X809B2C3B7C5F77AB" name="X809B2C3B7C5F77AB"></a></p>

<h5>43.10-15 ApproximateSuborbitsStabilizerPermGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ApproximateSuborbitsStabilizerPermGroup</code>( <var class="Arg">G</var>, <var class="Arg">pnt</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns an approximation of the orbits of <code class="code">Stabilizer( <var class="Arg">G</var>, <var class="Arg">pnt</var> )</code> on all points of the orbit <code class="code">Orbit( <var class="Arg">G</var>, <var class="Arg">pnt</var> )</code>, without computing the full point stabilizer; As not all Schreier generators are used, the result may represent the orbits of only a subgroup of the point stabilizer.</p>

<p><a id="X8188051F79E72A95" name="X8188051F79E72A95"></a></p>

<h4>43.11 <span class="Heading">Low Level Routines to Modify and Create Stabilizer Chains</span></h4>

<p>These operations modify a stabilizer chain or obtain new chains with specific properties. They are rather technical and should only be used if such low-level routines are deliberately required. (For all functions in this section the parameter <var class="Arg">S</var> is a stabilizer chain.)</p>

<p><a id="X86B31E6A81AE5FCB" name="X86B31E6A81AE5FCB"></a></p>

<h5>43.11-1 CopyStabChain</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CopyStabChain</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function returns a mutable copy of the stabilizer chain <var class="Arg">S</var> that has no mutable object (list or record) in common with <var class="Arg">S</var>. The <code class="code">labels</code> components of the result are possibly shared by several levels, but superfluous labels are removed. (An entry in <code class="code">labels</code> is superfluous if it does not occur among the <code class="code">genlabels</code> or <code class="code">translabels</code> on any of the levels which share that <code class="code">labels</code> component.)</p>

<p>This is useful for stabiliser sub-chains that have been obtained as the (iterated) <code class="code">stabilizer</code> component of a bigger chain.</p>

<p><a id="X7E167E557B567C6A" name="X7E167E557B567C6A"></a></p>

<h5>43.11-2 CopyOptionsDefaults</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CopyOptionsDefaults</code>( <var class="Arg">G</var>, <var class="Arg">options</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>sets components in a stabilizer chain options record <var class="Arg">options</var> according to what is known about the group <var class="Arg">G</var>. This can be used to obtain a new stabilizer chain for <var class="Arg">G</var> quickly.</p>

<p><a id="X87FF64AB87BFC779" name="X87FF64AB87BFC779"></a></p>

<h5>43.11-3 ChangeStabChain</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ChangeStabChain</code>( <var class="Arg">S</var>, <var class="Arg">base</var>[, <var class="Arg">reduced</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>changes or reduces a stabilizer chain <var class="Arg">S</var> to be adapted to the base <var class="Arg">base</var>. The optional argument <var class="Arg">reduced</var> is interpreted as follows.</p>


<dl>
<dt><strong class="Mark"><code class="code">reduced = </code><code class="keyw">false</code> : </strong></dt>
<dd><p>change the stabilizer chain, do not reduce it,</p>

</dd>
<dt><strong class="Mark"><code class="code">reduced = </code><code class="keyw">true</code> : </strong></dt>
<dd><p>change the stabilizer chain, reduce it.</p>

</dd>
</dl>
<p><a id="X8778B4657D3FD97B" name="X8778B4657D3FD97B"></a></p>

<h5>43.11-4 ExtendStabChain</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExtendStabChain</code>( <var class="Arg">S</var>, <var class="Arg">base</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>extends the stabilizer chain <var class="Arg">S</var> so that it corresponds to base <var class="Arg">base</var>. The original base of <var class="Arg">S</var> must be a subset of <var class="Arg">base</var>.</p>

<p><a id="X7E5E9F727D0B19D9" name="X7E5E9F727D0B19D9"></a></p>

<h5>43.11-5 ReduceStabChain</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ReduceStabChain</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>changes the stabilizer chain <var class="Arg">S</var> to a reduced stabilizer chain by eliminating trivial steps.</p>

<p><a id="X85BF290D848C4091" name="X85BF290D848C4091"></a></p>

<h5>43.11-6 RemoveStabChain</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RemoveStabChain</code>( <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><var class="Arg">S</var> must be a stabilizer record in a stabilizer chain. This chain then is cut off at <var class="Arg">S</var> by changing the entries in <var class="Arg">S</var>. This can be used to remove trailing trivial steps.</p>

<p><a id="X84E4906B86E5C089" name="X84E4906B86E5C089"></a></p>

<h5>43.11-7 EmptyStabChain</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EmptyStabChain</code>( <var class="Arg">labels</var>, <var class="Arg">id</var>[, <var class="Arg">pnt</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>constructs a stabilizer chain for the trivial group with <code class="code">identity</code> value equal to<var class="Arg">id</var> and <code class="code">labels = </code><span class="SimpleMath">{ <var class="Arg">id</var> } ∪</span> <var class="Arg">labels</var> (but of course with <code class="code">genlabels</code> and <code class="code">generators</code> values an empty list). If the optional third argument <var class="Arg">pnt</var> is present, the only stabilizer of the chain is initialized with the one-point basic orbit <code class="code">[ <var class="Arg">pnt</var> ]</code> and with <code class="code">translabels</code> and <code class="code">transversal</code> components.</p>

<p><a id="X80C7D2E87E6EE357" name="X80C7D2E87E6EE357"></a></p>

<h5>43.11-8 InsertTrivialStabilizer</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InsertTrivialStabilizer</code>( <var class="Arg">S</var>, <var class="Arg">pnt</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="func">InsertTrivialStabilizer</code> initializes the current stabilizer with <var class="Arg">pnt</var> as <code class="func">EmptyStabChain</code> (<a href="chap43.html#X84E4906B86E5C089"><span class="RefLink">43.11-7</span></a>) did, but assigns the original <var class="Arg">S</var> to the new <code class="code"><var class="Arg">S</var>.stabilizer</code> component, such that a new level with trivial basic orbit (but identical <code class="code">labels</code> and <code class="code">ShallowCopy</code>ed <code class="code">genlabels</code> and <code class="code">generators</code>) is inserted. This function should be used only if <var class="Arg">pnt</var> really is fixed by the generators of <var class="Arg">S</var>, because then new generators can be added and the orbit and transversal at the same time extended with <code class="func">AddGeneratorsExtendSchreierTree</code> (<a href="chap43.html#X8373007880EBF736"><span class="RefLink">43.11-10</span></a>).</p>

<p><a id="X7B47B379824F6150" name="X7B47B379824F6150"></a></p>

<h5>43.11-9 IsFixedStabilizer</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFixedStabilizer</code>( <var class="Arg">S</var>, <var class="Arg">pnt</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns <code class="keyw">true</code> if <var class="Arg">pnt</var> is fixed by all generators of <var class="Arg">S</var> and <code class="keyw">false</code> otherwise.</p>

<p><a id="X8373007880EBF736" name="X8373007880EBF736"></a></p>

<h5>43.11-10 AddGeneratorsExtendSchreierTree</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AddGeneratorsExtendSchreierTree</code>( <var class="Arg">S</var>, <var class="Arg">new</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>adds the elements in <var class="Arg">new</var> to the list of generators of <var class="Arg">S</var> and at the same time extends the orbit and transversal. This is the only legal way to extend a Schreier tree (because this involves careful handling of the tree components).</p>

<p><a id="X86C78160854C7F30" name="X86C78160854C7F30"></a></p>

<h4>43.12 <span class="Heading">Backtrack</span></h4>

<p>A main use for stabilizer chains is in backtrack algorithms for permutation groups. <strong class="pkg">GAP</strong> implements a partition-backtrack algorithm as described in <a href="chapBib.html#biBLeon91">[Leo91]</a> and refined in <a href="chapBib.html#biBTheissen97">[The97]</a>.</p>

<p><a id="X7BE3F03C80BF8B08" name="X7BE3F03C80BF8B08"></a></p>

<h5>43.12-1 SubgroupProperty</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SubgroupProperty</code>( <var class="Arg">G</var>, <var class="Arg">Pr</var>[, <var class="Arg">L</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><var class="Arg">Pr</var> must be a one-argument function that returns <code class="keyw">true</code> or <code class="keyw">false</code> for elements of the group <var class="Arg">G</var>, and the subset of elements of <var class="Arg">G</var> that fulfill <var class="Arg">Pr</var> must be a subgroup. (<em>If the latter is not true the result of this operation is unpredictable!</em>) This command computes this subgroup. The optional argument <var class="Arg">L</var> must be a subgroup of the set of all elements in <var class="Arg">G</var> fulfilling <var class="Arg">Pr</var> and can be given if known in order to speed up the calculation.</p>

<p><a id="X7EE7DDCC87C4BC31" name="X7EE7DDCC87C4BC31"></a></p>

<h5>43.12-2 ElementProperty</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementProperty</code>( <var class="Arg">G</var>, <var class="Arg">Pr</var>[, <var class="Arg">L</var>[, <var class="Arg">R</var>]] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="func">ElementProperty</code> returns an element <span class="SimpleMath">π</span> of the permutation group <var class="Arg">G</var> such that the one-argument function <var class="Arg">Pr</var> returns <code class="keyw">true</code> for <span class="SimpleMath">π</span>. It returns <code class="keyw">fail</code> if no such element exists in <var class="Arg">G</var>. The optional arguments <var class="Arg">L</var> and <var class="Arg">R</var> are subgroups of <var class="Arg">G</var> such that the property <var class="Arg">Pr</var> has the same value for all elements in the cosets <var class="Arg">L</var> <span class="SimpleMath">g</span> and <span class="SimpleMath">g</span> <var class="Arg">R</var>, respectively, with <span class="SimpleMath">g ∈ <var class="Arg">G</var></span>.</p>

<p>A typical example of using the optional subgroups <var class="Arg">L</var> and <var class="Arg">R</var> is the conjugacy test for elements <span class="SimpleMath">a</span> and <span class="SimpleMath">b</span> for which one can set <var class="Arg">L</var><span class="SimpleMath">:= C_<var class="Arg">G</var>(a)</span> and <var class="Arg">R</var><span class="SimpleMath">:= C_<var class="Arg">G</var>(b)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">propfun:= el -&gt; (1,2,3)^el in [ (1,2,3), (1,3,2) ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubgroupProperty( g, propfun, Subgroup( g, [ (1,2,3) ] ) );</span>
Group([ (1,2,3), (2,3) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ElementProperty( g, el -&gt; Order( el ) = 2 );</span>
(2,4)
</pre></div>

<p>Chapter <a href="chap42.html#X80F808307A2D5AB8"><span class="RefLink">42</span></a> describes special operations to construct permutations in the symmetric group without using backtrack constructions.</p>

<p>Backtrack routines are also called by the methods for permutation groups that compute centralizers, normalizers, intersections, conjugating elements as well as stabilizers for the operations of a permutation group via <code class="func">OnPoints</code> (<a href="chap41.html#X7FE417DD837987B4"><span class="RefLink">41.2-1</span></a>), <code class="func">OnSets</code> (<a href="chap41.html#X85AA04347CD117F9"><span class="RefLink">41.2-4</span></a>), <code class="func">OnTuples</code> (<a href="chap41.html#X832CC5F87EEA4A7E"><span class="RefLink">41.2-5</span></a>) and <code class="func">OnSetsSets</code> (<a href="chap41.html#X7C10492081D72376"><span class="RefLink">41.2-7</span></a>). Some of these methods use more specific refinements than <code class="func">SubgroupProperty</code> (<a href="chap43.html#X7BE3F03C80BF8B08"><span class="RefLink">43.12-1</span></a>) or <code class="func">ElementProperty</code>. For the definition of refinements, and how one can define refinements, see Section <a href="chap87.html#X8174E19F87C3A8AB"><span class="RefLink">87.2</span></a>.</p>

<p><a id="X7A2D046B83DD5F5F" name="X7A2D046B83DD5F5F"></a></p>

<h5>43.12-3 TwoClosure</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TwoClosure</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The <em>2-closure</em> of a transitive permutation group <var class="Arg">G</var> on <span class="SimpleMath">n</span> points is the largest subgroup of the symmetric group <span class="SimpleMath">S_n</span> which has the same orbits on sets of ordered pairs of points as the group <var class="Arg">G</var> has. It also can be interpreted as the stabilizer of the orbital graphs of <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TwoClosure(Group((1,2,3),(2,3,4)));</span>
Sym( [ 1 .. 4 ] )
</pre></div>

<p><a id="X861461AB7964DC64" name="X861461AB7964DC64"></a></p>

<h5>43.12-4 InfoBckt</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InfoBckt</code></td><td class="tdright">(&nbsp;info class&nbsp;)</td></tr></table></div>
<p>is the info class for the partition backtrack routines.</p>

<p><a id="X78A68F5A80ADD1B6" name="X78A68F5A80ADD1B6"></a></p>

<h4>43.13 <span class="Heading">Working with large degree permutation groups</span></h4>

<p>Permutation groups of large degree (usually at least a few <span class="SimpleMath">10000</span>) can pose a challenge to the heuristics used in the algorithms for permutation groups. This section lists a few useful tricks that may speed up calculations with such large groups enormously.</p>

<p>The first aspect concerns solvable groups: A lot of calculations (including an initial stabilizer chain computation thanks to the algorithm from <a href="chapBib.html#biBSims90b">[Sim90]</a>) are faster if a permutation group is known to be solvable. On the other hand, proving nonsolvability can be expensive for higher degrees. Therefore <strong class="pkg">GAP</strong> will automatically test a permutation group for solvability, only if the degree is not exceeding <span class="SimpleMath">100</span>. (See also the <code class="code">tryPcgs</code> component of <code class="func">StabChainOptions</code> (<a href="chap43.html#X790C27B8783EDE68"><span class="RefLink">43.8-2</span></a>).) It is therefore beneficial to tell a group of larger degree, which is known to be solvable, that it is, using <code class="code">SetIsSolvableGroup(<var class="Arg">G</var>,true)</code>.</p>

<p>The second aspect concerns memory usage. A permutation on more than <span class="SimpleMath">65536</span> points requires <span class="SimpleMath">4</span> bytes per point for storing. So permutations on <span class="SimpleMath">256000</span> points require roughly 1MB of storage per permutation. Just storing the permutations required for a stabilizer chain might already go beyond the available memory, in particular if the base is not very short. In such a situation it can be useful, to replace the permutations by straight line program elements (see <a href="chap37.html#X8188799182D82A92"><span class="RefLink">37.9</span></a>).</p>

<p>The following code gives an example of usage: We create a group of degree <span class="SimpleMath">231000</span>. Using straight line program elements, one can compute a stabilizer chain in about <span class="SimpleMath">200</span> MB of memory.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Read("largeperms"); # read generators from file</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens:=StraightLineProgGens(permutationlist);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=Group(gens);</span>
&lt;permutation group with 5 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># use random algorithm (faster, but result is monte carlo)</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StabChainOptions(g).random:=1;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(g); # enforce computation of a stabilizer chain</span>
3529698298145066075557232833758234188056080273649172207877011796336000
</pre></div>

<p>Without straight line program elements, the same calculation runs into memory problems after a while even with 512MB of workspace:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h:=Group(permutationlist);</span>
&lt;permutation group with 5 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StabChainOptions(h).random:=1;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(h);</span>
exceeded the permitted memory (`-o' command line option) at
mlimit := 1; called from
SCRMakeStabStrong( S.stabilizer, [ g ], param, orbits, where, basesize,
 base, correct, missing, false ); called from
 SCRMakeStabStrong( S.stabilizer, [ g ], param, orbits, where, basesize,
...
</pre></div>

<p>The advantage in memory usage however is paid for in runtime: Comparisons of elements become much more expensive. One can avoid some of the related problems by registering a known base with the straight line program elements (see <code class="func">StraightLineProgGens</code> (<a href="chap37.html#X81BC263A7E45E775"><span class="RefLink">37.9-3</span></a>)). In this case element comparison will only compare the images of the given base points. If we are planning to do extensive calculations with the group, it can even be worth to recreate it with straight line program elements knowing a previously computed base:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># get the base we computed already</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bas:=BaseStabChain(StabChainMutable(g));</span>
[ 1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 55,
...
  2530, 2533, 2554, 2563, 2569 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens:=StraightLineProgGens(permutationlist,bas);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=Group(gens);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetSize(g,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">3529698298145066075557232833758234188056080273649172207877011796336000);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Random(g);; # enforce computation of a stabilizer chain</span>
</pre></div>

<p>As we know already base and size, this second stabilizer chain calculation is much faster than the first one and takes less memory.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap42.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap44.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chap16.html">16</a>  <a href="chap17.html">17</a>  <a href="chap18.html">18</a>  <a href="chap19.html">19</a>  <a href="chap20.html">20</a>  <a href="chap21.html">21</a>  <a href="chap22.html">22</a>  <a href="chap23.html">23</a>  <a href="chap24.html">24</a>  <a href="chap25.html">25</a>  <a href="chap26.html">26</a>  <a href="chap27.html">27</a>  <a href="chap28.html">28</a>  <a href="chap29.html">29</a>  <a href="chap30.html">30</a>  <a href="chap31.html">31</a>  <a href="chap32.html">32</a>  <a href="chap33.html">33</a>  <a href="chap34.html">34</a>  <a href="chap35.html">35</a>  <a href="chap36.html">36</a>  <a href="chap37.html">37</a>  <a href="chap38.html">38</a>  <a href="chap39.html">39</a>  <a href="chap40.html">40</a>  <a href="chap41.html">41</a>  <a href="chap42.html">42</a>  <a href="chap43.html">43</a>  <a href="chap44.html">44</a>  <a href="chap45.html">45</a>  <a href="chap46.html">46</a>  <a href="chap47.html">47</a>  <a href="chap48.html">48</a>  <a href="chap49.html">49</a>  <a href="chap50.html">50</a>  <a href="chap51.html">51</a>  <a href="chap52.html">52</a>  <a href="chap53.html">53</a>  <a href="chap54.html">54</a>  <a href="chap55.html">55</a>  <a href="chap56.html">56</a>  <a href="chap57.html">57</a>  <a href="chap58.html">58</a>  <a href="chap59.html">59</a>  <a href="chap60.html">60</a>  <a href="chap61.html">61</a>  <a href="chap62.html">62</a>  <a href="chap63.html">63</a>  <a href="chap64.html">64</a>  <a href="chap65.html">65</a>  <a href="chap66.html">66</a>  <a href="chap67.html">67</a>  <a href="chap68.html">68</a>  <a href="chap69.html">69</a>  <a href="chap70.html">70</a>  <a href="chap71.html">71</a>  <a href="chap72.html">72</a>  <a href="chap73.html">73</a>  <a href="chap74.html">74</a>  <a href="chap75.html">75</a>  <a href="chap76.html">76</a>  <a href="chap77.html">77</a>  <a href="chap78.html">78</a>  <a href="chap79.html">79</a>  <a href="chap80.html">80</a>  <a href="chap81.html">81</a>  <a href="chap82.html">82</a>  <a href="chap83.html">83</a>  <a href="chap84.html">84</a>  <a href="chap85.html">85</a>  <a href="chap86.html">86</a>  <a href="chap87.html">87</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
