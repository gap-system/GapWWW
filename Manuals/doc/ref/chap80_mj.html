<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (ref) - Chapter 80: Examples of Extending the System</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap80"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chap14_mj.html">14</a>  <a href="chap15_mj.html">15</a>  <a href="chap16_mj.html">16</a>  <a href="chap17_mj.html">17</a>  <a href="chap18_mj.html">18</a>  <a href="chap19_mj.html">19</a>  <a href="chap20_mj.html">20</a>  <a href="chap21_mj.html">21</a>  <a href="chap22_mj.html">22</a>  <a href="chap23_mj.html">23</a>  <a href="chap24_mj.html">24</a>  <a href="chap25_mj.html">25</a>  <a href="chap26_mj.html">26</a>  <a href="chap27_mj.html">27</a>  <a href="chap28_mj.html">28</a>  <a href="chap29_mj.html">29</a>  <a href="chap30_mj.html">30</a>  <a href="chap31_mj.html">31</a>  <a href="chap32_mj.html">32</a>  <a href="chap33_mj.html">33</a>  <a href="chap34_mj.html">34</a>  <a href="chap35_mj.html">35</a>  <a href="chap36_mj.html">36</a>  <a href="chap37_mj.html">37</a>  <a href="chap38_mj.html">38</a>  <a href="chap39_mj.html">39</a>  <a href="chap40_mj.html">40</a>  <a href="chap41_mj.html">41</a>  <a href="chap42_mj.html">42</a>  <a href="chap43_mj.html">43</a>  <a href="chap44_mj.html">44</a>  <a href="chap45_mj.html">45</a>  <a href="chap46_mj.html">46</a>  <a href="chap47_mj.html">47</a>  <a href="chap48_mj.html">48</a>  <a href="chap49_mj.html">49</a>  <a href="chap50_mj.html">50</a>  <a href="chap51_mj.html">51</a>  <a href="chap52_mj.html">52</a>  <a href="chap53_mj.html">53</a>  <a href="chap54_mj.html">54</a>  <a href="chap55_mj.html">55</a>  <a href="chap56_mj.html">56</a>  <a href="chap57_mj.html">57</a>  <a href="chap58_mj.html">58</a>  <a href="chap59_mj.html">59</a>  <a href="chap60_mj.html">60</a>  <a href="chap61_mj.html">61</a>  <a href="chap62_mj.html">62</a>  <a href="chap63_mj.html">63</a>  <a href="chap64_mj.html">64</a>  <a href="chap65_mj.html">65</a>  <a href="chap66_mj.html">66</a>  <a href="chap67_mj.html">67</a>  <a href="chap68_mj.html">68</a>  <a href="chap69_mj.html">69</a>  <a href="chap70_mj.html">70</a>  <a href="chap71_mj.html">71</a>  <a href="chap72_mj.html">72</a>  <a href="chap73_mj.html">73</a>  <a href="chap74_mj.html">74</a>  <a href="chap75_mj.html">75</a>  <a href="chap76_mj.html">76</a>  <a href="chap77_mj.html">77</a>  <a href="chap78_mj.html">78</a>  <a href="chap79_mj.html">79</a>  <a href="chap80_mj.html">80</a>  <a href="chap81_mj.html">81</a>  <a href="chap82_mj.html">82</a>  <a href="chap83_mj.html">83</a>  <a href="chap84_mj.html">84</a>  <a href="chap85_mj.html">85</a>  <a href="chap86_mj.html">86</a>  <a href="chap87_mj.html">87</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap79_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap81_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap80.html">[MathJax off]</a></p>
<p><a id="X8186831682A00097" name="X8186831682A00097"></a></p>
<div class="ChapSects"><a href="chap80_mj.html#X8186831682A00097">80 <span class="Heading">Examples of Extending the System</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap80_mj.html#X7B42DF6E7CCF507D">80.1 <span class="Heading">Addition of a Method</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap80_mj.html#X837CF3267EF0CFB3">80.2 <span class="Heading">Extending the Range of Definition of an Existing Operation</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap80_mj.html#X7D880DB779EBA8D5">80.3 <span class="Heading">Enforcing Property Tests</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap80_mj.html#X797545848520A44B">80.4 <span class="Heading">Adding a new Operation</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap80_mj.html#X874AF11D864AEC1B">80.5 <span class="Heading">Adding a new Attribute</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap80_mj.html#X8111D831783C9ED6">80.6 <span class="Heading">Adding a new Representation</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap80_mj.html#X86AA65D4815CAE95">80.7 <span class="Heading">Components versus Attributes</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap80_mj.html#X7E29DEC0813F8897">80.8 <span class="Heading">Adding new Concepts</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap80_mj.html#X7DC936877A3330D0">80.8-1 <span class="Heading">Example: M-groups</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap80_mj.html#X7CD762FD82DED051">80.8-2 <span class="Heading">Example: Groups with a word length</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap80_mj.html#X782AC35979925C71">80.8-3 <span class="Heading">Example: Groups with a decomposition as semidirect product</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap80_mj.html#X7BD325C5791C6A06">80.9 <span class="Heading">Creating Own Arithmetic Objects</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap80_mj.html#X87A88E3D7F6E2A7C">80.9-1 ArithmeticElementCreator</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap80_mj.html#X79E535CC7B82BA47">80.9-2 <span class="Heading">Example: ArithmeticElementCreator</span></a>
</span>
</div></div>
</div>

<h3>80 <span class="Heading">Examples of Extending the System</span></h3>

<p>This chapter gives a few examples of how one can extend the functionality of <strong class="pkg">GAP</strong>.</p>

<p>They are arranged in ascending difficulty. We show how to install new methods, add new operations and attributes and how to implement new features using categories and representations. (As we do not introduce completely new kinds of objects in these example it will not be necessary to declare any families.) Finally we show a simple way how to create new objects with an own arithmetic.</p>

<p>The examples given are all very rudimentary – no particular error checks are performed and the user interface sometimes is quite clumsy. These examples may be constructed for presentation purposes only and they do not necessarily constitute parts of the <strong class="pkg">GAP</strong> library.</p>

<p>Even more complex examples that create whole classes of objects anew will be given in the following two chapters <a href="chap81_mj.html#X8125CC6A87409887"><span class="RefLink">81</span></a> and <a href="chap82_mj.html#X7E485C967A5778C9"><span class="RefLink">82</span></a>.</p>

<p><a id="X7B42DF6E7CCF507D" name="X7B42DF6E7CCF507D"></a></p>

<h4>80.1 <span class="Heading">Addition of a Method</span></h4>

<p>The easiest case is the addition of a new algorithm as a method for an existing operation for the existing structures.</p>

<p>For example, assume we wanted to implement a better method for computing the exponent of a nilpotent group (it is the product of the exponents of the Sylow subgroups).</p>

<p>The first task is to find which operation is used by <strong class="pkg">GAP</strong> (it is <code class="func">Exponent</code> (<a href="chap39_mj.html#X7D44470C7DA59C1C"><span class="RefLink">39.16-2</span></a>)) and how it is declared. We can find this in the Reference Manual (in our particular case in section <a href="chap39_mj.html#X7F8264FA796B2B7D"><span class="RefLink">39.16</span></a>) and the declaration in the library file <code class="file">lib/grp.gd</code>. The easiest way to find the place of the declaration is usually to <code class="code">grep</code> over all <code class="code">.gd</code> and <code class="code">.g</code> files, see section <a href="chap83_mj.html#X848C952A87FB36E2"><span class="RefLink">83</span></a>.</p>

<p>In our example the declaration in the library is:</p>


<div class="example"><pre>
DeclareAttribute("Exponent",IsGroup);
</pre></div>

<p>Similarly we find that the filter <code class="func">IsNilpotentGroup</code> (<a href="chap39_mj.html#X87D062608719F2CD"><span class="RefLink">39.15-3</span></a>) represents the concept of being nilpotent.</p>

<p>We then write a function that implements the new algorithm which takes the right set of arguments and install it as a method. In our example this installation would be:</p>


<div class="example"><pre>
InstallMethod(Exponent,"for nilpotent groups",
  [IsGroup and IsNilpotent],
function(G)
  [function body omitted]
end);
</pre></div>

<p>We have left out the optional rank argument of <code class="func">InstallMethod</code> (<a href="chap78_mj.html#X837EFDAB7BEF290B"><span class="RefLink">78.3-1</span></a>), which normally is a wise choice –<strong class="pkg">GAP</strong> automatically uses an internal ranking based on the filters that is only offset by the given rank. So our method will certainly be regarded as "better" than a method that has been installed for mere groups or for solvable groups but will be ranked lower than the library method for abelian groups.</p>

<p>That's all. Using <a href="chap7_mj.html#X80848FF486BD6F9F"><span class="RefLink">7.2-1</span></a> we can check for a nilpotent group that indeed our new method will be used.</p>

<p>When testing, remember that the method selection will not check for properties that are not known. (This is done internally by checking the property tester first.) Therefore the method would not be applicable for the group <code class="code">g</code> in the following definition but only for the –mathematically identical but endowed with more knowledge by <strong class="pkg">GAP</strong>– group <code class="code">h</code>. (Section <a href="chap80_mj.html#X7D880DB779EBA8D5"><span class="RefLink">80.3</span></a> shows a way around this.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=Group((1,2),(1,3)(2,4));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h:=Group((1,2),(1,3)(2,4));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsNilpotentGroup(h); # enforce test</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HasIsNilpotentGroup(g);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HasIsNilpotentGroup(h);</span>
true
</pre></div>

<p>Let's now look at a slightly more complicated example: We want to implement a better method for computing normalizers in a nilpotent permutation group. (Such an algorithm can be found for example in <a href="chapBib_mj.html#biBluksrakocziwright97">[LRW97]</a>.)</p>

<p>We already know <code class="func">IsNilpotentGroup</code> (<a href="chap39_mj.html#X87D062608719F2CD"><span class="RefLink">39.15-3</span></a>), the filter <code class="func">IsPermGroup</code> (<a href="chap43_mj.html#X7879877482F59676"><span class="RefLink">43.1-1</span></a>) represents the concept of being a group of permutations.</p>

<p><strong class="pkg">GAP</strong> uses <code class="func">Normalizer</code> (<a href="chap39_mj.html#X87B5370C7DFD401D"><span class="RefLink">39.11-1</span></a>) to compute normalizers, however the declaration is a bit more complicated. In the library we find</p>


<div class="example"><pre>
InParentFOA( "Normalizer", IsGroup, IsObject, NewAttribute );
</pre></div>

<p>The full mechanism of <code class="func">InParentFOA</code> (<a href="chap85_mj.html#X7C0E62D8813A4EE6"><span class="RefLink">85.2-1</span></a>) is described in chapter <a href="chap85_mj.html#X8350247A8501969F"><span class="RefLink">85</span></a>, however for our purposes it is sufficient to know that for such a function the actual work is done by an operation <code class="code">NormalizerOp</code>, an underlying operation for <code class="func">Normalizer</code> (<a href="chap39_mj.html#X87B5370C7DFD401D"><span class="RefLink">39.11-1</span></a>) (and all the complications are just there to be able to remember certain results) and that the declaration of this operation is given by the first arguments, it would be:</p>


<div class="example"><pre>
DeclareOperation( "NormalizerOp", [IsGroup, IsObject] );
</pre></div>

<p>This time we decide to enter a non-default family predicate in the call to <code class="func">InstallMethod</code> (<a href="chap78_mj.html#X837EFDAB7BEF290B"><span class="RefLink">78.3-1</span></a>). We could just leave it out as in the previous call; this would yield the default value, the function <code class="func">ReturnTrue</code> (<a href="chap5_mj.html#X7DB422A2876CCC4D"><span class="RefLink">5.4-1</span></a>) of arbitrary many arguments which always returns <code class="keyw">true</code>. However, then the method might be called in some cases of inconsistent input (for example matrix groups in different characteristics) that ought to fall through the method selection to raise an error.</p>

<p>In our situation, we want the second group to be a subgroup of the first, so necessarily both must have the same family and we can use <code class="func">IsIdenticalObj</code> (<a href="chap12_mj.html#X7961183378DFB902"><span class="RefLink">12.5-1</span></a>) as family predicate.</p>

<p>Now we can install the method. Again this manual is lazy and does not show you the actual code:</p>


<div class="example"><pre>
InstallMethod(NormalizerOp,"for nilpotent permutation groups",IsIdenticalObj,
  [IsPermGroup and IsNilpotentGroup,
   IsPermGroup and IsNilpotentGroup],
function(G,U)
  [ function body omitted ]
end);
</pre></div>

<p><a id="X837CF3267EF0CFB3" name="X837CF3267EF0CFB3"></a></p>

<h4>80.2 <span class="Heading">Extending the Range of Definition of an Existing Operation</span></h4>

<p>It might be that the operation has been defined so far only for a set of objects that is too restrictive for our purposes (or we want to install a method that takes another number of arguments). If this is the case, the call to <code class="func">InstallMethod</code> (<a href="chap78_mj.html#X837EFDAB7BEF290B"><span class="RefLink">78.3-1</span></a>) causes an error message. We can avoid this by using <code class="func">InstallOtherMethod</code> (<a href="chap78_mj.html#X7D2C12DB841CE539"><span class="RefLink">78.3-2</span></a>) instead. It is also possible to re-declare an operation with another number of arguments and/or different filters for its arguments.</p>

<p><a id="X7D880DB779EBA8D5" name="X7D880DB779EBA8D5"></a></p>

<h4>80.3 <span class="Heading">Enforcing Property Tests</span></h4>

<p>As mentioned in Section <a href="chap78_mj.html#X851FC6387CA2B241"><span class="RefLink">78.4</span></a>, <strong class="pkg">GAP</strong> does not check unknown properties to test whether a method might be applicable. In some cases one wants to enforce this, however, because the gain from knowing the property outweighs the cost of its determination.</p>

<p>In this situation one has to install a method <em>without</em> the additional property (so it can be tried even if the property is not yet known) and at high rank (so it will be used before other methods). The first thing to do in the actual function then is to test the property and to bail out with <code class="func">TryNextMethod</code> (<a href="chap78_mj.html#X7EED949B83046A7F"><span class="RefLink">78.5-1</span></a>) if it turns out to be <code class="keyw">false</code>.</p>

<p>The above <code class="func">Exponent</code> (<a href="chap39_mj.html#X7D44470C7DA59C1C"><span class="RefLink">39.16-2</span></a>) example thus would become:</p>


<div class="example"><pre>
InstallMethod(Exponent,"test abelianity", [IsGroup],
  50,# enforced high rank
function(G)
  if not IsAbelian(G) then
    TryNextMethod();
  fi;
  [remaining function body omitted]
end);
</pre></div>

<p>The value "50" used in this example is quite arbitrary. A better way is to use values that are given by the system inherently: We want this method still to be ranked as high, <em>as if it had</em> the <code class="func">IsAbelian</code> (<a href="chap35_mj.html#X830A4A4C795FBC2D"><span class="RefLink">35.4-9</span></a>) requirement. So we have <strong class="pkg">GAP</strong> compute the extra rank of this:</p>


<div class="example"><pre>
InstallMethod(Exponent,"test abelianity", [IsGroup],
  # enforced absolute rank of `IsGroup and IsAbelian' installation: Subtract
  # the rank of `IsGroup' and add the rank of `IsGroup and IsAbelian':
  RankFilter(IsGroup and IsAbelian)
  -RankFilter(IsGroup),
function(G)
</pre></div>

<p>the slightly complicated construction of addition and subtraction is necessary because <code class="func">IsGroup</code> (<a href="chap39_mj.html#X7939B3177BBD61E4"><span class="RefLink">39.2-7</span></a>) and <code class="func">IsAbelian</code> (<a href="chap35_mj.html#X830A4A4C795FBC2D"><span class="RefLink">35.4-9</span></a>) might imply the <em>same</em> elementary filters which we otherwise would count twice.</p>

<p>A somehow similar situation occurs with matrix groups. Most methods for matrix groups are only applicable if the group is known to be finite.</p>

<p>However we should not enforce a finiteness test early (someone else later might install good methods for infinite groups while the finiteness test would be too expensive) but just before <strong class="pkg">GAP</strong> would give a "no method found" error. This is done by redispatching, see <a href="chap78_mj.html#X7B85DD797A907106"><span class="RefLink">78.6</span></a>. For example to enforce such a final finiteness test for normalizer calculations could be done by:</p>


<div class="example"><pre>
RedispatchOnCondition(NormalizerOp,IsIdenticalObj,
  [IsMatrixGroup,IsMatrixGroup],[IsFinite,IsFinite],0);
</pre></div>

<p><a id="X797545848520A44B" name="X797545848520A44B"></a></p>

<h4>80.4 <span class="Heading">Adding a new Operation</span></h4>

<p>Next, we will consider how to add own operations. As an example we take the Sylow normalizer in a group of a given prime. This operation gets two arguments, the first has to be a group, the second a prime number.</p>

<p>There is a function <code class="func">IsPrimeInt</code> (<a href="chap14_mj.html#X78FDA4437EDCA70C"><span class="RefLink">14.4-2</span></a>), but no property for being prime (which would be pointless as integers cannot store property values anyhow). So the second argument gets specified only as positive integer:</p>


<div class="example"><pre>
SylowNormalizer:=NewOperation("SylowNormalizer",[IsGroup,IsPosInt]);
</pre></div>

<p>(Note that we are using <code class="func">NewOperation</code> (<a href="chap78_mj.html#X85A9E019795B79D6"><span class="RefLink">78.1-4</span></a>) instead of <code class="func">DeclareOperation</code> (<a href="chap78_mj.html#X843F48137B899BC3"><span class="RefLink">78.1-5</span></a>) as used in the library. The only difference other than that <code class="func">DeclareOperation</code> (<a href="chap78_mj.html#X843F48137B899BC3"><span class="RefLink">78.1-5</span></a>) saves some typing, is that it also protects the variables against overwriting. When testing code (when one probably wants to change things) this might be restricting. If this does not bother you, you can use</p>


<div class="example"><pre>
DeclareOperation("SylowNormalizer",[IsGroup,IsPosInt]);
</pre></div>

<p>as well.)</p>

<p>The filters <code class="func">IsGroup</code> (<a href="chap39_mj.html#X7939B3177BBD61E4"><span class="RefLink">39.2-7</span></a>) and <code class="func">IsPosInt</code> (<a href="chap14_mj.html#X82A854757DFA9C76"><span class="RefLink">14.2-2</span></a>) given are <em>only</em> used to test that <code class="func">InstallMethod</code> (<a href="chap78_mj.html#X837EFDAB7BEF290B"><span class="RefLink">78.3-1</span></a>) installs methods with suitable arguments and will be completely ignored when using <code class="func">InstallOtherMethod</code> (<a href="chap78_mj.html#X7D2C12DB841CE539"><span class="RefLink">78.3-2</span></a>). Technically one could therefore simply use <code class="func">IsObject</code> (<a href="chap12_mj.html#X7B130AC98415CAFB"><span class="RefLink">12.1-1</span></a>) for all arguments in the declaration. The main point of using more specific filters here is to help documenting with which arguments the function is to be used (so for example a call <code class="code">SylowNormalizer(5,G)</code> would be invalid).</p>

<p>Of course initially there are no useful methods for newly declared operations; you will have to write and install them yourself.</p>

<p>If the operation only takes one argument and has reproducible results without side effects, it might be worth declaring it as an attribute instead; see Section <a href="chap80_mj.html#X874AF11D864AEC1B"><span class="RefLink">80.5</span></a>.</p>

<p><a id="X874AF11D864AEC1B" name="X874AF11D864AEC1B"></a></p>

<h4>80.5 <span class="Heading">Adding a new Attribute</span></h4>

<p>Now we look at an example of how to add a new attribute. As example we consider the set of all primes that divide the size of a group.</p>

<p>First we have to declare the attribute:</p>


<div class="example"><pre>
PrimesDividingSize:=NewAttribute("PrimesDividingSize",IsGroup);
</pre></div>

<p>(See <code class="func">NewAttribute</code> (<a href="chap13_mj.html#X7B9654807858A3B0"><span class="RefLink">13.5-3</span></a>)). This implicitly declares attribute tester and setter, it is convenient however to assign these to variables as well:</p>


<div class="example"><pre>
HasPrimesDividingSize:=Tester(PrimesDividingSize);
SetPrimesDividingSize:=Setter(PrimesDividingSize);
</pre></div>

<p>Alternatively, there is a declaration command <code class="func">DeclareAttribute</code> (<a href="chap13_mj.html#X7A00FC8A7A677A56"><span class="RefLink">13.5-4</span></a>) that executes all three assignments simultaneously and protects the variables against overwriting:</p>


<div class="example"><pre>
DeclareAttribute("PrimesDividingSize",IsGroup);
</pre></div>

<p>Next we have to install method(s) for the attribute that compute its value. (This is not strictly necessary. We could use the attribute also without methods only for storing and retrieving information, but calling it for objects for which the value is not known would produce a "no method found" error.) For this purpose we can imagine the attribute simply as an one-argument operation:</p>


<div class="example"><pre>
InstallMethod(PrimesDividingSize,"for finite groups",
  [IsGroup and IsFinite],
function(G)
  return PrimeDivisors(Size(G));
end);
</pre></div>

<p>The function installed <em>must</em> always return a value (or call <code class="func">TryNextMethod</code> (<a href="chap78_mj.html#X7EED949B83046A7F"><span class="RefLink">78.5-1</span></a>)). If the object is in the representation <code class="func">IsAttributeStoringRep</code> (<a href="chap13_mj.html#X7A951C33839AF2C1"><span class="RefLink">13.5-5</span></a>) this return value once computed will be automatically stored and retrieved if the attribute is called a second time. We don't have to call setter or tester ourselves. (This storage happens by <strong class="pkg">GAP</strong> internally calling the attribute setter with the return value of the function. Retrieval is by a high-ranking method which is installed under the condition <code class="code">HasPrimesDividingSize</code>. This method was installed automatically when the attribute was declared.)</p>

<p><a id="X8111D831783C9ED6" name="X8111D831783C9ED6"></a></p>

<h4>80.6 <span class="Heading">Adding a new Representation</span></h4>

<p>Next, we look at the implementation of a new representation of existing objects. In most cases we want to implement this representation only for efficiency reasons while keeping all the existing functionality.</p>

<p>For example, assume we wanted (following <a href="chapBib_mj.html#biBwielandt69">[Wie69]</a>) to implement permutation groups defined by relations.</p>

<p>Next, we have to decide a few basics about the representation. All existing permutation groups in the library are attribute storing and we probably want to keep this for our new objects. Thus the representation must be a subrepresentation of <code class="func">IsComponentObjectRep</code> (<a href="chap13_mj.html#X805F1C3B7C730062"><span class="RefLink">13.4-1</span></a>) and <code class="func">IsAttributeStoringRep</code> (<a href="chap13_mj.html#X7A951C33839AF2C1"><span class="RefLink">13.5-5</span></a>). Furthermore we want each object to be a permutation group and we can imply this directly in the representation.</p>

<p>We also decide that we store the degree (the largest point that might be moved) in a component <code class="code">degree</code> and the defining relations in a component <code class="code">relations</code> (we do not specify the format of relations here. In an actual implementation one would have to design this as well, but it does not affect the declarations this chapter is about).</p>


<div class="example"><pre>
IsPermutationGroupByRelations:=NewRepresentation(
  "IsPermutationGroupByRelations",
  IsComponentObjectRep and IsAttributeStoringRep and IsPermGroup,
  ["degree","relations"]);
</pre></div>

<p>(If we wanted to implement sparse matrices we might for example rather settle for a positional object in which we store a list of the nonzero entries.)</p>

<p>We can make the new representation a subrepresentation of an existing one. In such a case of course we have to provide all structure of this "parent" representation as well.</p>

<p>Next we need to check in which family our new objects will be. This will be the same family as of every other permutation group, namely the <code class="code">CollectionsFamily(PermutationsFamily)</code> (where the family <code class="code">PermutationsFamily = FamilyObj((1,2,3))</code> has been defined already in the library).</p>

<p>Now we can write a function to create our new objects. Usually it is helpful to look at functions from the library that are used in similar situations (for example <code class="func">GroupByGenerators</code> (<a href="chap39_mj.html#X7F81960287F3E32A"><span class="RefLink">39.2-2</span></a>) in our case) to make sure we have not forgotten any further requirements in the declaration we might have to add here. However in most cases the function is straightforward:</p>


<div class="example"><pre>
PermutationGroupByRelations:=function(degree,relations)
local g
  g:=Objectify(NewType(CollectionsFamily(PermutationsFamily),
		       IsPermutationGroupByRelations),
               rec(degree:=degree,relations:=relations));
end;
</pre></div>

<p>It also is a good idea to install a <code class="func">PrintObj</code> (<a href="chap6_mj.html#X815BF22186FD43C9"><span class="RefLink">6.3-5</span></a>) and possibly also a <code class="func">ViewObj</code> (<a href="chap6_mj.html#X815BF22186FD43C9"><span class="RefLink">6.3-5</span></a>) method –otherwise testing becomes quite hard:</p>


<div class="example"><pre>
InstallMethod(PrintObj,"for perm grps. given by relations",
  [IsPermutationGroupByRelations],
function(G)
  Print("PermutationGroupByRelations(", G!.degree,",",G!.relations,")");
end);
</pre></div>

<p>Next we have to write enough methods for the new representation so that the existing algorithms can be used. In particular we will have to implement methods for all operations for which library or kernel provides methods for the existing (alternative) representations. In our particular case there are no such methods. (If we would have implemented sparse matrices we would have had to implement methods for the list access and assignment functions, see <a href="chap21_mj.html#X7B202D147A5C2884"><span class="RefLink">21.2</span></a>.) However the existing way permutation groups are represented is by generators. To be able to use the existing machinery we want to be able to obtain a generating set also for groups in our new representation. This can be done (albeit not very effectively) by a stabilizer calculation in the symmetric group given by the <code class="code">degree</code> component. The operation function to use is probably a bit complicated and will depend on the format of the <code class="code">relations</code> (we have not specified in this example). In the following method we use <code class="code">operationfunction</code> as a placeholder;</p>


<div class="example"><pre>
InstallMethod(GeneratorsOfGroup,"for perm grps. given by relations",
  [IsPermutationGroupByRelations],
function(G)
local S,U;
  S:=SymmetricGroup(G!.degree);
  U:=Stabilizer(S,G!.relations,  operationfunction );
  return GeneratorsOfGroup(U);
end);
</pre></div>

<p>This is all we <em>must</em> do. Of course for performance reasons one might want to install methods for further operations as well.</p>

<p><a id="X86AA65D4815CAE95" name="X86AA65D4815CAE95"></a></p>

<h4>80.7 <span class="Heading">Components versus Attributes</span></h4>

<p>In the last section we introduced two new components, <code class="code">G!.degree</code> and <code class="code">G!.relations</code>. Technically, we could have used attributes instead. There is no clear distinction which variant is to be preferred: An attribute expresses part of the functionality available to certain objects (and thus could be computed later and probably even for a wider class of objects), a component is just part of the internal definition of an object.</p>

<p>So if the data is "of general interest", if we want the user to have access to it, attributes are preferable. Moreover, attributes can be used by the method selection (by specifying the filter <code class="code">HasAttr</code> for an attribute <code class="code">Attr</code>). They provide a clean interface and their immutability makes it safe to hand the data to a user who potentially could corrupt a components entries.</p>

<p>On the other hand more "technical" data (say the encoding of a sparse matrix) is better hidden from the user in a component, as declaring it as an attribute would not give any advantage.</p>

<p>Resource-wise, attributes need more memory (the attribute setter and tester are implicitly declared, and one filter bit is required), the attribute access is one further function call in the kernel, thus components might be an immeasurable bit faster.</p>

<p><a id="X7E29DEC0813F8897" name="X7E29DEC0813F8897"></a></p>

<h4>80.8 <span class="Heading">Adding new Concepts</span></h4>

<p>Now we look how to implement a new concept for existing objects and fit this in the method selection. Three examples that will be made more explicit below would be groups for which a "length" of elements (as a word in certain generators) is defined, groups that can be decomposed as a semidirect product and M-groups.</p>

<p>In each case we have two possibilities for the declaration. We can either declare it as a property or as a category. Both are eventually filter(s) and in this way indistinguishable for the method selection. However, the value of a property for a particular object can be unknown at first and later in the session be computed (to be <code class="keyw">true</code> or <code class="keyw">false</code>). This is implemented by reserving two filters for each property, one indicating whether the property value is known, and one, provided the value is known, to indicate the actual boolean value. Contrary to this, the decision whether or not an object lies in a category is taken at creation time and this is implemented using a single filter.</p>


<dl>
<dt><strong class="Mark">Property:</strong></dt>
<dd><p>Properties also are attributes: If a property value is not known for an object, <strong class="pkg">GAP</strong> tries to find a method to compute the property value. If no suitable method is found, an error is raised.</p>

</dd>
<dt><strong class="Mark">Category:</strong></dt>
<dd><p>An object is in a category if it has been created in it. Testing the category for an object simply returns this value. Existing objects cannot enter a new category later in life. This means that in most cases one has to write own code to create objects in a new category.</p>

<p>If we want to implement a completely new concept so that new operations are defined only for the new objects –for example bialgebras for which a second scalar multiplication is defined– usually a category is chosen.</p>

<p>Technically, the behaviour of the category <code class="code">IsXYZ</code>, declared as subcategory of <code class="code">IsABC</code> is therefore exactly the same as if we would declare <code class="code">IsXYZ</code> to be a property for <code class="code">IsABC</code> and install the following method:</p>


<div class="example"><pre>
InstallMethod(IsXYZ,"return false if not known",[IsABC],ReturnFalse);
</pre></div>

<p>(The word <code class="code">category</code> also has a well-defined mathematical meaning, but this does not need to concern us at this point. The set of objects which is defined to be a (<strong class="pkg">GAP</strong>) category does not need to be a category in the mathematical sense, vice versa not every mathematical category is declared as a (<strong class="pkg">GAP</strong>) category.)</p>

</dd>
</dl>
<p>Eventually the choice between category and property often becomes a matter of taste or style.</p>

<p>Sometimes there is even a third possibility (if you have <strong class="pkg">GAP</strong> 3 experience this might reflect most closely "an object whose operations record is <code class="code">XYOps</code>"): We might want to indicate this new concept simply by the fact that certain attributes are set. In this case we could simply use the respective attribute tester(s).</p>

<p>The examples given below each give a short argument why the respective solution was chosen, but one could argue as well for other choices.</p>

<p><a id="X7DC936877A3330D0" name="X7DC936877A3330D0"></a></p>

<h5>80.8-1 <span class="Heading">Example: M-groups</span></h5>

<p>M-groups are finite groups for which all irreducible complex representations are induced from linear representations of subgroups, it turns out that they are all solvable and that every supersolvable group is an M-group. See <a href="chapBib_mj.html#biBIsa76">[Isa76]</a> for further details.</p>

<p>Solvability and supersolvability both are testable properties. We therefore declare <code class="code">IsMGroup</code> as a property for solvable groups:</p>


<div class="example"><pre>
IsMGroup:=NewProperty("IsMGroup",IsSolvableGroup);
</pre></div>

<p>The filter <code class="func">IsSolvableGroup</code> (<a href="chap39_mj.html#X809C78D5877D31DF"><span class="RefLink">39.15-6</span></a>) in this declaration <em>only</em> means that methods for <code class="code">IsMGroup</code> by default can only be installed for groups that are (and know to be) solvable (though they could be installed for more general situations using <code class="func">InstallOtherMethod</code> (<a href="chap78_mj.html#X7D2C12DB841CE539"><span class="RefLink">78.3-2</span></a>)). It does not yet imply that M-groups are solvable. We must do this deliberately via an implication and we use the same technique to imply that every supersolvable group is an M-group.</p>


<div class="example"><pre>
InstallTrueMethod(IsSolvableGroup,IsMGroup);
InstallTrueMethod(IsMGroup,IsSupersolvableGroup);
</pre></div>

<p>Now we might install a method that tests for solvable groups whether they are M-groups:</p>


<div class="example"><pre>
InstallMethod(IsMGroup,"for solvable groups",[IsSolvableGroup],
function(G)
  [... code omitted. The function must return `true' or `false' ...]
end);
</pre></div>

<p>Note that this example of declaring the <code class="code">IsMGroup</code> property for solvable groups is not a part of the <strong class="pkg">GAP</strong> library, which uses a similar but different filter <code class="func">IsMonomialGroup</code> (<a href="chap39_mj.html#X83977EB97A8E2290"><span class="RefLink">39.15-9</span></a>).</p>

<p><a id="X7CD762FD82DED051" name="X7CD762FD82DED051"></a></p>

<h5>80.8-2 <span class="Heading">Example: Groups with a word length</span></h5>

<p>Our second example is that of groups for whose elements a <em>word length</em> is defined. (We assume that the word length is only defined in the context of the group with respect to a preselected generating set but not for single elements alone. However we will not delve into any details of how this length is defined and how it could be computed.)</p>

<p>Having a word length is a feature which enables other operations (for example a "word length" function). This is exactly what categories are intended for and therefore we use one.</p>

<p>First, we declare the category. All objects in this category are groups and so we inherit the supercategory <code class="func">IsGroup</code> (<a href="chap39_mj.html#X7939B3177BBD61E4"><span class="RefLink">39.2-7</span></a>):</p>


<div class="example"><pre>
DeclareCategory("IsGroupWithWordLength",IsGroup);
</pre></div>

<p>We also define the operation which is "enabled" by this category, the word length of a group element, which is defined for a group and an element (remember that group elements are described by the category <code class="func">IsMultiplicativeElementWithInverse</code> (<a href="chap31_mj.html#X7FDB14E57814FA3B"><span class="RefLink">31.14-13</span></a>)):</p>


<div class="example"><pre>
DeclareOperation("WordLengthOfElement",[IsGroupWithWordLength,
  IsMultiplicativeElementWithInverse]);
</pre></div>

<p>We then would proceed by installing methods to compute the word length in concrete cases and might for example add further operations to get shortest words in cosets.</p>

<p><a id="X782AC35979925C71" name="X782AC35979925C71"></a></p>

<h5>80.8-3 <span class="Heading">Example: Groups with a decomposition as semidirect product</span></h5>

<p>The third example is groups which have a (nontrivial) decomposition as a semidirect product. If this information has been found out, we want to be able to use it in algorithms. (Thus we do not only need the fact <em>that</em> there is a decomposition, but also the decomposition itself.)</p>

<p>We also want this to be applicable to every group and not only for groups which have been explicitly constructed via <code class="func">SemidirectProduct</code> (<a href="chap49_mj.html#X7D905A5778D7ACDE"><span class="RefLink">49.2-1</span></a>).</p>

<p>Instead we simply declare an attribute <code class="code">SemidirectProductDecomposition</code> for groups. (Again, in this manual we don't go in the details of how such an decomposition would look like).</p>


<div class="example"><pre>
DeclareAttribute("SemidirectProductDecomposition",IsGroup);
</pre></div>

<p>If a decomposition has been found, it can be stored in a group using <code class="code">SetSemidirectProductDecomposition</code>. (At the moment all groups in <strong class="pkg">GAP</strong> are attribute storing.)</p>

<p>Methods that rely on the existence of such a decomposition then get installed for the tester filter <code class="code">HasSemidirectProductDecomposition</code>.</p>

<p><a id="X7BD325C5791C6A06" name="X7BD325C5791C6A06"></a></p>

<h4>80.9 <span class="Heading">Creating Own Arithmetic Objects</span></h4>

<p>Finally let's look at a way to create new objects with a user-defined arithmetic such that one can form for example groups, rings or vector spaces of these elements. This topic is discussed in much more detail in chapter <a href="chap82_mj.html#X7E485C967A5778C9"><span class="RefLink">82</span></a>, in this section we present a simple approach that may be useful to get started but does not permit you to exploit all potential features.</p>

<p>The basic design is that the user designs some way to represent her objects in terms of <strong class="pkg">GAP</strong>s built-in types, for example as a list or a record. We call this the "defining data" of the new objects. Also provided are functions that perform arithmetic on this "defining data", that is they take objects of this form and return objects that represent the result of the operation. The function <code class="func">ArithmeticElementCreator</code> (<a href="chap80_mj.html#X87A88E3D7F6E2A7C"><span class="RefLink">80.9-1</span></a>) then is called to provide a wrapping such that proper new <strong class="pkg">GAP</strong>-objects are created which can be multiplied etc. with the default infix operations such as <code class="code">*</code>.</p>

<p><a id="X87A88E3D7F6E2A7C" name="X87A88E3D7F6E2A7C"></a></p>

<h5>80.9-1 ArithmeticElementCreator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ArithmeticElementCreator</code>( <var class="Arg">spec</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>offers a simple interface to create new arithmetic elements by providing functions that perform addition, multiplication and so forth, conforming to the specification <var class="Arg">spec</var>. <code class="code">ArithmeticElementCreator</code> creates a new category, representation and family for the new arithmetic elements being defined, and returns a function which takes the "defining data" of an element and returns the corresponding new arithmetic element.</p>

<p><var class="Arg">spec</var> is a record with one or more of the following components:</p>


<dl>
<dt><strong class="Mark"><code class="code">ElementName</code></strong></dt>
<dd><p>string used to identify the new type of object. A global identifier <code class="code">Is<var class="Arg">ElementName</var></code> will be defined to indicate a category for these now objects. (Therefore it is not clever to have blanks in the name). Also a collections category is defined. (You will get an error message if the identifier <code class="code">Is<var class="Arg">ElementName</var></code> is already defined.)</p>

</dd>
<dt><strong class="Mark"><code class="code">Equality</code>, <code class="code">LessThan</code>, <code class="code">One</code>, <code class="code">Zero</code>,
 <code class="code">Multiplication</code>, <code class="code">Inverse</code>, <code class="code">Addition</code>,
 <code class="code">AdditiveInverse</code></strong></dt>
<dd><p>functions defining the arithmetic operations. The functions interface on the level of "defining data", the actual methods installed will perform the unwrapping and wrapping as objects. Components are optional, but of course if no multiplication is defined elements cannot be multiplied and so forth.</p>

<p>There are default methods for <code class="code">Equality</code> and <code class="code">LessThan</code> which simply calculate on the defining data. If one is defined, it must be ensured that the other is compatible (so that <span class="SimpleMath">\(a &lt; b\)</span> implies not <span class="SimpleMath">\((a = b)\)</span>)</p>

</dd>
<dt><strong class="Mark"><code class="code">Print</code></strong></dt>
<dd><p>a function which prints the object. By default, just the defining data is printed.</p>

</dd>
<dt><strong class="Mark"><code class="code">MathInfo</code></strong></dt>
<dd><p>filters determining the mathematical properties of the elements created. A typical value is for example <code class="code">IsMultiplicativeElementWithInverse</code> for group elements.</p>

</dd>
<dt><strong class="Mark"><code class="code">RepInfo</code></strong></dt>
<dd><p>filters determining the representational properties of the elements created. The objects created are always component objects, so in most cases the only reasonable option is <code class="code">IsAttributeStoringRep</code> to permit the storing of attributes.</p>

</dd>
</dl>
<p>All components are optional and will be filled in with default values (though of course an empty record will not result in useful objects).</p>

<p>Note that the resulting objects are <em>not equal</em> to their defining data (even though by default they print as only the defining data). The operation <code class="code">UnderlyingElement</code> can be used to obtain the defining data of such an element.</p>

<p><a id="X79E535CC7B82BA47" name="X79E535CC7B82BA47"></a></p>

<h5>80.9-2 <span class="Heading">Example: ArithmeticElementCreator</span></h5>

<p>As the first example we look at subsets of <span class="SimpleMath">\(\{ 1, \ldots, 4 \}\)</span> and define an "addition" as union and "multiplication" as intersection. These operations are both commutative and we want the resulting elements to know this.</p>

<p>We therefore use the following specification:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># the whole set</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w := [1,2,3,4];</span>
[ 1, 2, 3, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PosetElementSpec :=rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  # name of the new elements</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  ElementName := "PosetOn4",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  # arithmetic operations</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  One := a -&gt; w,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Zero := a -&gt; [],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Multiplication := function(a, b) return Intersection(a, b); end,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Addition := function(a, b) return Union(a, b); end,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  # Mathematical properties of the elements</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  MathInfo := IsCommutativeElement and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              IsAssociativeElement and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              IsAdditivelyCommutativeElement</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mkposet := ArithmeticElementCreator(PosetElementSpec);</span>
function( x ) ... end
</pre></div>

<p>Now we can create new elements, perform arithmetic on them and form domains:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := mkposet([1,2,3]);</span>
[ 1, 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CategoriesOfObject(a);</span>
[ "IsExtAElement", "IsNearAdditiveElement", 
  "IsNearAdditiveElementWithZero", "IsAdditiveElement", 
  "IsExtLElement", "IsExtRElement", "IsMultiplicativeElement", 
  "IsMultiplicativeElementWithOne", "IsAssociativeElement",
  "IsAdditivelyCommutativeElement", "IsCommutativeElement",
  "IsPosetOn4" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a=[1,2,3];</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingElement(a)=[1,2,3];</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b:=mkposet([2,3,4]);</span>
[ 2, 3, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a+b;</span>
[ 1 .. 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a*b;</span>
[ 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s:=Semigroup(a,b);</span>
&lt;commutative semigroup with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(s);</span>
3
</pre></div>

<p>The categories <code class="code">IsPosetOn4</code> and <code class="code">IsPosetOn4Collection</code> can be used to install methods specific to the new objects.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPosetOn4Collection(s);</span>
true
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap79_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap81_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chap14_mj.html">14</a>  <a href="chap15_mj.html">15</a>  <a href="chap16_mj.html">16</a>  <a href="chap17_mj.html">17</a>  <a href="chap18_mj.html">18</a>  <a href="chap19_mj.html">19</a>  <a href="chap20_mj.html">20</a>  <a href="chap21_mj.html">21</a>  <a href="chap22_mj.html">22</a>  <a href="chap23_mj.html">23</a>  <a href="chap24_mj.html">24</a>  <a href="chap25_mj.html">25</a>  <a href="chap26_mj.html">26</a>  <a href="chap27_mj.html">27</a>  <a href="chap28_mj.html">28</a>  <a href="chap29_mj.html">29</a>  <a href="chap30_mj.html">30</a>  <a href="chap31_mj.html">31</a>  <a href="chap32_mj.html">32</a>  <a href="chap33_mj.html">33</a>  <a href="chap34_mj.html">34</a>  <a href="chap35_mj.html">35</a>  <a href="chap36_mj.html">36</a>  <a href="chap37_mj.html">37</a>  <a href="chap38_mj.html">38</a>  <a href="chap39_mj.html">39</a>  <a href="chap40_mj.html">40</a>  <a href="chap41_mj.html">41</a>  <a href="chap42_mj.html">42</a>  <a href="chap43_mj.html">43</a>  <a href="chap44_mj.html">44</a>  <a href="chap45_mj.html">45</a>  <a href="chap46_mj.html">46</a>  <a href="chap47_mj.html">47</a>  <a href="chap48_mj.html">48</a>  <a href="chap49_mj.html">49</a>  <a href="chap50_mj.html">50</a>  <a href="chap51_mj.html">51</a>  <a href="chap52_mj.html">52</a>  <a href="chap53_mj.html">53</a>  <a href="chap54_mj.html">54</a>  <a href="chap55_mj.html">55</a>  <a href="chap56_mj.html">56</a>  <a href="chap57_mj.html">57</a>  <a href="chap58_mj.html">58</a>  <a href="chap59_mj.html">59</a>  <a href="chap60_mj.html">60</a>  <a href="chap61_mj.html">61</a>  <a href="chap62_mj.html">62</a>  <a href="chap63_mj.html">63</a>  <a href="chap64_mj.html">64</a>  <a href="chap65_mj.html">65</a>  <a href="chap66_mj.html">66</a>  <a href="chap67_mj.html">67</a>  <a href="chap68_mj.html">68</a>  <a href="chap69_mj.html">69</a>  <a href="chap70_mj.html">70</a>  <a href="chap71_mj.html">71</a>  <a href="chap72_mj.html">72</a>  <a href="chap73_mj.html">73</a>  <a href="chap74_mj.html">74</a>  <a href="chap75_mj.html">75</a>  <a href="chap76_mj.html">76</a>  <a href="chap77_mj.html">77</a>  <a href="chap78_mj.html">78</a>  <a href="chap79_mj.html">79</a>  <a href="chap80_mj.html">80</a>  <a href="chap81_mj.html">81</a>  <a href="chap82_mj.html">82</a>  <a href="chap83_mj.html">83</a>  <a href="chap84_mj.html">84</a>  <a href="chap85_mj.html">85</a>  <a href="chap86_mj.html">86</a>  <a href="chap87_mj.html">87</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
