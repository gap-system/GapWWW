<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (ref) - Chapter 87: More about Stabilizer Chains</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap87"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chap14_mj.html">14</a>  <a href="chap15_mj.html">15</a>  <a href="chap16_mj.html">16</a>  <a href="chap17_mj.html">17</a>  <a href="chap18_mj.html">18</a>  <a href="chap19_mj.html">19</a>  <a href="chap20_mj.html">20</a>  <a href="chap21_mj.html">21</a>  <a href="chap22_mj.html">22</a>  <a href="chap23_mj.html">23</a>  <a href="chap24_mj.html">24</a>  <a href="chap25_mj.html">25</a>  <a href="chap26_mj.html">26</a>  <a href="chap27_mj.html">27</a>  <a href="chap28_mj.html">28</a>  <a href="chap29_mj.html">29</a>  <a href="chap30_mj.html">30</a>  <a href="chap31_mj.html">31</a>  <a href="chap32_mj.html">32</a>  <a href="chap33_mj.html">33</a>  <a href="chap34_mj.html">34</a>  <a href="chap35_mj.html">35</a>  <a href="chap36_mj.html">36</a>  <a href="chap37_mj.html">37</a>  <a href="chap38_mj.html">38</a>  <a href="chap39_mj.html">39</a>  <a href="chap40_mj.html">40</a>  <a href="chap41_mj.html">41</a>  <a href="chap42_mj.html">42</a>  <a href="chap43_mj.html">43</a>  <a href="chap44_mj.html">44</a>  <a href="chap45_mj.html">45</a>  <a href="chap46_mj.html">46</a>  <a href="chap47_mj.html">47</a>  <a href="chap48_mj.html">48</a>  <a href="chap49_mj.html">49</a>  <a href="chap50_mj.html">50</a>  <a href="chap51_mj.html">51</a>  <a href="chap52_mj.html">52</a>  <a href="chap53_mj.html">53</a>  <a href="chap54_mj.html">54</a>  <a href="chap55_mj.html">55</a>  <a href="chap56_mj.html">56</a>  <a href="chap57_mj.html">57</a>  <a href="chap58_mj.html">58</a>  <a href="chap59_mj.html">59</a>  <a href="chap60_mj.html">60</a>  <a href="chap61_mj.html">61</a>  <a href="chap62_mj.html">62</a>  <a href="chap63_mj.html">63</a>  <a href="chap64_mj.html">64</a>  <a href="chap65_mj.html">65</a>  <a href="chap66_mj.html">66</a>  <a href="chap67_mj.html">67</a>  <a href="chap68_mj.html">68</a>  <a href="chap69_mj.html">69</a>  <a href="chap70_mj.html">70</a>  <a href="chap71_mj.html">71</a>  <a href="chap72_mj.html">72</a>  <a href="chap73_mj.html">73</a>  <a href="chap74_mj.html">74</a>  <a href="chap75_mj.html">75</a>  <a href="chap76_mj.html">76</a>  <a href="chap77_mj.html">77</a>  <a href="chap78_mj.html">78</a>  <a href="chap79_mj.html">79</a>  <a href="chap80_mj.html">80</a>  <a href="chap81_mj.html">81</a>  <a href="chap82_mj.html">82</a>  <a href="chap83_mj.html">83</a>  <a href="chap84_mj.html">84</a>  <a href="chap85_mj.html">85</a>  <a href="chap86_mj.html">86</a>  <a href="chap87_mj.html">87</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap86_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap87.html">[MathJax off]</a></p>
<p><a id="X81F4282081027945" name="X81F4282081027945"></a></p>
<div class="ChapSects"><a href="chap87_mj.html#X81F4282081027945">87 <span class="Heading">More about Stabilizer Chains</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap87_mj.html#X870717BA831A0365">87.1 <span class="Heading">Generalized Conjugation Technique</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap87_mj.html#X8174E19F87C3A8AB">87.2 <span class="Heading">The General Backtrack Algorithm with Ordered Partitions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap87_mj.html#X82E18F38824B5856">87.2-1 <span class="Heading">Internal representation of ordered partitions</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap87_mj.html#X785508067969766B">87.2-2 <span class="Heading">Functions for setting up an R-base</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap87_mj.html#X82427DA47D458224">87.2-3 <span class="Heading">Refinement functions for the backtrack search</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap87_mj.html#X86CCA2B384A74856">87.2-4 <span class="Heading">Functions for meeting ordered partitions</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap87_mj.html#X7CA84E967B053C2C">87.3 <span class="Heading">Stabilizer Chains for Automorphisms Acting on Enumerators</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap87_mj.html#X864007907EA923FB">87.3-1 <span class="Heading">An operation domain for automorphisms</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap87_mj.html#X84A94914876C03F0">87.3-2 <span class="Heading">Enumerators for cosets of characteristic factors</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap87_mj.html#X79B146E9786FE153">87.3-3 <span class="Heading">Making automorphisms act on such enumerators</span></a>
</span>
</div></div>
</div>

<h3>87 <span class="Heading">More about Stabilizer Chains</span></h3>

<p>This chapter contains some rather technical complements to the material handled in the chapters <a href="chap42_mj.html#X80F808307A2D5AB8"><span class="RefLink">42</span></a> and <a href="chap43_mj.html#X85ED46007CED6191"><span class="RefLink">43</span></a>.</p>

<p><a id="X870717BA831A0365" name="X870717BA831A0365"></a></p>

<h4>87.1 <span class="Heading">Generalized Conjugation Technique</span></h4>

<p>The command <code class="code">ConjugateGroup( <var class="Arg">G</var>, <var class="Arg">p</var> )</code> (see <code class="func">ConjugateGroup</code> (<a href="chap39_mj.html#X7E4143A08040BB47"><span class="RefLink">39.2-6</span></a>)) for a permutation group <var class="Arg">G</var> with stabilizer chain equips its result also with a stabilizer chain, namely with the chain of <var class="Arg">G</var> conjugate by <var class="Arg">p</var>. Conjugating a stabilizer chain by a permutation <var class="Arg">p</var> means replacing all the points which appear in the <code class="code">orbit</code> components by their images under <var class="Arg">p</var> and replacing every permutation <var class="Arg">g</var> which appears in a <code class="code">labels</code> or <code class="code">transversal</code> component by its conjugate <span class="SimpleMath">\(g^p\)</span>. The conjugate <span class="SimpleMath">\(g^p\)</span> acts on the mapped points exactly as <var class="Arg">g</var> did on the original points, i.e., <span class="SimpleMath">\((pnt.p). g^p = (pnt.g).p\)</span>. Since the entries in the <code class="code">translabels</code> components are integers pointing to positions of the <code class="code">labels</code> list, the <code class="code">translabels</code> lists just have to be permuted by <var class="Arg">p</var> for the conjugated stabilizer. Then <code class="code">generators</code> is reconstructed as <code class="code">labels{ genlabels }</code> and <code class="code">transversal{ orbit }</code> as <code class="code">labels{ translabels{ orbit } }</code>.</p>

<p>This conjugation technique can be generalized. Instead of mapping points and permutations under the same permutation <var class="Arg">p</var>, it is sometimes desirable (e.g., in the context of permutation group homomorphisms) to map the points with an arbitrary mapping <span class="SimpleMath">\(map\)</span> and the permutations with a homomorphism <span class="SimpleMath">\(hom\)</span> such that the compatibility of the actions is still valid: <span class="SimpleMath">\(map(pnt).hom(g) = map(pnt.g)\)</span>. (Of course the ordinary conjugation is a special case of this, with <span class="SimpleMath">\(map(pnt) = pnt.p\)</span> and <span class="SimpleMath">\(hom(g) = g^p\)</span>.)</p>

<p>In the generalized case, the "conjugated" chain need not be a stabilizer chain for the image of <span class="SimpleMath">\(hom\)</span>, since the "preimage" of the stabilizer of <span class="SimpleMath">\(map(b)\)</span> (where <span class="SimpleMath">\(b\)</span> is a base point) need not fix <span class="SimpleMath">\(b\)</span>, but only fixes the preimage <span class="SimpleMath">\(map^{{-1}}( map(b) )\)</span> setwise. Therefore the method can be applied only to one level and the next stabilizer must be computed explicitly. But if <span class="SimpleMath">\(map\)</span> is injective, we have <span class="SimpleMath">\(map(b).hom(g) = map(b)\)</span> if and only if <span class="SimpleMath">\(b.g = b\)</span>, and if this holds, then <span class="SimpleMath">\(g = w(g_1, \ldots, g_n)\)</span> is a word in the generators <span class="SimpleMath">\(g_1, \ldots, g_n\)</span> of the stabilizer of <span class="SimpleMath">\(b\)</span> and <span class="SimpleMath">\(hom(g) =^* w( hom(g_1), \ldots, hom(g_n) )\)</span> is in the "conjugated" stabilizer. If, more generally, <span class="SimpleMath">\(hom\)</span> is a right inverse to a homomorphism <span class="SimpleMath">\(\varphi\)</span> (i.e., <span class="SimpleMath">\(\varphi(hom(g)) = g\)</span> for all <span class="SimpleMath">\(g\)</span>), equality <span class="SimpleMath">\(*\)</span> holds modulo the kernel of <span class="SimpleMath">\(\varphi\)</span>; in this case the "conjugated" chain can be made into a real stabilizer chain by extending each level with the generators of the kernel and appending a proper stabilizer chain of the kernel at the end. These special cases will occur in the algorithms for permutation group homomorphisms (see <a href="chap40_mj.html#X83702FC27B3C3098"><span class="RefLink">40</span></a>).</p>

<p>To "conjugate" the points (i.e., <code class="code">orbit</code>) and permutations (i.e., <code class="code">labels</code>) of the Schreier tree, a loop is set up over the <code class="code">orbit</code> list constructed during the orbit algorithm, and for each vertex <span class="SimpleMath">\(b\)</span> with unique edge <span class="SimpleMath">\(a(l)b\)</span> ending at <span class="SimpleMath">\(b\)</span>, the label <span class="SimpleMath">\(l\)</span> is mapped with <span class="SimpleMath">\(hom\)</span> and <span class="SimpleMath">\(b\)</span> with <span class="SimpleMath">\(map\)</span>. We assume that the <code class="code">orbit</code> list was built w.r.t. a certain ordering <span class="SimpleMath">\(&lt;\)</span> of the labels, where <span class="SimpleMath">\(l' &lt; l\)</span> means that every point in the orbit was mapped with <span class="SimpleMath">\(l'\)</span> before it was mapped with <span class="SimpleMath">\(l\)</span>. This shape of the <code class="code">orbit</code> list is guaranteed if the Schreier tree is extended only by <code class="func">AddGeneratorsExtendSchreierTree</code> (<a href="chap43_mj.html#X8373007880EBF736"><span class="RefLink">43.11-10</span></a>), and it is then also guaranteed for the "conjugated" Schreier tree. (The ordering of the labels cannot be read from the Schreier tree, however.)</p>

<p>In the generalized case, it can happen that the edge <span class="SimpleMath">\(a(l)b\)</span> bears a label <span class="SimpleMath">\(l\)</span> whose image is "old", i.e., equal to the image of an earlier label <span class="SimpleMath">\(l' &lt; l\)</span>. Because of the compatibility of the actions we then have <span class="SimpleMath">\(map(b) = map(a).hom(l)^{{-1}} = map(a).hom(l')^{{-1}} = map(a{{l'}}^{{-1}})\)</span>, so <span class="SimpleMath">\(map(b)\)</span> is already equal to the image of the vertex <span class="SimpleMath">\(a{{l'}}^{{-1}}\)</span>. This vertex must have been encountered before <span class="SimpleMath">\(b = al^{{-1}}\)</span> because <span class="SimpleMath">\(l' &lt; l\)</span>. We conclude that the image of a label can be "old" only if the vertex at the end of the corresponding edge has an "old" image, too, but then it need not be "conjugated" at all. A similar remark applies to labels which map under <span class="SimpleMath">\(hom\)</span> to the identity.</p>

<p><a id="X8174E19F87C3A8AB" name="X8174E19F87C3A8AB"></a></p>

<h4>87.2 <span class="Heading">The General Backtrack Algorithm with Ordered Partitions</span></h4>

<p>Section <a href="chap43_mj.html#X86C78160854C7F30"><span class="RefLink">43.12</span></a> describes the basic functions for a backtrack search. The purpose of this section is to document how the general backtrack algorithm is implemented in <strong class="pkg">GAP</strong> and which parts you have to modify if you want to write your own backtrack routines.</p>

<p><a id="X82E18F38824B5856" name="X82E18F38824B5856"></a></p>

<h5>87.2-1 <span class="Heading">Internal representation of ordered partitions</span></h5>

<p><strong class="pkg">GAP</strong> represents an ordered partition as a record with the following components.</p>


<dl>
<dt><strong class="Mark"><code class="code">points</code></strong></dt>
<dd><p>a list of all points contained in the partition, such that the points of each cell from lie consecutively,</p>

</dd>
<dt><strong class="Mark"><code class="code">cellno</code></strong></dt>
<dd><p>a list whose <var class="Arg">i</var>th entry is the number of the cell which contains the point <var class="Arg">i</var>,</p>

</dd>
<dt><strong class="Mark"><code class="code">firsts</code></strong></dt>
<dd><p>a list such that <code class="code">points[firsts[<var class="Arg">j</var>]]</code> is the first point in <code class="code">points</code> which is in cell <var class="Arg">j</var>,</p>

</dd>
<dt><strong class="Mark"><code class="code">lengths</code></strong></dt>
<dd><p>a list of the cell lengths.</p>

</dd>
</dl>
<p>Some of the information is redundant, e.g., the <code class="code">lengths</code> could also be read off the <code class="code">firsts</code> list, but since this need not be increasing, it would require some searching. Similar for <code class="code">cellno</code>, which could be replaced by a systematic search of <code class="code">points</code>, keeping track of what cell is currently being traversed. With the above components, the <var class="Arg">m</var>th cell of a partition <var class="Arg">P</var> is expressed as <code class="code"><var class="Arg">P</var>.points{ [ <var class="Arg">P</var>.firsts[<var class="Arg">m</var>] .. <var class="Arg">P</var>.firsts[<var class="Arg">m</var>] + <var class="Arg">P</var>.lengths[<var class="Arg">m</var>] - 1 ] }</code>. The most important operations, however, to be performed upon <var class="Arg">P</var> are the splitting of a cell and the reuniting of the two parts. Following the strategy of J. Leon, this is done as follows:</p>


<dl>
<dt><strong class="Mark">(1)</strong></dt>
<dd><p>The points which make up the cell that is to be split are sorted so that the ones that remain inside occupy positions <code class="code">[ <var class="Arg">P</var>.firsts[<var class="Arg">m</var>] .. <var class="Arg">last</var> ]</code> in the list <code class="code"><var class="Arg">P</var>.points</code> (for a suitable value of <var class="Arg">last</var>).</p>

</dd>
<dt><strong class="Mark">(2)</strong></dt>
<dd><p>The points at positions <code class="code">[ <var class="Arg">last</var> + 1 .. <var class="Arg">P</var>.firsts[<var class="Arg">m</var>] + <var class="Arg">P</var>.lengths[<var class="Arg">m</var>] - 1 ]</code> will form the additional cell. For this new cell requires additional entries are added to the lists <code class="code"><var class="Arg">P</var>.firsts</code> (namely, <code class="code"><var class="Arg">last</var>+1</code>) and <code class="code"><var class="Arg">P</var>.lengths</code> (namely, <code class="code"><var class="Arg">P</var>.firsts[<var class="Arg">m</var>] + <var class="Arg">P</var>.lengths[<var class="Arg">m</var>] - <var class="Arg">last</var> - 1</code>).</p>

</dd>
<dt><strong class="Mark">(3)</strong></dt>
<dd><p>The entries of the sublist <code class="code"><var class="Arg">P</var>.cellno{ [ <var class="Arg">last</var>+1 .. <var class="Arg">P</var>.firsts[<var class="Arg">m</var>] + P.lengths[<var class="Arg">m</var>]-1 ] }</code> must be set to the number of the new cell.</p>

</dd>
<dt><strong class="Mark">(4)</strong></dt>
<dd><p>The entry <code class="code"><var class="Arg">P</var>.lengths[<var class="Arg">m</var>]</code> must be reduced to <code class="code"><var class="Arg">last</var> - <var class="Arg">P</var>.firsts[<var class="Arg">m</var>] + 1</code>.</p>

</dd>
</dl>
<p>Then reuniting the two cells requires only the reversal of steps 2 to 4 above. The list <code class="code"><var class="Arg">P</var>.points</code> need not be rearranged.</p>

<p><a id="X785508067969766B" name="X785508067969766B"></a></p>

<h5>87.2-2 <span class="Heading">Functions for setting up an R-base</span></h5>

<p>This subsection explains some <strong class="pkg">GAP</strong> functions which are local to the library file <code class="file">lib/stbcbckt.gi</code> which contains the code for backtracking in permutation groups. They are mentioned here because you might find them helpful when you want to implement you own backtracking function based on the partition concept. An important argument to most of the functions is the R-base <span class="SimpleMath">\(R\)</span>, which you should regard as a black box. We will tell you how to set it up, how to maintain it and where to pass it as argument, but it is not necessary for you to know its internal representation. However, if you insist to learn the whole story: Here are the record components from which an R-base is made up:</p>


<dl>
<dt><strong class="Mark"><code class="code">domain</code></strong></dt>
<dd><p>the set <span class="SimpleMath">\(\Omega\)</span> on which the group <span class="SimpleMath">\(G\)</span> operates</p>

</dd>
<dt><strong class="Mark"><code class="code">base</code></strong></dt>
<dd><p>the sequence <span class="SimpleMath">\((a_1, \ldots, a_r)\)</span> of base points</p>

</dd>
<dt><strong class="Mark"><code class="code">partition</code></strong></dt>
<dd><p>an ordered partition, initially <span class="SimpleMath">\(\Pi_0\)</span>, this will be refined to <span class="SimpleMath">\(\Pi_1, \ldots, \Pi_r\)</span> during the backtrack algorithm</p>

</dd>
<dt><strong class="Mark"><code class="code">where</code></strong></dt>
<dd><p>a list such that <span class="SimpleMath">\(a_i\)</span> lies in cell number <code class="code">where</code><span class="SimpleMath">\([i]\)</span> of <span class="SimpleMath">\(\Pi_i\)</span></p>

</dd>
<dt><strong class="Mark"><code class="code">rfm</code></strong></dt>
<dd><p>a list whose <span class="SimpleMath">\(i\)</span>th entry is a list of refinements which take <span class="SimpleMath">\(\Sigma_i\)</span> to <span class="SimpleMath">\(\Sigma_{{i+1}}\)</span>; the structure of a refinement is described below</p>

</dd>
<dt><strong class="Mark"><code class="code">chain</code></strong></dt>
<dd><p>a (copy of a) stabilizer chain for <span class="SimpleMath">\(G\)</span> (not if <span class="SimpleMath">\(G\)</span> is a symmetric group)</p>

</dd>
<dt><strong class="Mark"><code class="code">fix</code></strong></dt>
<dd><p>only if <span class="SimpleMath">\(G\)</span> is a symmetric group: a list whose <span class="SimpleMath">\(i\)</span> entry contains <code class="code">Fixcells( </code><span class="SimpleMath">\(\Pi_i\)</span><code class="code"> )</code></p>

</dd>
<dt><strong class="Mark"><code class="code">level</code></strong></dt>
<dd><p>initially equal to <code class="code">chain</code>, this will be changed to chains for the stabilizers <span class="SimpleMath">\(G_{{a_1 \ldots a_i}}\)</span> for <span class="SimpleMath">\(i = 1, \ldots, r\)</span> during the backtrack algorithm; if <span class="SimpleMath">\(G\)</span> is a symmetric group, only the number of moved points is stored for each stabilizer</p>

</dd>
<dt><strong class="Mark"><code class="code">lev</code></strong></dt>
<dd><p>a list whose <span class="SimpleMath">\(i\)</span>th entry remembers the <code class="code">level</code> entry for <span class="SimpleMath">\(G_{{a_1 \ldots a_{{i-1}}}}\)</span></p>

</dd>
<dt><strong class="Mark"><code class="code">level2</code>, <code class="code">lev2</code></strong></dt>
<dd><p>a similar construction for a second group (used in intersection calculations), <code class="keyw">false</code> otherwise. This second group <span class="SimpleMath">\(H\)</span> activated if the R-base is constructed as <code class="code">EmptyRBase( </code><span class="SimpleMath">\([ G, H ], \Omega, \Pi_0\)</span><code class="code"> )</code> (if <span class="SimpleMath">\(G = H\)</span>, <strong class="pkg">GAP</strong> sets <code class="code">level2 = </code><code class="keyw">true</code> instead).</p>

</dd>
<dt><strong class="Mark"><code class="code">nextLevel</code></strong></dt>
<dd><p>this is described below</p>

</dd>
</dl>
<p>As our guiding example, we present code for the function <code class="func">Centralizer</code> (<a href="chap35_mj.html#X7DE33AFC823C7873"><span class="RefLink">35.4-4</span></a>) which calculates the centralizer of an element <span class="SimpleMath">\(g\)</span> in the group <span class="SimpleMath">\(G\)</span>. (The real code is more general and has a few more subtleties.)</p>


<div class="example"><pre>
Pi_0 := TrivialPartition( omega );
R := EmptyRBase( G, omega, Pi_0 );
R.nextLevel := function( Pi, rbase )
local  fix, p, q, where;
NextRBasePoint( Pi, rbase );
fix := Fixcells( Pi );
for p  in fix  do
  q := p ^ g;
  where := IsolatePoint( Pi, q );
  if where &lt;&gt; false  then
    Add( fix, q );
    ProcessFixpoint( R, q );
    AddRefinement( R, "Centralizer", [ Pi.cellno[ p ], q, where ] );
    if Pi.lengths[ where ] = 1  then
      p := FixpointCellNo( Pi, where );
      ProcessFixpoint( R, p );
      AddRefinement( R, "ProcessFixpoint", [ p, where ] );
    fi;
  fi;
od;
end;

return PartitionBacktrack(
  G,
  c -&gt; g ^ c = g,
  false,
  R,
  [ Pi_0, g ],
  L, R );
</pre></div>

<p>The list numbers below refer to the line numbers of the code above.</p>


<dl>
<dt><strong class="Mark">1.</strong></dt>
<dd><p><code class="code">omega</code> is the set on which <code class="code">G</code> acts and <code class="code">Pi_0</code> is the first member of the decreasing sequence of partitions mentioned in <a href="chap43_mj.html#X86C78160854C7F30"><span class="RefLink">43.12</span></a>. We set <code class="code">Pi_0 = omega</code>, which is constructed as <code class="code">TrivialPartition( omega )</code>, but we could have started with a finer partition, e.g., into unions of <code class="code">g</code>-cycles of the same length.</p>

</dd>
<dt><strong class="Mark">2.</strong></dt>
<dd><p>This statement sets up the R-base in the variable <code class="code">R</code>.</p>

</dd>
<dt><strong class="Mark">3.-21.</strong></dt>
<dd><p>These lines define a function <code class="code">R.nextLevel</code> which is called whenever an additional member in the sequence <code class="code">Pi_0 </code><span class="SimpleMath">\(\geq \Pi_1 \geq \ldots\)</span> of partitions is needed. If <span class="SimpleMath">\(\Pi_i\)</span> does not yet contain enough base points in one-point cells, <strong class="pkg">GAP</strong> will call <code class="code">R.nextLevel( </code><span class="SimpleMath">\(\Pi_i,\)</span><code class="code"> R )</code>, and this function will choose a new base point <span class="SimpleMath">\(a_{{i+1}}\)</span>, refine <span class="SimpleMath">\(\Pi_i\)</span> to <span class="SimpleMath">\(\Pi_{{i+1}}\)</span> (thereby <em>changing</em> the first argument) and store all necessary information in <code class="code">R</code>.</p>

</dd>
<dt><strong class="Mark">5.</strong></dt>
<dd><p>This statement selects a new base point <span class="SimpleMath">\(a_{{i+1}}\)</span>, which is not yet in a one-point cell of <span class="SimpleMath">\(\Pi\)</span> and still moved by the stabilizer <span class="SimpleMath">\(G_{{a_1 \ldots a_i}}\)</span> of the earlier base points. If certain points of <code class="code">omega</code> should be preferred as base point (e.g., because they belong to long cycles of <code class="code">g</code>), a list of points starting with the most wanted ones, can be given as an optional third argument to <code class="code">NextRBasePoint</code> (actually, this is done in the real code for <code class="func">Centralizer</code> (<a href="chap35_mj.html#X7DE33AFC823C7873"><span class="RefLink">35.4-4</span></a>)).</p>

</dd>
<dt><strong class="Mark">6.</strong></dt>
<dd><p><code class="code">Fixcells( </code><span class="SimpleMath">\(\Pi\)</span><code class="code"> )</code> returns the list of points in one-point cells of <span class="SimpleMath">\(\Pi\)</span> (ordered as the cells are ordered in <span class="SimpleMath">\(\Pi\)</span>).</p>

</dd>
<dt><strong class="Mark">7.</strong></dt>
<dd><p>For every point <span class="SimpleMath">\(p \in fix\)</span>, if we know the image <span class="SimpleMath">\(p\)</span><code class="code">^</code><span class="SimpleMath">\(g\)</span> under <span class="SimpleMath">\(c \in C_G(e)\)</span>, we also know <span class="SimpleMath">\(( p\)</span><code class="code">^</code><span class="SimpleMath">\(g )\)</span><code class="code">^</code><span class="SimpleMath">\(c = ( p\)</span><code class="code">^</code><span class="SimpleMath">\(c )\)</span><code class="code">^</code><span class="SimpleMath">\(g\)</span>. We therefore want to isolate these extra points in <span class="SimpleMath">\(\Pi\)</span>.</p>

</dd>
<dt><strong class="Mark">9.</strong></dt>
<dd><p>This statement puts point <span class="SimpleMath">\(q\)</span> in a cell of its own, returning in <code class="code">where</code> the number of the cell of <span class="SimpleMath">\(\Pi\)</span> from which <span class="SimpleMath">\(q\)</span> was taken. If <span class="SimpleMath">\(q\)</span> was already the only point in its cell, <code class="code">where = </code><code class="keyw">false</code> instead.</p>

</dd>
<dt><strong class="Mark">12.</strong></dt>
<dd><p>This command does the necessary bookkeeping for the extra base point <span class="SimpleMath">\(q\)</span>: It prescribes <span class="SimpleMath">\(q\)</span> as next base in the stabilizer chain for <span class="SimpleMath">\(G\)</span> (needed, e.g., in line 5) and returns <code class="keyw">false</code> if <span class="SimpleMath">\(q\)</span> was already fixed the stabilizer of the earlier base points (and <code class="keyw">true</code> otherwise; this is not used here). Another call to <code class="code">ProcessFixpoint</code> like this was implicitly made by the function <code class="code">NextRBasePoint</code> to register the chosen base point. By contrast, the point <span class="SimpleMath">\(q\)</span> was not chosen this way, so <code class="code">ProcessFixpoint</code> must be called explicitly for <span class="SimpleMath">\(q\)</span>.</p>

</dd>
<dt><strong class="Mark">13.</strong></dt>
<dd><p>This statement registers the function which will be used during the backtrack search to perform the corresponding refinements on the "image partition" <span class="SimpleMath">\(\Sigma_i\)</span> (to yield the refined <span class="SimpleMath">\(\Sigma_{{i+1}}\)</span>). After choosing an image <span class="SimpleMath">\(b_{{i+1}}\)</span> for the base point <span class="SimpleMath">\(a_{{i+1}}\)</span>, <strong class="pkg">GAP</strong> will compute <span class="SimpleMath">\(\Sigma_i \wedge (\{ b_{{i+1}} \}, \Omega \setminus \{ b_{{i+1}} \})\)</span> and store this partition in <span class="SimpleMath">\(I\)</span><code class="code">.partition</code>, where <span class="SimpleMath">\(I\)</span> is a black box similar to <span class="SimpleMath">\(R\)</span>, but corresponding to the current "image partition" (hence it is an "R-image" in analogy to the R-base). Then <strong class="pkg">GAP</strong> will call the function <code class="code">Refinements.Centralizer( R, I, Pi.cellno[ p ], p, where )</code>, with the then current values of <span class="SimpleMath">\(R\)</span> and <span class="SimpleMath">\(I\)</span>, but where <span class="SimpleMath">\(\Pi\)</span><code class="code">.cellno</code><span class="SimpleMath">\([ p ]\)</span>, <span class="SimpleMath">\(p\)</span>, <code class="code">where</code> still have the values they have at the time of this <code class="code">AddRefinement</code> command. This function call will further refine <span class="SimpleMath">\(I\)</span><code class="code">.partition</code> to yield <span class="SimpleMath">\(\Sigma_{{i+1}}\)</span> as it is programmed in the function <code class="code">Refinements.Centralizer</code>, which is described below. (The global variable <code class="code">Refinements</code> is a record which contains all refinement functions for all backtracking procedures.)</p>

</dd>
<dt><strong class="Mark">14.-19.</strong></dt>
<dd><p>If the cell from which <span class="SimpleMath">\(q\)</span> was taken out had only two points, we now have an additional one-point cell. This condition is checked in line 13 and if it is true, this extra fixpoint <span class="SimpleMath">\(p\)</span> is taken (line 15), processed like <span class="SimpleMath">\(q\)</span> before (line 16) and is then (line 17) passed to another refinement function <code class="code">Refinements.ProcessFixpoint( R, I, p, where )</code>, which is also described below.</p>

</dd>
<dt><strong class="Mark">23.-29.</strong></dt>
<dd><p>This command starts the backtrack search. Its result will be the centralizer as a subgroup of <span class="SimpleMath">\(G\)</span>. Its arguments are</p>

</dd>
<dt><strong class="Mark">24.</strong></dt>
<dd><p>the group we want to run through,</p>

</dd>
<dt><strong class="Mark">25.</strong></dt>
<dd><p>the property we want to test, as a <strong class="pkg">GAP</strong> function,</p>

</dd>
<dt><strong class="Mark">26.</strong></dt>
<dd><p><code class="keyw">false</code> if we are looking for a subgroup, <code class="keyw">true</code> in the case of a representative search (when the result would be one representative),</p>

</dd>
<dt><strong class="Mark">27.</strong></dt>
<dd><p>the R-base,</p>

</dd>
<dt><strong class="Mark">28.</strong></dt>
<dd><p>a list of data, to be stored in <span class="SimpleMath">\(I\)</span><code class="code">.data</code>, which has in position 1 the first member <span class="SimpleMath">\(\Sigma_0\)</span> of the decreasing sequence of "image partitions" mentioned in <a href="chap43_mj.html#X86C78160854C7F30"><span class="RefLink">43.12</span></a>. In the centralizer example, position 2 contains the element that is to be centralized. In the case of a representative search, i.e., a conjugacy test <span class="SimpleMath">\(g\)</span><code class="code">^</code><span class="SimpleMath">\(c\)</span><code class="code"> ?= </code><span class="SimpleMath">\(h\)</span>, we would have <span class="SimpleMath">\(h\)</span> instead of <span class="SimpleMath">\(g\)</span> here, and possibly a <span class="SimpleMath">\(\Sigma_0\)</span> different from <span class="SimpleMath">\(\Pi_0\)</span> (e.g., a partition into unions of <span class="SimpleMath">\(h\)</span>-cycles of same length).</p>

</dd>
<dt><strong class="Mark">29.</strong></dt>
<dd><p>two subgroups <span class="SimpleMath">\(L \leq C_G(g)\)</span> and <span class="SimpleMath">\(R \leq C_G(h)\)</span> known in advance (we have <span class="SimpleMath">\(L = R\)</span> in the centralizer case).</p>

</dd>
</dl>
<p><a id="X82427DA47D458224" name="X82427DA47D458224"></a></p>

<h5>87.2-3 <span class="Heading">Refinement functions for the backtrack search</span></h5>

<p>The last subsection showed how the refinement process leading from <span class="SimpleMath">\(\Pi_i\)</span> to <span class="SimpleMath">\(\Pi_{{i+1}}\)</span> is coded in the function <span class="SimpleMath">\(R\)</span><code class="code">.nextLevel</code>, this has to be executed once the base point <span class="SimpleMath">\(a_{{i+1}}\)</span>. The analogous refinement step from <span class="SimpleMath">\(\Sigma_i\)</span> to <span class="SimpleMath">\(\Sigma_{{i+1}}\)</span> must be performed for each choice of an image <span class="SimpleMath">\(b_{{i+1}}\)</span> for <span class="SimpleMath">\(a_{{i+1}}\)</span>, and it will depend on the corresponding value of <span class="SimpleMath">\(\Sigma_i \wedge (\{b_{{i+1}}\}, \Omega \setminus \{b_{{i+1}}\})\)</span>. But before we can continue our centralizer example, we must, for the interested reader, document the record components of the other black box <span class="SimpleMath">\(I\)</span>, as we did above for the R-base black box <span class="SimpleMath">\(R\)</span>. Most of the components change as <strong class="pkg">GAP</strong> walks up and down the levels of the search tree.</p>


<dl>
<dt><strong class="Mark"><code class="code">data</code></strong></dt>
<dd><p>this will be mentioned below</p>

</dd>
<dt><strong class="Mark"><code class="code">depth</code></strong></dt>
<dd><p>the level <span class="SimpleMath">\(i\)</span> in the search tree of the current node <span class="SimpleMath">\(\Sigma_i\)</span></p>

</dd>
<dt><strong class="Mark"><code class="code">bimg</code></strong></dt>
<dd><p>a list of images of the points in <span class="SimpleMath">\(R\)</span><code class="code">.base</code></p>

</dd>
<dt><strong class="Mark"><code class="code">partition</code></strong></dt>
<dd><p>the partition <span class="SimpleMath">\(\Sigma_i\)</span> of the current node</p>

</dd>
<dt><strong class="Mark"><code class="code">level</code></strong></dt>
<dd><p>the stabilizer chain <span class="SimpleMath">\(R\)</span><code class="code">.lev</code><span class="SimpleMath">\([i]\)</span> at the current level</p>

</dd>
<dt><strong class="Mark"><code class="code">perm</code></strong></dt>
<dd><p>a permutation mapping <code class="code">Fixcells</code><span class="SimpleMath">\(( \Pi_i )\)</span> to <code class="code">Fixcells</code><span class="SimpleMath">\(( \Sigma_i )\)</span>; this implies mapping <span class="SimpleMath">\((a_1, \ldots, a_i)\)</span> to <span class="SimpleMath">\((b_1, \ldots, b_i)\)</span></p>

</dd>
<dt><strong class="Mark"><code class="code">level2</code>, <code class="code">perm2</code></strong></dt>
<dd><p>a similar construction for the second stabilizer chain, <code class="keyw">false</code> otherwise (and <code class="keyw">true</code> if <span class="SimpleMath">\(R\)</span><code class="code">.level2 = </code><code class="keyw">true</code>)</p>

</dd>
</dl>
<p>As declared in the above code for <code class="func">Centralizer</code> (<a href="chap35_mj.html#X7DE33AFC823C7873"><span class="RefLink">35.4-4</span></a>), the refinement is performed by the function <code class="code">Refinement.Centralizer</code><span class="SimpleMath">\(( R, I, \Pi\)</span><code class="code">.cellno</code><span class="SimpleMath">\([p], p, where )\)</span>. The functions in the record <code class="code">Refinement</code> always take two additional arguments before the ones specified in the <code class="code">AddRefinement</code> call (in line 13 above), namely the R-base <span class="SimpleMath">\(R\)</span> and the current value <span class="SimpleMath">\(I\)</span> of the "R-image". In our example, <span class="SimpleMath">\(p\)</span> is a fixpoint of <span class="SimpleMath">\(\Pi = \Pi_i \wedge (\{ a_{{i+1}} \}, \Omega \setminus \{ a_{{i+1}} \})\)</span> such that <span class="SimpleMath">\(where = \Pi\)</span><code class="code">.cellno</code><span class="SimpleMath">\([ p^g ]\)</span>. The <code class="code">Refinement</code> functions must return <code class="keyw">false</code> if the refinement is unsuccessful (e.g., because it leads to <span class="SimpleMath">\(\Sigma_{{i+1}}\)</span> having different cell sizes from <span class="SimpleMath">\(\Pi_{{i+1}}\)</span>) and <code class="keyw">true</code> otherwise. Our particular function looks like this.</p>


<div class="example"><pre>
Refinements.Centralizer := function( R, I, cellno, p, where )
local  Sigma, q;
Sigma := I.partition;
q := FixpointCellNo( Sigma, cellno ) ^ I.data[ 2 ];
return IsolatePoint( Sigma, q ) = where and ProcessFixpoint( I, p, q );
end;
</pre></div>

<p>The list numbers below refer to the line numbers of the code immediately above.</p>


<dl>
<dt><strong class="Mark">3.</strong></dt>
<dd><p>The current value of <span class="SimpleMath">\(\Sigma_i \wedge (\{ b_{{i+1}} \}, \Omega \setminus \{ b_{{i+1}} \})\)</span> is always found in <span class="SimpleMath">\(I\)</span><code class="code">.partition</code>.</p>

</dd>
<dt><strong class="Mark">4.</strong></dt>
<dd><p>The image of the only point in cell number <span class="SimpleMath">\(cellno = \Pi_i\)</span><code class="code">.cellno</code><span class="SimpleMath">\([ p ]\)</span> in <span class="SimpleMath">\(\Sigma\)</span> under <span class="SimpleMath">\(g = I\)</span><code class="code">.data</code><span class="SimpleMath">\([ 2 ]\)</span> is calculated.</p>

</dd>
<dt><strong class="Mark">5.</strong></dt>
<dd><p>The function returns <code class="keyw">true</code> only if the image <span class="SimpleMath">\(q\)</span> has the same cell number in <span class="SimpleMath">\(\Sigma\)</span> as <span class="SimpleMath">\(p\)</span> had in <span class="SimpleMath">\(\Pi\)</span> (i.e., <span class="SimpleMath">\(where\)</span>) and if <span class="SimpleMath">\(q\)</span> can be prescribed as an image for <span class="SimpleMath">\(p\)</span> under the coset of the stabilizer <span class="SimpleMath">\(G_{{a_1 \ldots a_{{i+1}}}}.c\)</span> where <span class="SimpleMath">\(c \in G\)</span> is an (already constructed) element mapping the earlier base points <span class="SimpleMath">\(a_1, \ldots, a_{{i+1}}\)</span> to the already chosen images <span class="SimpleMath">\(b_1, \ldots, b_{{i+1}}\)</span>. This latter condition is tested by <code class="code">ProcessFixpoint</code><span class="SimpleMath">\(( I, p, q )\)</span> which, if successful, also does the necessary bookkeeping in <span class="SimpleMath">\(I\)</span>. In analogy to the remark about line 12 in the program above, the chosen image <span class="SimpleMath">\(b_{{i+1}}\)</span> for the base point <span class="SimpleMath">\(a_{{i+1}}\)</span> has already been processed implicitly by the function <code class="code">PartitionBacktrack</code>, and this processing includes the construction of an element <span class="SimpleMath">\(c \in G\)</span> which maps <code class="code">Fixcells</code><span class="SimpleMath">\(( \Pi_i )\)</span> to <code class="code">Fixcells</code><span class="SimpleMath">\(( \Sigma_i )\)</span> and <span class="SimpleMath">\(a_{{i+1}}\)</span> to <span class="SimpleMath">\(b_{{i+1}}\)</span>. By contrast, the extra fixpoints <span class="SimpleMath">\(p\)</span> and <span class="SimpleMath">\(q\)</span> in <span class="SimpleMath">\(\Pi_{{i+1}}\)</span> and <span class="SimpleMath">\(\Sigma_{{i+1}}\)</span> were not chosen automatically, so they require an explicit call of <code class="code">ProcessFixpoint</code>, which replaces the element <span class="SimpleMath">\(c\)</span> by some <span class="SimpleMath">\(c'.c\)</span> (with <span class="SimpleMath">\(c' \in G_{{a_1 \ldots a_{{i+1}}}}\)</span>) which in addition maps <span class="SimpleMath">\(p\)</span> to <span class="SimpleMath">\(q\)</span>, or returns <code class="keyw">false</code> if this is impossible.</p>

</dd>
</dl>
<p>You should now be able to guess what <code class="code">Refinements.ProcessFixpoint</code><span class="SimpleMath">\(( R, I, p, where )\)</span> does: it simply returns <code class="code">ProcessFixpoint</code><span class="SimpleMath">\(( I, p, \)</span><code class="code">FixpointCellNo</code><span class="SimpleMath">\(( I\)</span><code class="code">.partition</code><span class="SimpleMath">\(, where ) )\)</span>.</p>

<p><em>Summary.</em></p>

<p>When you write your own backtrack functions using the partition technique, you have to supply an R-base, including a component <code class="code">nextLevel</code>, and the functions in the <code class="code">Refinements</code> record which you need. Then you can start the backtrack by passing the R-base and the additional data (for the <code class="code">data</code> component of the "R-image") to <code class="code">PartitionBacktrack</code>.</p>

<p><a id="X86CCA2B384A74856" name="X86CCA2B384A74856"></a></p>

<h5>87.2-4 <span class="Heading">Functions for meeting ordered partitions</span></h5>

<p>A kind of refinement that occurs in particular in the normalizer calculation involves computing the meet of <span class="SimpleMath">\(\Pi\)</span> (cf. lines 6ff. above) with an arbitrary other partition <span class="SimpleMath">\(\Lambda\)</span>, not just with one point. To do this efficiently, <strong class="pkg">GAP</strong> uses the following two functions.</p>

<p><code class="code">StratMeetPartition( </code><span class="SimpleMath">\(R\)</span>, <span class="SimpleMath">\(\Pi\)</span>, <span class="SimpleMath">\(\Lambda\)</span> <code class="code">[</code>, <span class="SimpleMath">\(g\)</span> <code class="code">] )</code></p>

<p><code class="code">MeetPartitionStrat( </code><span class="SimpleMath">\(R\)</span>, <span class="SimpleMath">\(I\)</span><code class="code">{, </code><span class="SimpleMath">\(\Lambda'\)</span><code class="code">}[, {</code><span class="SimpleMath">\(g'\)</span><code class="code">}]</code>, <span class="SimpleMath">\(strat\)</span> <code class="code">)</code></p>

<p>Such a <code class="code">StratMeetPartition</code> command would typically appear in the function call <span class="SimpleMath">\(R\)</span><code class="code">.nextLevel</code><span class="SimpleMath">\(( \Pi, R )\)</span> (during the refinement of <span class="SimpleMath">\(\Pi_i\)</span> to <span class="SimpleMath">\(\Pi_{{i+1}}\)</span>). This command replaces <span class="SimpleMath">\(\Pi\)</span> by <span class="SimpleMath">\(\Pi \wedge \Lambda\)</span> (thereby <em>changing</em> the second argument) and returns a "meet strategy" <span class="SimpleMath">\(strat\)</span>. This is (for us) a black box which serves two purposes: First, it allows <strong class="pkg">GAP</strong> to calculate faster the corresponding meet <span class="SimpleMath">\(\Sigma \wedge \Lambda'\)</span>, which must then appear in a <code class="code">Refinements</code> function (during the refinement of <span class="SimpleMath">\(\Sigma_i\)</span> to <span class="SimpleMath">\(\Sigma_{{i+1}}\)</span>). It is faster to compute <span class="SimpleMath">\(\Sigma \wedge \Lambda'\)</span> with the "meet strategy" of <span class="SimpleMath">\(\Pi \wedge \Lambda\)</span> because if the refinement of <span class="SimpleMath">\(\Sigma\)</span> is successful at all, the intersection of a cell from the left hand side of the <span class="SimpleMath">\(\wedge\)</span> sign with a cell from the right hand side must have the same size in both cases (and <span class="SimpleMath">\(strat\)</span> records these sizes, so that only non-empty intersections must be calculated for <span class="SimpleMath">\(\Sigma \wedge \Lambda'\)</span>). Second, if there is a discrepancy between the behaviour prescribed by <span class="SimpleMath">\(strat\)</span> and the behaviour observed when refining <span class="SimpleMath">\(\Sigma\)</span>, the refinement can immediately be abandoned.</p>

<p>On the other hand, if you only want to meet a partition <span class="SimpleMath">\(\Pi\)</span> with <span class="SimpleMath">\(\Lambda\)</span> for a one-time use, without recording a strategy, you can simply type <code class="code">StratMeetPartition</code><span class="SimpleMath">\(( \Pi, \Lambda )\)</span> as in the following example, which also demonstrates some other partition-related commands.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P := Partition( [[1,2],[3,4,5],[6]] );;  Cells( P );</span>
[ [ 1, 2 ], [ 3, 4, 5 ], [ 6 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := Partition( OnTuplesTuples( last, (1,3,6) ) );;  Cells( Q );</span>
[ [ 3, 2 ], [ 6, 4, 5 ], [ 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StratMeetPartition( P, Q );</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># The ``meet strategy'' was not recorded, ignore this result.</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Cells( P );</span>
[ [ 1 ], [ 5, 4 ], [ 6 ], [ 2 ], [ 3 ] ]
</pre></div>

<p>You can even say <code class="code">StratMeetPartition</code><span class="SimpleMath">\(( \Pi, \Delta )\)</span> where <span class="SimpleMath">\(\Delta\)</span> is simply a subset of <span class="SimpleMath">\(\Omega\)</span>, it will then be interpreted as the partition <span class="SimpleMath">\((\Delta, \Omega \setminus \Delta)\)</span>.</p>

<p><strong class="pkg">GAP</strong> makes use of the advantages of a "meet strategy" if the refinement function in <code class="code">Refinements</code> contains a <code class="code">MeetPartitionStrat</code> command where <span class="SimpleMath">\(strat\)</span> is the "meet strategy" calculated by <code class="code">StratMeetPartition</code> before. Such a command replaces <span class="SimpleMath">\(I\)</span><code class="code">.partition</code> by its meet with <span class="SimpleMath">\(\Lambda'\)</span>, again changing the argument <span class="SimpleMath">\(I\)</span>. The necessary reversal of these changes when backtracking from a node (and prescribing the next possible image for a base point) is automatically done by the function <code class="code">PartitionBacktrack</code>.</p>

<p>In all cases, an additional argument <span class="SimpleMath">\(g\)</span> means that the meet is to be taken not with <span class="SimpleMath">\(\Lambda\)</span>, but instead with <span class="SimpleMath">\(\Lambda.{{g^{{-1}}}}\)</span>, where operation on ordered partitions is meant cellwise (and setwise on each cell). (Analogously for the primed arguments.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P := Partition( [[1,2],[3,4,5],[6]] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StratMeetPartition( P, P, (1,6,3) );;  Cells( P );</span>
[ [ 1 ], [ 5, 4 ], [ 6 ], [ 2 ], [ 3 ] ]
</pre></div>

<p>Note that <span class="SimpleMath">\(P.(1,3,6) = Q\)</span>.</p>

<p><a id="X7CA84E967B053C2C" name="X7CA84E967B053C2C"></a></p>

<h4>87.3 <span class="Heading">Stabilizer Chains for Automorphisms Acting on Enumerators</span></h4>

<p>This section describes a way of representing the automorphism group of a group as permutation group, following <a href="chapBib_mj.html#biBSims97">[Sim97]</a>. The code however is not yet included in the <strong class="pkg">GAP</strong> library.</p>

<p>In this section we present an example in which objects we already know (namely, automorphisms of solvable groups) are equipped with the permutation-like operations <code class="code">^</code> and <code class="code">/</code> for action on positive integers. To achieve this, we must define a new type of objects which behave like permutations but are represented as automorphisms acting on an enumerator. Our goal is to generalize the Schreier-Sims algorithm for construction of a stabilizer chain to groups of such new automorphisms.</p>

<p><a id="X864007907EA923FB" name="X864007907EA923FB"></a></p>

<h5>87.3-1 <span class="Heading">An operation domain for automorphisms</span></h5>

<p>The idea we describe here is due to C. Sims. We consider a group <span class="SimpleMath">\(A\)</span> of automorphisms of a group <span class="SimpleMath">\(G\)</span>, given by generators, and we would like to know its order. Of course we could follow the strategy of the Schreier-Sims algorithm (described in <a href="chap43_mj.html#X7FA58C3A8283F3BD"><span class="RefLink">43.6</span></a>) for <span class="SimpleMath">\(A\)</span> acting on <span class="SimpleMath">\(G\)</span>. This would involve a call of <code class="code">StabChainStrong( EmptyStabChain( [], One( <var class="Arg">A</var> ) ), GroupGenerators( <var class="Arg">A</var> ) )</code> where <code class="code">StabChainStrong</code> is a function as the one described in the pseudo-code below:</p>


<div class="example"><pre>
StabChainStrong := function( S, newgens )
  Extend the Schreier tree of S with newgens.
  for sch  in  Schreier generators  do
    if not sch in S.stabilizer  then
      StabChainStrong( S.stabilizer, [ sch ] );
    fi;
  od;
end;
</pre></div>

<p>The membership test <span class="SimpleMath">\(sch \notin S\)</span><code class="code">.stabilizer</code> can be performed because the stabilizer chain of <span class="SimpleMath">\(S\)</span><code class="code">.stabilizer</code> is already correct at that moment. We even know a base in advance, namely any generating set for <span class="SimpleMath">\(G\)</span>. Fix such a generating set <span class="SimpleMath">\((g_1, \ldots, g_d)\)</span> and observe that this base is generally very short compared to the degree <span class="SimpleMath">\(|G|\)</span> of the operation. The problem with the Schreier-Sims algorithm, however, is then that the length of the first basic orbit <span class="SimpleMath">\(g_1.A\)</span> would already have the magnitude of <span class="SimpleMath">\(|G|\)</span>, and the basic orbits at deeper levels would not be much shorter. For the advantage of a short base we pay the high price of long basic orbits, since the product of the (few) basic orbit lengths must equal <span class="SimpleMath">\(|A|\)</span>. Such long orbits make the Schreier-Sims algorithm infeasible, so we have to look for a longer base with shorter basic orbits.</p>

<p>Assume that <span class="SimpleMath">\(G\)</span> is solvable and choose a characteristic series with elementary abelian factors. For the sake of simplicity we assume that <span class="SimpleMath">\(N &lt; G\)</span> is an elementary abelian characteristic subgroup with elementary abelian factor group <span class="SimpleMath">\(G/N\)</span>. Since <span class="SimpleMath">\(N\)</span> is characteristic, <span class="SimpleMath">\(A\)</span> also acts as a group of automorphisms on the factor group <span class="SimpleMath">\(G/N\)</span>, but of course not necessarily faithfully. To retain a faithful action, we let <span class="SimpleMath">\(A\)</span> act on the disjoint union <span class="SimpleMath">\(G/N\)</span> with <span class="SimpleMath">\(G\)</span>, and choose as base <span class="SimpleMath">\((g_1 N, \ldots, g_d N, g_1, \ldots, g_d)\)</span>. Now the first <span class="SimpleMath">\(d\)</span> basic orbits lie inside <span class="SimpleMath">\(G/N\)</span> and can have length at most <span class="SimpleMath">\([G:N]\)</span>. Since the base points <span class="SimpleMath">\(g_1 N, \ldots, g_d N\)</span> form a generating set for <span class="SimpleMath">\(G/N\)</span>, their iterated stabilizer <span class="SimpleMath">\(A^{(d+1)}\)</span> acts trivially on the factor group <span class="SimpleMath">\(G/N\)</span>, i.e., it leaves the cosets <span class="SimpleMath">\(g_i N\)</span> invariant. Accordingly, the next <span class="SimpleMath">\(d\)</span> basic orbits lie inside <span class="SimpleMath">\(g_i N\)</span> (for <span class="SimpleMath">\(i = 1, \ldots, d\)</span>) and can have length at most <span class="SimpleMath">\(|N|\)</span>.</p>

<p>Generalizing this method to a characteristic series <span class="SimpleMath">\(G = N_0 &gt; N_1 &gt; \ldots &gt; N_l = \{ 1 \}\)</span> of length <span class="SimpleMath">\(l &gt; 2\)</span>, we can always find a base of length <span class="SimpleMath">\(l.d\)</span> such that each basic orbit is contained in a coset of a characteristic factor, i.e. in a set of the form <span class="SimpleMath">\(g_i N_{{j-1}} / N_j\)</span> (where <span class="SimpleMath">\(g_i\)</span> is one of the generators of <span class="SimpleMath">\(G\)</span> and <span class="SimpleMath">\(1 \leq j \leq l\)</span>). In particular, the length of the basic orbits is bounded by the size of the corresponding characteristic factors. To implement a Schreier-Sims algorithm for such a base, we must be able to let automorphisms act on cosets of characteristic factors <span class="SimpleMath">\(g_i N_{{j-1}} / N_j\)</span>, for varying <span class="SimpleMath">\(i\)</span> and <span class="SimpleMath">\(j\)</span>. We would like to translate each such action into an action on <span class="SimpleMath">\(\{ 1, \ldots, [ N_{{j-1}}:N_j] \}\)</span>, because then we need not enumerate the operation domain, which is the disjoint union of <span class="SimpleMath">\(G / N_1\)</span>, <span class="SimpleMath">\(G / N_2 \ldots G / N_l\)</span>, as a whole. Enumerating it as a whole would result in basic orbits like <code class="code">orbit</code><span class="SimpleMath">\( \subseteq \{ 1001, \ldots, 1100 \}\)</span> with a <code class="code">transversal</code> list whose first 1000 entries would be unbound, but still require 4 bytes of memory each (see <a href="chap43_mj.html#X81D7FCE47AC7F942"><span class="RefLink">43.9</span></a>).</p>

<p>Identifying each coset <span class="SimpleMath">\(g_i N_{{j-1}} / N_j\)</span> into <span class="SimpleMath">\(\{ 1, \ldots, [N_{{j-1}}:N_j] \}\)</span> of course means that we have to change the action of the automorphisms on every level of the stabilizer chain. Such flexibility is not possible with permutations because their effect on positive integers is "hardwired" into them, but we can install new operations for automorphisms.</p>

<p><a id="X84A94914876C03F0" name="X84A94914876C03F0"></a></p>

<h5>87.3-2 <span class="Heading">Enumerators for cosets of characteristic factors</span></h5>

<p>So far we have not used the fact that the characteristic factors are elementary abelian, but we will do so from here on. Our first task is to implement an enumerator (see <code class="func">AsList</code> (<a href="chap30_mj.html#X8289FCCC8274C89D"><span class="RefLink">30.3-8</span></a>) and <a href="chap21_mj.html#X7EA3ACE27E43D174"><span class="RefLink">21.23</span></a>) for a coset of a characteristic factor in a solvable group <span class="SimpleMath">\(G\)</span>. We assume that such a coset <span class="SimpleMath">\(g N/M\)</span> is given by</p>


<dl>
<dt><strong class="Mark">(1)</strong></dt>
<dd><p>a pcgs for the group <span class="SimpleMath">\(G\)</span> (see <code class="func">Pcgs</code> (<a href="chap45_mj.html#X84C3750C7A4EEC34"><span class="RefLink">45.2-1</span></a>)), let <span class="SimpleMath">\(n = \)</span><code class="code">Length( </code><span class="SimpleMath">\(pcgs\)</span><code class="code"> )</code>;</p>

</dd>
<dt><strong class="Mark">(2)</strong></dt>
<dd><p>a range <span class="SimpleMath">\(range = [ start .. stop ]\)</span> indicating that <span class="SimpleMath">\(N = \langle pcgs\{ [ start .. n ] \} \rangle\)</span> and <span class="SimpleMath">\(M = \langle pcgs\{ [ stop + 1 .. n ] \} \rangle\)</span>, i.e., the cosets of <span class="SimpleMath">\(pcgs\{ range \}\)</span> form a base for the vector space <span class="SimpleMath">\(N/M\)</span>;</p>

</dd>
<dt><strong class="Mark">(3)</strong></dt>
<dd><p>the representative <span class="SimpleMath">\(g\)</span>.</p>

</dd>
</dl>
<p>We first define a new representation for such enumerators and then construct them by simply putting these three pieces of data into a record object. The enumerator should behave as a list of group elements (representing cosets modulo <span class="SimpleMath">\(M\)</span>), consequently, its family will be the family of the <span class="SimpleMath">\(pcgs\)</span> itself.</p>


<div class="example"><pre>
DeclareRepresentation( "IsCosetSolvableFactorEnumeratorRep", IsEnumerator,
    [ "pcgs", "range", "representative" ] );

EnumeratorCosetSolvableFactor := function( pcgs, range, g )
    return Objectify( NewType( FamilyObj( pcgs ),
                   IsCosetSolvableFactorEnumeratorRep ),
                   rec( pcgs := pcgs,
                       range := range,
              representative := g ) );
end;
</pre></div>

<p>The definition of the operations <code class="func">Length</code> (<a href="chap21_mj.html#X780769238600AFD1"><span class="RefLink">21.17-5</span></a>), <code class="func">\[\]</code> (<a href="chap21_mj.html#X8297BBCD79642BE6"><span class="RefLink">21.2-1</span></a>) and <code class="func">Position</code> (<a href="chap21_mj.html#X79975EC6783B4293"><span class="RefLink">21.16-1</span></a>) is now straightforward. The code has sometimes been abbreviated and is meant "cum grano salis", e.g., the declaration of the local variables has been left out.</p>


<div class="example"><pre>
InstallMethod( Length, [ IsCosetSolvableFactorEnumeratorRep ],
    enum -&gt; Product( RelativeOrdersPcgs( enum!.pcgs ){ enum!.range } ) );

InstallMethod( \[\], [ IsCosetSolvableFactorEnumeratorRep,
        IsPosRat and IsInt ],
    function( enum, pos )
    elm := ();
    pos := pos - 1;
    for i  in Reversed( enum!.range )  do
        p := RelativeOrderOfPcElement( enum!.pcgs, i );
        elm := enum!.pcgs[ i ] ^ ( pos mod p ) * elm;
        pos := QuoInt( pos, p );
    od;
    return enum!.representative * elm;
end );

InstallMethod( Position, [ IsCosetSolvableFactorEnumeratorRep,
        IsObject, IsZeroCyc ],
    function( enum, elm, zero )
    exp := ExponentsOfPcElement( enum!.pcgs,
                   LeftQuotient( enum!.representative, elm ) );
    pos := 0;
    for i  in enum!.range  do
        pos := pos * RelativeOrderOfPcElement( pcgs, i ) + exp[ i ];
    od;
    return pos + 1;
end );
</pre></div>

<p><a id="X79B146E9786FE153" name="X79B146E9786FE153"></a></p>

<h5>87.3-3 <span class="Heading">Making automorphisms act on such enumerators</span></h5>

<p>Our next task is to make automorphisms of the solvable group <span class="SimpleMath">\(pcgs\)</span><code class="code">!.group</code> act on <span class="SimpleMath">\([ 1 .. \)</span><code class="code">Length</code><span class="SimpleMath">\(( enum ) ]\)</span> for such an enumerator <span class="SimpleMath">\(enum\)</span>. We achieve this by introducing a new representation of automorphisms on enumerators and by putting the enumerator together with the automorphism into an object which behaves like a permutation. Turning an ordinary automorphism into such a special automorphism requires then the construction of a new object which has the new type. We provide an operation <code class="code">PermOnEnumerator( <var class="Arg">model</var>, <var class="Arg">aut</var> )</code> which constructs such a new object having the same type as <var class="Arg">model</var>, but representing the automorphism <var class="Arg">aut</var>. So <var class="Arg">aut</var> can be either an ordinary automorphism or one which already has an enumerator in its type, but perhaps different from the one we want (i.e. from the one in <var class="Arg">model</var>).</p>


<div class="example"><pre>
DeclareCategory( "IsPermOnEnumerator",
    IsMultiplicativeElementWithInverse and IsPerm );

DeclareRepresentation( "IsPermOnEnumeratorDefaultRep",
    IsPermOnEnumerator and IsAttributeStoringRep,
    [ "perm" ] );

DeclareOperation( "PermOnEnumerator",
    [ IsEnumerator, IsObject ] );

InstallMethod( PermOnEnumerator,
    [ IsEnumerator, IsObject ],
    function( enum, a )
    SetFilterObj( a, IsMultiplicativeElementWithInverse );
    a := Objectify( NewKind( PermutationsOnEnumeratorsFamily,
                 IsPermOnEnumeratorDefaultRep ),
                 rec( perm := a ) );
    SetEnumerator( a, enum );
    return a;
end );

InstallMethod( PermOnEnumerator,
    [ IsEnumerator, IsPermOnEnumeratorDefaultRep ],
    function( enum, a )
    a := Objectify( TypeObj( a ), rec( perm := a!.perm ) );
    SetEnumerator( a, enum );
    return a;
end );
</pre></div>

<p>Next we have to install new methods for the operations which calculate the product of two automorphisms, because this product must again have the right type. We also have to write a function which uses the enumerators to apply such an automorphism to positive integers.</p>


<div class="example"><pre>
InstallMethod( \*, IsIdenticalObj,
    [ IsPermOnEnumeratorDefaultRep, IsPermOnEnumeratorDefaultRep ],
    function( a, b )
    perm := a!.perm * b!.perm;
    SetIsBijective( perm, true );
    return PermOnEnumerator( Enumerator( a ), perm );
end );

InstallMethod( \^,
    [ IsPosRat and IsInt, IsPermOnEnumeratorDefaultRep ],
    function( p, a )
    return PositionCanonical( Enumerator( a ),
                   Enumerator( a )[ p ] ^ a!.perm );
end );
</pre></div>

<p>How the corresponding methods for <code class="code"><var class="Arg">p</var> / <var class="Arg">aut</var></code> and <code class="code"><var class="Arg">aut</var> ^ <var class="Arg">n</var></code> look like is obvious.</p>

<p>Now we can formulate the recursive procedure <code class="code">StabChainStrong</code> which extends the stabilizer chain by adding in new generators <span class="SimpleMath">\(newgens\)</span>. We content ourselves again with pseudo-code, emphasizing only the lines which set the <code class="code">EnumeratorDomainPermutation</code>. We assume that initially <span class="SimpleMath">\(S\)</span> is a stabilizer chain for the trivial subgroup with a level for each pair <span class="SimpleMath">\((range,g)\)</span> characterizing an enumerator (as described above). We also assume that the <code class="code">identity</code> element at each level already has the type corresponding to that level.</p>


<div class="example"><pre>
StabChainStrong := function( S, newgens )
  for i  in [ 1 .. Length( newgens ) ]  do
    newgens[ i ] := AutomorphismOnEnumerator( S.identity, newgens[ i ] );
  od;
  Extend the Schreier tree of S with newgens.
  for sch  in  Schreier generators  do
    if not sch in S.stabilizer  then
      StabChainStrong( S.stabilizer, [ sch ] );
    fi;
  od;
end;
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap86_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chap14_mj.html">14</a>  <a href="chap15_mj.html">15</a>  <a href="chap16_mj.html">16</a>  <a href="chap17_mj.html">17</a>  <a href="chap18_mj.html">18</a>  <a href="chap19_mj.html">19</a>  <a href="chap20_mj.html">20</a>  <a href="chap21_mj.html">21</a>  <a href="chap22_mj.html">22</a>  <a href="chap23_mj.html">23</a>  <a href="chap24_mj.html">24</a>  <a href="chap25_mj.html">25</a>  <a href="chap26_mj.html">26</a>  <a href="chap27_mj.html">27</a>  <a href="chap28_mj.html">28</a>  <a href="chap29_mj.html">29</a>  <a href="chap30_mj.html">30</a>  <a href="chap31_mj.html">31</a>  <a href="chap32_mj.html">32</a>  <a href="chap33_mj.html">33</a>  <a href="chap34_mj.html">34</a>  <a href="chap35_mj.html">35</a>  <a href="chap36_mj.html">36</a>  <a href="chap37_mj.html">37</a>  <a href="chap38_mj.html">38</a>  <a href="chap39_mj.html">39</a>  <a href="chap40_mj.html">40</a>  <a href="chap41_mj.html">41</a>  <a href="chap42_mj.html">42</a>  <a href="chap43_mj.html">43</a>  <a href="chap44_mj.html">44</a>  <a href="chap45_mj.html">45</a>  <a href="chap46_mj.html">46</a>  <a href="chap47_mj.html">47</a>  <a href="chap48_mj.html">48</a>  <a href="chap49_mj.html">49</a>  <a href="chap50_mj.html">50</a>  <a href="chap51_mj.html">51</a>  <a href="chap52_mj.html">52</a>  <a href="chap53_mj.html">53</a>  <a href="chap54_mj.html">54</a>  <a href="chap55_mj.html">55</a>  <a href="chap56_mj.html">56</a>  <a href="chap57_mj.html">57</a>  <a href="chap58_mj.html">58</a>  <a href="chap59_mj.html">59</a>  <a href="chap60_mj.html">60</a>  <a href="chap61_mj.html">61</a>  <a href="chap62_mj.html">62</a>  <a href="chap63_mj.html">63</a>  <a href="chap64_mj.html">64</a>  <a href="chap65_mj.html">65</a>  <a href="chap66_mj.html">66</a>  <a href="chap67_mj.html">67</a>  <a href="chap68_mj.html">68</a>  <a href="chap69_mj.html">69</a>  <a href="chap70_mj.html">70</a>  <a href="chap71_mj.html">71</a>  <a href="chap72_mj.html">72</a>  <a href="chap73_mj.html">73</a>  <a href="chap74_mj.html">74</a>  <a href="chap75_mj.html">75</a>  <a href="chap76_mj.html">76</a>  <a href="chap77_mj.html">77</a>  <a href="chap78_mj.html">78</a>  <a href="chap79_mj.html">79</a>  <a href="chap80_mj.html">80</a>  <a href="chap81_mj.html">81</a>  <a href="chap82_mj.html">82</a>  <a href="chap83_mj.html">83</a>  <a href="chap84_mj.html">84</a>  <a href="chap85_mj.html">85</a>  <a href="chap86_mj.html">86</a>  <a href="chap87_mj.html">87</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
