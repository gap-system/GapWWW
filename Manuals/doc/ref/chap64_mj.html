<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (ref) - Chapter 64: Lie Algebras</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap64"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chap14_mj.html">14</a>  <a href="chap15_mj.html">15</a>  <a href="chap16_mj.html">16</a>  <a href="chap17_mj.html">17</a>  <a href="chap18_mj.html">18</a>  <a href="chap19_mj.html">19</a>  <a href="chap20_mj.html">20</a>  <a href="chap21_mj.html">21</a>  <a href="chap22_mj.html">22</a>  <a href="chap23_mj.html">23</a>  <a href="chap24_mj.html">24</a>  <a href="chap25_mj.html">25</a>  <a href="chap26_mj.html">26</a>  <a href="chap27_mj.html">27</a>  <a href="chap28_mj.html">28</a>  <a href="chap29_mj.html">29</a>  <a href="chap30_mj.html">30</a>  <a href="chap31_mj.html">31</a>  <a href="chap32_mj.html">32</a>  <a href="chap33_mj.html">33</a>  <a href="chap34_mj.html">34</a>  <a href="chap35_mj.html">35</a>  <a href="chap36_mj.html">36</a>  <a href="chap37_mj.html">37</a>  <a href="chap38_mj.html">38</a>  <a href="chap39_mj.html">39</a>  <a href="chap40_mj.html">40</a>  <a href="chap41_mj.html">41</a>  <a href="chap42_mj.html">42</a>  <a href="chap43_mj.html">43</a>  <a href="chap44_mj.html">44</a>  <a href="chap45_mj.html">45</a>  <a href="chap46_mj.html">46</a>  <a href="chap47_mj.html">47</a>  <a href="chap48_mj.html">48</a>  <a href="chap49_mj.html">49</a>  <a href="chap50_mj.html">50</a>  <a href="chap51_mj.html">51</a>  <a href="chap52_mj.html">52</a>  <a href="chap53_mj.html">53</a>  <a href="chap54_mj.html">54</a>  <a href="chap55_mj.html">55</a>  <a href="chap56_mj.html">56</a>  <a href="chap57_mj.html">57</a>  <a href="chap58_mj.html">58</a>  <a href="chap59_mj.html">59</a>  <a href="chap60_mj.html">60</a>  <a href="chap61_mj.html">61</a>  <a href="chap62_mj.html">62</a>  <a href="chap63_mj.html">63</a>  <a href="chap64_mj.html">64</a>  <a href="chap65_mj.html">65</a>  <a href="chap66_mj.html">66</a>  <a href="chap67_mj.html">67</a>  <a href="chap68_mj.html">68</a>  <a href="chap69_mj.html">69</a>  <a href="chap70_mj.html">70</a>  <a href="chap71_mj.html">71</a>  <a href="chap72_mj.html">72</a>  <a href="chap73_mj.html">73</a>  <a href="chap74_mj.html">74</a>  <a href="chap75_mj.html">75</a>  <a href="chap76_mj.html">76</a>  <a href="chap77_mj.html">77</a>  <a href="chap78_mj.html">78</a>  <a href="chap79_mj.html">79</a>  <a href="chap80_mj.html">80</a>  <a href="chap81_mj.html">81</a>  <a href="chap82_mj.html">82</a>  <a href="chap83_mj.html">83</a>  <a href="chap84_mj.html">84</a>  <a href="chap85_mj.html">85</a>  <a href="chap86_mj.html">86</a>  <a href="chap87_mj.html">87</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap63_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap65_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap64.html">[MathJax off]</a></p>
<p><a id="X78559D4C800AF58A" name="X78559D4C800AF58A"></a></p>
<div class="ChapSects"><a href="chap64_mj.html#X78559D4C800AF58A">64 <span class="Heading">Lie Algebras</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap64_mj.html#X80A607C47B7A2E69">64.1 <span class="Heading">Lie Objects</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X87F121978775AF48">64.1-1 LieObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X83E5DD4381D9A65D">64.1-2 IsLieObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X8725993C7BF386EE">64.1-3 LieFamily</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X81D9F5C6876FE93B">64.1-4 UnderlyingFamily</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X874B2B2A7F5A9A78">64.1-5 UnderlyingRingElement</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap64_mj.html#X789A44F283C16B2B">64.2 <span class="Heading">Constructing Lie algebras</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7D362350824FA115">64.2-1 LieAlgebraByStructureConstants</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7EEB79EE855E124C">64.2-2 RestrictedLieAlgebraByStructureConstants</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7C840A9F85D28C81">64.2-3 LieAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7F7B34BD80F0F1C8">64.2-4 FreeLieAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X8735EE937A0081F0">64.2-5 FullMatrixLieAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X821B6C197C08878B">64.2-6 RightDerivations</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7933F05F7DE342AB">64.2-7 SimpleLieAlgebra</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap64_mj.html#X798391F47E835F85">64.3 <span class="Heading">Distinguished Subalgebras</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X8111F58E7DE3E25C">64.3-1 LieCentre</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X811444717EEDCC34">64.3-2 LieCentralizer</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7E62B6B37A75E09D">64.3-3 LieNormalizer</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7C95C0057C977747">64.3-4 LieDerivedSubalgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7D072F6D7A3D0BAF">64.3-5 LieNilRadical</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X8445C9F17F7CBEA1">64.3-6 LieSolvableRadical</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X86114F157DFF6523">64.3-7 CartanSubalgebra</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap64_mj.html#X7A72840882F7A9B6">64.4 <span class="Heading">Series of Ideals</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7DEF89A8869809F5">64.4-1 LieDerivedSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7900D17E7BA26A48">64.4-2 LieLowerCentralSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X86A8701C868828C7">64.4-3 LieUpperCentralSeries</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap64_mj.html#X8208CE5F8286155F">64.5 <span class="Heading">Properties of a Lie Algebra</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7F97D08F7B738ADE">64.5-1 IsLieAbelian</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X78452F4E875A62A8">64.5-2 IsLieNilpotent</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X859FF1B3812B8FCC">64.5-3 IsLieSolvable</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap64_mj.html#X83F829017D46C544">64.6 <span class="Heading">Semisimple Lie Algebras and Root Systems</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X8401CDC2859F8A85">64.6-1 SemiSimpleType</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X82EBF10A7B3B6F6E">64.6-2 ChevalleyBasis</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X79B5D27681193625">64.6-3 IsRootSystem</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7D64D49479CBB203">64.6-4 IsRootSystemFromLieAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X80D15C027BB8029B">64.6-5 RootSystem</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7CA021E28527763E">64.6-6 UnderlyingLieAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7B6B0BBD8035D7E5">64.6-7 PositiveRoots</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X81F9E0E67DD2688F">64.6-8 NegativeRoots</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X829C78427A442C23">64.6-9 PositiveRootVectors</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7AB374DC87A39349">64.6-10 NegativeRootVectors</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7DBD179E7CCF6699">64.6-11 SimpleSystem</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X84E3FEF587CB66C3">64.6-12 CartanMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X878644D68571BF44">64.6-13 BilinearFormMat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7FAE45B37C5779A0">64.6-14 CanonicalGenerators</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap64_mj.html#X7945D07786D1C4BB">64.7 <span class="Heading">Semisimple Lie Algebras and Weyl Groups of Root Systems</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X82AA29DD7969A935">64.7-1 IsWeylGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X81EF01E57E5DC18A">64.7-2 SparseCartanMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X86BED5098322EBEF">64.7-3 WeylGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7829BC4D7F253649">64.7-4 ApplySimpleReflection</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X80A7204F7D40D80F">64.7-5 LongestWeylWordPerm</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7D4E213F82F73857">64.7-6 ConjugateDominantWeight</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7E000FA97949BFD5">64.7-7 WeylOrbitIterator</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap64_mj.html#X878080BB79BE3F2E">64.8 <span class="Heading">Restricted Lie algebras</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X81F28B1D830F28EB">64.8-1 IsRestrictedLieAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7D7BD5908016461B">64.8-2 PthPowerImages</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X879BB01782E7D7A9">64.8-3 PthPowerImage</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X8692ADD581359CA1">64.8-4 JenningsLieAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X785251E879E1BFC6">64.8-5 PCentralLieAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X781ADBEC850C7DE7">64.8-6 NaturalHomomorphismOfLieAlgebraFromNilpotentGroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap64_mj.html#X7C419FFA835EBE12">64.9 <span class="Heading">The Adjoint Representation</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X786886D882795F78">64.9-1 AdjointMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X873A64307AC6C63E">64.9-2 AdjointAssociativeAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X877CCFD5832E035D">64.9-3 KillingMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X8234046083B60F6E">64.9-4 KappaPerp</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7A00601387A060CF">64.9-5 IsNilpotentElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X86EF3E6F7BC0A8AD">64.9-6 NonNilpotentElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7A912D9E7B3BA874">64.9-7 FindSl2</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap64_mj.html#X7875070C85DD4E8E">64.10 <span class="Heading">Universal Enveloping Algebras</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X8226CD1680207A5F">64.10-1 UniversalEnvelopingAlgebra</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap64_mj.html#X7B8C71E07F50B286">64.11 <span class="Heading">Finitely Presented Lie Algebras</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X780A5B457A051110">64.11-1 FpLieAlgebraByCartanMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X79FD70C487EA9438">64.11-2 NilpotentQuotientOfFpLieAlgebra</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap64_mj.html#X7FBCB43C86BDD9C2">64.12 <span class="Heading">Modules over Lie Algebras and Their Cohomology</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X82CC31CF79F59FEE">64.12-1 IsCochain</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X79F3DF0D8791C2E3">64.12-2 Cochain</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7CF2919081600A3D">64.12-3 CochainSpace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7D6760DA84683011">64.12-4 ValueCochain</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X851F5EF47FA90CBC">64.12-5 LieCoboundaryOperator</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7FB815F38143939E">64.12-6 Cocycles</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7C4F372C7AE2F739">64.12-7 Coboundaries</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap64_mj.html#X78A201238137E822">64.13 <span class="Heading">Modules over Semisimple Lie Algebras</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7D8522E37ED1024A">64.13-1 DominantWeights</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X79AAC71E8267E9F8">64.13-2 DominantCharacter</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7BE7129384B012DF">64.13-3 DecomposeTensorProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7D67A9BC7E4714D9">64.13-4 DimensionOfHighestWeightModule</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap64_mj.html#X840E5FAE7D2C2702">64.14 <span class="Heading">Admissible Lattices in UEA</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X86E6722379576746">64.14-1 IsUEALatticeElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X79F4F58B7888B0A5">64.14-2 LatticeGeneratorsInUEA</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X875FD1627F3B72DB">64.14-3 ObjByExtRep</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X8248DB547B02B0FA">64.14-4 IsWeightRepElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7FB14F7F80EFF33F">64.14-5 HighestWeightModule</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap64_mj.html#X78515F448644204E">64.15 <span class="Heading">Tensor Products and Exterior and Symmetric Powers</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7A1E0AC4800E7FDA">64.15-1 TensorProductOfAlgebraModules</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X7F4AB6A1863E8FB2">64.15-2 ExteriorPowerOfAlgebraModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap64_mj.html#X842DF85687D61A56">64.15-3 SymmetricPowerOfAlgebraModule</a></span>
</div></div>
</div>

<h3>64 <span class="Heading">Lie Algebras</span></h3>

<p>A Lie algebra <span class="SimpleMath">\(L\)</span> is an algebra such that <span class="SimpleMath">\(x x = 0\)</span> and <span class="SimpleMath">\(x(yz) + y(zx) + z(xy) = 0\)</span> for all <span class="SimpleMath">\(x, y, z \in L\)</span>. A common way of creating a Lie algebra is by taking an associative algebra together with the commutator as product. Therefore the product of two elements <span class="SimpleMath">\(x, y\)</span> of a Lie algebra is usually denoted by <span class="SimpleMath">\([x,y]\)</span>, but in <strong class="pkg">GAP</strong> this denotes the list of the elements <span class="SimpleMath">\(x\)</span> and <span class="SimpleMath">\(y\)</span>; hence the product of elements is made by the usual <code class="code">*</code>. This gives no problems when dealing with Lie algebras given by a table of structure constants. However, for matrix Lie algebras the situation is not so easy as <code class="code">*</code> denotes the ordinary (associative) matrix multiplication. In <strong class="pkg">GAP</strong> this problem is solved by wrapping elements of a matrix Lie algebra up as <code class="code">LieObject</code>s, and then define the <code class="code">*</code> for <code class="code">LieObject</code>s to be the commutator (see <a href="chap64_mj.html#X80A607C47B7A2E69"><span class="RefLink">64.1</span></a>).</p>

<p><a id="X80A607C47B7A2E69" name="X80A607C47B7A2E69"></a></p>

<h4>64.1 <span class="Heading">Lie Objects</span></h4>

<p>Let <code class="code">x</code> be a ring element, then <code class="code">LieObject(x)</code> (see <code class="func">LieObject</code> (<a href="chap64_mj.html#X87F121978775AF48"><span class="RefLink">64.1-1</span></a>)) wraps <code class="code">x</code> up into an object that contains the same data (namely <code class="code">x</code>). The multiplication <code class="code">*</code> for Lie objects is formed by taking the commutator. More exactly, if <code class="code">l1</code> and <code class="code">l2</code> are the Lie objects corresponding to the ring elements <code class="code">r1</code> and <code class="code">r2</code>, then <code class="code">l1 * l2</code> is equal to the Lie object corresponding to <code class="code">r1 * r2 - r2 * r1</code>. Two rules for Lie objects are worth noting:</p>


<ul>
<li><p>An element is <em>not</em> equal to its Lie element.</p>

</li>
<li><p>If we take the Lie object of an ordinary (associative) matrix then this is again a matrix; it is therefore a collection (of its rows) and a list. But it is <em>not</em> a collection of collections of its entries, and its family is <em>not</em> a collections family.</p>

</li>
</ul>
<p>Given a family <code class="code">F</code> of ring elements, we can form its Lie family <code class="code">L</code>. The elements of <code class="code">F</code> and <code class="code">L</code> are in bijection, only the multiplications via <code class="code">*</code> differ for both families. More exactly, if <code class="code">l1</code> and <code class="code">l2</code> are the Lie elements corresponding to the elements <code class="code">f1</code> and <code class="code">f2</code> in <code class="code">F</code>, we have <code class="code">l1 * l2</code> equal to the Lie element corresponding to <code class="code">f1 * f2 - f2 * f1</code>. Furthermore, the product of Lie elements <code class="code">l1</code>, <code class="code">l2</code> and <code class="code">l3</code> is left-normed, that is <code class="code">l1*l2*l3</code> is equal to <code class="code">(l1*l2)*l3</code>.</p>

<p>The main reason to distinguish elements and Lie elements on the family level is that this helps to avoid forming domains that contain elements of both types. For example, if we could form vector spaces of matrices then at first glance it would be no problem to have both ordinary and Lie matrices in it, but as soon as we find out that the space is in fact an algebra (e.g., because its dimension is that of the full matrix algebra), we would run into strange problems.</p>

<p>Note that the family situation with Lie families may be not familiar.</p>


<ul>
<li><p>We have to be careful when installing methods for certain types of domains that may involve Lie elements. For example, the zero element of a matrix space is either an ordinary matrix or its Lie element, depending on the space. So either the method must be aware of both cases, or the method selection must distinguish the two cases. In the latter situation, only one method may be applicable to each case; this means that it is not sufficient to treat the Lie case with the additional requirement <code class="code">IsLieObjectCollection</code> but that we must explicitly require non-Lie elements for the non-Lie case.</p>

</li>
<li><p>Being a full matrix space is a property that may hold for a space of ordinary matrices or a space of Lie matrices. So methods for full matrix spaces must also be aware of Lie matrices.</p>

</li>
</ul>
<p><a id="X87F121978775AF48" name="X87F121978775AF48"></a></p>

<h5>64.1-1 LieObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieObject</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">obj</var> be a ring element. Then <code class="code">LieObject( <var class="Arg">obj</var> )</code> is the corresponding Lie object. If <var class="Arg">obj</var> lies in the family <code class="code">F</code>, then <code class="code">LieObject( <var class="Arg">obj</var> )</code> lies in the family <code class="code">LieFamily( F )</code> (see <code class="func">LieFamily</code> (<a href="chap64_mj.html#X8725993C7BF386EE"><span class="RefLink">64.1-3</span></a>)).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m:= [ [ 1, 0 ], [ 0, 1 ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lo:= LieObject( m );</span>
LieObject( [ [ 1, 0 ], [ 0, 1 ] ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m*m;</span>
[ [ 1, 0 ], [ 0, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lo*lo;</span>
LieObject( [ [ 0, 0 ], [ 0, 0 ] ] )
</pre></div>

<p><a id="X83E5DD4381D9A65D" name="X83E5DD4381D9A65D"></a></p>

<h5>64.1-2 IsLieObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLieObject</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLieObjectCollection</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsRestrictedLieObject</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsRestrictedLieObjectCollection</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>An object lies in <code class="func">IsLieObject</code> if and only if it lies in a family constructed by <code class="func">LieFamily</code> (<a href="chap64_mj.html#X8725993C7BF386EE"><span class="RefLink">64.1-3</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m:= [ [ 1, 0 ], [ 0, 1 ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lo:= LieObject( m );</span>
LieObject( [ [ 1, 0 ], [ 0, 1 ] ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLieObject( m );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLieObject( lo );</span>
true
</pre></div>

<p><a id="X8725993C7BF386EE" name="X8725993C7BF386EE"></a></p>

<h5>64.1-3 LieFamily</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieFamily</code>( <var class="Arg">Fam</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>is a family <code class="code">F</code> in bijection with the family <var class="Arg">Fam</var>, but with the Lie bracket as infix multiplication. That is, for <code class="code">x</code>, <code class="code">y</code> in <var class="Arg">Fam</var>, the product of the images in <code class="code">F</code> will be the image of <code class="code">x * y - y * x</code>.</p>

<p>The standard type of objects in a Lie family <code class="code">F</code> is <code class="code"><var class="Arg">F</var>!.packedType</code>.</p>

<p>The bijection from <var class="Arg">Fam</var> to <code class="code">F</code> is given by <code class="code">Embedding( <var class="Arg">Fam</var>, F )</code> (see <code class="func">Embedding</code> (<a href="chap32_mj.html#X86452F8587CBAEA0"><span class="RefLink">32.2-11</span></a>)); this bijection respects addition and additive inverses.</p>

<p><a id="X81D9F5C6876FE93B" name="X81D9F5C6876FE93B"></a></p>

<h5>64.1-4 UnderlyingFamily</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingFamily</code>( <var class="Arg">Fam</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>If <var class="Arg">Fam</var> is a Lie family then <code class="code">UnderlyingFamily( <var class="Arg">Fam</var> )</code> is a family <code class="code">F</code> such that <code class="code"><var class="Arg">Fam</var> = LieFamily( F )</code>.</p>

<p><a id="X874B2B2A7F5A9A78" name="X874B2B2A7F5A9A78"></a></p>

<h5>64.1-5 UnderlyingRingElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingRingElement</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">obj</var> be a Lie object constructed from a ring element <code class="code">r</code> by calling <code class="code">LieObject( r )</code>. Then <code class="code">UnderlyingRingElement( <var class="Arg">obj</var> )</code> returns the ring element <code class="code">r</code> used to construct <var class="Arg">obj</var>. If <code class="code">r</code> lies in the family <code class="code">F</code>, then <var class="Arg">obj</var> lies in the family <code class="code">LieFamily( F )</code> (see <code class="func">LieFamily</code> (<a href="chap64_mj.html#X8725993C7BF386EE"><span class="RefLink">64.1-3</span></a>)).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lo:= LieObject( [ [ 1, 0 ], [ 0, 1 ] ] );</span>
LieObject( [ [ 1, 0 ], [ 0, 1 ] ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m:=UnderlyingRingElement(lo);</span>
[ [ 1, 0 ], [ 0, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lo*lo;</span>
LieObject( [ [ 0, 0 ], [ 0, 0 ] ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m*m;</span>
[ [ 1, 0 ], [ 0, 1 ] ]
</pre></div>

<p><a id="X789A44F283C16B2B" name="X789A44F283C16B2B"></a></p>

<h4>64.2 <span class="Heading">Constructing Lie algebras</span></h4>

<p>In this section we describe functions that create Lie algebras. Creating and working with subalgebras goes exactly in the same way as for general algebras; so for that we refer to Chapter <a href="chap62_mj.html#X7DDBF6F47A2E021C"><span class="RefLink">62</span></a>.</p>

<p><a id="X7D362350824FA115" name="X7D362350824FA115"></a></p>

<h5>64.2-1 LieAlgebraByStructureConstants</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieAlgebraByStructureConstants</code>( <var class="Arg">R</var>, <var class="Arg">sct</var>[, <var class="Arg">nameinfo</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="func">LieAlgebraByStructureConstants</code> does the same as <code class="func">AlgebraByStructureConstants</code> (<a href="chap62_mj.html#X7CC58DFD816E6B65"><span class="RefLink">62.4-1</span></a>), and has the same meaning of arguments, except that the result is assumed to be a Lie algebra. Note that the function does not check whether <var class="Arg">sct</var> satisfies the Jacobi identity. (So if one creates a Lie algebra this way with a table that does not satisfy the Jacobi identity, errors may occur later on.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T:= EmptySCTable( 2, 0, "antisymmetric" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetEntrySCTable( T, 1, 2, [ 1/2, 1 ] );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= LieAlgebraByStructureConstants( Rationals, T );</span>
&lt;Lie algebra of dimension 2 over Rationals&gt;
</pre></div>

<p><a id="X7EEB79EE855E124C" name="X7EEB79EE855E124C"></a></p>

<h5>64.2-2 RestrictedLieAlgebraByStructureConstants</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RestrictedLieAlgebraByStructureConstants</code>( <var class="Arg">R</var>, <var class="Arg">sct</var>[, <var class="Arg">nameinfo</var>], <var class="Arg">pmapping</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="func">RestrictedLieAlgebraByStructureConstants</code> does the same as <code class="func">LieAlgebraByStructureConstants</code> (<a href="chap64_mj.html#X7D362350824FA115"><span class="RefLink">64.2-1</span></a>), and has the same meaning of all arguments, except that the result is assumed to be a restricted Lie algebra (see <a href="chap64_mj.html#X878080BB79BE3F2E"><span class="RefLink">64.8</span></a>) with the <span class="SimpleMath">\(p\)</span>-map given by the additional argument <var class="Arg">pmapping</var>. This last argument is a list of the length equal to the dimension of the algebra; its <span class="SimpleMath">\(i\)</span>-th entry specifies the <span class="SimpleMath">\(p\)</span>-th power of the <span class="SimpleMath">\(i\)</span>-th basis vector in the same format <code class="code">[ coeff1, position1, coeff2, position2, ... ]</code> as <code class="func">SetEntrySCTable</code> (<a href="chap62_mj.html#X817BD086876EC1C4"><span class="RefLink">62.4-4</span></a>) uses to specify entries of the structure constants table.</p>

<p>Note that the function does not check whether <var class="Arg">sct</var> satisfies the Jacobi identity, of whether <var class="Arg">pmapping</var> specifies a legitimate <span class="SimpleMath">\(p\)</span>-mapping.</p>

<p>The following example creates a commutative restricted Lie algebra of dimension 3, in which the <span class="SimpleMath">\(p\)</span>-th power of the <span class="SimpleMath">\(i\)</span>-th basis element is the <span class="SimpleMath">\(i+1\)</span>-th basis element (except for the 3rd basis element which goes to zero).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T:= EmptySCTable( 3, Zero(GF(5)), "antisymmetric" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= RestrictedLieAlgebraByStructureConstants( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                    GF(5), T, [[1,2],[1,3],[]] );</span>
&lt;Lie algebra of dimension 3 over GF(5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(Basis(L),PthPowerImage);</span>
[ v.2, v.3, 0*v.1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PthPowerImage(L.1+L.2);</span>
v.2+v.3
</pre></div>

<p><a id="X7C840A9F85D28C81" name="X7C840A9F85D28C81"></a></p>

<h5>64.2-3 LieAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieAlgebra</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieAlgebra</code>( <var class="Arg">F</var>, <var class="Arg">gens</var>[, <var class="Arg">zero</var>][, <var class="Arg">"basis"</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>For an associative algebra <var class="Arg">L</var>, <code class="code">LieAlgebra( <var class="Arg">L</var> )</code> is the Lie algebra isomorphic to <var class="Arg">L</var> as a vector space but with the Lie bracket as product.</p>

<p><code class="code">LieAlgebra( <var class="Arg">F</var>, <var class="Arg">gens</var> )</code> is the Lie algebra over the division ring <var class="Arg">F</var>, generated <em>as Lie algebra</em> by the Lie objects corresponding to the vectors in the list <var class="Arg">gens</var>.</p>

<p><em>Note</em> that the algebra returned by <code class="func">LieAlgebra</code> does not contain the vectors in <var class="Arg">gens</var>. The elements in <var class="Arg">gens</var> are wrapped up as Lie objects (see <a href="chap64_mj.html#X80A607C47B7A2E69"><span class="RefLink">64.1</span></a>). This allows one to create Lie algebras from ring elements with respect to the Lie bracket as product. But of course the product in the Lie algebra is the usual <code class="code">*</code>.</p>

<p>If there are three arguments, a division ring <var class="Arg">F</var> and a list <var class="Arg">gens</var> and an element <var class="Arg">zero</var>, then <code class="code">LieAlgebra( <var class="Arg">F</var>, <var class="Arg">gens</var>, <var class="Arg">zero</var> )</code> is the corresponding <var class="Arg">F</var>-Lie algebra with zero element the Lie object corresponding to <var class="Arg">zero</var>.</p>

<p>If the last argument is the string <code class="code">"basis"</code> then the vectors in <var class="Arg">gens</var> are known to form a basis of the algebra (as an <var class="Arg">F</var>-vector space).</p>

<p><em>Note</em> that even if each element in <var class="Arg">gens</var> is already a Lie element, i.e., is of the form <code class="code">LieElement( <var class="Arg">elm</var> )</code> for an object <var class="Arg">elm</var>, the elements of the result lie in the Lie family of the family that contains <var class="Arg">gens</var> as a subset.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A:= FullMatrixAlgebra( GF( 7 ), 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= LieAlgebra( A );</span>
&lt;Lie algebra of dimension 16 over GF(7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats:= [ [ [ 1, 0 ], [ 0, -1 ] ], [ [ 0, 1 ], [ 0, 0 ] ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            [ [ 0, 0 ], [ 1, 0] ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= LieAlgebra( Rationals, mats );</span>
&lt;Lie algebra over Rationals, with 3 generators&gt;
</pre></div>

<p><a id="X7F7B34BD80F0F1C8" name="X7F7B34BD80F0F1C8"></a></p>

<h5>64.2-4 FreeLieAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FreeLieAlgebra</code>( <var class="Arg">R</var>, <var class="Arg">rank</var>[, <var class="Arg">name</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FreeLieAlgebra</code>( <var class="Arg">R</var>, <var class="Arg">name1</var>, <var class="Arg">name2</var>, <var class="Arg">...</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns a free Lie algebra of rank <var class="Arg">rank</var> over the ring <var class="Arg">R</var>. <code class="code">FreeLieAlgebra( <var class="Arg">R</var>, <var class="Arg">name1</var>, <var class="Arg">name2</var>,...)</code> returns a free Lie algebra over <var class="Arg">R</var> with generators named <var class="Arg">name1</var>, <var class="Arg">name2</var>, and so on. The elements of a free Lie algebra are written on the Hall-Lyndon basis.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= FreeLieAlgebra( Rationals, "x", "y", "z" );</span>
&lt;Lie algebra over Rationals, with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= GeneratorsOfAlgebra( L );; x:= g[1];; y:=g[2];; z:= g[3];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z*(y*(x*(z*y)));</span>
(-1)*((x*(y*z))*(y*z))+(-1)*((x*((y*z)*z))*y)+(-1)*(((x*z)*(y*z))*y)
</pre></div>

<p><a id="X8735EE937A0081F0" name="X8735EE937A0081F0"></a></p>

<h5>64.2-5 FullMatrixLieAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FullMatrixLieAlgebra</code>( <var class="Arg">R</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MatrixLieAlgebra</code>( <var class="Arg">R</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MatLieAlgebra</code>( <var class="Arg">R</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>is the full matrix Lie algebra of <span class="SimpleMath">\(\textit{n} \times \textit{n}\)</span> matrices over the ring <var class="Arg">R</var>, for a nonnegative integer <var class="Arg">n</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FullMatrixLieAlgebra( GF(9), 10 );</span>
&lt;Lie algebra over GF(3^2), with 19 generators&gt;
</pre></div>

<p><a id="X821B6C197C08878B" name="X821B6C197C08878B"></a></p>

<h5>64.2-6 RightDerivations</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RightDerivations</code>( <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LeftDerivations</code>( <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Derivations</code>( <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>These functions all return the matrix Lie algebra of derivations of the algebra <span class="SimpleMath">\(A\)</span> with basis <var class="Arg">B</var>.</p>

<p><code class="code">RightDerivations( <var class="Arg">B</var> )</code> returns the algebra of derivations represented by their right action on the algebra <span class="SimpleMath">\(A\)</span>. This means that with respect to the basis <span class="SimpleMath">\(B\)</span> of <span class="SimpleMath">\(A\)</span>, the derivation <span class="SimpleMath">\(D\)</span> is described by the matrix <span class="SimpleMath">\([ d_{{i,j}} ]\)</span> which means that <span class="SimpleMath">\(D\)</span> maps the <span class="SimpleMath">\(i\)</span>-th basis element <span class="SimpleMath">\(b_i\)</span> to <span class="SimpleMath">\(\sum_{{j = 1}}^n d_{{i,j}} b_j\)</span>.</p>

<p><code class="code">LeftDerivations( <var class="Arg">B</var> )</code> returns the Lie algebra of derivations represented by their left action on the algebra <span class="SimpleMath">\(A\)</span>. So the matrices contained in the algebra output by <code class="code">LeftDerivations( <var class="Arg">B</var> )</code> are the transposes of the matrices contained in the output of <code class="code">RightDerivations( <var class="Arg">B</var> )</code>.</p>

<p><code class="func">Derivations</code> is just a synonym for <code class="func">RightDerivations</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A:= OctaveAlgebra( Rationals );</span>
&lt;algebra of dimension 8 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= Derivations( Basis( A ) );</span>
&lt;Lie algebra of dimension 14 over Rationals&gt;
</pre></div>

<p><a id="X7933F05F7DE342AB" name="X7933F05F7DE342AB"></a></p>

<h5>64.2-7 SimpleLieAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimpleLieAlgebra</code>( <var class="Arg">type</var>, <var class="Arg">n</var>, <var class="Arg">F</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function constructs the simple Lie algebra of type given by the string <var class="Arg">type</var> and rank <var class="Arg">n</var> over the field <var class="Arg">F</var>. The string <var class="Arg">type</var> must be one of <code class="code">"A"</code>, <code class="code">"B"</code>, <code class="code">"C"</code>, <code class="code">"D"</code>, <code class="code">"E"</code>, <code class="code">"F"</code>, <code class="code">"G"</code>, <code class="code">"H"</code>, <code class="code">"K"</code>, <code class="code">"S"</code>, <code class="code">"W"</code> or <code class="code">"M"</code>. For the types <code class="code">A</code> to <code class="code">G</code>, <var class="Arg">n</var> must be a positive integer. The last five types only exist over fields of characteristic <span class="SimpleMath">\(p&gt;0\)</span>. If the type is <code class="code">H</code>, then <var class="Arg">n</var> must be a list of positive integers of even length. If the type is <code class="code">K</code>, then <var class="Arg">n</var> must be a list of positive integers of odd length. For the types <code class="code">S</code> and <code class="code">W</code>, <var class="Arg">n</var> must be a list of positive integers of any length. If the type is <code class="code">M</code>, then the Melikyan algebra is constructed. In this case <var class="Arg">n</var> must be a list of two positive integers. This Lie algebra only exists over fields of characteristic <span class="SimpleMath">\(5\)</span>. This Lie algebra is <span class="SimpleMath">\(ℤ \times ℤ\)</span> graded; and the grading can be accessed via the attribute <code class="code">Grading(L)</code> (see <code class="func">Grading</code> (<a href="chap62_mj.html#X7DCA2568870A2D34"><span class="RefLink">62.9-20</span></a>)). In some cases the Lie algebra returned by this function is not simple. Examples are the Lie algebras of type <span class="SimpleMath">\(A_n\)</span> over a field of characteristic <span class="SimpleMath">\(p&gt;0\)</span> where <span class="SimpleMath">\(p\)</span> divides <span class="SimpleMath">\(n+1\)</span>, and the Lie algebras of type <span class="SimpleMath">\(K_n\)</span> where <span class="SimpleMath">\(n\)</span> is a list of length 1.</p>

<p>If <var class="Arg">type</var> is one of <code class="code">A</code>, <code class="code">B</code>, <code class="code">C</code>, <code class="code">D</code>, <code class="code">E</code>, <code class="code">F</code>, <code class="code">G</code>, and <var class="Arg">F</var> is a field of characteristic zero, then the basis of the returned Lie algebra is a Chevalley basis.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SimpleLieAlgebra( "E", 6, Rationals );</span>
&lt;Lie algebra of dimension 78 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SimpleLieAlgebra( "A", 6, GF(5) );</span>
&lt;Lie algebra of dimension 48 over GF(5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SimpleLieAlgebra( "W", [1,2], GF(5) );</span>
&lt;Lie algebra of dimension 250 over GF(5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SimpleLieAlgebra( "H", [1,2], GF(5) );</span>
&lt;Lie algebra of dimension 123 over GF(5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "M", [1,1], GF(5) );</span>
&lt;Lie algebra of dimension 125 over GF(5)&gt;
</pre></div>

<p><a id="X798391F47E835F85" name="X798391F47E835F85"></a></p>

<h4>64.3 <span class="Heading">Distinguished Subalgebras</span></h4>

<p>Here we describe functions that calculate well-known subalgebras and ideals of a Lie algebra (such as the centre, the centralizer of a subalgebra, etc.).</p>

<p><a id="X8111F58E7DE3E25C" name="X8111F58E7DE3E25C"></a></p>

<h5>64.3-1 LieCentre</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieCentre</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieCenter</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The <em>Lie</em> centre of the Lie algebra <var class="Arg">L</var> is the kernel of the adjoint mapping, that is, the set <span class="SimpleMath">\(\{ a \in L : \forall x \in L: a x = 0 \}\)</span>.</p>

<p>In characteristic <span class="SimpleMath">\(2\)</span> this may differ from the usual centre (that is the set of all <span class="SimpleMath">\(a \in L\)</span> such that <span class="SimpleMath">\(a x = x a\)</span> for all <span class="SimpleMath">\(x \in L\)</span>). Therefore, this operation is named <code class="func">LieCentre</code> and not <code class="func">Centre</code> (<a href="chap35_mj.html#X847ABE6F781C7FE8"><span class="RefLink">35.4-5</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= FullMatrixLieAlgebra( GF(3), 3 );</span>
&lt;Lie algebra over GF(3), with 5 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LieCentre( L );</span>
&lt;two-sided ideal in &lt;Lie algebra of dimension 9 over GF(3)&gt;, 
  (dimension 1)&gt;
</pre></div>

<p><a id="X811444717EEDCC34" name="X811444717EEDCC34"></a></p>

<h5>64.3-2 LieCentralizer</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieCentralizer</code>( <var class="Arg">L</var>, <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>is the annihilator of <var class="Arg">S</var> in the Lie algebra <var class="Arg">L</var>, that is, the set <span class="SimpleMath">\(\{ a \in L : \forall s \in S: a*s = 0 \}\)</span>. Here <var class="Arg">S</var> may be a subspace or a subalgebra of <var class="Arg">L</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "G", 2, Rationals );</span>
&lt;Lie algebra of dimension 14 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b:= BasisVectors( Basis( L ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LieCentralizer( L, Subalgebra( L, [ b[1], b[2] ] ) );</span>
&lt;Lie algebra of dimension 1 over Rationals&gt;
</pre></div>

<p><a id="X7E62B6B37A75E09D" name="X7E62B6B37A75E09D"></a></p>

<h5>64.3-3 LieNormalizer</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieNormalizer</code>( <var class="Arg">L</var>, <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>is the normalizer of the subspace <var class="Arg">U</var> in the Lie algebra <var class="Arg">L</var>, that is, the set <span class="SimpleMath">\(N_L(U) = \{ x \in L : [x,U] \subset U \}\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "G", 2, Rationals );</span>
&lt;Lie algebra of dimension 14 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b:= BasisVectors( Basis( L ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LieNormalizer( L, Subalgebra( L, [ b[1], b[2] ] ) );</span>
&lt;Lie algebra of dimension 8 over Rationals&gt;
</pre></div>

<p><a id="X7C95C0057C977747" name="X7C95C0057C977747"></a></p>

<h5>64.3-4 LieDerivedSubalgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieDerivedSubalgebra</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>is the (Lie) derived subalgebra of the Lie algebra <var class="Arg">L</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"> L:= FullMatrixLieAlgebra( GF( 3 ), 3 );</span>
&lt;Lie algebra over GF(3), with 5 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LieDerivedSubalgebra( L );</span>
&lt;Lie algebra of dimension 8 over GF(3)&gt;
</pre></div>

<p><a id="X7D072F6D7A3D0BAF" name="X7D072F6D7A3D0BAF"></a></p>

<h5>64.3-5 LieNilRadical</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieNilRadical</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>This function calculates the (Lie) nil radical of the Lie algebra <var class="Arg">L</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats:= [ [[1,0],[0,0]], [[0,1],[0,0]], [[0,0],[0,1]] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= LieAlgebra( Rationals, mats );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LieNilRadical( L );</span>
&lt;two-sided ideal in &lt;Lie algebra of dimension 3 over Rationals&gt;, 
  (dimension 2)&gt;
</pre></div>

<p><a id="X8445C9F17F7CBEA1" name="X8445C9F17F7CBEA1"></a></p>

<h5>64.3-6 LieSolvableRadical</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieSolvableRadical</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns the (Lie) solvable radical of the Lie algebra <var class="Arg">L</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= FullMatrixLieAlgebra( Rationals, 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LieSolvableRadical( L );</span>
&lt;two-sided ideal in &lt;Lie algebra of dimension 9 over Rationals&gt;, 
  (dimension 1)&gt;
</pre></div>

<p><a id="X86114F157DFF6523" name="X86114F157DFF6523"></a></p>

<h5>64.3-7 CartanSubalgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CartanSubalgebra</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>A Cartan subalgebra of a Lie algebra <var class="Arg">L</var> is defined as a nilpotent subalgebra of <var class="Arg">L</var> equal to its own Lie normalizer in <var class="Arg">L</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "G", 2, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CartanSubalgebra( L );</span>
&lt;Lie algebra of dimension 2 over Rationals&gt;
</pre></div>

<p><a id="X7A72840882F7A9B6" name="X7A72840882F7A9B6"></a></p>

<h4>64.4 <span class="Heading">Series of Ideals</span></h4>

<p><a id="X7DEF89A8869809F5" name="X7DEF89A8869809F5"></a></p>

<h5>64.4-1 LieDerivedSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieDerivedSeries</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>is the (Lie) derived series of the Lie algebra <var class="Arg">L</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats:= [ [[1,0],[0,0]], [[0,1],[0,0]], [[0,0],[0,1]] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= LieAlgebra( Rationals, mats );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LieDerivedSeries( L );</span>
[ &lt;Lie algebra of dimension 3 over Rationals&gt;, 
  &lt;Lie algebra of dimension 1 over Rationals&gt;, 
  &lt;Lie algebra of dimension 0 over Rationals&gt; ]
</pre></div>

<p><a id="X7900D17E7BA26A48" name="X7900D17E7BA26A48"></a></p>

<h5>64.4-2 LieLowerCentralSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieLowerCentralSeries</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>is the (Lie) lower central series of the Lie algebra <var class="Arg">L</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats:= [ [[ 1, 0 ], [ 0, 0 ]], [[0,1],[0,0]], [[0,0],[0,1]] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:=LieAlgebra( Rationals, mats );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LieLowerCentralSeries( L );</span>
[ &lt;Lie algebra of dimension 3 over Rationals&gt;, 
  &lt;Lie algebra of dimension 1 over Rationals&gt; ]
</pre></div>

<p><a id="X86A8701C868828C7" name="X86A8701C868828C7"></a></p>

<h5>64.4-3 LieUpperCentralSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieUpperCentralSeries</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>is the (Lie) upper central series of the Lie algebra <var class="Arg">L</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats:= [ [[ 1, 0 ], [ 0, 0 ]], [[0,1],[0,0]], [[0,0],[0,1]] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:=LieAlgebra( Rationals, mats );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LieUpperCentralSeries( L );</span>
[ &lt;two-sided ideal in &lt;Lie algebra of dimension 3 over Rationals&gt;, 
      (dimension 1)&gt;, &lt;Lie algebra of dimension 0 over Rationals&gt; 
 ]
</pre></div>

<p><a id="X8208CE5F8286155F" name="X8208CE5F8286155F"></a></p>

<h4>64.5 <span class="Heading">Properties of a Lie Algebra</span></h4>

<p><a id="X7F97D08F7B738ADE" name="X7F97D08F7B738ADE"></a></p>

<h5>64.5-1 IsLieAbelian</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLieAbelian</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>returns <code class="keyw">true</code> if <var class="Arg">L</var> is a Lie algebra such that each product of elements in <var class="Arg">L</var> is zero, and <code class="keyw">false</code> otherwise.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"> T:= EmptySCTable( 5, 0, "antisymmetric" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"> L:= LieAlgebraByStructureConstants( Rationals, T );</span>
&lt;Lie algebra of dimension 5 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLieAbelian( L );</span>
true
</pre></div>

<p><a id="X78452F4E875A62A8" name="X78452F4E875A62A8"></a></p>

<h5>64.5-2 IsLieNilpotent</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLieNilpotent</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>A Lie algebra <var class="Arg">L</var> is defined to be (Lie) <em>nilpotent</em> when its (Lie) lower central series reaches the trivial subalgebra.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T:= EmptySCTable( 5, 0, "antisymmetric" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= LieAlgebraByStructureConstants( Rationals, T );</span>
&lt;Lie algebra of dimension 5 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLieNilpotent( L );</span>
true
</pre></div>

<p><a id="X859FF1B3812B8FCC" name="X859FF1B3812B8FCC"></a></p>

<h5>64.5-3 IsLieSolvable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLieSolvable</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>A Lie algebra <var class="Arg">L</var> is defined to be (Lie) <em>solvable</em> when its (Lie) derived series reaches the trivial subalgebra.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T:= EmptySCTable( 5, 0, "antisymmetric" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= LieAlgebraByStructureConstants( Rationals, T );</span>
&lt;Lie algebra of dimension 5 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLieSolvable( L );</span>
true
</pre></div>

<p><a id="X83F829017D46C544" name="X83F829017D46C544"></a></p>

<h4>64.6 <span class="Heading">Semisimple Lie Algebras and Root Systems</span></h4>

<p>This section contains some functions for dealing with semisimple Lie algebras and their root systems.</p>

<p><a id="X8401CDC2859F8A85" name="X8401CDC2859F8A85"></a></p>

<h5>64.6-1 SemiSimpleType</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SemiSimpleType</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">L</var> be a semisimple Lie algebra, i.e., a direct sum of simple Lie algebras. Then <code class="func">SemiSimpleType</code> returns the type of <var class="Arg">L</var>, i.e., a string containing the types of the simple summands of <var class="Arg">L</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "E", 8, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b:= BasisVectors( Basis( L ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K:= LieCentralizer(L, Subalgebra(L, [ b[61]+b[79]+b[101]+b[102] ]));</span>
&lt;Lie algebra of dimension 102 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lev:= LeviMalcevDecomposition(K);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SemiSimpleType( lev[1] );</span>
"B3 A1"
</pre></div>

<p><a id="X82EBF10A7B3B6F6E" name="X82EBF10A7B3B6F6E"></a></p>

<h5>64.6-2 ChevalleyBasis</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ChevalleyBasis</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">L</var> must be a semisimple Lie algebra with a split Cartan subalgebra. Then <code class="code">ChevalleyBasis(<var class="Arg">L</var>)</code> returns a list consisting of three sublists. Together these sublists form a Chevalley basis of <var class="Arg">L</var>. The first list contains the positive root vectors, the second list contains the negative root vectors, and the third list the Cartan elements of the Chevalley basis.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "G", 2, Rationals );</span>
&lt;Lie algebra of dimension 14 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ChevalleyBasis( L );</span>
[ [ v.1, v.2, v.3, v.4, v.5, v.6 ], 
  [ v.7, v.8, v.9, v.10, v.11, v.12 ], [ v.13, v.14 ] ]
</pre></div>

<p><a id="X79B5D27681193625" name="X79B5D27681193625"></a></p>

<h5>64.6-3 IsRootSystem</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsRootSystem</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>Category of root systems.</p>

<p><a id="X7D64D49479CBB203" name="X7D64D49479CBB203"></a></p>

<h5>64.6-4 IsRootSystemFromLieAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsRootSystemFromLieAlgebra</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>Category of root systems that come from (semisimple) Lie algebras. They often have special attributes such as <code class="func">UnderlyingLieAlgebra</code> (<a href="chap64_mj.html#X7CA021E28527763E"><span class="RefLink">64.6-6</span></a>), <code class="func">PositiveRootVectors</code> (<a href="chap64_mj.html#X829C78427A442C23"><span class="RefLink">64.6-9</span></a>), <code class="func">NegativeRootVectors</code> (<a href="chap64_mj.html#X7AB374DC87A39349"><span class="RefLink">64.6-10</span></a>), <code class="func">CanonicalGenerators</code> (<a href="chap64_mj.html#X7FAE45B37C5779A0"><span class="RefLink">64.6-14</span></a>).</p>

<p><a id="X80D15C027BB8029B" name="X80D15C027BB8029B"></a></p>

<h5>64.6-5 RootSystem</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RootSystem</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><code class="func">RootSystem</code> calculates the root system of the semisimple Lie algebra <var class="Arg">L</var> with a split Cartan subalgebra.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "G", 2, Rationals );</span>
&lt;Lie algebra of dimension 14 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( L );</span>
&lt;root system of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRootSystem( R );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRootSystemFromLieAlgebra( R );</span>
true
</pre></div>

<p><a id="X7CA021E28527763E" name="X7CA021E28527763E"></a></p>

<h5>64.6-6 UnderlyingLieAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingLieAlgebra</code>( <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For a root system <var class="Arg">R</var> coming from a semisimple Lie algebra <code class="code">L</code>, returns the Lie algebra <code class="code">L</code>.</p>

<p><a id="X7B6B0BBD8035D7E5" name="X7B6B0BBD8035D7E5"></a></p>

<h5>64.6-7 PositiveRoots</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PositiveRoots</code>( <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The list of positive roots of the root system <var class="Arg">R</var>.</p>

<p><a id="X81F9E0E67DD2688F" name="X81F9E0E67DD2688F"></a></p>

<h5>64.6-8 NegativeRoots</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NegativeRoots</code>( <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The list of negative roots of the root system <var class="Arg">R</var>.</p>

<p><a id="X829C78427A442C23" name="X829C78427A442C23"></a></p>

<h5>64.6-9 PositiveRootVectors</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PositiveRootVectors</code>( <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>A list of positive root vectors of the root system <var class="Arg">R</var> that comes from a Lie algebra <code class="code">L</code>. This is a list in bijection with the list <code class="code">PositiveRoots( L )</code> (see <code class="func">PositiveRoots</code> (<a href="chap64_mj.html#X7B6B0BBD8035D7E5"><span class="RefLink">64.6-7</span></a>)). The root vector is a non-zero element of the root space (in <code class="code">L</code>) of the corresponding root.</p>

<p><a id="X7AB374DC87A39349" name="X7AB374DC87A39349"></a></p>

<h5>64.6-10 NegativeRootVectors</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NegativeRootVectors</code>( <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>A list of negative root vectors of the root system <var class="Arg">R</var> that comes from a Lie algebra <code class="code">L</code>. This is a list in bijection with the list <code class="code">NegativeRoots( L )</code> (see <code class="func">NegativeRoots</code> (<a href="chap64_mj.html#X81F9E0E67DD2688F"><span class="RefLink">64.6-8</span></a>)). The root vector is a non-zero element of the root space (in <code class="code">L</code>) of the corresponding root.</p>

<p><a id="X7DBD179E7CCF6699" name="X7DBD179E7CCF6699"></a></p>

<h5>64.6-11 SimpleSystem</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimpleSystem</code>( <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>A list of simple roots of the root system <var class="Arg">R</var>.</p>

<p><a id="X84E3FEF587CB66C3" name="X84E3FEF587CB66C3"></a></p>

<h5>64.6-12 CartanMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CartanMatrix</code>( <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The Cartan matrix of the root system <var class="Arg">R</var>, relative to the simple roots in <code class="code">SimpleSystem( <var class="Arg">R</var> )</code> (see <code class="func">SimpleSystem</code> (<a href="chap64_mj.html#X7DBD179E7CCF6699"><span class="RefLink">64.6-11</span></a>)).</p>

<p><a id="X878644D68571BF44" name="X878644D68571BF44"></a></p>

<h5>64.6-13 BilinearFormMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BilinearFormMat</code>( <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The matrix of the bilinear form of the root system <var class="Arg">R</var>. If we denote this matrix by <span class="SimpleMath">\(B\)</span>, then we have <span class="SimpleMath">\(B(i,j) = (\alpha_i, \alpha_j)\)</span>, where the <span class="SimpleMath">\(\alpha_i\)</span> are the simple roots of <var class="Arg">R</var>.</p>

<p><a id="X7FAE45B37C5779A0" name="X7FAE45B37C5779A0"></a></p>

<h5>64.6-14 CanonicalGenerators</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CanonicalGenerators</code>( <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">R</var> must be a root system coming from a semisimple Lie algebra <code class="code">L</code>. This function returns <span class="SimpleMath">\(3l\)</span> generators of <var class="Arg">L</var>, <span class="SimpleMath">\(x_1, \ldots, x_l, y_1, \ldots, y_l, h_1, \ldots, h_l\)</span>, where <span class="SimpleMath">\(x_i\)</span> lies in the root space corresponding to the <span class="SimpleMath">\(i\)</span>-th simple root of the root system of <var class="Arg">L</var>, <span class="SimpleMath">\(y_i\)</span> lies in the root space corresponding to <span class="SimpleMath">\(-\)</span> the <span class="SimpleMath">\(i\)</span>-th simple root, and the <span class="SimpleMath">\(h_i\)</span> are elements of the Cartan subalgebra. These elements satisfy the relations <span class="SimpleMath">\(h_i * h_j = 0\)</span>, <span class="SimpleMath">\(x_i * y_j = \delta_{ij} h_i\)</span>, <span class="SimpleMath">\(h_j * x_i = c_{ij} x_i\)</span>, <span class="SimpleMath">\(h_j * y_i = -c_{ij} y_i\)</span>, where <span class="SimpleMath">\(c_{ij}\)</span> is the entry of the Cartan matrix on position <span class="SimpleMath">\(ij\)</span>.</p>

<p>Also if <span class="SimpleMath">\(a\)</span> is a root of the root system <var class="Arg">R</var> (so <span class="SimpleMath">\(a\)</span> is a list of numbers), then we have the relation <span class="SimpleMath">\(h_i * x = a[i] x\)</span>, where <span class="SimpleMath">\(x\)</span> is a root vector corresponding to <span class="SimpleMath">\(a\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "G", 2, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( L );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingLieAlgebra( R );</span>
&lt;Lie algebra of dimension 14 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PositiveRoots( R );</span>
[ [ 2, -1 ], [ -3, 2 ], [ -1, 1 ], [ 1, 0 ], [ 3, -1 ], [ 0, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:= PositiveRootVectors( R );</span>
[ v.1, v.2, v.3, v.4, v.5, v.6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=CanonicalGenerators( R );</span>
[ [ v.1, v.2 ], [ v.7, v.8 ], [ v.13, v.14 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g[3][1]*x[1];</span>
(2)*v.1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g[3][2]*x[1];</span>
(-1)*v.1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># i.e., x[1] is the root vector belonging to the root [ 2, -1 ]</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BilinearFormMat( R );</span>
[ [ 1/12, -1/8 ], [ -1/8, 1/4 ] ]
</pre></div>

<p><a id="X7945D07786D1C4BB" name="X7945D07786D1C4BB"></a></p>

<h4>64.7 <span class="Heading">Semisimple Lie Algebras and Weyl Groups of Root Systems</span></h4>

<p>This section deals with the Weyl group of a root system. A Weyl group is represented by its action on the weight lattice. A <em>weight</em> is by definition a linear function <span class="SimpleMath">\(\lambda: H \rightarrow F\)</span> (where <span class="SimpleMath">\(F\)</span> is the ground field), such that the values <span class="SimpleMath">\(\lambda(h_i)\)</span> are all integers (where the <span class="SimpleMath">\(h_i\)</span> are the Cartan elements of the <code class="func">CanonicalGenerators</code> (<a href="chap64_mj.html#X7FAE45B37C5779A0"><span class="RefLink">64.6-14</span></a>)). On the other hand each weight is determined by these values. Therefore we represent a weight by a vector of integers; the <span class="SimpleMath">\(i\)</span>-th entry of this vector is the value <span class="SimpleMath">\(\lambda(h_i)\)</span>. Now the elements of the Weyl group are represented by matrices, and if <code class="code">g</code> is an element of a Weyl group and <code class="code">w</code> a weight, then <code class="code">w*g</code> gives the result of applying <code class="code">g</code> to <code class="code">w</code>. Another way of applying the <span class="SimpleMath">\(i\)</span>-th simple reflection to a weight is by using the function <code class="func">ApplySimpleReflection</code> (<a href="chap64_mj.html#X7829BC4D7F253649"><span class="RefLink">64.7-4</span></a>).</p>

<p>A Weyl group is generated by the simple reflections. So <code class="func">GeneratorsOfGroup</code> (<a href="chap39_mj.html#X79C44528864044C5"><span class="RefLink">39.2-4</span></a>) for a Weyl group <code class="code">W</code> gives a list of matrices and the <span class="SimpleMath">\(i\)</span>-th entry of this list is the simple reflection corresponding to the <span class="SimpleMath">\(i\)</span>-th simple root of the corresponding root system.</p>

<p><a id="X82AA29DD7969A935" name="X82AA29DD7969A935"></a></p>

<h5>64.7-1 IsWeylGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsWeylGroup</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>A Weyl group is a group generated by reflections, with the attribute <code class="func">SparseCartanMatrix</code> (<a href="chap64_mj.html#X81EF01E57E5DC18A"><span class="RefLink">64.7-2</span></a>) set.</p>

<p><a id="X81EF01E57E5DC18A" name="X81EF01E57E5DC18A"></a></p>

<h5>64.7-2 SparseCartanMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SparseCartanMatrix</code>( <var class="Arg">W</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>This is a sparse form of the Cartan matrix of the corresponding root system. If we denote the Cartan matrix by <code class="code">C</code>, then the sparse Cartan matrix of <var class="Arg">W</var> is a list (of length equal to the length of the Cartan matrix), where the <code class="code">i</code>-th entry is a list consisting of elements <code class="code">[ j, C[i][j] ]</code>, where <code class="code">j</code> is such that <code class="code">C[i][j]</code> is non-zero.</p>

<p><a id="X86BED5098322EBEF" name="X86BED5098322EBEF"></a></p>

<h5>64.7-3 WeylGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WeylGroup</code>( <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The Weyl group of the root system <var class="Arg">R</var>. It is generated by the simple reflections. A simple reflection is represented by a matrix, and the result of letting a simple reflection <code class="code">m</code> act on a weight <code class="code">w</code> is obtained by <code class="code">w*m</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "F", 4, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( L );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W:= WeylGroup( R );</span>
&lt;matrix group with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWeylGroup( W );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SparseCartanMatrix( W );</span>
[ [ [ 1, 2 ], [ 3, -1 ] ], [ [ 2, 2 ], [ 4, -1 ] ], 
  [ [ 1, -1 ], [ 3, 2 ], [ 4, -1 ] ], 
  [ [ 2, -1 ], [ 3, -2 ], [ 4, 2 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= GeneratorsOfGroup( W );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ 1, 1, 1, 1 ]*g[2];</span>
[ 1, -1, 1, 2 ]
</pre></div>

<p><a id="X7829BC4D7F253649" name="X7829BC4D7F253649"></a></p>

<h5>64.7-4 ApplySimpleReflection</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ApplySimpleReflection</code>( <var class="Arg">SC</var>, <var class="Arg">i</var>, <var class="Arg">wt</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">SC</var> is the sparse Cartan matrix of a Weyl group. This function applies the <var class="Arg">i</var>-th simple reflection to the weight <var class="Arg">wt</var>, thus changing <var class="Arg">wt</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "F", 4, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W:= WeylGroup( RootSystem( L ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C:= SparseCartanMatrix( W );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w:= [ 1, 1, 1, 1 ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplySimpleReflection( C, 2, w );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w;</span>
[ 1, -1, 1, 2 ]
</pre></div>

<p><a id="X80A7204F7D40D80F" name="X80A7204F7D40D80F"></a></p>

<h5>64.7-5 LongestWeylWordPerm</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LongestWeylWordPerm</code>( <var class="Arg">W</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Let <span class="SimpleMath">\(g_0\)</span> be the longest element in the Weyl group <var class="Arg">W</var>, and let <span class="SimpleMath">\(\{ \alpha_1, \ldots, \alpha_l \}\)</span> be a simple system of the corresponding root system. Then <span class="SimpleMath">\(g_0\)</span> maps <span class="SimpleMath">\(\alpha_i\)</span> to <span class="SimpleMath">\(-\alpha_{{\sigma(i)}}\)</span>, where <span class="SimpleMath">\(\sigma\)</span> is a permutation of <span class="SimpleMath">\((1, \ldots, l)\)</span>. This function returns that permutation.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "E", 6, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W:= WeylGroup( RootSystem( L ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LongestWeylWordPerm( W );</span>
(1,6)(3,5)
</pre></div>

<p><a id="X7D4E213F82F73857" name="X7D4E213F82F73857"></a></p>

<h5>64.7-6 ConjugateDominantWeight</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConjugateDominantWeight</code>( <var class="Arg">W</var>, <var class="Arg">wt</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConjugateDominantWeightWithWord</code>( <var class="Arg">W</var>, <var class="Arg">wt</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">W</var> is a Weyl group and <var class="Arg">wt</var> a weight (i.e., a list of integers). <code class="func">ConjugateDominantWeight</code> returns the unique dominant weight conjugate to <var class="Arg">wt</var> under <var class="Arg">W</var>.</p>

<p><code class="func">ConjugateDominantWeightWithWord</code> returns a list of two elements. The first of these is the dominant weight conjugate to <var class="Arg">wt</var>. The second element is a list of indices of simple reflections that have to be applied to <var class="Arg">wt</var> in order to get the dominant weight conjugate to it.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "E", 6, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W:= WeylGroup( RootSystem( L ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C:= SparseCartanMatrix( W );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w:= [ 1, -1, 2, -2, 3, -3 ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugateDominantWeight( W, w );</span>
[ 2, 1, 0, 0, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c:= ConjugateDominantWeightWithWord( W, w );</span>
[ [ 2, 1, 0, 0, 0, 0 ], [ 2, 4, 2, 3, 6, 5, 4, 2, 3, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for i in [1..Length(c[2])] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">ApplySimpleReflection( C, c[2][i], w );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w;</span>
[ 2, 1, 0, 0, 0, 0 ]
</pre></div>

<p><a id="X7E000FA97949BFD5" name="X7E000FA97949BFD5"></a></p>

<h5>64.7-7 WeylOrbitIterator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WeylOrbitIterator</code>( <var class="Arg">W</var>, <var class="Arg">wt</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns an iterator for the orbit of the weight <var class="Arg">wt</var> under the action of the Weyl group <var class="Arg">W</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "E", 6, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W:= WeylGroup( RootSystem( L ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orb:= WeylOrbitIterator( W, [ 1, 1, 1, 1, 1, 1 ] );</span>
&lt;iterator&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextIterator( orb );</span>
[ 1, 1, 1, 1, 1, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextIterator( orb );</span>
[ -1, -1, -1, -1, -1, -1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orb:= WeylOrbitIterator( W, [ 1, 1, 1, 1, 1, 1 ] );</span>
&lt;iterator&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k:= 0;</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">while not IsDoneIterator( orb ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">w:= NextIterator( orb ); k:= k+1;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k;  # this is the size of the Weyl group of E6</span>
51840
</pre></div>

<p><a id="X878080BB79BE3F2E" name="X878080BB79BE3F2E"></a></p>

<h4>64.8 <span class="Heading">Restricted Lie algebras</span></h4>

<p>A Lie algebra <span class="SimpleMath">\(L\)</span> over a field of characteristic <span class="SimpleMath">\(p&gt;0\)</span> is called restricted if there is a map <span class="SimpleMath">\(x \mapsto x^p\)</span> from <span class="SimpleMath">\(L\)</span> into <span class="SimpleMath">\(L\)</span> (called a <span class="SimpleMath">\(p\)</span>-map) such that ad <span class="SimpleMath">\(x^p = (\)</span>ad<span class="SimpleMath">\( x)^p\)</span>, <span class="SimpleMath">\((\alpha x)^p = \alpha^p x^p\)</span> and <span class="SimpleMath">\((x+y)^p = x^p + y^p + \sum_{{i=1}}^{{p-1}} s_i(x,y)\)</span>, where <span class="SimpleMath">\(s_i: L \times L \rightarrow L\)</span> are certain Lie polynomials in two variables. Using these relations we can calculate <span class="SimpleMath">\(y^p\)</span> for all <span class="SimpleMath">\(y \in L\)</span>, once we know <span class="SimpleMath">\(x^p\)</span> for <span class="SimpleMath">\(x\)</span> in a basis of <span class="SimpleMath">\(L\)</span>. Therefore a <span class="SimpleMath">\(p\)</span>-map is represented in <strong class="pkg">GAP</strong>  by a list containing the images of the basis vectors of a basis <span class="SimpleMath">\(B\)</span> of <span class="SimpleMath">\(L\)</span>. For this reason this list is an attribute of the basis <span class="SimpleMath">\(B\)</span>.</p>

<p><a id="X81F28B1D830F28EB" name="X81F28B1D830F28EB"></a></p>

<h5>64.8-1 IsRestrictedLieAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsRestrictedLieAlgebra</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Test whether <var class="Arg">L</var> is restricted.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "W", [2], GF(5));</span>
&lt;Lie algebra of dimension 25 over GF(5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRestrictedLieAlgebra( L );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "W", [1], GF(5));</span>
&lt;Lie algebra of dimension 5 over GF(5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRestrictedLieAlgebra( L );</span>
true
</pre></div>

<p><a id="X7D7BD5908016461B" name="X7D7BD5908016461B"></a></p>

<h5>64.8-2 PthPowerImages</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PthPowerImages</code>( <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">B</var> is a basis of a restricted Lie algebra. This function returns the list of the images of the basis vectors of <var class="Arg">B</var> under the <span class="SimpleMath">\(p\)</span>-map.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "W", [1], GF(11) );</span>
&lt;Lie algebra of dimension 11 over GF(11)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B:= Basis( L );</span>
CanonicalBasis( &lt;Lie algebra of dimension 11 over GF(11)&gt; )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PthPowerImages( B );</span>
[ 0*v.1, v.2, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 
  0*v.1 ]
</pre></div>

<p><a id="X879BB01782E7D7A9" name="X879BB01782E7D7A9"></a></p>

<h5>64.8-3 PthPowerImage</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PthPowerImage</code>( <var class="Arg">B</var>, <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PthPowerImage</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PthPowerImage</code>( <var class="Arg">x</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>This function computes the image of an element <var class="Arg">x</var> of a restricted Lie algebra under its <span class="SimpleMath">\(p\)</span>-map.</p>

<p>In the first form, a basis of the Lie algebra is provided; this basis stores the <span class="SimpleMath">\(p\)</span>th powers of its elements. It is the traditional form, provided for backwards compatibility.</p>

<p>In its second form, only the element <var class="Arg">x</var> is provided. It is the only form for elements of Lie algebras with no predetermined basis, such as those constructed by <code class="func">LieObject</code> (<a href="chap64_mj.html#X87F121978775AF48"><span class="RefLink">64.1-1</span></a>).</p>

<p>In its third form, an extra non-negative integer <var class="Arg">n</var> is specified; the <span class="SimpleMath">\(p\)</span>-mapping is iterated <var class="Arg">n</var> times on the element <var class="Arg">x</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "W", [1], GF(11) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B:= Basis( L );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:= B[1]+B[11];</span>
v.1+v.11
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PthPowerImage( B, x );</span>
v.1+v.11
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PthPowerImage( x, 2 );</span>
v.1+v.11
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := FreeAssociativeAlgebra(GF(2),"x","y");</span>
&lt;algebra over GF(2), with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := LieObject(f.1);; y := LieObject(f.2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x*y; x^2; PthPowerImage(x);</span>
LieObject( (Z(2)^0)*x*y+(Z(2)^0)*y*x )
LieObject( &lt;zero&gt; of ... )
LieObject( (Z(2)^0)*x^2 )
</pre></div>

<p><a id="X8692ADD581359CA1" name="X8692ADD581359CA1"></a></p>

<h5>64.8-4 JenningsLieAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; JenningsLieAlgebra</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">G</var> be a nontrivial <span class="SimpleMath">\(p\)</span>-group, and let <span class="SimpleMath">\(\textit{G} = G_1 \supset G_2 \supset \cdots \supset G_m = 1\)</span> be its Jennings series (see <code class="func">JenningsSeries</code> (<a href="chap39_mj.html#X82A34BD681F24A94"><span class="RefLink">39.17-14</span></a>)). Then the quotients <span class="SimpleMath">\(G_i / G_{{i+1}}\)</span> are elementary abelian <span class="SimpleMath">\(p\)</span>-groups, i.e., they can be viewed as vector spaces over <code class="code">GF</code><span class="SimpleMath">\((p)\)</span>. Now the Jennings-Lie algebra <span class="SimpleMath">\(L\)</span> of <var class="Arg">G</var> is the direct sum of those vector spaces. The Lie bracket on <span class="SimpleMath">\(L\)</span> is induced by the commutator in <var class="Arg">G</var>. Furthermore, the map <span class="SimpleMath">\(g \mapsto g^p\)</span> in <var class="Arg">G</var> induces a <span class="SimpleMath">\(p\)</span>-map in <span class="SimpleMath">\(L\)</span> making <span class="SimpleMath">\(L\)</span> into a restricted Lie algebra. In the canonical basis of <span class="SimpleMath">\(L\)</span> this <span class="SimpleMath">\(p\)</span>-map is added as an attribute. A Lie algebra created by <code class="func">JenningsLieAlgebra</code> is naturally graded. The attribute <code class="func">Grading</code> (<a href="chap62_mj.html#X7DCA2568870A2D34"><span class="RefLink">62.9-20</span></a>) is set.</p>

<p><a id="X785251E879E1BFC6" name="X785251E879E1BFC6"></a></p>

<h5>64.8-5 PCentralLieAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PCentralLieAlgebra</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">G</var> is a nontrivial <span class="SimpleMath">\(p\)</span>-group. <code class="code">PCentralLieAlgebra( <var class="Arg">G</var> )</code> does the same as <code class="func">JenningsLieAlgebra</code> (<a href="chap64_mj.html#X8692ADD581359CA1"><span class="RefLink">64.8-4</span></a>) except that the <span class="SimpleMath">\(p\)</span>-central series is used instead of the Jennings series (see <code class="func">PCentralSeries</code> (<a href="chap39_mj.html#X7809B7ED792669F3"><span class="RefLink">39.17-13</span></a>)). This function also returns a graded Lie algebra. However, it is not necessarily restricted.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:= SmallGroup( 3^6, 123 );</span>
&lt;pc group of size 729 with 6 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= JenningsLieAlgebra( G );</span>
&lt;Lie algebra of dimension 6 over GF(3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HasPthPowerImages( Basis( L ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PthPowerImages( Basis( L ) );</span>
[ v.6, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Grading( L );</span>
rec( hom_components := function( d ) ... end, max_degree := 3, 
  min_degree := 1, source := Integers )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( [1,2,3], g.hom_components );</span>
[ &lt;vector space over GF(3), with 3 generators&gt;, 
  &lt;vector space over GF(3), with 2 generators&gt;, 
  &lt;vector space over GF(3), with 1 generators&gt; ]
</pre></div>

<p><a id="X781ADBEC850C7DE7" name="X781ADBEC850C7DE7"></a></p>

<h5>64.8-6 NaturalHomomorphismOfLieAlgebraFromNilpotentGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalHomomorphismOfLieAlgebraFromNilpotentGroup</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>This is an attribute of Lie algebras created by <code class="func">JenningsLieAlgebra</code> (<a href="chap64_mj.html#X8692ADD581359CA1"><span class="RefLink">64.8-4</span></a>) or <code class="func">PCentralLieAlgebra</code> (<a href="chap64_mj.html#X785251E879E1BFC6"><span class="RefLink">64.8-5</span></a>). Then <var class="Arg">L</var> is the direct sum of quotients of successive terms of the Jennings, or <span class="SimpleMath">\(p\)</span>-central series of a <span class="SimpleMath">\(p\)</span>-group G. Let <code class="code">Gi</code> be the <span class="SimpleMath">\(i\)</span>-th term in this series, and let <code class="code">f = NaturalHomomorphismOfLieAlgebraFromNilpotentGroup( <var class="Arg">L</var> )</code>, then for <code class="code">g</code> in <code class="code">Gi</code>, <code class="code">f( <var class="Arg">g</var>, <var class="Arg">i</var> )</code> returns the element of <var class="Arg">L</var> (lying in the <span class="SimpleMath">\(i\)</span>-th homogeneous component) corresponding to <code class="code">g</code>.</p>

<p><a id="X7C419FFA835EBE12" name="X7C419FFA835EBE12"></a></p>

<h4>64.9 <span class="Heading">The Adjoint Representation</span></h4>

<p>In this section we show functions for calculating with the adjoint representation of a Lie algebra (and the corresponding trace form, called the Killing form) (see also <code class="func">AdjointBasis</code> (<a href="chap62_mj.html#X788F4E6184E5C863"><span class="RefLink">62.9-5</span></a>) and <code class="func">IndicesOfAdjointBasis</code> (<a href="chap62_mj.html#X800A410B8536E6DD"><span class="RefLink">62.9-6</span></a>)).</p>

<p><a id="X786886D882795F78" name="X786886D882795F78"></a></p>

<h5>64.9-1 AdjointMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AdjointMatrix</code>( <var class="Arg">B</var>, <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>is the matrix of the adjoint representation of the element <var class="Arg">x</var> w.r.t. the basis <var class="Arg">B</var>. The adjoint map is the left multiplication by <var class="Arg">x</var>. The <span class="SimpleMath">\(i\)</span>-th column of the resulting matrix represents the image of the <span class="SimpleMath">\(i\)</span>-th basis vector of <var class="Arg">B</var> under left multiplication by <var class="Arg">x</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "A", 1, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AdjointMatrix( Basis( L ), Basis( L )[1] );</span>
[ [ 0, 0, -2 ], [ 0, 0, 0 ], [ 0, 1, 0 ] ]
</pre></div>

<p><a id="X873A64307AC6C63E" name="X873A64307AC6C63E"></a></p>

<h5>64.9-2 AdjointAssociativeAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AdjointAssociativeAlgebra</code>( <var class="Arg">L</var>, <var class="Arg">K</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>is the associative matrix algebra (with 1) generated by the matrices of the adjoint representation of the subalgebra <var class="Arg">K</var> on the Lie algebra <var class="Arg">L</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "A", 1, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AdjointAssociativeAlgebra( L, L );</span>
&lt;algebra of dimension 9 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AdjointAssociativeAlgebra( L, CartanSubalgebra( L ) );</span>
&lt;algebra of dimension 3 over Rationals&gt;
</pre></div>

<p><a id="X877CCFD5832E035D" name="X877CCFD5832E035D"></a></p>

<h5>64.9-3 KillingMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; KillingMatrix</code>( <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>is the matrix of the Killing form <span class="SimpleMath">\(\kappa\)</span> with respect to the basis <var class="Arg">B</var>, i.e., the matrix <span class="SimpleMath">\(( \kappa( b_i, b_j ) )\)</span> where <span class="SimpleMath">\(b_1, b_2, \ldots\)</span> are the basis vectors of <var class="Arg">B</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "A", 1, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KillingMatrix( Basis( L ) );</span>
[ [ 0, 4, 0 ], [ 4, 0, 0 ], [ 0, 0, 8 ] ]
</pre></div>

<p><a id="X8234046083B60F6E" name="X8234046083B60F6E"></a></p>

<h5>64.9-4 KappaPerp</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; KappaPerp</code>( <var class="Arg">L</var>, <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>is the orthogonal complement of the subspace <var class="Arg">U</var> of the Lie algebra <var class="Arg">L</var> with respect to the Killing form <span class="SimpleMath">\(\kappa\)</span>, that is, the set <span class="SimpleMath">\(U^{{\perp}} = \{ x \in L; \kappa( x, y ) = 0 \hbox{ for all } y \in L \}\)</span>.</p>

<p><span class="SimpleMath">\(U^{{\perp}}\)</span> is a subspace of <var class="Arg">L</var>, and if <var class="Arg">U</var> is an ideal of <var class="Arg">L</var> then <span class="SimpleMath">\(U^{{\perp}}\)</span> is a subalgebra of <var class="Arg">L</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "A", 1, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b:= BasisVectors( Basis( L ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= VectorSpace( Rationals, [b[1],b[2]] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KappaPerp( L, V );</span>
&lt;vector space of dimension 1 over Rationals&gt;
</pre></div>

<p><a id="X7A00601387A060CF" name="X7A00601387A060CF"></a></p>

<h5>64.9-5 IsNilpotentElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsNilpotentElement</code>( <var class="Arg">L</var>, <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p><var class="Arg">x</var> is nilpotent in <var class="Arg">L</var> if its adjoint matrix is a nilpotent matrix.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "A", 1, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsNilpotentElement( L, Basis( L )[1] );</span>
true
</pre></div>

<p><a id="X86EF3E6F7BC0A8AD" name="X86EF3E6F7BC0A8AD"></a></p>

<h5>64.9-6 NonNilpotentElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NonNilpotentElement</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>A non-nilpotent element of a Lie algebra <var class="Arg">L</var> is an element <span class="SimpleMath">\(x\)</span> such that ad<span class="SimpleMath">\(x\)</span> is not nilpotent. If <var class="Arg">L</var> is not nilpotent, then by Engel's theorem non-nilpotent elements exist in <var class="Arg">L</var>. In this case this function returns a non-nilpotent element of <var class="Arg">L</var>, otherwise (if <var class="Arg">L</var> is nilpotent) <code class="keyw">fail</code> is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "G", 2, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NonNilpotentElement( L );</span>
v.13
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsNilpotentElement( L, last );</span>
false
</pre></div>

<p><a id="X7A912D9E7B3BA874" name="X7A912D9E7B3BA874"></a></p>

<h5>64.9-7 FindSl2</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FindSl2</code>( <var class="Arg">L</var>, <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function tries to find a subalgebra <span class="SimpleMath">\(S\)</span> of the Lie algebra <var class="Arg">L</var> with <span class="SimpleMath">\(S\)</span> isomorphic to <span class="SimpleMath">\(sl_2\)</span> and such that the nilpotent element <var class="Arg">x</var> of <var class="Arg">L</var> is contained in <span class="SimpleMath">\(S\)</span>. If such an algebra exists then it is returned, otherwise <code class="keyw">fail</code> is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "G", 2, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b:= BasisVectors( Basis( L ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsNilpotentElement( L, b[1] );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FindSl2( L, b[1] );</span>
&lt;Lie algebra of dimension 3 over Rationals&gt;
</pre></div>

<p><a id="X7875070C85DD4E8E" name="X7875070C85DD4E8E"></a></p>

<h4>64.10 <span class="Heading">Universal Enveloping Algebras</span></h4>

<p><a id="X8226CD1680207A5F" name="X8226CD1680207A5F"></a></p>

<h5>64.10-1 UniversalEnvelopingAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UniversalEnvelopingAlgebra</code>( <var class="Arg">L</var>[, <var class="Arg">B</var>] )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns the universal enveloping algebra of the Lie algebra <var class="Arg">L</var>. The elements of this algebra are written on a Poincare-Birkhoff-Witt basis.</p>

<p>If a second argument <var class="Arg">B</var> is given, it must be a basis of <var class="Arg">L</var>, and an isomorphic copy of the universal enveloping algebra is returned, generated by the images (in the universal enveloping algebra) of the elements of <var class="Arg">B</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "A", 1, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UL:= UniversalEnvelopingAlgebra( L );</span>
&lt;algebra-with-one of dimension infinity over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= GeneratorsOfAlgebraWithOne( UL );</span>
[ [(1)*x.1], [(1)*x.2], [(1)*x.3] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g[3]^2*g[2]^2*g[1]^2;</span>
[(-4)*x.1*x.2*x.3^3+(1)*x.1^2*x.2^2*x.3^2+(2)*x.3^3+(2)*x.3^4]
</pre></div>

<p><a id="X7B8C71E07F50B286" name="X7B8C71E07F50B286"></a></p>

<h4>64.11 <span class="Heading">Finitely Presented Lie Algebras</span></h4>

<p>Finitely presented Lie algebras can be constructed from free Lie algebras by using the <code class="code">/</code> constructor, i.e., <code class="code">FL/[r1, ..., rk]</code> is the quotient of the free Lie algebra <code class="code">FL</code> by the ideal generated by the elements <code class="code">r1, ..., rk</code> of <code class="code">FL</code>. If the finitely presented Lie algebra <code class="code">K</code> happens to be finite dimensional then an isomorphic structure constants Lie algebra can be constructed by <code class="code">NiceAlgebraMonomorphism(K)</code> (see <code class="func">NiceAlgebraMonomorphism</code> (<a href="chap62_mj.html#X7B249E8E86D895F0"><span class="RefLink">62.10-9</span></a>)), which returns a surjective homomorphism. The structure constants Lie algebra can then be accessed by calling <code class="func">Range</code> (<a href="chap32_mj.html#X7B6FD7277CDE9FCB"><span class="RefLink">32.3-7</span></a>) for this map. Also limited computations with elements of the finitely presented Lie algebra are possible.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= FreeLieAlgebra( Rationals, "s", "t" );</span>
&lt;Lie algebra over Rationals, with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gL:= GeneratorsOfAlgebra( L );; s:= gL[1];; t:= gL[2];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K:= L/[ s*(s*t), t*(t*(s*t)), s*(t*(s*t))-t*(s*t) ];</span>
&lt;Lie algebra over Rationals, with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h:= NiceAlgebraMonomorphism( K );</span>
[ [(1)*s], [(1)*t] ] -&gt; [ v.1, v.2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= Range( h );</span>
&lt;Lie algebra of dimension 3 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLieNilpotent( U );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gK:= GeneratorsOfAlgebra( K );</span>
[ [(1)*s], [(1)*t] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gK[1]*(gK[2]*gK[1]) = Zero( K );</span>
true
</pre></div>

<p><a id="X780A5B457A051110" name="X780A5B457A051110"></a></p>

<h5>64.11-1 FpLieAlgebraByCartanMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FpLieAlgebraByCartanMatrix</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">C</var> must be a Cartan matrix. The function returns the finitely-presented Lie algebra over the field of rational numbers defined by this Cartan matrix. By Serre's theorem, this Lie algebra is a semisimple Lie algebra, and its root system has Cartan matrix <var class="Arg">C</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C:= [ [ 2, -1 ], [ -3, 2 ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K:= FpLieAlgebraByCartanMatrix( C );</span>
&lt;Lie algebra over Rationals, with 6 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h:= NiceAlgebraMonomorphism( K );</span>
[ [(1)*x1], [(1)*x2], [(1)*x3], [(1)*x4], [(1)*x5], [(1)*x6] ] -&gt; 
[ v.1, v.2, v.3, v.4, v.5, v.6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SemiSimpleType( Range( h ) );</span>
"G2"
</pre></div>

<p><a id="X79FD70C487EA9438" name="X79FD70C487EA9438"></a></p>

<h5>64.11-2 NilpotentQuotientOfFpLieAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NilpotentQuotientOfFpLieAlgebra</code>( <var class="Arg">FpL</var>, <var class="Arg">max</var>[, <var class="Arg">weights</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">FpL</var> is a finitely presented Lie algebra. Let <span class="SimpleMath">\(K\)</span> be the quotient of <var class="Arg">FpL</var> by the <var class="Arg">max</var>+1-th term of its lower central series. This function calculates a surjective homomorphism from <var class="Arg">FpL</var> onto <span class="SimpleMath">\(K\)</span>. When called with the third argument <var class="Arg">weights</var>, the <span class="SimpleMath">\(k\)</span>-th generator of <var class="Arg">FpL</var> gets assigned the <span class="SimpleMath">\(k\)</span>-th element of the list <var class="Arg">weights</var>. In that case a quotient is calculated of <var class="Arg">FpL</var> by the ideal generated by all elements of weight <var class="Arg">max</var>+1. If the list <var class="Arg">weights</var> only consists of <span class="SimpleMath">\(1\)</span>'s then the two calls are equivalent. The default value of <var class="Arg">weights</var> is a list (of length equal to the number of generators of <var class="Arg">FpL</var>) consisting of <span class="SimpleMath">\(1\)</span>'s.</p>

<p>If the relators of <var class="Arg">FpL</var> are homogeneous, then the resulting algebra is naturally graded.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= FreeLieAlgebra( Rationals, "x", "y" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= GeneratorsOfAlgebra(L);; x:= g[1]; y:= g[2];</span>
(1)*x
(1)*y
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rr:=[ ((y*x)*x)*x-6*(y*x)*y, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         3*((((y*x)*x)*x)*x)*x-20*(((y*x)*x)*x)*y ];</span>
[ (-1)*(x*(x*(x*y)))+(6)*((x*y)*y), 
  (-3)*(x*(x*(x*(x*(x*y)))))+(20)*(x*(x*((x*y)*y)))+(
    -20)*((x*(x*y))*(x*y)) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K:= L/rr;</span>
&lt;Lie algebra over Rationals, with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h:=NilpotentQuotientOfFpLieAlgebra(K, 50, [1,2] );</span>
[ [(1)*x], [(1)*y] ] -&gt; [ v.1, v.2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= Range( h );</span>
&lt;Lie algebra of dimension 50 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Grading( L );</span>
rec( hom_components := function( d ) ... end, max_degree := 50, 
  min_degree := 1, source := Integers )
</pre></div>

<p><a id="X7FBCB43C86BDD9C2" name="X7FBCB43C86BDD9C2"></a></p>

<h4>64.12 <span class="Heading">Modules over Lie Algebras and Their Cohomology</span></h4>

<p>Representations of Lie algebras are dealt with in the same way as representations of ordinary algebras (see <a href="chap62_mj.html#X818DE6C57D1A4B33"><span class="RefLink">62.11</span></a>). In this section we mainly deal with modules over general Lie algebras and their cohomology. The next section is devoted to modules over semisimple Lie algebras. An <span class="SimpleMath">\(s\)</span>-cochain of a module <span class="SimpleMath">\(V\)</span> over a Lie algebra <span class="SimpleMath">\(L\)</span> is an <span class="SimpleMath">\(s\)</span>-linear map</p>

<p class="center">\[
c: L \times \cdots \times L \rightarrow V ,
\]</p>

<p>with <span class="SimpleMath">\(s\)</span> factors <span class="SimpleMath">\(L\)</span>, that is skew-symmetric (meaning that if any of the arguments are interchanged, <span class="SimpleMath">\(c\)</span> changes to <span class="SimpleMath">\(-c\)</span>).</p>

<p>Let <span class="SimpleMath">\((x_1, \ldots, x_n)\)</span> be a basis of <span class="SimpleMath">\(L\)</span>. Then any <span class="SimpleMath">\(s\)</span>-cochain is determined by the values <span class="SimpleMath">\(c( x_{{i_1}}, \ldots, x_{{i_s}} )\)</span>, where <span class="SimpleMath">\(1 \leq i_1 &lt; i_2 &lt; \cdots &lt; i_s \leq \dim L\)</span>. Now this value again is a linear combination of basis elements of <span class="SimpleMath">\(V\)</span>: <span class="SimpleMath">\(c( x_{{i_1}}, \ldots, x_{{i_s}} ) = \sum \lambda^k_{{i_1,\ldots, i_s}} v_k\)</span>. Denote the dimension of <span class="SimpleMath">\(V\)</span> by <span class="SimpleMath">\(r\)</span>. Then we represent an <span class="SimpleMath">\(s\)</span>-cocycle by a list of <span class="SimpleMath">\(r\)</span> lists. The <span class="SimpleMath">\(j\)</span>-th of those lists consists of entries of the form</p>

<p class="center">\[
[ [ i_1, i_2, \ldots, i_s ], \lambda^j_{{i_1, \ldots, i_s}} ]
\]</p>

<p>where the coefficient on the second position is non-zero. (We only store those entries for which this coefficient is non-zero.) It follows that every <span class="SimpleMath">\(s\)</span>-tuple <span class="SimpleMath">\((i_1, \ldots, i_s)\)</span> gives rise to <span class="SimpleMath">\(r\)</span> basis elements.</p>

<p>So the zero cochain is represented by a list of the form <code class="code">[ [ ], [ ], \ldots, [ ] ]</code>. Furthermore, if <span class="SimpleMath">\(V\)</span> is, e.g., <span class="SimpleMath">\(4\)</span>-dimensional, then the <span class="SimpleMath">\(2\)</span>-cochain represented by</p>


<div class="example"><pre>
[ [ [ [1,2], 2] ], [ ], [ [ [1,2], 1/2 ] ], [ ] ]
</pre></div>

<p>maps the pair <span class="SimpleMath">\((x_1, x_2)\)</span> to <span class="SimpleMath">\(2v_1 + 1/2 v_3\)</span> (where <span class="SimpleMath">\(v_1\)</span> is the first basis element of <span class="SimpleMath">\(V\)</span>, and <span class="SimpleMath">\(v_3\)</span> the third), and all other pairs to zero.</p>

<p>By definition, <span class="SimpleMath">\(0\)</span>-cochains are constant maps <span class="SimpleMath">\(c( x ) = v_c \in V\)</span> for all <span class="SimpleMath">\(x \in L\)</span>. So <span class="SimpleMath">\(0\)</span>-cochains have a different representation: they are just represented by the list <code class="code">[ v_c ]</code>.</p>

<p>Cochains are constructed using the function <code class="func">Cochain</code> (<a href="chap64_mj.html#X79F3DF0D8791C2E3"><span class="RefLink">64.12-2</span></a>), if <var class="Arg">c</var> is a cochain, then its corresponding list is returned by <code class="code">ExtRepOfObj( <var class="Arg">c</var> )</code>.</p>

<p><a id="X82CC31CF79F59FEE" name="X82CC31CF79F59FEE"></a></p>

<h5>64.12-1 IsCochain</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCochain</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCochainCollection</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>Categories of cochains and of collections of cochains.</p>

<p><a id="X79F3DF0D8791C2E3" name="X79F3DF0D8791C2E3"></a></p>

<h5>64.12-2 Cochain</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Cochain</code>( <var class="Arg">V</var>, <var class="Arg">s</var>, <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Constructs a <var class="Arg">s</var>-cochain given by the data in <var class="Arg">obj</var>, with respect to the Lie algebra module <var class="Arg">V</var>. If <var class="Arg">s</var> is non-zero, then <var class="Arg">obj</var> must be a list.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "A", 1, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= AdjointModule( L );</span>
&lt;3-dimensional left-module over &lt;Lie algebra of dimension 
3 over Rationals&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c1:= Cochain( V, 2, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              [ [ [ [ 1, 3 ], -1 ] ], [ ], [ [ [ 2, 3 ], 1/2 ] ] ]);</span>
&lt;2-cochain&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExtRepOfObj( c1 );</span>
[ [ [ [ 1, 3 ], -1 ] ], [  ], [ [ [ 2, 3 ], 1/2 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c2:= Cochain( V, 0, Basis( V )[1] );</span>
&lt;0-cochain&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExtRepOfObj( c2 );</span>
v.1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCochain( c2 );</span>
true
</pre></div>

<p><a id="X7CF2919081600A3D" name="X7CF2919081600A3D"></a></p>

<h5>64.12-3 CochainSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CochainSpace</code>( <var class="Arg">V</var>, <var class="Arg">s</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns the space of all <var class="Arg">s</var>-cochains with respect to <var class="Arg">V</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "A", 1, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= AdjointModule( L );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C:=CochainSpace( V, 2 );</span>
&lt;vector space of dimension 9 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BasisVectors( Basis( C ) );</span>
[ &lt;2-cochain&gt;, &lt;2-cochain&gt;, &lt;2-cochain&gt;, &lt;2-cochain&gt;, &lt;2-cochain&gt;, 
  &lt;2-cochain&gt;, &lt;2-cochain&gt;, &lt;2-cochain&gt;, &lt;2-cochain&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExtRepOfObj( last[1] );</span>
[ [ [ [ 1, 2 ], 1 ] ], [  ], [  ] ]
</pre></div>

<p><a id="X7D6760DA84683011" name="X7D6760DA84683011"></a></p>

<h5>64.12-4 ValueCochain</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ValueCochain</code>( <var class="Arg">c</var>, <var class="Arg">y1</var>, <var class="Arg">y2</var>, <var class="Arg">...</var>, <var class="Arg">ys</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">c</var> is an <code class="code">s</code>-cochain. This function returns the value of <var class="Arg">c</var> when applied to the <code class="code">s</code> elements <var class="Arg">y1</var> to <var class="Arg">ys</var> (that lie in the Lie algebra acting on the module corresponding to <var class="Arg">c</var>). It is also possible to call this function with two arguments: first <var class="Arg">c</var> and then the list containing <code class="code"><var class="Arg">y1</var>,...,<var class="Arg">ys</var></code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "A", 1, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= AdjointModule( L );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C:= CochainSpace( V, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c:= Basis( C )[1];</span>
&lt;2-cochain&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"> ValueCochain( c, Basis(L)[2], Basis(L)[1] );</span>
(-1)*v.1
</pre></div>

<p><a id="X851F5EF47FA90CBC" name="X851F5EF47FA90CBC"></a></p>

<h5>64.12-5 LieCoboundaryOperator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieCoboundaryOperator</code>( <var class="Arg">c</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This is a function that takes an <code class="code">s</code>-cochain <var class="Arg">c</var>, and returns an <code class="code">s+1</code>-cochain. The coboundary operator is applied.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "A", 1, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= AdjointModule( L );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C:= CochainSpace( V, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c:= Basis( C )[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c1:= LieCoboundaryOperator( c );</span>
&lt;3-cochain&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c2:= LieCoboundaryOperator( c1 );</span>
&lt;4-cochain&gt;
</pre></div>

<p><a id="X7FB815F38143939E" name="X7FB815F38143939E"></a></p>

<h5>64.12-6 Cocycles</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Cocycles</code>( <var class="Arg">V</var>, <var class="Arg">s</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>is the space of all <var class="Arg">s</var>-cocycles with respect to the Lie algebra module <var class="Arg">V</var>. That is the kernel of the coboundary operator when restricted to the space of <var class="Arg">s</var>-cochains.</p>

<p><a id="X7C4F372C7AE2F739" name="X7C4F372C7AE2F739"></a></p>

<h5>64.12-7 Coboundaries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Coboundaries</code>( <var class="Arg">V</var>, <var class="Arg">s</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>is the space of all <var class="Arg">s</var>-coboundaries with respect to the Lie algebra module <var class="Arg">V</var>. That is the image of the coboundary operator, when applied to the space of <var class="Arg">s</var>-1-cochains. By definition the space of all 0-coboundaries is zero.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T:= EmptySCTable( 3, 0, "antisymmetric" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetEntrySCTable( T, 1, 2, [ 1, 3 ] );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= LieAlgebraByStructureConstants( Rationals, T );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= FaithfulModule( L );</span>
&lt;left-module over &lt;Lie algebra of dimension 3 over Rationals&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Cocycles( V, 2 );</span>
&lt;vector space of dimension 7 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Coboundaries( V, 2 );</span>
&lt;vector space over Rationals, with 9 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dimension( last );</span>
5
</pre></div>

<p><a id="X78A201238137E822" name="X78A201238137E822"></a></p>

<h4>64.13 <span class="Heading">Modules over Semisimple Lie Algebras</span></h4>

<p>This section contains functions for calculating information on representations of semisimple Lie algebras. First we have some functions for calculating some combinatorial data (set of dominant weights, the dominant character, the decomposition of a tensor product, the dimension of a highest-weight module). Then there is a function for creating an admissible lattice in the universal enveloping algebra of a semisimple Lie algebra. Finally we have a function for constructing a highest-weight module over a semisimple Lie algebra.</p>

<p><a id="X7D8522E37ED1024A" name="X7D8522E37ED1024A"></a></p>

<h5>64.13-1 DominantWeights</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DominantWeights</code>( <var class="Arg">R</var>, <var class="Arg">maxw</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns a list consisting of two lists. The first of these contains the dominant weights (written on the basis of fundamental weights) of the irreducible highest-weight module, with highest weight <var class="Arg">maxw</var>, over the Lie algebra with the root system <var class="Arg">R</var>. The <span class="SimpleMath">\(i\)</span>-th element of the second list is the level of the <span class="SimpleMath">\(i\)</span>-th dominant weight. (Where the level is defined as follows. For a weight <span class="SimpleMath">\(\mu\)</span> we write <span class="SimpleMath">\(\mu = \lambda - \sum_i k_i \alpha_i\)</span>, where the <span class="SimpleMath">\(\alpha_i\)</span> are the simple roots, and <span class="SimpleMath">\(\lambda\)</span> the highest weight. Then the level of <span class="SimpleMath">\(\mu\)</span> is <span class="SimpleMath">\(\sum_i k_i\)</span>.)</p>

<p><a id="X79AAC71E8267E9F8" name="X79AAC71E8267E9F8"></a></p>

<h5>64.13-2 DominantCharacter</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DominantCharacter</code>( <var class="Arg">L</var>, <var class="Arg">maxw</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DominantCharacter</code>( <var class="Arg">R</var>, <var class="Arg">maxw</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>For a highest weight <var class="Arg">maxw</var> and a semisimple Lie algebra <var class="Arg">L</var>, this returns the dominant weights of the highest-weight module over <var class="Arg">L</var>, with highest weight <var class="Arg">maxw</var>. The output is a list of two lists, the first list contains the dominant weights; the second list contains their multiplicities.</p>

<p>The first argument can also be a root system, in which case the dominant character of the highest-weight module over the corresponding semisimple Lie algebra is returned.</p>

<p><a id="X7BE7129384B012DF" name="X7BE7129384B012DF"></a></p>

<h5>64.13-3 DecomposeTensorProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DecomposeTensorProduct</code>( <var class="Arg">L</var>, <var class="Arg">w1</var>, <var class="Arg">w2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">L</var> is a semisimple Lie algebra and <var class="Arg">w1</var>, <var class="Arg">w2</var> are dominant weights. Let <span class="SimpleMath">\(V_i\)</span> be the irreducible highest-weight module over <var class="Arg">L</var> with highest weight <span class="SimpleMath">\(w_i\)</span> for <span class="SimpleMath">\(i = 1, 2\)</span>. Let <span class="SimpleMath">\(W = V_1 \otimes V_2\)</span>. Then in general <span class="SimpleMath">\(W\)</span> is a reducible <var class="Arg">L</var>-module. Now this function returns a list of two lists. The first of these is the list of highest weights of the irreducible modules occurring in the decomposition of <span class="SimpleMath">\(W\)</span> as a direct sum of irreducible modules. The second list contains the multiplicities of these weights (i.e., the number of copies of the irreducible module with the corresponding highest weight that occur in <span class="SimpleMath">\(W\)</span>). The algorithm uses Klimyk's formula (see <a href="chapBib_mj.html#biBKlimyk68">[Kli68]</a> or <a href="chapBib_mj.html#biBKlimyk66">[Kli66]</a> for the original Russian version).</p>

<p><a id="X7D67A9BC7E4714D9" name="X7D67A9BC7E4714D9"></a></p>

<h5>64.13-4 DimensionOfHighestWeightModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DimensionOfHighestWeightModule</code>( <var class="Arg">L</var>, <var class="Arg">w</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">L</var> is a semisimple Lie algebra, and <var class="Arg">w</var> a dominant weight. This function returns the dimension of the highest-weight module over <var class="Arg">L</var> with highest weight <var class="Arg">w</var>. The algorithm uses Weyl's dimension formula.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "F", 4, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( L );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DominantWeights( R, [ 1, 1, 0, 0 ] );</span>
[ [ [ 1, 1, 0, 0 ], [ 2, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 1, 0, 0 ], 
      [ 1, 0, 0, 0 ], [ 0, 0, 0, 0 ] ], [ 0, 3, 4, 8, 11, 19 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DominantCharacter( L, [ 1, 1, 0, 0 ] );</span>
[ [ [ 1, 1, 0, 0 ], [ 2, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 1, 0, 0 ], 
      [ 1, 0, 0, 0 ], [ 0, 0, 0, 0 ] ], [ 1, 1, 4, 6, 14, 21 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DecomposeTensorProduct( L, [ 1, 0, 0, 0 ], [ 0, 0, 1, 0 ] );</span>
[ [ [ 1, 0, 1, 0 ], [ 1, 0, 0, 0 ], [ 0, 0, 0, 1 ], [ 0, 1, 0, 0 ], 
      [ 2, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 1, 1, 0, 0 ] ], 
  [ 1, 1, 1, 1, 1, 1, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DimensionOfHighestWeightModule( L, [ 1, 2, 3, 4 ] );</span>
79316832731136
</pre></div>

<p><a id="X840E5FAE7D2C2702" name="X840E5FAE7D2C2702"></a></p>

<h4>64.14 <span class="Heading">Admissible Lattices in UEA</span></h4>

<p>Let <span class="SimpleMath">\(L\)</span> be a semisimple Lie algebra over a field of characteristic <span class="SimpleMath">\(0\)</span>, and let <span class="SimpleMath">\(R\)</span> be its root system. For a positive root <span class="SimpleMath">\(\alpha\)</span> we let <span class="SimpleMath">\(x_{\alpha}\)</span> and <span class="SimpleMath">\(y_{\alpha}\)</span> be positive and negative root vectors, respectively, both from a fixed Chevalley basis of <span class="SimpleMath">\(L\)</span>. Furthermore, <span class="SimpleMath">\(h_1, \ldots, h_l\)</span> are the Cartan elements from the same Chevalley basis. Also we set</p>

<p class="center">\[
x_{\alpha}^{(n)} = {{x_{\alpha}^n \over n!}},
y_{\alpha}^{(n)} = {{y_{\alpha}^n \over n!}} .
\]</p>

<p>Furthermore, let <span class="SimpleMath">\(\alpha_1, \ldots, \alpha_s\)</span> denote the positive roots of <span class="SimpleMath">\(R\)</span>. For multi-indices <span class="SimpleMath">\(N = (n_1, \ldots, n_s)\)</span>, <span class="SimpleMath">\(M = (m_1, \ldots, m_s)\)</span> and <span class="SimpleMath">\(K = (k_1, \ldots, k_s)\)</span> (where <span class="SimpleMath">\(n_i, m_i, k_i \geq 0\)</span>) set</p>

<div class="pcenter"><table class="GAPDocTablenoborder">
<tr>
<td class="tdleft"><span class="SimpleMath">\(x^N\)</span></td>
<td class="tdcenter">=</td>
<td class="tdleft"><span class="SimpleMath">\(x_{{\alpha_1}}^{(n_1)} \cdots x_{{\alpha_s}}^{(n_s)}\)</span>,</td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">\(y^M\)</span></td>
<td class="tdcenter">=</td>
<td class="tdleft"><span class="SimpleMath">\(y_{{\alpha_1}}^{(m_1)} \cdots y_{{\alpha_s}}^{(m_s)}\)</span>,</td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">\(h^K\)</span></td>
<td class="tdcenter">=</td>
<td class="tdleft"><span class="SimpleMath">\({{h_1 \choose k_1}} \cdots {{h_l \choose k_l}}\)</span></td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p>Then by a theorem of Kostant, the <span class="SimpleMath">\(x_{\alpha}^{(n)}\)</span> and <span class="SimpleMath">\(y_{\alpha}^{(n)}\)</span> generate a subring of the universal enveloping algebra <span class="SimpleMath">\(U(L)\)</span> spanned (as a free <span class="SimpleMath">\(Z\)</span>-module) by the elements</p>

<p class="center">\[
y^M h^K x^N
\]</p>

<p>(see, e.g., <a href="chapBib_mj.html#biBHum72">[Hum72]</a> or <a href="chapBib_mj.html#biBHum78">[Hum78, Section 26]</a>) So by the Poincare-Birkhoff-Witt theorem this subring is a lattice in <span class="SimpleMath">\(U(L)\)</span>. Furthermore, this lattice is invariant under the <span class="SimpleMath">\(x_{\alpha}^{(n)}\)</span> and <span class="SimpleMath">\(y_{\alpha}^{(n)}\)</span>. Therefore, it is called an admissible lattice in <span class="SimpleMath">\(U(L)\)</span>.</p>

<p>The next functions enable us to construct the generators of such an admissible lattice.</p>

<p><a id="X86E6722379576746" name="X86E6722379576746"></a></p>

<h5>64.14-1 IsUEALatticeElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsUEALatticeElement</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsUEALatticeElementCollection</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsUEALatticeElementFamily</code>( <var class="Arg">fam</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>is the category of elements of an admissible lattice in the universal enveloping algebra of a semisimple Lie algebra <code class="code">L</code>.</p>

<p><a id="X79F4F58B7888B0A5" name="X79F4F58B7888B0A5"></a></p>

<h5>64.14-2 LatticeGeneratorsInUEA</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LatticeGeneratorsInUEA</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">L</var> must be a semisimple Lie algebra of characteristic <span class="SimpleMath">\(0\)</span>. This function returns a list of generators of an admissible lattice in the universal enveloping algebra of <var class="Arg">L</var>, relative to the Chevalley basis contained in <code class="code">ChevalleyBasis( <var class="Arg">L</var> )</code> (see <code class="func">ChevalleyBasis</code> (<a href="chap64_mj.html#X82EBF10A7B3B6F6E"><span class="RefLink">64.6-2</span></a>)). First are listed the negative root vectors (denoted by <span class="SimpleMath">\(y_1, \ldots, y_s\)</span>), then the positive root vectors (denoted by <span class="SimpleMath">\(x_1, \ldots, x_s\)</span>). At the end of the list there are the Cartan elements. They are printed as <code class="code">( hi/1 )</code>, which means</p>

<p class="center">\[
{{h_i \choose 1}}.
\]</p>

<p>In general the printed form <code class="code">( hi/ k )</code> means</p>

<p class="center">\[
{{h_i \choose k}}.
\]</p>

<p>Also <span class="SimpleMath">\(y_i^{(m)}\)</span> is printed as <code class="code">yi^(m)</code>, which means that entering <code class="code">yi^m</code> at the <strong class="pkg">GAP</strong> prompt results in the output <code class="code">m!*yi^(m)</code>.</p>

<p>Products of lattice generators are collected using the following order: first come the <span class="SimpleMath">\(y_i^{(m_i)}\)</span> (in the same order as the positive roots), then the <span class="SimpleMath">\({h_i \choose k_i}\)</span>, and then the <span class="SimpleMath">\(x_i^{(n_i)}\)</span> (in the same order as the positive roots).</p>

<p><a id="X875FD1627F3B72DB" name="X875FD1627F3B72DB"></a></p>

<h5>64.14-3 ObjByExtRep</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ObjByExtRep</code>( <var class="Arg">F</var>, <var class="Arg">descr</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>An UEALattice element is represented by a list of the form <code class="code">[ m1, c1, m2, c2, ... ]</code>, where the <code class="code">c1</code>, <code class="code">c2</code> etc. are coefficients, and the <code class="code">m1</code>, <code class="code">m2</code> etc. are monomials. A monomial is a list of the form <code class="code">[ ind1, e1, ind2, e2, ... ]</code> where <code class="code">ind1</code>, <code class="code">ind2</code> are indices, and <code class="code">e1</code>, <code class="code">e2</code> etc. are exponents. Let <span class="SimpleMath">\(N\)</span> be the number of positive roots of the underlying Lie algebra <code class="code">L</code>. The indices lie between 1 and <span class="SimpleMath">\(dim(L)\)</span>. If an index lies between 1 and <code class="code">N</code>, then it represents a negative root vector (corresponding to the root <code class="code">NegativeRoots( R )[ind]</code>, where <code class="code">R</code> is the root system of <code class="code">L</code>; see <code class="func">NegativeRoots</code> (<a href="chap64_mj.html#X81F9E0E67DD2688F"><span class="RefLink">64.6-8</span></a>)). This leads to a factor <code class="code">yind1^(e1)</code> in the printed form of the monomial (which equals <code class="code">z^e1/e1!</code>, where <code class="code">z</code> is a basis element of <code class="code">L</code>). If an index lies between <span class="SimpleMath">\(N+1\)</span> and <span class="SimpleMath">\(2N\)</span>, then it represents a positive root vector. Finally, if ind lies between <span class="SimpleMath">\(2N+1\)</span> and <span class="SimpleMath">\(2N+rank\)</span>, then it represents an element of the Cartan subalgebra. This is printed as <span class="SimpleMath">\(( h_1/ e_1 )\)</span>, meaning <span class="SimpleMath">\({h_1 \choose e_1}\)</span>, where <span class="SimpleMath">\(h_1, \ldots, h_{rank}\)</span> are the canonical Cartan generators.</p>

<p>The zero element is represented by the empty list, the identity element by the list <code class="code">[ [], 1 ]</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "G", 2, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=LatticeGeneratorsInUEA( L );</span>
[ y1, y2, y3, y4, y5, y6, x1, x2, x3, x4, x5, x6, ( h13/1 ), 
  ( h14/1 ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsUEALatticeElement( g[1] );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g[1]^3;</span>
6*y1^(3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q:= g[7]*g[1]^2;</span>
-2*y1+2*y1*( h13/1 )+2*y1^(2)*x1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExtRepOfObj( q );</span>
[ [ 1, 1 ], -2, [ 1, 1, 13, 1 ], 2, [ 1, 2, 7, 1 ], 2 ]
</pre></div>

<p><a id="X8248DB547B02B0FA" name="X8248DB547B02B0FA"></a></p>

<h5>64.14-4 IsWeightRepElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsWeightRepElement</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsWeightRepElementCollection</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsWeightRepElementFamily</code>( <var class="Arg">fam</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>Is a category of vectors, that is used to construct elements of highest-weight modules (by <code class="func">HighestWeightModule</code> (<a href="chap64_mj.html#X7FB14F7F80EFF33F"><span class="RefLink">64.14-5</span></a>)).</p>

<p><code class="code">WeightRepElement</code>s are represented by a list of the form <code class="code">[ v1, c1, v2, c2, ....]</code>, where the <code class="code">vi</code> are basis vectors, and the <code class="code">ci</code> are coefficients. Furthermore a basis vector <code class="code">v</code> is a weight vector. It is represented by a list of the form <code class="code">[ k, mon, wt ]</code>, where <code class="code">k</code> is an integer (the basis vectors are numbered from <span class="SimpleMath">\(1\)</span> to <span class="SimpleMath">\(\dim V\)</span>, where <span class="SimpleMath">\(V\)</span> is the highest weight module), <code class="code">mon</code> is an <code class="code">UEALatticeElement</code> (which means that the result of applying <code class="code">mon</code> to a highest weight vector is <code class="code">v</code>; see <code class="func">IsUEALatticeElement</code> (<a href="chap64_mj.html#X86E6722379576746"><span class="RefLink">64.14-1</span></a>)) and <code class="code">wt</code> is the weight of <code class="code">v</code>. A <code class="code">WeightRepElement</code> is printed as <code class="code">mon*v0</code>, where <code class="code">v0</code> denotes a fixed highest weight vector.</p>

<p>If <code class="code">v</code> is a <code class="code">WeightRepElement</code>, then <code class="code">ExtRepOfObj( v )</code> returns the corresponding list, and if <code class="code">list</code> is such a list and <var class="Arg">fam</var> a <code class="code">WeightRepElementFamily</code>, then <code class="code">ObjByExtRep( <var class="Arg">list</var>, <var class="Arg">fam</var> )</code> returns the corresponding <code class="code">WeightRepElement</code>.</p>

<p><a id="X7FB14F7F80EFF33F" name="X7FB14F7F80EFF33F"></a></p>

<h5>64.14-5 HighestWeightModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HighestWeightModule</code>( <var class="Arg">L</var>, <var class="Arg">wt</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>returns the highest weight module with highest weight <var class="Arg">wt</var> of the semisimple Lie algebra <var class="Arg">L</var> of characteristic <span class="SimpleMath">\(0\)</span>.</p>

<p>Note that the elements of such a module lie in the category <code class="func">IsLeftAlgebraModuleElement</code> (<a href="chap62_mj.html#X80E786467F9163F9"><span class="RefLink">62.11-9</span></a>) (and in particular they do not lie in the category <code class="func">IsWeightRepElement</code> (<a href="chap64_mj.html#X8248DB547B02B0FA"><span class="RefLink">64.14-4</span></a>)). However, if <code class="code">v</code> is an element of such a module, then <code class="code">ExtRepOfObj( v )</code> is a <code class="code">WeightRepElement</code>.</p>

<p>Note that for the following examples of this chapter we increase the line length limit from its default value 80 to 81 in order to make some long output expressions fit into the lines.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K1:= SimpleLieAlgebra( "G", 2, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K2:= SimpleLieAlgebra( "B", 2, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= DirectSumOfAlgebras( K1, K2 );</span>
&lt;Lie algebra of dimension 24 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= HighestWeightModule( L, [ 0, 1, 1, 1 ] );</span>
&lt;224-dimensional left-module over &lt;Lie algebra of dimension 
24 over Rationals&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vv:= GeneratorsOfLeftModule( V );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vv[100];</span>
y5*y7*y10*v0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e:= ExtRepOfObj( vv[100] );</span>
y5*y7*y10*v0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExtRepOfObj( e );</span>
[ [ 100, y5*y7*y10, [ -3, 2, -1, 1 ] ], 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Basis(L)[17]^vv[100];</span>
-1*y5*y7*y8*v0-1*y5*y9*v0
</pre></div>

<p><a id="X78515F448644204E" name="X78515F448644204E"></a></p>

<h4>64.15 <span class="Heading">Tensor Products and Exterior and Symmetric Powers</span></h4>

<p><a id="X7A1E0AC4800E7FDA" name="X7A1E0AC4800E7FDA"></a></p>

<h5>64.15-1 TensorProductOfAlgebraModules</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TensorProductOfAlgebraModules</code>( <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TensorProductOfAlgebraModules</code>( <var class="Arg">V</var>, <var class="Arg">W</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here the elements of <var class="Arg">list</var> must be algebra modules. The tensor product is returned as an algebra module. The two-argument version works in the same way and returns the tensor product of its arguments.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra("G",2,Rationals);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= HighestWeightModule( L, [ 1, 0 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W:= TensorProductOfAlgebraModules( [ V, V, V ] );</span>
&lt;343-dimensional left-module over &lt;Lie algebra of dimension 
14 over Rationals&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w:= Basis(W)[1];</span>
1*(1*v0&lt;x&gt;1*v0&lt;x&gt;1*v0)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Basis(L)[1]^w;</span>
&lt;0-tensor&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Basis(L)[7]^w;</span>
1*(1*v0&lt;x&gt;1*v0&lt;x&gt;y1*v0)+1*(1*v0&lt;x&gt;y1*v0&lt;x&gt;1*v0)+1*(y
1*v0&lt;x&gt;1*v0&lt;x&gt;1*v0)
</pre></div>

<p><a id="X7F4AB6A1863E8FB2" name="X7F4AB6A1863E8FB2"></a></p>

<h5>64.15-2 ExteriorPowerOfAlgebraModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExteriorPowerOfAlgebraModule</code>( <var class="Arg">V</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">V</var> must be an algebra module, defined over a Lie algebra. This function returns the <var class="Arg">k</var>-th exterior power of <var class="Arg">V</var> as an algebra module.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra("G",2,Rationals);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= HighestWeightModule( L, [ 1, 0 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W:= ExteriorPowerOfAlgebraModule( V, 3 );</span>
&lt;35-dimensional left-module over &lt;Lie algebra of dimension 
14 over Rationals&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w:= Basis(W)[1];</span>
1*(1*v0/\y1*v0/\y3*v0)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Basis(L)[10]^w;</span>
1*(1*v0/\y1*v0/\y6*v0)+1*(1*v0/\y3*v0/\y5*v0)+1*(y1*v0/\y3*v0/\y4*v0)
</pre></div>

<p><a id="X842DF85687D61A56" name="X842DF85687D61A56"></a></p>

<h5>64.15-3 SymmetricPowerOfAlgebraModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SymmetricPowerOfAlgebraModule</code>( <var class="Arg">V</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">V</var> must be an algebra module. This function returns the <var class="Arg">k</var>-th symmetric power of <var class="Arg">V</var> (as an algebra module).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra("G",2,Rationals);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= HighestWeightModule( L, [ 1, 0 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W:= SymmetricPowerOfAlgebraModule( V, 3 );</span>
&lt;84-dimensional left-module over &lt;Lie algebra of dimension 
14 over Rationals&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w:= Basis(W)[1];</span>
1*(1*v0.1*v0.1*v0)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Basis(L)[2]^w;</span>
&lt;0-symmetric element&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Basis(L)[7]^w;</span>
3*(1*v0.1*v0.y1*v0)
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap63_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap65_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chap14_mj.html">14</a>  <a href="chap15_mj.html">15</a>  <a href="chap16_mj.html">16</a>  <a href="chap17_mj.html">17</a>  <a href="chap18_mj.html">18</a>  <a href="chap19_mj.html">19</a>  <a href="chap20_mj.html">20</a>  <a href="chap21_mj.html">21</a>  <a href="chap22_mj.html">22</a>  <a href="chap23_mj.html">23</a>  <a href="chap24_mj.html">24</a>  <a href="chap25_mj.html">25</a>  <a href="chap26_mj.html">26</a>  <a href="chap27_mj.html">27</a>  <a href="chap28_mj.html">28</a>  <a href="chap29_mj.html">29</a>  <a href="chap30_mj.html">30</a>  <a href="chap31_mj.html">31</a>  <a href="chap32_mj.html">32</a>  <a href="chap33_mj.html">33</a>  <a href="chap34_mj.html">34</a>  <a href="chap35_mj.html">35</a>  <a href="chap36_mj.html">36</a>  <a href="chap37_mj.html">37</a>  <a href="chap38_mj.html">38</a>  <a href="chap39_mj.html">39</a>  <a href="chap40_mj.html">40</a>  <a href="chap41_mj.html">41</a>  <a href="chap42_mj.html">42</a>  <a href="chap43_mj.html">43</a>  <a href="chap44_mj.html">44</a>  <a href="chap45_mj.html">45</a>  <a href="chap46_mj.html">46</a>  <a href="chap47_mj.html">47</a>  <a href="chap48_mj.html">48</a>  <a href="chap49_mj.html">49</a>  <a href="chap50_mj.html">50</a>  <a href="chap51_mj.html">51</a>  <a href="chap52_mj.html">52</a>  <a href="chap53_mj.html">53</a>  <a href="chap54_mj.html">54</a>  <a href="chap55_mj.html">55</a>  <a href="chap56_mj.html">56</a>  <a href="chap57_mj.html">57</a>  <a href="chap58_mj.html">58</a>  <a href="chap59_mj.html">59</a>  <a href="chap60_mj.html">60</a>  <a href="chap61_mj.html">61</a>  <a href="chap62_mj.html">62</a>  <a href="chap63_mj.html">63</a>  <a href="chap64_mj.html">64</a>  <a href="chap65_mj.html">65</a>  <a href="chap66_mj.html">66</a>  <a href="chap67_mj.html">67</a>  <a href="chap68_mj.html">68</a>  <a href="chap69_mj.html">69</a>  <a href="chap70_mj.html">70</a>  <a href="chap71_mj.html">71</a>  <a href="chap72_mj.html">72</a>  <a href="chap73_mj.html">73</a>  <a href="chap74_mj.html">74</a>  <a href="chap75_mj.html">75</a>  <a href="chap76_mj.html">76</a>  <a href="chap77_mj.html">77</a>  <a href="chap78_mj.html">78</a>  <a href="chap79_mj.html">79</a>  <a href="chap80_mj.html">80</a>  <a href="chap81_mj.html">81</a>  <a href="chap82_mj.html">82</a>  <a href="chap83_mj.html">83</a>  <a href="chap84_mj.html">84</a>  <a href="chap85_mj.html">85</a>  <a href="chap86_mj.html">86</a>  <a href="chap87_mj.html">87</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
