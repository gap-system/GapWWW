<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (CAP) - Chapter 7: Add Functions</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap7"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap6.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap8.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap7_mj.html">[MathJax on]</a></p>
<p><a id="X87A9DB228112DF45" name="X87A9DB228112DF45"></a></p>
<div class="ChapSects"><a href="chap7.html#X87A9DB228112DF45">7 <span class="Heading">Add Functions</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7.html#X85EC14607B6F66FE">7.1 <span class="Heading">Functions Installed by Add</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7.html#X85E3D9E07B8BC960">7.2 <span class="Heading">Add Method</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7.html#X7D83FC527EA66166">7.3 <span class="Heading">InstallAdd Function</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7.html#X78B69C307CF0DE53">7.4 <span class="Heading">Install All Adds</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7.html#X7AFA0108870EE97C">7.5 <span class="Heading">Prepare functions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X84409FF87D35BE99">7.5-1 CAPOperationPrepareFunction</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7843089F86F47D3B">7.5-2 CAPAddPrepareFunction</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X82AEE9507F0B48BC">7.5-3 ListCAPPrepareFunctions</a></span>
</div></div>
</div>

<h3>7 <span class="Heading">Add Functions</span></h3>

<p>This section describes the overall structure of Add-functions and the functions installed by them.</p>

<p><a id="X85EC14607B6F66FE" name="X85EC14607B6F66FE"></a></p>

<h4>7.1 <span class="Heading">Functions Installed by Add</span></h4>

<p>Add functions (up to some exceptions) have the following syntax</p>

<p>DeclareOperation( "AddSomeFunc", [ IsCapCategory, IsList, IsInt ] );</p>

<p>The first argument is the category to which some function (e.g. KernelObject) is added, the second is a list containing pairs of functions and additional filters for the arguments, (e.g. if one argument is a morphism, an additional filter could be IsMomomorphism). The third is a weight which will then be the weight for SomeFunc. This is described later. If only one function is to be installed, the list can be replaced by the function. Via InstallMethod, CAP installs the given function(s) as methods for the install name of SomeFunc, as listed in the MethodRecord. If no install name is given, the name SomeFunc is used.</p>

<p>All installed methods follow the following steps, described below:</p>


<ul>
<li><p>Redirect function</p>

</li>
<li><p>Prefunction</p>

</li>
<li><p>Function</p>

</li>
<li><p>Logic</p>

</li>
<li><p>Postfunction</p>

</li>
<li><p>Addfunction</p>

</li>
</ul>
<p>Every other part, except from function, does only depend on the name SomeFunc. We now explain the steps in detail.</p>


<ul>
<li><p>Redirect function: The redirect is used to redirect the computation from the given functions to some other symbol. If there is for example a with given method for some universal property, and the universal object is already computed, the redirect function might detect such a thing, calls the with given operation with the universal object as additional argument and then returns the value. In general, the redirect can be an arbitrary function. It is called with the same arguments as the operation SomeFunc itself and can return an array containing [ true, something ], which will cause the installed method to simply return the object something, or [ false ]. If the output is false, the computation will continue with the step Prefunction. Additionally, for every category and every name like SomeFunc, there is a boolean, stored in the categorys redirects component under the name of SomeFunc, which, when it is false, will prevent the redirect function from being executed.</p>

</li>
</ul>

<ul>
<li><p>Prefunction: The prefunction should be used for error handling and soft checks of the sanity of the input to SomeFunc (e.g. for KernelLift it should check wether range and source of the morphims coincide). Generally, the prefunction is defined in the method record and only depend on the name SomeFunc. It is called with the same input as the function itself, and should return either [ true ], which continues the computation, or [ false, "message" ], which will cause an error with message "message" and some additional information.</p>

</li>
</ul>

<ul>
<li><p>Full prefunction: The full prefuction has the same semantics as the prefunction, but can perform additional, very costly checks. They are disabled by default.</p>

</li>
</ul>

<ul>
<li><p>Function: This will launch the function(s) given as arguments. The result should be as specified in the type of SomeFunc. The resulting object is now named the result.</p>

</li>
</ul>

<ul>
<li><p>Logic: For every function, some logical todos can be implemented in a logic texfile for the category. If there is some logic written down in a file belonging to the category, or belonging to some type of category. Please see the description of logic for more details. If there is some logic and some predicate relations for the function SomeFunc, it is installed in this step for the result.</p>

</li>
</ul>

<ul>
<li><p>Postfunction: The postfunction called with the arguments of the function and the result. It can be an arbitrary function doing some cosmetics. If for example SomeFunc is KernelEmbeddingedding, it will set the KernelObject of the input morphism to result. The postfunction is also taken from the method record and does only depend on the name SomeFunc.</p>

</li>
</ul>

<ul>
<li><p>Addfunction: If the result is a category cell, it is added to the category for which the function was installed.</p>

</li>
</ul>
<p><a id="X85E3D9E07B8BC960" name="X85E3D9E07B8BC960"></a></p>

<h4>7.2 <span class="Heading">Add Method</span></h4>

<p>Except from installing a new method for the name SomeFunc, an Add method does slightly more. Every Add method has the same structure. The steps in the Add method are as follows:</p>


<ul>
<li><p>Weight check: If the current weight of the operation is lower than the given weight of the new functions, then the add function returns and installs nothing.</p>

</li>
</ul>

<ul>
<li><p>Option check: There are two possible options for every add method: SetPrimitive and IsDerivation.</p>


<ul>
<li><p>SetPrimitive should be a boolean, the default is true. If SetPrimitive is false, then the current call of this add will not set the installed function to be primitive. This is used for derivations.</p>

</li>
<li><p>IsDerivation should be a boolean, default is false. If it is true, the add method assumes that the given function is a derivation and does not try to install a corresponding pair (See below).</p>

</li>
</ul>
</li>
</ul>

<ul>
<li><p>Standard weight: If the weight parameter is -1, the Standard weight is assumed, which is 100.</p>

</li>
</ul>

<ul>
<li><p>Checking for pairs: If the function is not a with given operation, has a corresponding with given or is a with given, and is newly installed, i.e. the current installation weight which is given to the add function is less than the current weight, the add method is going to install a corresponding pair function, i.e. a function for the corresponding with or without given method, which redirects to the currently installed functions. It also deactivates the redirect for this function. Note that the pair install is only done for primitive functions, and if the current weight is higher than the given weight.</p>

</li>
</ul>

<ul>
<li><p>Can compute: Set the corresponding can compute of the category to true</p>

</li>
</ul>

<ul>
<li><p>Install methods: Decide on the methods used to install the function. Check wether InstallMethodWithCache, InstallMethodWithToDoForIsWellDefined, both, or simply InstallMethod is used. This is decided by the ToDo and the caching flags.</p>

</li>
</ul>

<ul>
<li><p>Installation: Next, the method to install the functions is created. It creates the correct filter list, by merging the standard filters for the operation with the particular filters for the given functions, then installs the method as described above.</p>

</li>
</ul>

<ul>
<li><p>SetPrimitive: If the set primitive flag is true, it is set as primitive in the weight list of the category.</p>

</li>
</ul>

<ul>
<li><p>Pair install: If there is a function pair, as described above, it is installed.</p>

</li>
</ul>
<p>After calling an add method, the corresponding Operation is available in the category. Also, some derivations, which are triggered by the setting of the primitive value, might be available.</p>

<p><a id="X7D83FC527EA66166" name="X7D83FC527EA66166"></a></p>

<h4>7.3 <span class="Heading">InstallAdd Function</span></h4>

<p>Almost all Add methods in the CAP kernel are installed by the CapInternalInstallAdd operation. The definition of this function is as follows:</p>

<p>DeclareOperation( "CapInternalInstallAdd", [ IsRecord ] );</p>

<p>The record can have the following components, used as described:</p>


<ul>
<li><p>function_name: The name of the function. This does not have to coincide with the installation name. It is used for the derivation weight.</p>

</li>
</ul>

<ul>
<li><p>installation_name (optional): A string which is the name of the operation for which the functions given to the Add method are installed as methods.</p>

</li>
</ul>

<ul>
<li><p>pre_function (optional): A function which is used as the prefunction of the installed methods, as described above.</p>

</li>
</ul>

<ul>
<li><p>redirect_function (optional): A function which is used as the redirect function of the installed methods, as described above.</p>

</li>
</ul>

<ul>
<li><p>post_function (optional): A function which is used as the postfunction of the installed methods, as described above.</p>

</li>
</ul>

<ul>
<li><p>filter_list: A list containing the basic filters for the methods installed by the add methods. Possible are filters, or the strings category, object, morphism, or twocell, which will then be replaced at the time the add method is called with the corresponding filters of the category.</p>

</li>
</ul>

<ul>
<li><p>well_defined_todo (optional): A boolean, default value is true, which states wether there should be to do list entries which propagate well definedness from the input of the installed methods to their output. Please note that true only makes sense if at least one argument and the output of the installed method is a cell.</p>

</li>
</ul>

<ul>
<li><p>cache_name (optional): The name of the cache which is used for the installed methods. If no cache name is given, the caching for the operation is deactivated completely.</p>

</li>
</ul>

<ul>
<li><p>argument_list (optional): A list containing integers, which defines which arguments should be used for the additional functions, (e.g redirect, pre, ...). This is important for the Op method contructions. If no argument list is given, all arguments are used. Please note that if you have a method selection argument for your function, you need to give the argument_list to explicitly state which argument is the method selection argument.</p>

</li>
</ul>

<ul>
<li><p>return_type (optional): The return type can be one of the following:</p>


<ul>
<li><p><code class="code">object</code> or <code class="code">object_or_fail</code>,</p>

</li>
<li><p><code class="code">morphism</code> or <code class="code">morphism_or_fail</code>,</p>

</li>
<li><p><code class="code">twocell</code>,</p>

</li>
<li><p><code class="code">bool</code>,</p>

</li>
<li><p><code class="code">other_object</code>,</p>

</li>
<li><p><code class="code">other_morphism</code>.</p>

<p>If it is one of the first three options, the correct <code class="code">Add</code> function (see above) is used for the result of the computation. Otherwise, no <code class="code">Add</code> function is used after all.</p>

</li>
</ul>
</li>
</ul>

<ul>
<li><p>is_with_given: Boolean, marks wether the function which is to be installed a with given function or not.</p>

</li>
</ul>

<ul>
<li><p>with_given_without_given_name_pair (optional): If the currently installed operation has a corresponding with given operation or is the with given of another operation, the names of both should be in this list.</p>

</li>
</ul>

<ul>
<li><p>functorial (optional): If an object has a corresponding functorial function, e.g., KernelObject and KernelObjectFunctorial, the name of the functorial is stored as a string.</p>

</li>
</ul>

<ul>
<li><p>number_of_diagram_arguments: Specifies how many of the arguments (counting from the first argument) of the function specify the diagram of the universal object. Default value is 1.</p>

</li>
</ul>

<ul>
<li><p>dual_arguments_reversed: Boolean, marks whether for the call of the dual operation all arguments have to be given in reversed order.</p>

</li>
</ul>

<ul>
<li><p>dual_preprocessor_func: let f be an operation with dual operation g. For the automatic installation of g from f, the arguments given to g are preprocessed by this given function.</p>

</li>
</ul>

<ul>
<li><p>dual_postprocessor_func: let f be an operation with dual operation g. For the automatic installation of g from f, the computed value of f is postprocessed by the given function.</p>

</li>
</ul>

<ul>
<li><p>zero_arguments_for_add_method: the add method of this operation should get a function without arguments</p>

</li>
</ul>
<p>Using all those entries, the operation CapInternalInstallAdd installs add methods as described above. It first provides a sanity check for all the entries described, then installs the Add method in 4 ways, with list or functions as second argument, and with an optional third parameter for the weight.</p>

<p><a id="X78B69C307CF0DE53" name="X78B69C307CF0DE53"></a></p>

<h4>7.4 <span class="Heading">Install All Adds</span></h4>

<p>The function CAP_INTERNAL_INSTALL_ALL_ADDS does not take any arguments, it is an auxiliary function which iterates over the CAP_INTERNAL_METHOD_NAME_RECORD and calls, after some cosmetics, the CapInternalInstallAdd with the corresponding method record entry. The steps below are performed for every entry of the method record:</p>


<ul>
<li><p>No install check: If the no_install component in the record is set to true, the loop continues with the next entry, since this flag indicates that there should be no add function for this operation.</p>

</li>
</ul>

<ul>
<li><p>Cache check: If there is no cache_name, set it to the name of the method record entry.</p>

</li>
</ul>

<ul>
<li><p>Function name: Set the component function_name to the entry name.</p>

</li>
</ul>

<ul>
<li><p>Redirect: Since the redirect function needs the category to work correctly, the given redirects in the method records are packed up to discard the last argument, which is the category.</p>

</li>
</ul>

<ul>
<li><p>arg_list: Next, an argument list for redirect and post function is created, by looking at the filter list in the record. If the first one is a list, the first and the last (method selection argument) is used, otherwise only the first.</p>

</li>
</ul>

<ul>
<li><p>WithGiven special case: If the current entry belongs to a WithGiven operation, the with_given_without_given_name_pair is set, the with given flag is set to true, and the CapInternalInstallAdd is called with the record. The loop then continues.</p>

</li>
</ul>

<ul>
<li><p>Non universal object special case: If the Operation does not have a universal type, i.e. does not belong to a universal construction, CapInternalInstallAdd is called with the record. The loop then continues.</p>

</li>
</ul>
<p>Please note that we are now in the case where the operation belongs to a universal construction, (e.g. KernelLift) and is not a WithGiven type of operation.</p>


<ul>
<li><p>argument_list: If the method is an Op construction, i.e. has a method selection object, the argument list is set to all but the last object and then used as above. Otherwise, the argument_list is set to all arguments.</p>

</li>
</ul>

<ul>
<li><p>If the Operation constructs a universal object, the postfunction is created and then CapInternalInstallAdd is called.</p>

</li>
</ul>

<ul>
<li><p>If the Operation constructs a universal morphism, the redirect is created and stored in the record. Also, the postfunction is created. Then CapInternalInstallAdd is called.</p>

</li>
</ul>
<p>After one call of this function, all add methods are installed correctly. A second call should not do anything.</p>

<p><a id="X7AFA0108870EE97C" name="X7AFA0108870EE97C"></a></p>

<h4>7.5 <span class="Heading">Prepare functions</span></h4>

<p><a id="X84409FF87D35BE99" name="X84409FF87D35BE99"></a></p>

<h5>7.5-1 CAPOperationPrepareFunction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CAPOperationPrepareFunction</code>( <var class="Arg">prepare_function</var>, <var class="Arg">category</var>, <var class="Arg">func</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a function</p>

<p>Given a non-CAP-conform function for any of the categorical operations, i.e., a function that computes the direct sum of two objects instead of a list of objects, this function wraps the function with a wrapper function to fit in the CAP context. For the mentioned binary direct sum one can call this function with <code class="code">"BinaryDirectSumToDirectSum"</code> as <var class="Arg">prepare_function</var>, the category, and the binary direct sum function. The function then returns a function that can be used for the direct sum categorical operation.</p>

<p>Note that <var class="Arg">func</var> is not handled by the CAP caching mechanism and that the use of prepare functions is incompatible with <code class="code">WithGiven</code> operations. Thus, one has to ensure manually that the equality and typing specifications are fulfilled.</p>

<p><a id="X7843089F86F47D3B" name="X7843089F86F47D3B"></a></p>

<h5>7.5-2 CAPAddPrepareFunction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CAPAddPrepareFunction</code>( <var class="Arg">prepare_function</var>, <var class="Arg">name</var>, <var class="Arg">doc_string</var>[, <var class="Arg">precondition_list</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Adds a prepare function to the list of CAP's prepare functions. The first argument is the prepare function itself. It should always be a function that takes a category and a function and returns a function. The argument <var class="Arg">name</var> is the name of the prepare function, which is used in <code class="code">CAPOperationPrepareFunction</code>. The argument <var class="Arg">doc_string</var> should be a short string describing the functions. The optional argument <var class="Arg">precondition_list</var> can describe preconditions for the prepare function to work, i.e., if the category does need to have PreCompose computable. This information is also recovered automatically from the prepare function itself, so the <var class="Arg">precondition_list</var> is only necessary if the function needed is not explicitly used in the prepare function, e.g., if you use <code class="code">+</code> instead of <code class="code">AdditionForMorphisms</code>.</p>

<p><a id="X82AEE9507F0B48BC" name="X82AEE9507F0B48BC"></a></p>

<h5>7.5-3 ListCAPPrepareFunctions</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ListCAPPrepareFunctions</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Lists all prepare functions.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap6.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap8.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
