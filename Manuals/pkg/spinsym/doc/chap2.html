<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (SpinSym) - Chapter 2: Usage and features</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap2"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap2_mj.html">[MathJax on]</a></p>
<p><a id="X8243772F820CC34E" name="X8243772F820CC34E"></a></p>
<div class="ChapSects"><a href="chap2.html#X8243772F820CC34E">2 <span class="Heading">Usage and features</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7B57D3B284BE53F9">2.1 <span class="Heading">Accessing the tables</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7FFBFA7E7E31EA14">2.2 <span class="Heading">Character parameters</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X87BE0EFA878CA593">2.2-1 <span class="Heading">Parameters of ordinary characters</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X85178CBC7E7039FF">2.2-2 <span class="Heading">Parameters of modular characters</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X857C89397E32A4E1">2.3 <span class="Heading">Class parameters</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7B846F3782B35EF3">2.3-1 SpinSymStandardRepresentative</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X78925C167ABA9462">2.3-2 SpinSymStandardRepresentativeImage</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7C885CF87A06E0DF">2.3-3 SpinSymPreimage</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X8243866286DA609C">2.3-4 SpinSymBrauerCharacter</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X87EF85BC816651BF">2.3-5 SpinSymBasicCharacter</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7BB8AC1D781BD6FE">2.4 <span class="Heading">Young subgroups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X798B9B1482CBDDC0">2.4-1 SpinSymCharacterTableOfMaximalYoungSubgroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X849A37657F53BAE3">2.4-2 SpinSymBrauerTableOfMaximalYoungSubgroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7906869F7F190E76">2.5 <span class="Heading">Class Fusions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7C4BE18086E671CD">2.5-1 SpinSymClassFusion</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X857FB2A17904A9CE">2.5-2 SpinSymClassFusion2Ain2S</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X84DDBEEF7BA42414">2.5-3 SpinSymClassFusion2Sin2S</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7A4425B58361A2FD">2.5-4 SpinSymClassFusion2Ain2A</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7BE629FB81C12F27">2.5-5 SpinSymClassFusion2Sin2A</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X8310E6BC7CC1A2F5">2.5-6 SpinSymClassFusion2SSin2S</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7854E1E785A0378A">2.5-7 SpinSymClassFusion2SAin2SS</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X83B113007DF2BB69">2.5-8 SpinSymClassFusion2ASin2SS</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X786B6E2D7CF13B51">2.5-9 SpinSymClassFusion2AAin2SA</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X80DFBE347B87AA43">2.5-10 SpinSymClassFusion2AAin2AS</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X796897DF78143E05">2.5-11 SpinSymClassFusion2AAin2A</a></span>
</div></div>
</div>

<h3>2 <span class="Heading">Usage and features</span></h3>

<p><a id="X7B57D3B284BE53F9" name="X7B57D3B284BE53F9"></a></p>

<h4>2.1 <span class="Heading">Accessing the tables</span></h4>

<p>All Brauer tables in this package are relative to a <em>generic</em> ordinary character table obtained by one of the following constructions</p>


<dl>
<dt><strong class="Mark"></strong></dt>
<dd><p><code class="code">CharacterTable( "2.Sym(n)" )</code>, the character table of <span class="SimpleMath">2.Sym(n)</span> ,</p>

</dd>
<dt><strong class="Mark"></strong></dt>
<dd><p><code class="code">CharacterTable( "2.Alt(n)" )</code>, the character table of <span class="SimpleMath">2.Alt(n)</span> ,</p>

</dd>
<dt><strong class="Mark"></strong></dt>
<dd><p><code class="code">CharacterTable( "Sym(n)" )</code>, the character table of <span class="SimpleMath">Sym(n)</span>,</p>

</dd>
<dt><strong class="Mark"></strong></dt>
<dd><p><code class="code">CharacterTable( "Alt(n)" )</code>, the character table of <span class="SimpleMath">Alt(n)</span>.</p>

</dd>
</dl>
<p>Note that these are synonymous expressions for</p>


<dl>
<dt><strong class="Mark"></strong></dt>
<dd><p><code class="code">CharacterTable( "DoubleCoverSymmetric", n )</code>,</p>

</dd>
<dt><strong class="Mark"></strong></dt>
<dd><p><code class="code">CharacterTable( "DoubleCoverAlternating", n )</code>,</p>

</dd>
<dt><strong class="Mark"></strong></dt>
<dd><p><code class="code">CharacterTable( "Symmetric", n )</code>,</p>

</dd>
<dt><strong class="Mark"></strong></dt>
<dd><p><code class="code">CharacterTable( "Alternating", n )</code>,</p>

</dd>
</dl>
<p>respectively. More detailed information on these tables is to be found in <a href="chapBib.html#biBNoeske2002">[3]</a>. In this manual, we call such a character table an (ordinary) <em>SpinSym table</em>. If <code class="code">ordtbl</code> is an ordinary SpinSym table, the relative Brauer table in characteristic <code class="code">p</code> can be accessed using the <code class="code">mod</code>-operator (i.e. <code class="code">ordtbl mod p;</code>). Such a Brauer table is called a (<span class="SimpleMath">p</span>-modular) <em>SpinSym table</em> in the following.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ordtbl:= CharacterTable( "2.Sym(18)" );</span>
CharacterTable( "2.Sym(18)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">modtbl:= ordtbl mod 3;</span>
BrauerTable( "2.Sym(18)", 3 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrdinaryCharacterTable(modtbl)=ordtbl;</span>
true

</pre></div>

<p><a id="X7FFBFA7E7E31EA14" name="X7FFBFA7E7E31EA14"></a></p>

<h4>2.2 <span class="Heading">Character parameters</span></h4>

<p>An ordinary SpinSym table has character parameters, that is, a list of suitable labels corresponding to the rows of <code class="code">ordtbl</code> and therefore the irreducible ordinary characters of the underlying group. See <code class="code">CharacterParameters()</code> in the GAP Reference Manual.</p>

<p><a id="X87BE0EFA878CA593" name="X87BE0EFA878CA593"></a></p>

<h5>2.2-1 <span class="Heading">Parameters of ordinary characters</span></h5>

<p>In the following, `ordinary (spin) character' is used synonymously for `irreducible ordinary (spin) character'. It is well known that there is a bijection between the set of ordinary characters of <span class="SimpleMath">Sym(n)</span> and the set <span class="SimpleMath">P(n)</span> of all partitions of <span class="SimpleMath">n</span>. Recall that a partition of a natural number <span class="SimpleMath">n</span> is a list of non-increasing positive integers (its <em>parts</em>) that sum up to <span class="SimpleMath">n</span>. In this way, every ordinary character <span class="SimpleMath">χ</span> of <span class="SimpleMath">Sym(n)</span> has a label of the form <code class="code">[1,c]</code> where <code class="code">c</code> is a partition of <span class="SimpleMath">n</span>. The labels of the ordinary characters of <span class="SimpleMath">Alt(n)</span> are induced by Clifford theory as follows. Either the restriction <span class="SimpleMath">ψ=χ|_Alt(n)</span> of <span class="SimpleMath">χ</span> to <span class="SimpleMath">Alt(n)</span> is an ordinary character of <span class="SimpleMath">Alt(n)</span>, or <span class="SimpleMath">ψ</span> decomposes as the sum of two distinct ordinary characters <span class="SimpleMath">ψ_1</span> and <span class="SimpleMath">ψ_2</span>.</p>

<p>In the first case there is another ordinary character of <span class="SimpleMath">Sym(n)</span>, say <span class="SimpleMath">ξ</span> labelled by <code class="code">[1,d]</code>, such that the restriction of <span class="SimpleMath">ξ</span> to <span class="SimpleMath">Alt(n)</span> is equal to <span class="SimpleMath">ψ</span>. Moreover, the induced character of <span class="SimpleMath">Sym(n)</span> obtained from <span class="SimpleMath">ψ</span> decomposes as the sum of <span class="SimpleMath">χ</span> and <span class="SimpleMath">ξ</span>. Then <span class="SimpleMath">ψ</span> is labelled by <code class="code">[1,c]</code> or <code class="code">[1,d]</code>.</p>

<p>In the second case, both <span class="SimpleMath">ψ_1</span> and <span class="SimpleMath">ψ_2</span> induce irreducibly up to <span class="SimpleMath">χ</span>. Then <span class="SimpleMath">ψ_1</span> and <span class="SimpleMath">ψ_2</span> are labelled by <code class="code">[1,[c,'+']]</code> and <code class="code">[1,[c,'-']]</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ctS:= CharacterTable( "Sym(5)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacterParameters(ctS);</span>
[ [ 1, [ 1, 1, 1, 1, 1 ] ], [ 1, [ 2, 1, 1, 1 ] ], [ 1, [ 2, 2, 1 ] ], 
  [ 1, [ 3, 1, 1 ] ], [ 1, [ 3, 2 ] ], [ 1, [ 4, 1 ] ], [ 1, [ 5 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ctA:= CharacterTable( "Alt(5)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacterParameters(ctA);</span>
[ [ 1, [ 1, 1, 1, 1, 1 ] ], [ 1, [ 2, 1, 1, 1 ] ], [ 1, [ 2, 2, 1 ] ], 
  [ 1, [ [ 3, 1, 1 ], '+' ] ], [ 1, [ [ 3, 1, 1 ], '-' ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chi:= Irr(ctS)[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">psi:= RestrictedClassFunction(chi,ctA);;           </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Position(Irr(ctA),psi);    </span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">xi:= Irr(ctS)[7];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RestrictedClassFunction(xi,ctA) = psi;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InducedClassFunction(psi,ctS) = chi + xi;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">chi:= Irr(ctS)[4];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">psi:= RestrictedClassFunction(chi,ctA);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">psi1:= Irr(ctA)[4];; psi2:= Irr(ctA)[5];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">psi = psi1 + psi2;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InducedClassFunction(psi1,ctS) = chi;              </span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InducedClassFunction(psi2,ctS) = chi;</span>
true

</pre></div>

<p>If <span class="SimpleMath">χ</span> is an ordinary character of <span class="SimpleMath">2.Sym(n)</span> or <span class="SimpleMath">2.Alt(n)</span> , then <span class="SimpleMath">χ(z)=χ(1)</span> or <span class="SimpleMath">χ(z)=-χ(1)</span>. If <span class="SimpleMath">χ(z)=χ(1)</span>, then <span class="SimpleMath">χ</span> is obtained by inflation (along the central subgroup generated by <span class="SimpleMath">z</span>) from an ordinary character of <span class="SimpleMath">Sym(n)</span> or <span class="SimpleMath">Alt(n)</span>, respectively, whose label is given to <span class="SimpleMath">χ</span>. Otherwise, if <span class="SimpleMath">χ</span> is a spin character, that is <span class="SimpleMath">χ(z)=-χ(1)</span>, then its label is described next.</p>

<p>The set of ordinary spin characters of <span class="SimpleMath">2.Sym(n)</span> is parameterized by the subset <span class="SimpleMath">D(n)</span> of <span class="SimpleMath">P(n)</span> of all distinct-parts partitions of <span class="SimpleMath">n</span> (also called bar partitions). If <code class="code">c</code> is an even distinct-parts partition of <span class="SimpleMath">n</span>, then there is a unique ordinary spin character of <span class="SimpleMath">2.Sym(n)</span> that is labelled by <code class="code">[2,c]</code>. In contrast, if <code class="code">c</code> is an odd distinct-parts partition of <span class="SimpleMath">n</span>, then there are two distinct ordinary spin characters of <span class="SimpleMath">2.Sym(n)</span> that are labelled by <code class="code">[2,[c,'+']]</code> and <code class="code">[2,[c,'-']]</code>. Now the labels of the ordinary spin characters of <span class="SimpleMath">2.Alt(n)</span> follow from the labels of <span class="SimpleMath">2.Sym(n)</span> in the same way as those of <span class="SimpleMath">Alt(n)</span> follow from the labels of <span class="SimpleMath">Sym(n)</span> (see the beginning of this subsection <a href="chap2.html#X87BE0EFA878CA593"><span class="RefLink">2.2-1</span></a>).</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ctS:= CharacterTable( "Sym(5)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ct2S:= CharacterTable( "2.Sym(5)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ch:= CharacterParameters(ct2S);</span>
[ [ 1, [ 1, 1, 1, 1, 1 ] ], [ 1, [ 2, 1, 1, 1 ] ], [ 1, [ 2, 2, 1 ] ], 
  [ 1, [ 3, 1, 1 ] ], [ 1, [ 3, 2 ] ], [ 1, [ 4, 1 ] ], [ 1, [ 5 ] ], 
  [ 2, [ [ 3, 2 ], '+' ] ], [ 2, [ [ 3, 2 ], '-' ] ], 
  [ 2, [ [ 4, 1 ], '+' ] ], [ 2, [ [ 4, 1 ], '-' ] ], [ 2, [ 5 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pos:= Positions( List(ch, x-&gt; x[1]), 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RestrictedClassFunctions( Irr(ctS), ct2S ) = Irr(ct2S){pos}; #inflation</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ct2A:= CharacterTable( "2.Alt(5)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacterParameters(ct2A);</span>
[ [ 1, [ 1, 1, 1, 1, 1 ] ], [ 1, [ 2, 1, 1, 1 ] ], [ 1, [ 2, 2, 1 ] ], 
  [ 1, [ [ 3, 1, 1 ], '+' ] ], [ 1, [ [ 3, 1, 1 ], '-' ] ], [ 2, [ 3, 2 ] ], 
  [ 2, [ 4, 1 ] ], [ 2, [ [ 5 ], '+' ] ], [ 2, [ [ 5 ], '-' ] ] ]

</pre></div>

<p><a id="X85178CBC7E7039FF" name="X85178CBC7E7039FF"></a></p>

<h5>2.2-2 <span class="Heading">Parameters of modular characters</span></h5>

<p>In the following, `<span class="SimpleMath">p</span>-modular (spin) character' is used synonymously for `irreducible <span class="SimpleMath">p</span>-modular (spin) character'. The set of <span class="SimpleMath">p</span>-modular characters of <span class="SimpleMath">Sym(n)</span> is parameterized by the set of all <span class="SimpleMath">p</span>-regular partitions of <span class="SimpleMath">n</span>. A partition is <span class="SimpleMath">p</span>-regular if no part is repeated more than <span class="SimpleMath">p-1</span> times. Now every <span class="SimpleMath">p</span>-modular character <span class="SimpleMath">χ</span> of <span class="SimpleMath">Sym(n)</span> has a label of the form <code class="code">[1,c]</code> where <code class="code">c</code> is a <span class="SimpleMath">p</span>-regular partition of <span class="SimpleMath">n</span>.</p>

<p>Again, the labels for the <span class="SimpleMath">p</span>-modular spin characters of <span class="SimpleMath">Alt(n)</span> follow from the labels of <span class="SimpleMath">Sym(n)</span>. However, comparing subsection <a href="chap2.html#X87BE0EFA878CA593"><span class="RefLink">2.2-1</span></a>, their format is slightly different.</p>

<p>If <span class="SimpleMath">χ</span> and <span class="SimpleMath">ξ</span> are distinct <span class="SimpleMath">p</span>-modular characters of <span class="SimpleMath">Sym(n)</span> that restrict to the same <span class="SimpleMath">p</span>-modular character <span class="SimpleMath">ψ</span> of <span class="SimpleMath">Alt(n)</span>, then <span class="SimpleMath">ψ</span> is labelled by <code class="code">[1,[c,'0']]</code> where either <span class="SimpleMath">χ</span> or <span class="SimpleMath">ξ</span> is labelled by <code class="code">[1,c]</code>. If <span class="SimpleMath">χ</span> is a <span class="SimpleMath">p</span>-modular character of <span class="SimpleMath">Sym(n)</span> whose restriction to <span class="SimpleMath">Alt(n)</span> decomposes as the sum of two distinct <span class="SimpleMath">p</span>-modular characters, then these are labelled by <code class="code">[1,[c,'+']]</code> and <code class="code">[1,[c,'-']]</code> where <span class="SimpleMath">χ</span> is labelled by <code class="code">[1,c]</code>.</p>

<p>As in the ordinary case, the set of <span class="SimpleMath">p</span>-modular characters of <span class="SimpleMath">2.Sym(n)</span> is the union of the subset consisting of all inflated <span class="SimpleMath">p</span>-modular characters of <span class="SimpleMath">Sym(n)</span> and the subset of spin characters characterized by negative integer values on the central element <span class="SimpleMath">z</span>. The analogue statement holds for <span class="SimpleMath">2.Alt(n)</span>. The set of <span class="SimpleMath">p</span>-modular spin characters of <span class="SimpleMath">2.Sym(n)</span> is parameterized by the set of all restricted <span class="SimpleMath">p</span>-strict partitions of <span class="SimpleMath">n</span>. A partition is called <span class="SimpleMath">p</span>-strict if every repeated part is divisible by <span class="SimpleMath">p</span>, and a <span class="SimpleMath">p</span>-strict partition <span class="SimpleMath">λ</span> is restricted if <span class="SimpleMath">λ_i-λ_i+1&lt;p</span> whenever <span class="SimpleMath">λ_i</span> is divisible <span class="SimpleMath">p</span>, and <span class="SimpleMath">λ_i-λ_i+1≤ p</span> otherwise for all parts <span class="SimpleMath">λ_i</span> of <span class="SimpleMath">λ</span> (where we set <span class="SimpleMath">λ_i+1=0</span> if <span class="SimpleMath">λ_i</span> is the last part). If <code class="code">c</code> is a restricted <span class="SimpleMath">p</span>-strict partition of <span class="SimpleMath">n</span> such that <span class="SimpleMath">n</span> minus the number of parts not divisible by <span class="SimpleMath">p</span> is even, then there is a unique <span class="SimpleMath">p</span>-modular spin character of <span class="SimpleMath">2.Sym(n)</span> that is labelled by <code class="code">[2,[c,'0']]</code>. Its restriction to <span class="SimpleMath">2.Alt(n)</span> decomposes as the sum of two distinct <span class="SimpleMath">p</span>-modular characters which are labelled by <code class="code">[2,[c,'+']]</code> and <code class="code">[2,[c,'-']]</code>. If <span class="SimpleMath">n</span> minus the number of parts of <code class="code">c</code> that are not divisible by <span class="SimpleMath">p</span> is odd, then there are two distinct <span class="SimpleMath">p</span>-modular spin characters of <span class="SimpleMath">2.Sym(n)</span> that are labelled by <code class="code">[2,[c,'+']]</code> and <code class="code">[2,[c,'-']]</code>. Both of these characters restrict to the same irreducible <span class="SimpleMath">p</span>-modular spin character of <span class="SimpleMath">2.Alt(n)</span> which is labelled by <code class="code">[2,[c,'0']]</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ctS:= CharacterTable( "Sym(5)" ) mod 3;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ct2S:= CharacterTable( "2.Sym(5)" ) mod 3;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ch:= CharacterParameters(ct2S);</span>
[ [ 1, [ 5 ] ], [ 1, [ 4, 1 ] ], [ 1, [ 3, 2 ] ], 
  [ 1, [ 3, 1, 1 ] ], [ 1, [ 2, 2, 1 ] ], 
  [ 2, [ [ 4, 1 ], '+' ] ], [ 2, [ [ 4, 1 ], '-' ] ], 
  [ 2, [ [ 3, 2 ], '0' ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pos:= Positions( List(ch, x-&gt; x[1]), 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RestrictedClassFunctions( Irr(ctS), ct2S ) = Irr(ct2S){pos}; #inflation</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ct2A:= CharacterTable( "2.Alt(5)" ) mod 3;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacterParameters(ct2A);</span>
[ [ 1, [ [ 5 ], '0' ] ], [ 1, [ [ 4, 1 ], '0' ] ], 
  [ 1, [ [ 3, 1, 1 ], '+' ] ], [ 1, [ [ 3, 1, 1 ], '-' ] ], 
  [ 2, [ [ 4, 1 ], '0' ] ], [ 2, [ [ 3, 2 ], '+' ] ], [ 2, [ [ 3, 2 ], '-' ] ] ]

</pre></div>

<p><a id="X857C89397E32A4E1" name="X857C89397E32A4E1"></a></p>

<h4>2.3 <span class="Heading">Class parameters</span></h4>

<p>Let <code class="code">ct</code> be an ordinary SpinSym table. Then <code class="code">ct</code> has a list of class parameters, that is, a list of suitable labels corresponding to the columns of <code class="code">ct</code> and therefore the conjugacy classes of the underlying group. See <code class="code">ClassParameters()</code> in the GAP Reference Manual. If <code class="code">bt</code> is a Brauer table in characteristic <span class="SimpleMath">p</span> relative to <code class="code">ct</code>, its class parameters are inherited from <code class="code">ct</code> in correspondence with the <span class="SimpleMath">p</span>-regular conjugacy classes of the underlying group.</p>

<p>Let <span class="SimpleMath">P(n)</span> denote the set of partitions of <span class="SimpleMath">n</span>.</p>

<p>The conjugacy classes of <span class="SimpleMath">Sym(n)</span> are naturally parameterized by the cycle types of their elements, and each cycle type corresponds to a partition of <span class="SimpleMath">n</span>. Therefore a conjugacy class <span class="SimpleMath">C</span> of <span class="SimpleMath">Sym(n)</span> is characterized by its <em>type</em> <span class="SimpleMath">c</span> in <span class="SimpleMath">P(n)</span>. The corresponding entry in the list of class parameters is <code class="code">[1,c]</code>. Assume that <span class="SimpleMath">C</span> is a subset of <span class="SimpleMath">Alt(n)</span>. Then <span class="SimpleMath">C</span> is also a conjugacy class of <span class="SimpleMath">Alt(n)</span> if and only if not all parts of <span class="SimpleMath">c</span> are odd and pairwise distinct. Otherwise, <span class="SimpleMath">C</span> splits as the union of two distinct <span class="SimpleMath">Alt(n)</span>-classes of the same size, <span class="SimpleMath">C^+</span> of type <span class="SimpleMath">c^+</span> and <span class="SimpleMath">C^-</span> of type <span class="SimpleMath">c^-</span>. The corresponding entries in the list of class parameters are <code class="code">[1,[c,'+']]</code> and <code class="code">[1,[c,'-']]</code>, respectively.</p>

<p>Furthermore, the preimage <span class="SimpleMath">C'=C^{π^-1}</span> is either a conjugacy class of <span class="SimpleMath">2.Sym(n)</span> of type <span class="SimpleMath">c</span> with class parameter <code class="code">[1,c]</code>, or <span class="SimpleMath">C'</span> splits as the union of two distinct <span class="SimpleMath">2.Sym(n)</span> -classes <span class="SimpleMath">C'_1</span> and <span class="SimpleMath">C'_2=zC'_1</span> , both of type <span class="SimpleMath">c</span> with corresponding class parameters <code class="code">[1,c]</code> and <code class="code">[2,c]</code>, respectively. An analogous description applies for the conjugacy classes of <span class="SimpleMath">2.Alt(n)</span> .</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ct:= CharacterTable( "Sym(3)" );;  </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassParameters(ct);</span>
[ [ 1, [ 1, 1, 1 ] ], [ 1, [ 2, 1 ] ], [ 1, [ 3 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ct:= CharacterTable( "Alt(3)" );;  </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassParameters(ct);</span>
[ [ 1, [ 1, 1, 1 ] ], [ 1, [ [ 3 ], '+' ] ], [ 1, [ [ 3 ], '-' ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ct:= CharacterTable( "2.Sym(3)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassParameters(ct);</span>
[ [ 1, [ 1, 1, 1 ] ], [ 2, [ 1, 1, 1 ] ], [ 1, [ 2, 1 ] ], [ 2, [ 2, 1 ] ], 
  [ 1, [ 3 ] ], [ 2, [ 3 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ct:= CharacterTable( "2.Alt(3)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassParameters(ct);</span>
[ [ 1, [ 1, 1, 1 ] ], [ 2, [ 1, 1, 1 ] ], 
  [ 1, [ [ 3 ], '+' ] ], [ 2, [ [ 3 ], '+' ] ], 
  [ 1, [ [ 3 ], '-' ] ], [ 2, [ [ 3 ], '-' ] ] ]

</pre></div>

<p>To each conjugacy class of <span class="SimpleMath">2.Sym(n)</span> or <span class="SimpleMath">2.Alt(n)</span> a certain standard representative is assigned in the following way. Let <span class="SimpleMath">c=[c_1,c_2,...,c_m]</span> be a partition of <span class="SimpleMath">n</span>. We set <span class="SimpleMath">d_1=0</span>, <span class="SimpleMath">d_i=c_1+... +c_i-1</span> for <span class="SimpleMath">i≥ 2</span>, and</p>

<p class="pcenter">t(c_i,d_i)= t_d_i+1t_d_i+2... t_d_i+c_i-1</p>

<p>for <span class="SimpleMath">1≤ i≤ m-1</span>, where <span class="SimpleMath">t(c_i,d_i)= 1</span> if <span class="SimpleMath">c_i=1</span>. The <em>standard representative of type</em> <span class="SimpleMath">c</span> is defined as</p>

<p class="pcenter">t_c=t(c_1,d_1)t(c_2,d_2)...t(c_m-1,d_m-1).</p>

<p>Furthermore, we define the standard representatives of type <span class="SimpleMath">c^+=</span><code class="code">[c,'+']</code> and <span class="SimpleMath">c^-=</span><code class="code">[c,'-']</code> to be <span class="SimpleMath">t_c^+=t_c</span> and <span class="SimpleMath">t_c^-=t_1^-1t_c t_1</span>, respectively.</p>

<p>For example, the standard representative of type <span class="SimpleMath">c=[7,4,3,1]</span> in <span class="SimpleMath">P(15)</span> is</p>

<p class="pcenter">t_c=t_1t_2t_3t_4t_5t_6t_8t_9t_10t_12t_13.</p>

<p>Now <span class="SimpleMath">C'</span> is a conjugacy class of <span class="SimpleMath">2.Sym(n)</span> or <span class="SimpleMath">2.Alt(n)</span> with parameter</p>


<dl>
<dt><strong class="Mark"></strong></dt>
<dd><p><code class="code">[1,c]</code> if and only if <span class="SimpleMath">t_c</span> is an element of <span class="SimpleMath">C'</span> ,</p>

</dd>
<dt><strong class="Mark"></strong></dt>
<dd><p><code class="code">[2,c]</code> if and only if <span class="SimpleMath">zt_c</span> is an element of <span class="SimpleMath">C'</span> ,</p>

</dd>
<dt><strong class="Mark"></strong></dt>
<dd><p><code class="code">[1,[c,'+']]</code> if and only if <span class="SimpleMath">t_c^+</span> is an element of <span class="SimpleMath">C'</span> ,</p>

</dd>
<dt><strong class="Mark"></strong></dt>
<dd><p><code class="code">[2,[c,'+']]</code> if and only if <span class="SimpleMath">zt_c^+</span> is an element of <span class="SimpleMath">C'</span> ,</p>

</dd>
<dt><strong class="Mark"></strong></dt>
<dd><p><code class="code">[1,[c,'-']]</code> if and only if <span class="SimpleMath">t_c^-</span> is an element of <span class="SimpleMath">C'</span> ,</p>

</dd>
<dt><strong class="Mark"></strong></dt>
<dd><p><code class="code">[2,[c,'-']]</code> if and only if <span class="SimpleMath">zt_c^-</span> is an element of <span class="SimpleMath">C'</span> .</p>

</dd>
</dl>
<p><a id="X7B846F3782B35EF3" name="X7B846F3782B35EF3"></a></p>

<h5>2.3-1 SpinSymStandardRepresentative</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpinSymStandardRepresentative</code>( <var class="Arg">c</var>, <var class="Arg">rep</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: the image of the standard representative of type <var class="Arg">c</var> under a given <span class="SimpleMath">2.Sym(n)</span>-representation.</p>

<p>Expecting the second entry of a class parameter of <span class="SimpleMath">2.Sym(n)</span> or <span class="SimpleMath">2.Alt(n)</span> , say <var class="Arg">c</var>, the standard representative of type <var class="Arg">c</var> under a given representation of <span class="SimpleMath">2.Sym(n)</span> is computed. The argument <var class="Arg">rep</var> is assumed to be a list <span class="SimpleMath">[t_1^R,t_2^R,...,t_n-1^R]</span> given by the images of the generators <span class="SimpleMath">t_1,...,t_n-1</span> of <span class="SimpleMath">2.Sym(n)</span> under a (not necessarily faithful) representation <span class="SimpleMath">R</span> of <span class="SimpleMath">2.Sym(n)</span> .</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ct:= CharacterTable("2.Sym(15)") mod 5;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cl:= ClassParameters(ct)[99];</span>
[ 1, [ 7, 4, 3, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c:= cl[2];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rep:= BasicSpinRepresentationOfSymmetricGroup(15,5);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= SpinSymStandardRepresentative(c,rep); </span>
&lt; immutable compressed matrix 64x64 over GF(25) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrdersClassRepresentatives(ct)[99];</span>
168
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order(t);</span>
168
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BrauerCharacterValue(t);</span>
0

</pre></div>

<p><a id="X78925C167ABA9462" name="X78925C167ABA9462"></a></p>

<h5>2.3-2 SpinSymStandardRepresentativeImage</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpinSymStandardRepresentativeImage</code>( <var class="Arg">c</var>[, <var class="Arg">j</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: the image of the standard representative of type <var class="Arg">c</var> under the natural epimorphism <span class="SimpleMath">π:2.Sym({j,...,j+n-1}) -&gt; Sym({j,...,j+n-1})</span>.</p>

<p>Given the second entry <var class="Arg">c</var> of a class parameter of <span class="SimpleMath">2.Sym(n)</span> or <span class="SimpleMath">2.Alt(n)</span> , and optionally a positive integer <var class="Arg">j</var>, the image of the standard representative of type <var class="Arg">c</var> under <span class="SimpleMath">π:2.Sym({j,...,j+n-1}) -&gt; Sym({j,...,j+n-1})</span> with <span class="SimpleMath">t_i^π=(i,i+1)</span> for <span class="SimpleMath">j≤ i≤ j+n-2</span> is computed by calling <code class="keyw">SpinSymStandardRepresentative(c,rep)</code> where <code class="code">rep</code> is the list <code class="code">[(j,j+1),(j+1,j+2),...,(j+n-2,j+n-1)]</code>. By default, <code class="code">j=1</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s1:= SpinSymStandardRepresentativeImage([7,4,3,1]);         </span>
(1,7,6,5,4,3,2)(8,11,10,9)(12,14,13)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s2:= SpinSymStandardRepresentativeImage([[7,4,3,1],'-']);</span>
(1,2,7,6,5,4,3)(8,11,10,9)(12,14,13)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s2 = s1^(1,2);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SpinSymStandardRepresentativeImage([7,4,3,1],3);       </span>
(3,9,8,7,6,5,4)(10,13,12,11)(14,16,15)

</pre></div>

<p><a id="X7C885CF87A06E0DF" name="X7C885CF87A06E0DF"></a></p>

<h5>2.3-3 SpinSymPreimage</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpinSymPreimage</code>( <var class="Arg">c</var>, <var class="Arg">rep</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a (standard) lift of the element <var class="Arg">c</var> of <span class="SimpleMath">Sym(n)</span> in <span class="SimpleMath">2.Sym(n)</span> under a given <span class="SimpleMath">2.Sym(n)</span>-representation.</p>

<p>See <a href="chapBib.html#biBMaas2011">[2, (5.1.12)]</a> for the definition of the lift that is returned by this function. The permutation <var class="Arg">c</var> is written as a product of simple transpositions <span class="SimpleMath">(i,i+1)</span>, then these are replaced by the images of their canonical lifts <span class="SimpleMath">t_i</span> under a given representation <span class="SimpleMath">R</span> of <span class="SimpleMath">2.Sym(n)</span> (recall the beginning of Chapter <a href="chap1.html#X7DFB63A97E67C0A1"><span class="RefLink">1</span></a> for the definition of <span class="SimpleMath">t_i</span>). Here <var class="Arg">rep</var> is assumed to be the list <span class="SimpleMath">[t_1^R,t_2^R,...,t_n-1^R]</span>.</p>

<p>Note that a more efficient computation may be achieved by computing and storing a list of all necessary transpositions once and for all, before lifting (many) elements (under a possibly large representation).</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rep:= BasicSpinRepresentationOfSymmetricGroup(15);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c:= SpinSymStandardRepresentativeImage([5,4,3,2,1]);</span>
(1,5,4,3,2)(6,9,8,7)(10,12,11)(13,14)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C:= SpinSymPreimage(c,rep);</span>
&lt; immutable compressed matrix 64x64 over GF(9) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C = SpinSymStandardRepresentative([5,4,3,2,1],rep);</span>
true

</pre></div>

<p><a id="X8243866286DA609C" name="X8243866286DA609C"></a></p>

<h5>2.3-4 SpinSymBrauerCharacter</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpinSymBrauerCharacter</code>( <var class="Arg">ccl</var>, <var class="Arg">ords</var>, <var class="Arg">rep</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: the Brauer character afforded by a given representation of <span class="SimpleMath">2.Sym(n)</span> .</p>

<p>This function is based on a simplified computation of the <strong class="pkg">GAP</strong> attribute <code class="code">BrauerCharacterValue(mat)</code> for an invertible matrix <code class="code">mat</code> over a finite field whose characteristic is coprime to the order of <code class="code">mat</code>.</p>

<p>The arguments <var class="Arg">ccl</var> and <var class="Arg">ords</var> are expected to be the values of the attributes <code class="code">ClassParameters(modtbl)</code> and <code class="code">OrdersClassRepresentatives(modtbl)</code> of a (possibly incomplete) <span class="SimpleMath">p</span>-modular SpinSym table <code class="code">modtbl</code> of <span class="SimpleMath">2.Sym(n)</span> .</p>

<p>The argument <var class="Arg">rep</var> is assumed to be a list <span class="SimpleMath">[t_1^R,t_2^R,...,t_n-1^R]</span> given by the images of the generators <span class="SimpleMath">t_1,...,t_n-1</span> of <span class="SimpleMath">2.Sym(n)</span> under a (not necessarily faithful) <span class="SimpleMath">2.Sym(n)</span> -representation <span class="SimpleMath">R</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ct:= CharacterTable("DoubleCoverSymmetric",15);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bt:= CharacterTableRegular(ct,5);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= GetFusionMap(bt,ct);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ccl:= ClassParameters(ct){fus};;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ords:= OrdersClassRepresentatives(bt);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rep:= BasicSpinRepresentationOfSymmetricGroup(15,5);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi:= SpinSymBrauerCharacter(ccl,ords,rep);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi in Irr(ct mod 5);</span>
true

</pre></div>

<p><a id="X87EF85BC816651BF" name="X87EF85BC816651BF"></a></p>

<h5>2.3-5 SpinSymBasicCharacter</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpinSymBasicCharacter</code>( <var class="Arg">modtbl</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a <span class="SimpleMath">p</span>-modular basic spin character of the (possibly incomplete) <span class="SimpleMath">p</span>-modular SpinSym table <var class="Arg">modtbl</var> of <span class="SimpleMath">2.Sym(n)</span> .</p>

<p>This is just a shortcut for constructing a basic spin representation of <span class="SimpleMath">2.Sym(n)</span> in characteristic <span class="SimpleMath">p</span> and computing its Brauer character by calling <code class="func">SpinSymBrauerCharacter</code> (<a href="chap2.html#X8243866286DA609C"><span class="RefLink">2.3-4</span></a>) afterwards.</p>


<div class="example"><pre>
 
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetClassParameters(bt,ccl);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SpinSymBasicCharacter(bt) = phi;</span>
true

</pre></div>

<p><a id="X7BB8AC1D781BD6FE" name="X7BB8AC1D781BD6FE"></a></p>

<h4>2.4 <span class="Heading">Young subgroups</span></h4>

<p>Let <span class="SimpleMath">k</span> and <span class="SimpleMath">l</span> be integers greater than <span class="SimpleMath">1</span> and set <span class="SimpleMath">n=k+l</span>. The following subgroup of <span class="SimpleMath">2.Sym(n)</span> ,</p>

<p class="pcenter">2.(Sym(k)×Sym(l)) = &lt; t_1,...,t_k-1, t_k+1,...,t_n-1 &gt;,</p>

<p>is called a (maximal) <em>Young subgroup</em> of <span class="SimpleMath">2.Sym(n)</span> . Similarly, the intersection <span class="SimpleMath">2.(Alt(k)×Alt(l))</span> of <span class="SimpleMath">2.(Sym(k)×Sym(l))</span> and <span class="SimpleMath">2.Alt(n)</span> is a (maximal) Young subgroup of <span class="SimpleMath">2.Alt(n)</span> . Note that <span class="SimpleMath">(2.(Sym(k)×Sym(l)))^π</span> is isomorphic to <span class="SimpleMath">Sym(k)×Sym(l)</span> and <span class="SimpleMath">(2.(Alt(k)×Alt(l)))^π</span> is isomorphic to <span class="SimpleMath">Alt(k)×Alt(l)</span> but only <span class="SimpleMath">2.(Alt(k)×Alt(l))</span> which is isomorphic to <span class="SimpleMath">(2.Alt(k)×2.Alt(l))/ &lt;(z,z)&gt;</span> is a central product. In between <span class="SimpleMath">2.(Alt(k)×Alt(l))</span> and <span class="SimpleMath">2.(Sym(k)×Sym(l))</span> there are further central products <span class="SimpleMath">2.(Sym(k)×Alt(l))</span> which is isomorphic to <span class="SimpleMath">(2.Sym(k)×2.Alt(l))/&lt;(z,z)&gt;</span> and <span class="SimpleMath">2.(Alt(k)×Sym(l))</span> which is isomorphic to <span class="SimpleMath">(2.Alt(k)×2.Sym(l))/&lt;(z,z)&gt;</span> which are <span class="SimpleMath">π</span>-preimages of <span class="SimpleMath">Sym(k)×Alt(l)</span> and <span class="SimpleMath">Alt(k)×Sym(l)</span>, respectively. See <a href="chapBib.html#biBMaas2011">[2, Section 5.2]</a>.</p>

<p><a id="X798B9B1482CBDDC0" name="X798B9B1482CBDDC0"></a></p>

<h5>2.4-1 SpinSymCharacterTableOfMaximalYoungSubgroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpinSymCharacterTableOfMaximalYoungSubgroup</code>( <var class="Arg">k</var>, <var class="Arg">l</var>, <var class="Arg">type</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: the ordinary character table of a maximal Young subgroup depending on <var class="Arg">type</var>.</p>

<p>For integers <var class="Arg">k</var> and <var class="Arg">l</var> greater than <span class="SimpleMath">1</span> the function returns the ordinary character table of <span class="SimpleMath">2.(Alt(k)×Alt(l))</span>, <span class="SimpleMath">2.(Alt(k)×Sym(l))</span>, <span class="SimpleMath">2.(Sym(k)×Alt(l))</span>, or <span class="SimpleMath">2.(Sym(k)×Sym(l))</span> depending on the string <var class="Arg">type</var> being <code class="code">"Alternating"</code>, <code class="code">"AlternatingSymmetric"</code>, <code class="code">"SymmetricAlternating"</code>, or <code class="code">"Symmetric"</code>, respectively.</p>

<p>If <var class="Arg">type</var> is <code class="code">"Symmetric"</code> then the output is computed by means of Clifford's theory from the character tables of <span class="SimpleMath">2.(Sym(k)×Alt(l))</span>, <span class="SimpleMath">2.(Alt(k)×Alt(l))</span>, and <span class="SimpleMath">2.(Alt(k)×Sym(l))</span> (see <a href="chapBib.html#biBMaas2011">[2, Section 5.2]</a>). These `ingredients' are computed and then stored in the attribute <code class="code">SpinSymIngredients</code> so they can be accessed during the construction (and for the construction of a relative Brauer table too, see <code class="func">SpinSymBrauerTableOfMaximalYoungSubgroup</code> (<a href="chap2.html#X849A37657F53BAE3"><span class="RefLink">2.4-2</span></a>)).</p>

<p>The construction of the character tables of <var class="Arg">type</var> <code class="code">"Alternating"</code>, <code class="code">"AlternatingSymmetric"</code>, or <code class="code">"SymmetricAlternating"</code> is straightforward and may be accomplished by first construcing a direct product, for example, the character table of <span class="SimpleMath">2.Sym(k)×2.Alt(l)</span>, followed by the construction of the character table of the factor group mod <span class="SimpleMath">&lt;(z,z)&gt;</span>.</p>

<p>However, we use a faster method that builds up the table from scratch, using the appropriate component tables as ingredients (for example, the generic character tables of <span class="SimpleMath">2.Sym(k)</span> and <span class="SimpleMath">2.Alt(l)</span> ). In this way we can easily build up a suitable list of class parameters that are needed to determine the class fusion in the construction of <var class="Arg">type</var> <code class="code">"Symmetric"</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2AA:= SpinSymCharacterTableOfMaximalYoungSubgroup(8,5,"Alternating"); </span>
CharacterTable( "2.(Alt(8)xAlt(5))" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SpinSymCharacterTableOfMaximalYoungSubgroup(8,5,"AlternatingSymmetric");</span>
CharacterTable( "2.(Alt(8)xSym(5))" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SpinSymCharacterTableOfMaximalYoungSubgroup(8,5,"SymmetricAlternating");     </span>
CharacterTable( "2.(Sym(8)xAlt(5))" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2SS:= SpinSymCharacterTableOfMaximalYoungSubgroup(8,5,"Symmetric");           </span>
CharacterTable( "2.(Sym(8)xSym(5))" )

</pre></div>

<p><a id="X849A37657F53BAE3" name="X849A37657F53BAE3"></a></p>

<h5>2.4-2 SpinSymBrauerTableOfMaximalYoungSubgroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpinSymBrauerTableOfMaximalYoungSubgroup</code>( <var class="Arg">ordtbl</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: the <var class="Arg">p</var>-modular character table of the ordinary character table <var class="Arg">ordtbl</var> returned by the function <code class="func">SpinSymCharacterTableOfMaximalYoungSubgroup</code> (<a href="chap2.html#X798B9B1482CBDDC0"><span class="RefLink">2.4-1</span></a>).</p>

<p>If the rational prime <var class="Arg">p</var> is odd, then the construction of the irreducible Brauer characters is really the same as in the ordinary case but it depends on the <var class="Arg">p</var>-modular tables of of <var class="Arg">ordtbl</var>'s `ingredients'. If some Brauer table that is necessary for the construction is not available then <code class="code">fail</code> is returned.</p>

<p>Alternatively, the <code class="code">mod</code>-operator may be used.</p>

<p>For <var class="Arg">p</var> <span class="SimpleMath">=2</span> the Brauer table is essentially constructed as a direct product by standard <strong class="pkg">GAP</strong> methods written by Thomas Breuer.</p>

<p>We call a character table returned by <code class="func">SpinSymCharacterTableOfMaximalYoungSubgroup</code> (<a href="chap2.html#X798B9B1482CBDDC0"><span class="RefLink">2.4-1</span></a>) or <code class="func">SpinSymBrauerTableOfMaximalYoungSubgroup</code> a SpinSym table too. It has lists of class and character parameters whose format is explained in <a href="chapBib.html#biBMaas2011">[2, Sections 5.2, 5.3]</a>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SpinSymBrauerTableOfMaximalYoungSubgroup(2AA,3);</span>
BrauerTable( "2.(Alt(8)xAlt(5))", 3 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2SS mod 5;</span>
BrauerTable( "2.(Sym(8)xSym(5))", 5 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ct:= 2SS mod 2;  </span>
BrauerTable( "2.(Sym(8)xSym(5))", 2 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ct1:= CharacterTable("Sym(8)") mod 2;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ct2:= CharacterTable("Sym(5)") mod 2;;     </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Irr(ct1*ct2) = Irr(ct);</span>
true

</pre></div>

<p><a id="X7906869F7F190E76" name="X7906869F7F190E76"></a></p>

<h4>2.5 <span class="Heading">Class Fusions</span></h4>

<p>The following functions determine class fusion maps between SpinSym tables by means of their class parameters. Such `default' class fusion maps allow to induce characters from various subgroups of <span class="SimpleMath">2.Sym(n)</span> or <span class="SimpleMath">2.Alt(n)</span> consistently.</p>

<p><a id="X7C4BE18086E671CD" name="X7C4BE18086E671CD"></a></p>

<h5>2.5-1 SpinSymClassFusion</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpinSymClassFusion</code>( <var class="Arg">ctSource</var>, <var class="Arg">ctDest</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a fusion map from the SpinSym table <var class="Arg">ctSource</var> to the SpinSym table <var class="Arg">ctDest</var>. This map is stored if there is no other fusion map from <var class="Arg">ctSource</var> to <var class="Arg">ctDest</var> stored yet.</p>

<p>The possible input tables are expected to be either ordinary or <span class="SimpleMath">p</span>-modular SpinSym tables of the following pairs of groups</p>

<div class="pcenter"><table class="GAPDocTablenoborder">
<tr>
<td class="tdcenter">Source</td>
<td class="tdcenter"><span class="SimpleMath">-&gt;</span></td>
<td class="tdcenter">Dest</td>
</tr>
<tr>
<td class="tdcenter"><span class="SimpleMath">2.Alt(n)</span></td>
<td class="tdcenter"></td>
<td class="tdcenter"><span class="SimpleMath">2.Sym(n)</span></td>
</tr>
<tr>
<td class="tdcenter"><span class="SimpleMath">2.Sym(k)</span></td>
<td class="tdcenter"></td>
<td class="tdcenter"><span class="SimpleMath">2.Sym(n)</span></td>
</tr>
<tr>
<td class="tdcenter"><span class="SimpleMath">2.Alt(k)</span></td>
<td class="tdcenter"></td>
<td class="tdcenter"><span class="SimpleMath">2.Alt(n)</span></td>
</tr>
<tr>
<td class="tdcenter"><span class="SimpleMath">2.Sym(n-2)</span></td>
<td class="tdcenter"></td>
<td class="tdcenter"><span class="SimpleMath">2.Alt(n)</span></td>
</tr>
<tr>
<td class="tdcenter"><span class="SimpleMath">2.(Sym(k)×Sym(l))</span></td>
<td class="tdcenter"></td>
<td class="tdcenter"><span class="SimpleMath">2.Sym(k+l)</span></td>
</tr>
<tr>
<td class="tdcenter"><span class="SimpleMath">2.(Sym(k)×Alt(l))</span></td>
<td class="tdcenter"></td>
<td class="tdcenter"><span class="SimpleMath">2.(Sym(k)×Sym(l))</span></td>
</tr>
<tr>
<td class="tdcenter"><span class="SimpleMath">2.(Alt(k)×Sym(l))</span></td>
<td class="tdcenter"></td>
<td class="tdcenter"><span class="SimpleMath">2.(Sym(k)×Sym(l))</span></td>
</tr>
<tr>
<td class="tdcenter"><span class="SimpleMath">2.(Alt(k)×Alt(l))</span></td>
<td class="tdcenter"></td>
<td class="tdcenter"><span class="SimpleMath">2.(Sym(k)×Alt(l))</span></td>
</tr>
<tr>
<td class="tdcenter"><span class="SimpleMath">2.(Alt(k)×Alt(l))</span></td>
<td class="tdcenter"></td>
<td class="tdcenter"><span class="SimpleMath">2.(Alt(k)×Sym(l))</span></td>
</tr>
<tr>
<td class="tdcenter"><span class="SimpleMath">2.(Alt(k)×Alt(l))</span></td>
<td class="tdcenter"></td>
<td class="tdcenter"><span class="SimpleMath">2.Alt(k+l)</span></td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p>The appropriate function (see the descriptions below) is called to determine the fusion map <code class="code">fus</code>. If <code class="code">GetFusionMap(ctSource, ctDest)</code> fails, then <code class="code">fus</code> is stored by calling <code class="code">StoreFusion(ctSource, fus, ctDest)</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ctD:= CharacterTable("2.Sym(18)");;                                  </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ctS:= SpinSymCharacterTableOfMaximalYoungSubgroup(10,8,"Symmetric");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GetFusionMap(ctS,ctD);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SpinSymClassFusion(ctS,ctD);;</span>
#I SpinSymClassFusion: stored fusion map from 2.(Sym(10)xSym(8)) to 2.Sym(18)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GetFusionMap(ctS,ctD) &lt;&gt; fail;</span>
true

</pre></div>

<p><a id="X857FB2A17904A9CE" name="X857FB2A17904A9CE"></a></p>

<h5>2.5-2 SpinSymClassFusion2Ain2S</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpinSymClassFusion2Ain2S</code>( <var class="Arg">cclSource</var>, <var class="Arg">cclDest</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a fusion map between the SpinSym tables of <span class="SimpleMath">2.Alt(n)</span> and <span class="SimpleMath">2.Sym(n)</span>.</p>

<p>Given lists of class parameters <var class="Arg">cclSource</var> and <var class="Arg">cclDest</var> of (ordinary or <span class="SimpleMath">p</span>-modular) SpinSym tables of <span class="SimpleMath">2.Alt(n)</span> and <span class="SimpleMath">2.Sym(n)</span>, respectively, a corresponding class fusion map is determined. See <a href="chapBib.html#biBMaas2011">[2, (5.4.1)]</a>.</p>

<p><a id="X84DDBEEF7BA42414" name="X84DDBEEF7BA42414"></a></p>

<h5>2.5-3 SpinSymClassFusion2Sin2S</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpinSymClassFusion2Sin2S</code>( <var class="Arg">cclSource</var>, <var class="Arg">cclDest</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a fusion map between the SpinSym tables of <span class="SimpleMath">2.Sym(k)</span> and <span class="SimpleMath">2.Sym(n)</span> for <span class="SimpleMath">k≤ n</span>.</p>

<p>Given lists of class parameters <var class="Arg">cclSource</var> and <var class="Arg">cclDest</var> of (ordinary or <span class="SimpleMath">p</span>-modular) SpinSym tables of <span class="SimpleMath">2.Sym(k)</span> and <span class="SimpleMath">2.Sym(n)</span> for <span class="SimpleMath">k≤ n</span>, respectively, a corresponding class fusion map is determined. See <a href="chapBib.html#biBMaas2011">[2, (5.4.2)]</a>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ctD:= CharacterTable("2.Sym(18)");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ctS:= CharacterTable("2.Sym(6)");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cclD:= ClassParameters(ctD);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cclS:= ClassParameters(ctS);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= SpinSymClassFusion2Sin2S(cclS,cclD);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StoreFusion(ctS,fus,ctD);</span>

</pre></div>

<p><a id="X7A4425B58361A2FD" name="X7A4425B58361A2FD"></a></p>

<h5>2.5-4 SpinSymClassFusion2Ain2A</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpinSymClassFusion2Ain2A</code>( <var class="Arg">cclSource</var>, <var class="Arg">cclDest</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a fusion map between the SpinSym tables of <span class="SimpleMath">2.Alt(k)</span> and <span class="SimpleMath">2.Alt(n)</span> for <span class="SimpleMath">k≤ n</span>.</p>

<p>Given lists of class parameters <var class="Arg">cclSource</var> and <var class="Arg">cclDest</var> of (ordinary or <span class="SimpleMath">p</span>-modular) SpinSym tables of <span class="SimpleMath">2.Alt(k)</span> and <span class="SimpleMath">2.Alt(n)</span> for <span class="SimpleMath">k≤ n</span>, respectively, a corresponding class fusion map is determined. See <a href="chapBib.html#biBMaas2011">[2, (5.4.3)]</a>.</p>

<p><a id="X7BE629FB81C12F27" name="X7BE629FB81C12F27"></a></p>

<h5>2.5-5 SpinSymClassFusion2Sin2A</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpinSymClassFusion2Sin2A</code>( <var class="Arg">cclSource</var>, <var class="Arg">cclDest</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a fusion map between the SpinSym tables of <span class="SimpleMath">2.Sym(n-2)</span> and <span class="SimpleMath">2.Alt(n)</span>.</p>

<p>Given lists of class parameters <var class="Arg">cclSource</var> and <var class="Arg">cclDest</var> of (ordinary or <span class="SimpleMath">p</span>-modular) SpinSym tables of <span class="SimpleMath">2.Sym(n-2)</span> and <span class="SimpleMath">2.Alt(n)</span>, respectively, a corresponding class fusion map with respect to the embedding of <span class="SimpleMath">&lt; t_1t_n-2,...,t_n-3t_n-1 &gt;</span> isomorphic to <span class="SimpleMath">2.Sym(n-2)</span> in <span class="SimpleMath">2.Alt(n)</span> is determined. See <a href="chapBib.html#biBMaas2011">[2, (5.4.4)]</a>.</p>

<p><a id="X8310E6BC7CC1A2F5" name="X8310E6BC7CC1A2F5"></a></p>

<h5>2.5-6 SpinSymClassFusion2SSin2S</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpinSymClassFusion2SSin2S</code>( <var class="Arg">cclSource</var>, <var class="Arg">cclDest</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a fusion map between the SpinSym tables of <span class="SimpleMath">2.(Sym(k)×Sym(l))</span> and <span class="SimpleMath">2.Sym(k+l)</span>.</p>

<p>Given lists of class parameters <var class="Arg">cclSource</var> and <var class="Arg">cclDest</var> of (ordinary or <span class="SimpleMath">p</span>-modular) SpinSym tables of <span class="SimpleMath">2.(Sym(k)×Sym(l))</span> and <span class="SimpleMath">2.Sym(k+l)</span>, respectively, a corresponding class fusion map is determined by means of <a href="chapBib.html#biBMaas2011">[2, (5.1.6)]</a>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ctD:= CharacterTable("2.Sym(18)");;                                  </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ctS:= SpinSymCharacterTableOfMaximalYoungSubgroup(10,8,"Symmetric");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cclD:= ClassParameters(ctD);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cclS:= ClassParameters(ctS);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= SpinSymClassFusion2SSin2S(cclS,cclD);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StoreFusion(ctS,fus,ctD);</span>

</pre></div>

<p><a id="X7854E1E785A0378A" name="X7854E1E785A0378A"></a></p>

<h5>2.5-7 SpinSymClassFusion2SAin2SS</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpinSymClassFusion2SAin2SS</code>( <var class="Arg">cclSource</var>, <var class="Arg">cclDest</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a fusion map between the SpinSym tables of <span class="SimpleMath">2.(Sym(k)×Alt(l))</span> and <span class="SimpleMath">2.(Sym(k)×Sym(l))</span>.</p>

<p>Given lists of class parameters <var class="Arg">cclSource</var> and <var class="Arg">cclDest</var> of (ordinary or <span class="SimpleMath">p</span>-modular) SpinSym tables of <span class="SimpleMath">2.(Sym(k)×Alt(l))</span> and <span class="SimpleMath">2.(Sym(k)×Sym(l))</span>, respectively, a corresponding class fusion map is determined. See <a href="chapBib.html#biBMaas2011">[2, (5.4.6)]</a>.</p>

<p><a id="X83B113007DF2BB69" name="X83B113007DF2BB69"></a></p>

<h5>2.5-8 SpinSymClassFusion2ASin2SS</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpinSymClassFusion2ASin2SS</code>( <var class="Arg">cclSource</var>, <var class="Arg">cclDest</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a fusion map between the SpinSym tables of <span class="SimpleMath">2.(Alt(k)×Sym(l))</span> and <span class="SimpleMath">2.(Sym(k)×Sym(l))</span>.</p>

<p>Given lists of class parameters <var class="Arg">cclSource</var> and <var class="Arg">cclDest</var> of (ordinary or <span class="SimpleMath">p</span>-modular) SpinSym tables of <span class="SimpleMath">2.(Alt(k)×Sym(l))</span> and <span class="SimpleMath">2.(Sym(k)×Sym(l))</span>, respectively, a corresponding class fusion map is determined analogously to <a href="chapBib.html#biBMaas2011">[2, (5.4.6)]</a>.</p>

<p><a id="X786B6E2D7CF13B51" name="X786B6E2D7CF13B51"></a></p>

<h5>2.5-9 SpinSymClassFusion2AAin2SA</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpinSymClassFusion2AAin2SA</code>( <var class="Arg">cclSource</var>, <var class="Arg">cclDest</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a fusion map between the SpinSym tables of <span class="SimpleMath">2.(Alt(k)×Alt(l))</span> and <span class="SimpleMath">2.(Sym(k)×Alt(l))</span>.</p>

<p>Given lists of class parameters <var class="Arg">cclSource</var> and <var class="Arg">cclDest</var> of (ordinary or <span class="SimpleMath">p</span>-modular) SpinSym tables of <span class="SimpleMath">2.(Alt(k)×Alt(l))</span> and <span class="SimpleMath">2.(Sym(k)×Alt(l))</span>, respectively, a corresponding class fusion map is determined. See <a href="chapBib.html#biBMaas2011">[2, (5.4.7)]</a>.</p>

<p><a id="X80DFBE347B87AA43" name="X80DFBE347B87AA43"></a></p>

<h5>2.5-10 SpinSymClassFusion2AAin2AS</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpinSymClassFusion2AAin2AS</code>( <var class="Arg">cclSource</var>, <var class="Arg">cclDest</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a fusion map between the SpinSym tables of <span class="SimpleMath">2.(Alt(k)×Alt(l))</span> and <span class="SimpleMath">2.(Alt(k)×Sym(l))</span>.</p>

<p>Given lists of class parameters <var class="Arg">cclSource</var> and <var class="Arg">cclDest</var> of (ordinary or <span class="SimpleMath">p</span>-modular) SpinSym tables of <span class="SimpleMath">2.(Alt(k)×Alt(l))</span> and <span class="SimpleMath">2.(Alt(k)×Sym(l))</span>, respectively, a corresponding class fusion map is determined analogously to <a href="chapBib.html#biBMaas2011">[2, (5.4.7)]</a>.</p>

<p><a id="X796897DF78143E05" name="X796897DF78143E05"></a></p>

<h5>2.5-11 SpinSymClassFusion2AAin2A</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpinSymClassFusion2AAin2A</code>( <var class="Arg">cclSource</var>, <var class="Arg">cclDest</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a fusion map between the SpinSym tables of <span class="SimpleMath">2.(Alt(k)×Alt(l))</span> and <span class="SimpleMath">2.Alt(k+l)</span>.</p>

<p>Given lists of class parameters <var class="Arg">cclSource</var> and <var class="Arg">cclDest</var> of (ordinary or <span class="SimpleMath">p</span>-modular) SpinSym tables of <span class="SimpleMath">2.(Alt(k)×Alt(l))</span> and <span class="SimpleMath">2.Alt(k+l)</span>, respectively, a corresponding class fusion map is determined. See <a href="chapBib.html#biBMaas2011">[2, (5.4.8)]</a>.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
