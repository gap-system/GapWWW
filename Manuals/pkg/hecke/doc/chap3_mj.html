<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (hecke) - Chapter 3: Specht functionality</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap3"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap3.html">[MathJax off]</a></p>
<p><a id="X7ED1AB5C7E41D277" name="X7ED1AB5C7E41D277"></a></p>
<div class="ChapSects"><a href="chap3_mj.html#X7ED1AB5C7E41D277">3 <span class="Heading">Specht functionality</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X78AA2DBD7D5D3F02">3.1 <span class="Heading">Porting notes</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X8340A4F97986693C">3.1-1 <span class="Heading">Structure of <strong class="pkg">Hecke</strong></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X8120A27282B82CC8">3.1-2 <span class="Heading">Renamings</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X7A7DF4FC796EF66F">3.2 <span class="Heading">Specht functions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7FE26921867C440A">3.2-1 Specht</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X8037763587274161">3.2-2 <span class="Heading">Simple information access</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7C92700882971537">3.2-3 <span class="Heading">The functions MakeSpecht, MakePIM and MakeSimple</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X86F599A07A7C1C33">3.2-4 <span class="Heading">Decomposition numbers of the symmetric groups</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X838BEC0382BF87EA">3.2-5 <span class="Heading">Hecke algebras over fields of positive characteristic</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X83009CE685621BD4">3.2-6 <span class="Heading">The Fock space and Hecke algebras over fields of characteristic zero
</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7B57DF517F73F00D">3.2-7 Schur</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X84F0F9E47D5EEBCF">3.2-8 DecompositionMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7F616CCE808FA11E">3.2-9 CrystalDecompositionMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X829A23A97EE4C20E">3.2-10 DecompositionNumber</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X7C5B169286EFC900">3.3 <span class="Heading">Partitions in <strong class="pkg">Hecke</strong></span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X87A6E8DD85F3F020">3.4 <span class="Heading">Inducing and restricting modules</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X81D7F7A4812BB04D">3.4-1 RInducedModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X780709B3865BC344">3.4-2 SInducedModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X783BC74E81A7D0E6">3.4-3 RRestrictedModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X8041ABFA86D7A3EF">3.4-4 SRestrictedModule</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X79F430837BA7BAD2">3.5 <span class="Heading">Operations on decomposition matrices</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7D257389845738DB">3.5-1 InducedDecompositionMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X803A99987E501AC9">3.5-2 IsNewIndecomposable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X802E811683E611EE">3.5-3 InvertDecompositionMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X87B18FD97B2D8E80">3.5-4 AdjustmentMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X78B0FF2079269138">3.5-5 SaveDecompositionMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X84DD2D517FC1F905">3.5-6 CalculateDecompositionMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7FDC65328102C1B9">3.5-7 MatrixDecompositionMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X86EBEBF680EBC98E">3.5-8 DecompositionMatrixMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7B05627D83E6977E">3.5-9 AddIndecomposable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X79FA055E8250E6A2">3.5-10 RemoveIndecomposable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X8434DC7C8364CB54">3.5-11 MissingIndecomposables</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X7A697AAA799BA7D4">3.6 <span class="Heading">Calculating dimensions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X828528747E4AC4C9">3.6-1 SimpleDimension</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7B98631580E193BB">3.6-2 SpechtDimension</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X78F1DC277875BAFD">3.7 <span class="Heading">Combinatorics on Young diagrams</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X820A908F8337F59C">3.7-1 Schaper</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7FB82B3184287362">3.7-2 IsSimpleModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7A6262B684185E3D">3.7-3 MullineuxMap</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7CC6C04482DD1E9D">3.7-4 MullineuxSymbol</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7826922879DD8D8A">3.7-5 PartitionMullineuxSymbol</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7CE4D6487FD009B1">3.7-6 GoodNodes</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X783B52458335975F">3.7-7 NormalNodes</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X85B290977A17D9EE">3.7-8 GoodNodeSequence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7B704FE781A311E5">3.7-9 PartitionGoodNodeSequence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7A9DC101850008A2">3.7-10 GoodNodeLatticePath</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7918D9DE7ACE2294">3.7-11 LittlewoodRichardsonRule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7B9901427D1CF6F4">3.7-12 InverseLittlewoodRichardsonRule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X790D4ACF7930340F">3.7-13 EResidueDiagram</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7DE3773C78BC324C">3.7-14 HookLengthDiagram</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7F2ACCBF788A62E8">3.7-15 RemoveRimHook</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7CEA98C779BDBD1A">3.7-16 AddRimHook</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X8350934A7F9AB5BE">3.8 <span class="Heading">Operations on partitions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X867496487DC35776">3.8-1 ECore</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X8236220C87814790">3.8-2 IsECore</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X8538AAAF8628A725">3.8-3 EQuotient</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7F357B417D495B6F">3.8-4 CombineEQuotientECore</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7C460635829E7ED0">3.8-5 EWeight</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X86308F6C818B220C">3.8-6 ERegularPartitions</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7BEDA8F286ED5F20">3.8-7 IsERegular</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7D131AF0839089BD">3.8-8 ConjugatePartition</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X8711CC56792711A7">3.8-9 PartitionBetaSet</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7EC4D0FA81B55391">3.8-10 ETopLadder</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X820388EF7C8333BA">3.8-11 Dominates</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X84DB1DD37AF227CF">3.8-12 LengthLexicographic</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X8480188D81ECBD92">3.8-13 Lexicographic</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X78F41DF77D6F8292">3.8-14 ReverseDominance</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X83890936806E3A34">3.9 <span class="Heading">Miscellaneous functions on modules</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7A8E810C85A62DD6">3.9-1 Specialized</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X8232C0A1846A27FB">3.9-2 ERegulars</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X822E8193835DD1D9">3.9-3 SplitECores</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7E92948B80075E46">3.9-4 Coefficient</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X79FB3FE67D55BCFA">3.9-5 InnerProduct</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X7D473E167C866CEC">3.10 <span class="Heading">Semi-standard and standard tableaux</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7F0F9663796E6978">3.10-1 Tableau</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X79ADB1B980D12A14">3.10-2 SemiStandardTableaux</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7E51D6107DBE2A74">3.10-3 StandardTableaux</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7869DA9A8198BD28">3.10-4 ConjugateTableau</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7E5351C27C9253D9">3.10-5 ShapeTableau</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7CABF92D7BF07DD1">3.10-6 TypeTableau</a></span>
</div></div>
</div>

<h3>3 <span class="Heading">Specht functionality</span></h3>

<p><a id="X78AA2DBD7D5D3F02" name="X78AA2DBD7D5D3F02"></a></p>

<h4>3.1 <span class="Heading">Porting notes</span></h4>

<p>Porting the <strong class="pkg">Specht</strong> <span class="SimpleMath">\(2.4\)</span> package to <strong class="pkg">GAP</strong> 4 did not influence the algorithms but required a completely new object oriented design of the underlying data structures. In <strong class="pkg">GAP</strong> 3 records were used to represent algebra objects, modules and decomposition matrices of <strong class="pkg">Specht</strong> <span class="SimpleMath">\(2.4\)</span>. Further functions were stored inside of such records to provide name safety.</p>

<p>In <strong class="pkg">Hecke</strong> objects represent all the data that was named above. The overloading mechanism the former record-internal functions to be available on the toplevel. The operation selection mechanism of <strong class="pkg">GAP</strong> 4 allows one to concentrate on the computation code instead of dealing with different possible argument inputs.</p>

<p>Since variable argument length operations are not yet supported by <strong class="pkg">GAP</strong> 4, we introduced our own dispatcher facility to enable the former possibility of passing patrition arguments as sequences of integers (see <a href="chap3_mj.html#X7C5B169286EFC900"><span class="RefLink">3.3</span></a>).</p>

<p><a id="X8340A4F97986693C" name="X8340A4F97986693C"></a></p>

<h5>3.1-1 <span class="Heading">Structure of <strong class="pkg">Hecke</strong></span></h5>

<p>The data structure hierarchy in <strong class="pkg">GAP</strong> 4 is defined through filters and their dependencies.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsAlgebraObj</code></td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsHecke</code></td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSchur</code></td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p><code class="func">IsAlgebraObj</code> is a generic filter for the objects returned by the functions <code class="func">Specht</code> (<a href="chap3_mj.html#X7FE26921867C440A"><span class="RefLink">3.2-1</span></a>) and <code class="func">Schur</code> (<a href="chap3_mj.html#X7B57DF517F73F00D"><span class="RefLink">3.2-7</span></a>). Concretely, <code class="func">Specht</code> (<a href="chap3_mj.html#X7FE26921867C440A"><span class="RefLink">3.2-1</span></a>) returns an <code class="func">IsHecke</code> object (automatically also an <code class="func">IsAlgebraObj</code> object). For design reasons <code class="func">IsSchur</code> is a subfilter of <code class="func">IsHecke</code>. This allows to use the same functions for Schur-algebras as for Hecke-algebras with minor restrictions.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsAlgebraObjModule</code></td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsHeckeModule</code></td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsHeckeSpecht</code></td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsHeckePIM</code></td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsHeckeSimple</code></td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFockModule</code></td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFockSpecht</code></td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFockPIM</code></td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFockSimple</code></td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSchurModule</code></td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSchurWeyl</code></td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSchurPIM</code></td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSchurSimple</code></td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFockSchurModule</code></td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFockSchurWeyl</code></td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFockSchurPIM</code></td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFockSchurSimple</code></td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>The hierarchy of module objects is more complex. On top we have the filter <code class="func">IsAlgebraObjModule</code>. Its direct descendant <code class="func">IsHeckeModule</code> has <code class="func">IsHeckeSpecht</code>, <code class="func">IsHeckePIM</code>, <code class="func">IsHeckeSimple</code>, <code class="func">IsFockModule</code> and <code class="func">IsSchurModule</code> as subfilters. Again the last two subfilter relations have no mathematical sense but are technically comfortable. The filter <code class="func">IsFockModule</code> is superfilter of <code class="func">IsFockSpecht</code>, <code class="func">IsFockPIM</code>, <code class="func">IsFockSimple</code> and <code class="func">IsFockSchurModule</code>. Analogously, <code class="func">IsSchurModule</code> is superfilter of <code class="func">IsSchurWeyl</code>, <code class="func">IsSchurPIM</code>, <code class="func">IsSchurSimple</code> and <code class="func">IsFockSchurModule</code> which itself is superfilter of <code class="func">IsFockSchurWeyl</code>, <code class="func">IsFockSchurPIM</code>, <code class="func">IsFockSchurSimple</code>. Further, there are subfilter relations between <code class="func">IsFockSpecht</code> and <code class="func">IsHeckeSpecht</code> etc., <code class="func">IsFockSchurWeyl</code> and <code class="func">IsFockSpecht</code> etc., <code class="func">IsFockSchurWeyl</code> and <code class="func">IsSchurWeyl</code> etc., <code class="func">IsSchurWeyl</code> and <code class="func">IsHeckeSpecht</code> etc. filters.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDecompositionMatrix</code></td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCrystalDecompositionMatrix</code></td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>For decomposition matrices we use the filter <code class="func">IsDecompositionMatrix</code> and its subfilter <code class="func">IsCrystalDecompositionMatrix</code>.</p>

<p><a id="X8120A27282B82CC8" name="X8120A27282B82CC8"></a></p>

<h5>3.1-2 <span class="Heading">Renamings</span></h5>

<p>To keep things as backwards compatible as possible, we tried not to change names and function signatures. But for the former <code class="code">H.***</code>- and <code class="code">H.operations.***</code>-style functions it makes more sense to use toplevel functions (especially when the <span class="SimpleMath">\(H\)</span> is not explicitly needed inside of the called operation). Here is an overview of some important changes:</p>

<div class="pcenter"><table class="GAPDocTable">
<tr>
<td class="tdcenter"><strong class="pkg">GAP</strong> 3</td>
<td class="tdcenter"><strong class="pkg">GAP</strong> 4</td>
</tr>
<tr>
<td class="tdcenter"><code class="code">H.S</code></td>
<td class="tdcenter"><code class="func">MakeSpecht</code> (<a href="chap3_mj.html#X7C92700882971537"><span class="RefLink">3.2-3</span></a>)</td>
</tr>
<tr>
<td class="tdcenter"><code class="code">H.P</code></td>
<td class="tdcenter"><code class="func">MakePIM</code> (<a href="chap3_mj.html#X7C92700882971537"><span class="RefLink">3.2-3</span></a>)</td>
</tr>
<tr>
<td class="tdcenter"><code class="code">H.D</code></td>
<td class="tdcenter"><code class="func">MakeSimple</code> (<a href="chap3_mj.html#X7C92700882971537"><span class="RefLink">3.2-3</span></a>)</td>
</tr>
<tr>
<td class="tdcenter"><code class="code">H.Sq</code></td>
<td class="tdcenter"><code class="func">MakeFockSpecht</code> (<a href="chap3_mj.html#X83009CE685621BD4"><span class="RefLink">3.2-6</span></a>)</td>
</tr>
<tr>
<td class="tdcenter"><code class="code">H.Pq</code></td>
<td class="tdcenter"><code class="func">MakeFockPIM</code> (<a href="chap3_mj.html#X83009CE685621BD4"><span class="RefLink">3.2-6</span></a>)</td>
</tr>
<tr>
<td class="tdcenter"><code class="code">S.W</code></td>
<td class="tdcenter"><code class="func">MakeSpecht</code> (<a href="chap3_mj.html#X7C92700882971537"><span class="RefLink">3.2-3</span></a>)</td>
</tr>
<tr>
<td class="tdcenter"><code class="code">S.F</code></td>
<td class="tdcenter"><code class="func">MakeSimple</code> (<a href="chap3_mj.html#X7C92700882971537"><span class="RefLink">3.2-3</span></a>)</td>
</tr>
<tr>
<td class="tdcenter"><code class="code">InducedModule</code></td>
<td class="tdcenter"><code class="func">RInducedModule</code> (<a href="chap3_mj.html#X81D7F7A4812BB04D"><span class="RefLink">3.4-1</span></a>)</td>
</tr>
<tr>
<td class="tdcenter"><code class="code">RestrictedModule</code></td>
<td class="tdcenter"><code class="func">RRestrictedModule</code> (<a href="chap3_mj.html#X783BC74E81A7D0E6"><span class="RefLink">3.4-3</span></a>)</td>
</tr>
<tr>
<td class="tdcenter"><code class="code">H.operations.New</code></td>
<td class="tdcenter"><code class="code">Module</code></td>
</tr>
<tr>
<td class="tdcenter"><code class="code">H.operations.Collect</code></td>
<td class="tdcenter"><code class="code">Collect</code></td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p><a id="X7A7DF4FC796EF66F" name="X7A7DF4FC796EF66F"></a></p>

<h4>3.2 <span class="Heading">Specht functions</span></h4>

<p><a id="X7FE26921867C440A" name="X7FE26921867C440A"></a></p>

<h5>3.2-1 Specht</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Specht</code>( <var class="Arg">e</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Specht</code>( <var class="Arg">e</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Specht</code>( <var class="Arg">e</var>, <var class="Arg">p</var>, <var class="Arg">val</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Specht</code>( <var class="Arg">e</var>, <var class="Arg">p</var>, <var class="Arg">val</var>, <var class="Arg">ring</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: object belonging to the filter <code class="func">IsHecke</code> (<a href="chap3_mj.html#X8340A4F97986693C"><span class="RefLink">3.1-1</span></a>)</p>

<p>Let <span class="SimpleMath">\(R\)</span> be a field of characteristic <span class="SimpleMath">\(0\)</span>, <span class="SimpleMath">\(q\)</span> a non-zero element of <span class="SimpleMath">\(R\)</span>, and let <span class="SimpleMath">\(e\)</span> be the smallest positive integer such that <span class="SimpleMath">\(1+q+\ldots+q^{e-1}=0\)</span> (we set <span class="SimpleMath">\(e=0\)</span> if no such integer exists). The object returned by <code class="code">Specht(e)</code> allows calculations in the Grothendieck rings of the Hecke algebras <span class="SimpleMath">\(H\)</span> of type <em>A</em> which are defined over <span class="SimpleMath">\(R\)</span> and have parameter <span class="SimpleMath">\(q\)</span>. Below we also describe how to consider Hecke algebras defined over fields of positive characteristic.</p>

<p><code class="func">Specht</code> returns an object which contains information about the the family of Hecke algebras determined by <span class="SimpleMath">\(R\)</span> and <span class="SimpleMath">\(q\)</span>. This object needs to be passed to the most of the <strong class="pkg">Hecke</strong> functions as an argument.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(5);</span>
&lt;Hecke algebra with e = 5&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(last);</span>
Specht(e=5, S(), P(), D())
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroCharacteristic(last);</span>
true
</pre></div>

<p>There is also a method <code class="func">Schur</code> (<a href="chap3_mj.html#X7B57DF517F73F00D"><span class="RefLink">3.2-7</span></a>) for doing calculations with the <span class="SimpleMath">\(q\)</span>-Schur algebra. See <code class="func">DecompositionMatrix</code> (<a href="chap3_mj.html#X84F0F9E47D5EEBCF"><span class="RefLink">3.2-8</span></a>), and <code class="func">CrystalDecompositionMatrix</code> (<a href="chap3_mj.html#X7F616CCE808FA11E"><span class="RefLink">3.2-9</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X8037763587274161" name="X8037763587274161"></a></p>

<h5>3.2-2 <span class="Heading">Simple information access</span></h5>

<p>We allow to read/store some information from/in the algebra object returned by <code class="func">Specht</code> (<a href="chap3_mj.html#X7FE26921867C440A"><span class="RefLink">3.2-1</span></a>) using the following functions.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OrderOfQ</code>( <var class="Arg">H</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <span class="SimpleMath">\(e\)</span>.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Characteristic</code>( <var class="Arg">H</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <span class="SimpleMath">\(p\)</span>.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SetOrdering</code>( <var class="Arg">H</var>, <var class="Arg">Ordering</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Provides writing access to <span class="SimpleMath">\(Ordering\)</span> that is stored in <span class="SimpleMath">\(H\)</span>. The ordering influences the way how decomposition matrices are printed.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpechtDirectory</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>Setting this global variable the user can tell <strong class="pkg">Hecke</strong> where to find decomposition matrices that are not in the library and also not in the current directory. By default this variable is set to the current directory.</p>

<p><a id="X7C92700882971537" name="X7C92700882971537"></a></p>

<h5>3.2-3 <span class="Heading">The functions MakeSpecht, MakePIM and MakeSimple</span></h5>

<p>The functions MakeSpecht, MakePIM and MakeSimple return objects belonging to the filter <code class="func">IsAlgebraObjModule</code> (<a href="chap3_mj.html#X8340A4F97986693C"><span class="RefLink">3.1-1</span></a>) which correspond to Specht modules (<code class="func">IsHeckeSpecht</code> (<a href="chap3_mj.html#X8340A4F97986693C"><span class="RefLink">3.1-1</span></a>)), projective indecomposable modules (<code class="func">IsHeckePIM</code> (<a href="chap3_mj.html#X8340A4F97986693C"><span class="RefLink">3.1-1</span></a>)) and simple modules (<code class="func">IsHeckeSimple</code> (<a href="chap3_mj.html#X8340A4F97986693C"><span class="RefLink">3.1-1</span></a>)) respectively. <strong class="pkg">Hecke</strong> allows manipulation of arbitrary linear combinations of these "modules", as well as a way of inducing and restricting them, "multiplying" them and converting between these three natural bases of the Grothendieck ring. Multiplication of modules corresponds to taking a tensor productand then inducing (thus giving a module for a larger Hecke algebra). Each of these three functions can be called in four different ways, as we now describe.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MakeSpecht</code>( <var class="Arg">H</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MakePIM</code>( <var class="Arg">H</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MakeSimple</code>( <var class="Arg">H</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>In the first form, <span class="SimpleMath">\(\mu\)</span> is a partition (either a list, or a sequence of integers) and the corresponding Specht module, PIM, or simple module (respectively), is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(5);; MakePIM(H,4,3,2);; Display(last);</span>
P(4,3,2)
</pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MakeSpecht</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MakePIM</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MakeSimple</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Here, <span class="SimpleMath">\(x\)</span> is an <span class="SimpleMath">\(H\)</span>-module. In this form, <code class="func">MakeSpecht</code> rewrites <span class="SimpleMath">\(x\)</span> as a linear combination of Specht modules, if possible. Similarly, <code class="func">MakePIM</code> and <code class="func">MakeSimple</code> rewrite <span class="SimpleMath">\(x\)</span> as a linear combination of PIMs and simple modules respectively. These conversions require knowledge of the relevant decomposition matrix of <span class="SimpleMath">\(H\)</span>; if this is not known then <code class="keyw">fail</code> is returned (over fields of characteristic zero, all of the decomposition matrices are known via the algorithm of <a href="chapBib_mj.html#biBLLT">[LLT96]</a>; various other decomposition matrices are included with <strong class="pkg">Hecke</strong>). For example, <code class="code">MakeSpecht(MakePIM(</code><span class="SimpleMath">\(H, \mu\)</span><code class="code">))</code> returns <span class="SimpleMath">\(\sum_\nu d_{\nu,\mu} S(\nu)\)</span> or <code class="keyw">fail</code> if some of these decomposition multiplicities are not known.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( MakeSimple( MakePIM(H,4,3,2) ) );</span>
D(5,3,1) + 2D(4,3,2) + D(2^4,1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( MakeSpecht( MakeSimple( MakeSpecht(H,1,1,1,1,1) ) ) );</span>
 - S(5) + S(4,1) - S(3,1^2) + S(2,1^3)
</pre></div>

<p>As the last example shows, <strong class="pkg">Hecke</strong> does not always behave as expected. The reason for this is that Specht modules indexed by <span class="SimpleMath">\(e\)</span>-singular partitions can always be written as a linear combination of Specht modules which involve only <span class="SimpleMath">\(e\)</span>-regular partitions. As such, it is not always clear when two elements are equal in the Grothendieck ring. Consequently, to test whether two modules are equal you should first rewrite both modules in the <span class="SimpleMath">\(D\)</span>-basis; this is <em>not</em> done by <strong class="pkg">Hecke</strong> because it would be very inefficient.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MakeSpecht</code>( <var class="Arg">d</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MakePIM</code>( <var class="Arg">d</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MakeSimple</code>( <var class="Arg">d</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>In the third form, <span class="SimpleMath">\(d\)</span> is a decomposition matrix and <span class="SimpleMath">\(\mu\)</span> is a partition. This is useful when you are trying to calculate a new decomposition matrix <span class="SimpleMath">\(d\)</span> because it allows you to do calculations using the known entries of <span class="SimpleMath">\(d\)</span> to deduce information about the unknown ones. When used in this way, <code class="func">MakePIM</code> and <code class="func">MakeSimple</code> use <span class="SimpleMath">\(d\)</span> to rewrite <span class="SimpleMath">\(P(\mu)\)</span> and <span class="SimpleMath">\(D(\mu)\)</span> respectively as a linear combination of Specht modules and <code class="func">MakeSpecht</code> uses <span class="SimpleMath">\(d\)</span> to write <span class="SimpleMath">\(S(\mu)\)</span> as a linear combination of simple modules. If the values of the unknown entries in <span class="SimpleMath">\(d\)</span> are needed, <code class="keyw">fail</code> is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(3,3);;   # e = 3, p = 3 = characteristic of 'R'</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"> d:=InducedDecompositionMatrix(DecompositionMatrix(H,14));;</span>
# Inducing....
The following projectives are missing from &lt;d&gt;:
    [ 15 ]  [ 8, 7 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(MakePIM(d,4,3,3,2,2,1));</span>
S(4,3^2,2^2,1) + S(4,3^2,2,1^3) + S(4,3,2^3,1^2) + S(3^3,2^2,1^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(MakeSpecht(d,7, 3, 3, 2));</span>
D(11,2,1^2) + D(10,3,1^2) + D(8,5,1^2) + D(8,3^2,1) + D(7,6,1^2) + D(7,3^2,2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(MakeSimple(d,14,1));</span>
fail
</pre></div>

<p>The final example returned <code class="keyw">fail</code> because the partitions <span class="SimpleMath">\((14,1)\)</span> and <span class="SimpleMath">\((15)\)</span> have the same <span class="SimpleMath">\(3\)</span>-core (and <span class="SimpleMath">\(P(15)\)</span> is missing from <span class="SimpleMath">\(d\)</span>).</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MakeSpecht</code>( <var class="Arg">d</var>, <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MakePIM</code>( <var class="Arg">d</var>, <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MakeSimple</code>( <var class="Arg">d</var>, <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>In the final form, <span class="SimpleMath">\(d\)</span> is a decomposition matrix and <span class="SimpleMath">\(x\)</span> is a module. All three functions rewrite <span class="SimpleMath">\(x\)</span> in their respective basis using <span class="SimpleMath">\(d\)</span>. Again this is only useful when you are trying to calculate a new decomposition matrix because, for any "known" decomposition matrix <span class="SimpleMath">\(d\)</span>, <code class="code">MakeSpecht(</code><span class="SimpleMath">\(x\)</span><code class="code">)</code> and <code class="code">MakeSpecht(</code><span class="SimpleMath">\(d, x\)</span><code class="code">)</code> are equivalent (and similarly for <code class="func">MakePIM</code> and <code class="func">MakeSimple</code>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(MakeSpecht(d, MakeSimple(d,10,5) ));</span>
 - S(13,2) + S(10,5)
</pre></div>

<p><a id="X86F599A07A7C1C33" name="X86F599A07A7C1C33"></a></p>

<h5>3.2-4 <span class="Heading">Decomposition numbers of the symmetric groups</span></h5>

<p>The last example looked at Hecke algebras with parameter <span class="SimpleMath">\(q=1\)</span> and <span class="SimpleMath">\(R\)</span> a field of characteristic <span class="SimpleMath">\(3\)</span> (so <span class="SimpleMath">\(e=3\)</span>); that is, the group algebra of the symmetric group over a field of characteristic <span class="SimpleMath">\(3\)</span>. More generally, the command <code class="code">Specht(</code><span class="SimpleMath">\(p,p\)</span><code class="code">)</code> can be used to consider the group algebras of the symmetric groups over fields of characteristic <span class="SimpleMath">\(p\)</span> (i.e. <span class="SimpleMath">\(e=p\)</span> and <span class="SimpleMath">\(R\)</span> a field of characteristic <span class="SimpleMath">\(p\)</span>). For example, the dimensions of the simple modules of <span class="SimpleMath">\(S_6\)</span> over fields of characteristic <span class="SimpleMath">\(5\)</span> can be computed as follows:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(5,5);; SimpleDimension(H,6);</span>
6       : 1
5,1     : 5
4,2     : 8
4,1^2   : 10
3^2     : 5
3,2,1   : 8
3,1^3   : 10
2^3     : 5
2^2,1^2 : 1
2,1^4   : 5
true
</pre></div>

<p><a id="X838BEC0382BF87EA" name="X838BEC0382BF87EA"></a></p>

<h5>3.2-5 <span class="Heading">Hecke algebras over fields of positive characteristic</span></h5>

<p>To consider Hecke algebras defined over arbitrary fields, <code class="func">Specht</code> (<a href="chap3_mj.html#X7FE26921867C440A"><span class="RefLink">3.2-1</span></a>) must also be supplied with a valuation map <span class="SimpleMath">\(val\)</span> as an argument. The function <span class="SimpleMath">\(val\)</span> is a map from some PID into the natural numbers; at present it is needed only by functions which rely (at least implicitly), upon the <span class="SimpleMath">\(q\)</span>-analogue of Schaper's theorem. In general, <span class="SimpleMath">\(val\)</span> depends upon <span class="SimpleMath">\(q\)</span> and the characteristic of <span class="SimpleMath">\(R\)</span>; full details can be found in <a href="chapBib_mj.html#biBJM2">[JM97]</a>. Over fields of characteristic zero and in the symmetric group case, the function <span class="SimpleMath">\(val\)</span> is automatically defined by <code class="func">Specht</code> (<a href="chap3_mj.html#X7FE26921867C440A"><span class="RefLink">3.2-1</span></a>). When <span class="SimpleMath">\(R\)</span> is a field of characteristic zero, <span class="SimpleMath">\(val([i]_q)\)</span> is <span class="SimpleMath">\(1\)</span> if <span class="SimpleMath">\(e\)</span> divides <span class="SimpleMath">\(i\)</span> and <span class="SimpleMath">\(0\)</span> otherwise (this is the valuation map associated to the prime ideal in <span class="SimpleMath">\(ℂ[v]\)</span> generated by the <span class="SimpleMath">\(e\)</span>-th cyclotomic polynomial). When <span class="SimpleMath">\(q=1\)</span> and <span class="SimpleMath">\(R\)</span> is a field of characteristic <span class="SimpleMath">\(p\)</span>, <span class="SimpleMath">\(val\)</span> is the usual <span class="SimpleMath">\(p\)</span>-adic valuation map. As another example, if <span class="SimpleMath">\(q=4\)</span> and <span class="SimpleMath">\(R\)</span> is a field of characteristic <span class="SimpleMath">\(5\)</span> (so <span class="SimpleMath">\(e=2\)</span>), then the valuation map sends the integer <span class="SimpleMath">\(x\)</span> to <span class="SimpleMath">\(\nu_5([4]_x)\)</span> where <span class="SimpleMath">\([4]_x\)</span> is interpreted as an integer and <span class="SimpleMath">\(\nu_5\)</span> is the usual <span class="SimpleMath">\(5\)</span>-adic valuation. To consider this Hecke algebra one could proceed as follows:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">val:=function(x) local v;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      x:=Sum([0..x-1],v-&gt;4^v);  # x-&gt;[x]_q</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      v:=0; while x mod 5=0 do x:=x/5; v:=v+1; od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      return v;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(2,5,val,"e2q4");; Display(H);</span>
Specht(e=2, p=5, S(), P(), D(), HeckeRing="e2q4")
</pre></div>

<p>Notice the string "e2q4" which was also passed to <code class="func">Specht</code> (<a href="chap3_mj.html#X7FE26921867C440A"><span class="RefLink">3.2-1</span></a>) in this example. Although it is not strictly necessary, it is a good idea when using a "non-standard" valuation map <span class="SimpleMath">\(val\)</span> to specify the value of <span class="SimpleMath">\(HeckeRing\)</span>. This string is used for internal bookkeeping by <strong class="pkg">Hecke</strong>; in particular, it is used to determine filenames when reading and saving decomposition matrices. If a "standard" valuation map is used then <span class="SimpleMath">\(HeckeRing\)</span> is set to the string "e&lt;e&gt;p&lt;p&gt;"; otherwise it defaults to "unknown". The function <code class="func">SaveDecompositionMatrix</code> (<a href="chap3_mj.html#X78B0FF2079269138"><span class="RefLink">3.5-5</span></a>) will not save any decomposition matrix for any Hecke algebra <span class="SimpleMath">\(H\)</span> with <span class="SimpleMath">\(HeckeRing=\)</span>"unknown".</p>

<p><a id="X83009CE685621BD4" name="X83009CE685621BD4"></a></p>

<h5>3.2-6 <span class="Heading">The Fock space and Hecke algebras over fields of characteristic zero
</span></h5>

<p>For Hecke algebras <span class="SimpleMath">\(H\)</span> defined over fields of characteristic zero Lascoux, Leclerc and Thibon <a href="chapBib_mj.html#biBLLT">[LLT96]</a> have described an easy, inductive, algorithm for calculating the decomposition matrices of <span class="SimpleMath">\(H\)</span>. Their algorithm really calculates the <em>canonical basis</em>, or (global) <em>crystal basis</em> of the Fock space; results of Grojnowski-Lusztig <a href="chapBib_mj.html#biBGr">[Gro94]</a> show that computing this basis is equivalent to computing the decomposition matrices of <span class="SimpleMath">\(H\)</span> (see also <a href="chapBib_mj.html#biBA">[Ari96]</a>).</p>

<p>The <em>Fock space</em> <span class="SimpleMath">\( F\)</span> is an (integrable) module for the quantum group <span class="SimpleMath">\(U_q( sl^_{e})\)</span> of the affine special linear group. <span class="SimpleMath">\( F\)</span> is a free <span class="SimpleMath">\(ℂ[v]\)</span>-module with basis the set of all Specht modules <span class="SimpleMath">\(S(\mu)\)</span> for all partitions <span class="SimpleMath">\(\mu\)</span> of all integers.</p>

<p>Here <span class="SimpleMath">\(v\)</span> is an indeterminate over the integers (or strictly, <span class="SimpleMath">\(ℂ\)</span>) that is stored in the algebra object produced by <code class="func">Specht</code> (<a href="chap3_mj.html#X7FE26921867C440A"><span class="RefLink">3.2-1</span></a>). The canonical basis elements <span class="SimpleMath">\(Pq(\mu)\)</span> for the <span class="SimpleMath">\(U_q( sl^_e)\)</span>-submodule of <span class="SimpleMath">\( F\)</span> generated by the <span class="SimpleMath">\(0\)</span>-partition are indexed by <span class="SimpleMath">\(e\)</span>-regular partitions <span class="SimpleMath">\(\mu\)</span>. Moreover, under <em>specialization</em>, <span class="SimpleMath">\(Pq(\mu)\)</span> maps to <span class="SimpleMath">\(P(\mu)\)</span>. An eloquent description of the algorithm for computing <span class="SimpleMath">\(Pq(\mu)\)</span> can be found in <a href="chapBib_mj.html#biBLLT">[LLT96]</a>.</p>

<p>To access the elements of the Fock space <strong class="pkg">Hecke</strong> provides the functions:</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MakeFockPIM</code>( <var class="Arg">H</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MakeFockSpecht</code>( <var class="Arg">H</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Notice that, unlike <code class="func">MakePIM</code> (<a href="chap3_mj.html#X7C92700882971537"><span class="RefLink">3.2-3</span></a>) and <code class="func">MakeSpecht</code> (<a href="chap3_mj.html#X7C92700882971537"><span class="RefLink">3.2-3</span></a>), the only arguments which <code class="func">MakeFockPIM</code> and <code class="func">MakeFockSpecht</code> accept are partitions.</p>

<p>The function <code class="func">MakeFockPIM</code> computes the canonical basis element <span class="SimpleMath">\(Pq(\mu)\)</span> of the Fock space corresponding to the <span class="SimpleMath">\(e\)</span>-regular partition <span class="SimpleMath">\(\mu\)</span> (there is a canonical basis -- defined using a larger quantum group -- for the whole of the Fock space <a href="chapBib_mj.html#biBLT">[LT96]</a>; conjecturally, this basis can be used to compute the decomposition matrices for the <span class="SimpleMath">\(q\)</span>-Schur algebra over fields of characteristic zero). The second function returns a standard basis element <span class="SimpleMath">\(Sq(\mu)\)</span> of <span class="SimpleMath">\(F\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(4);; MakeFockPIM(H,6,2);; Display(last);</span>
Sq(6,2) + vSq(5,3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RRestrictedModule(last); Display(last);</span>
&lt;direct sum of 3 Sq-modules&gt;
Sq(6,1) + (v+v^-1)Sq(5,2) + vSq(4,3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MakePIM(last);; Display(last);</span>
Pq(6,1) + (v+v^-1)Pq(5,2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Specialized(last);; Display(last);</span>
P(6,1) + 2P(5,2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MakeFockSpecht(H,5,3,2);; Display(last);</span>
Sq(5,3,2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RInducedModule(last,0);; Display(last);</span>
v^-1Sq(5,3^2)
</pre></div>

<p>The modules returned by <code class="func">MakeFockPIM</code> and <code class="func">MakeFockSpecht</code> behave very much like elements of the Grothendieck ring of <span class="SimpleMath">\(H\)</span>; however, they should be considered as elements of the Fock space. The key difference is that when induced or restricted "quantum" analogues of induction and restriction are used. These analogues correspond to the action of <span class="SimpleMath">\(U_q( sl^_{e})\)</span> on <span class="SimpleMath">\( F\)</span> <a href="chapBib_mj.html#biBLLT">[LLT96]</a>.</p>

<p>In effect, the functions <code class="func">MakeFockPIM</code> and <code class="func">MakeFockSpecht</code> allow computations in the Fock space, using the functions <code class="func">RInducedModule</code> (<a href="chap3_mj.html#X81D7F7A4812BB04D"><span class="RefLink">3.4-1</span></a>) and <code class="func">RRestrictedModule</code> (<a href="chap3_mj.html#X783BC74E81A7D0E6"><span class="RefLink">3.4-3</span></a>). The functions <code class="func">MakeSpecht</code> (<a href="chap3_mj.html#X7C92700882971537"><span class="RefLink">3.2-3</span></a>), <code class="func">MakePIM</code> (<a href="chap3_mj.html#X7C92700882971537"><span class="RefLink">3.2-3</span></a>) and <code class="func">MakeSimple</code> (<a href="chap3_mj.html#X7C92700882971537"><span class="RefLink">3.2-3</span></a>) can also be applied to elements of the Fock space, in which case they have the expected effect. In addition, any element of the Fock space can be specialized to give the corresponding element of the Grothendieck ring of <span class="SimpleMath">\(H\)</span> (it is because of this correspondence that we do not make a distinction between elements of the Fock space and the Grothendieck ring of <span class="SimpleMath">\(H\)</span>).</p>

<p>When working over fields of characteristic zero <strong class="pkg">Hecke</strong> will automatically calculate any canonical basis elements that it needs for computations in the Grothendieck ring of <span class="SimpleMath">\(H\)</span>. If you are not interested in the canonical basis elements you need never work with them directly.</p>

<p><a id="X7B57DF517F73F00D" name="X7B57DF517F73F00D"></a></p>

<h5>3.2-7 Schur</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Schur</code>( <var class="Arg">e</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Schur</code>( <var class="Arg">e</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Schur</code>( <var class="Arg">e</var>, <var class="Arg">p</var>, <var class="Arg">val</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Schur</code>( <var class="Arg">e</var>, <var class="Arg">p</var>, <var class="Arg">val</var>, <var class="Arg">ring</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: object belonging to the filter <code class="func">IsSchur</code> (<a href="chap3_mj.html#X8340A4F97986693C"><span class="RefLink">3.1-1</span></a>)</p>

<p>This function behaves almost identically to the function <code class="func">Specht</code> (<a href="chap3_mj.html#X7FE26921867C440A"><span class="RefLink">3.2-1</span></a>), the only difference being that the belonging modules are printed as "W", "P", "F" and that they correspond to the <span class="SimpleMath">\(q\)</span>-Weyl modules, the projective indecomposable modules, and the simple modules of the <span class="SimpleMath">\(q\)</span>-Schur algebra respectively. Note that the <code class="code">Make***</code>-functions (i.e. <code class="func">MakeSpecht</code> (<a href="chap3_mj.html#X7C92700882971537"><span class="RefLink">3.2-3</span></a>) is used to generate <span class="SimpleMath">\(q\)</span>-Weyl modules). Further, note that our labeling of these modules is non-standard, following that used by James in <a href="chapBib_mj.html#biBJ">[Jam90]</a>. The standard labeling can be obtained from ours by replacing all partitions by their conjugates.</p>

<p>Almost all of the functions in <strong class="pkg">Hecke</strong> which accept a Hecke algebra object <span class="SimpleMath">\(H\)</span> will also accept the object <span class="SimpleMath">\(S\)</span> returned by <code class="func">Schur</code> .</p>

<p>In the current version of <strong class="pkg">Hecke</strong> the decomposition matrices of <span class="SimpleMath">\(q\)</span>-Schur algebras are not fully supported. The <code class="func">InducedDecompositionMatrix</code> (<a href="chap3_mj.html#X7D257389845738DB"><span class="RefLink">3.5-1</span></a>) function can be applied to these matrices; however there are no additional routines available for calculating the columns corresponding to <span class="SimpleMath">\(e\)</span>-singular partitions. The decomposition matrices for the <span class="SimpleMath">\(q\)</span>-Schur algebras defined over a field of characteristic <span class="SimpleMath">\(0\)</span> for <span class="SimpleMath">\(n\leq 10\)</span> are in the <strong class="pkg">Hecke</strong> libraries.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S:=Schur(2);</span>
&lt;Schur algebra with e = 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InducedDecompositionMatrix(DecompositionMatrix(S,3));</span>
The following projectives are missing from &lt;d&gt;:
    [ 2, 2 ]
&lt;5x5 decomposition matrix&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(last);</span>
4    | 1         
3,1  | 1 1       
2^2  | . 1 .     
2,1^2| 1 1 . 1   
1^4  | 1 . . 1 1

# DecompositionMatrix(S,4) returns the full decomposition matrix. The point of
# this example is to emphasize the current limitations of Schur.
</pre></div>

<p>Note that when <span class="SimpleMath">\(S\)</span> is defined over a field of characteristic zero then the functions <code class="func">MakeFockSpecht</code> (<a href="chap3_mj.html#X83009CE685621BD4"><span class="RefLink">3.2-6</span></a>) and <code class="func">MakeFockPIM</code> (<a href="chap3_mj.html#X83009CE685621BD4"><span class="RefLink">3.2-6</span></a>) will calculate the canonical basis elements (see <code class="func">Specht</code> (<a href="chap3_mj.html#X7FE26921867C440A"><span class="RefLink">3.2-1</span></a>)); currently <code class="code">MakeFockPIM(</code><span class="SimpleMath">\(\mu\)</span><code class="code">)</code> is implemented only for <span class="SimpleMath">\(e\)</span>-regular partitions.</p>

<p>See also <code class="func">Specht</code> (<a href="chap3_mj.html#X7FE26921867C440A"><span class="RefLink">3.2-1</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X84F0F9E47D5EEBCF" name="X84F0F9E47D5EEBCF"></a></p>

<h5>3.2-8 DecompositionMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DecompositionMatrix</code>( <var class="Arg">H</var>, <var class="Arg">n</var>[, <var class="Arg">Ordering</var>] )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DecompositionMatrix</code>( <var class="Arg">H</var>, <var class="Arg">file</var>[, <var class="Arg">Ordering</var>] )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the decomposition matrix <span class="SimpleMath">\(D\)</span> of <span class="SimpleMath">\(H(S_n)\)</span> where <span class="SimpleMath">\(H\)</span> is a Hecke algebra object returned by the function <code class="func">Specht</code> (<a href="chap3_mj.html#X7FE26921867C440A"><span class="RefLink">3.2-1</span></a>) (or <code class="func">Schur</code> (<a href="chap3_mj.html#X7B57DF517F73F00D"><span class="RefLink">3.2-7</span></a>) ).</p>

<p><code class="func">DecompositionMatrix</code> first checks whether the required decomposition matrix exists as a library file (checking first in the current directory, next in the directory specified by <code class="func">SpechtDirectory</code> (<a href="chap3_mj.html#X8037763587274161"><span class="RefLink">3.2-2</span></a>), and finally in the <strong class="pkg">Hecke</strong> libraries). If the base field of <span class="SimpleMath">\(H\)</span> has characteristic zero, <code class="func">DecompositionMatrix</code> next looks for <em>crystallized decomposition matrices</em> (see <code class="func">CrystalDecompositionMatrix</code> (<a href="chap3_mj.html#X7F616CCE808FA11E"><span class="RefLink">3.2-9</span></a>)). If the decomposition matrix <span class="SimpleMath">\(d\)</span> is not stored in the library <code class="func">DecompositionMatrix</code> will calculate <span class="SimpleMath">\(d\)</span> when <span class="SimpleMath">\(H\)</span> is a Hecke algebra with a base field of characteristic zero, and will return <code class="code">fail</code> otherwise (in which case the function <code class="func">CalculateDecompositionMatrix</code> (<a href="chap3_mj.html#X84DD2D517FC1F905"><span class="RefLink">3.5-6</span></a>) can be used to force <strong class="pkg">Hecke</strong> to try and calculate this matrix).</p>

<p>For Hecke algebras defined over fields of characteristic zero, <strong class="pkg">Hecke</strong> uses the algorithm of <a href="chapBib_mj.html#biBLLT">[LLT96]</a> to calculate decomposition matrices The decomposition matrices for the <span class="SimpleMath">\(q\)</span>-Schur algebras for <span class="SimpleMath">\(n\leq10\)</span> are contained in the <strong class="pkg">Hecke</strong> library, as are those for the symmetric group over fields of positive characteristic when <span class="SimpleMath">\(n&lt;15\)</span>.</p>

<p>Once a decomposition matrix is known, <strong class="pkg">Hecke</strong> keeps an internal copy of it which is used by the functions <code class="func">MakeSpecht</code> (<a href="chap3_mj.html#X7C92700882971537"><span class="RefLink">3.2-3</span></a>), <code class="func">MakePIM</code> (<a href="chap3_mj.html#X7C92700882971537"><span class="RefLink">3.2-3</span></a>), and <code class="func">MakeSimple</code> (<a href="chap3_mj.html#X7C92700882971537"><span class="RefLink">3.2-3</span></a>); these functions also read decomposition matrix files as needed.</p>

<p>If you set the variable <code class="func">SpechtDirectory</code> (<a href="chap3_mj.html#X8037763587274161"><span class="RefLink">3.2-2</span></a>), then <strong class="pkg">Hecke</strong> will also search for decomposition matrix files in this directory. The files in the current directory override those in <code class="func">SpechtDirectory</code> (<a href="chap3_mj.html#X8037763587274161"><span class="RefLink">3.2-2</span></a>) and those in the <strong class="pkg">Hecke</strong> libraries.</p>

<p>In the second form of the function, when a <span class="SimpleMath">\(filename\)</span> is supplied, <code class="func">DecompositionMatrix</code> will read the decomposition matrix in the file <span class="SimpleMath">\(filename\)</span>, and this matrix will become <strong class="pkg">Hecke</strong>'s internal copy of this matrix.</p>

<p>By default, the rows and columns of the decomposition matrices are ordered <code class="func">DecompositionMatrix</code> with an ordering function such as <code class="func">LengthLexicographic</code> (<a href="chap3_mj.html#X84DB1DD37AF227CF"><span class="RefLink">3.8-12</span></a>) or <code class="func">ReverseDominance</code> (<a href="chap3_mj.html#X78F41DF77D6F8292"><span class="RefLink">3.8-14</span></a>). You do not need to specify the ordering you want every time you call <code class="func">DecompositionMatrix</code>; <strong class="pkg">Hecke</strong> will keep the same ordering until you change it again. This ordering can also be set "by hand" using the operation <code class="func">SetOrdering</code> (<a href="chap3_mj.html#X8037763587274161"><span class="RefLink">3.2-2</span></a>)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DecompositionMatrix(Specht(3),6,LengthLexicographic);</span>
&lt;11x7 decomposition matrix&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(last);</span>
6      | 1             
5,1    | 1 1           
4,2    | . . 1         
3^2    | . 1 . 1       
4,1^2  | . 1 . . 1     
3,2,1  | 1 1 . 1 1 1   
2^3    | 1 . . . . 1   
3,1^3  | . . . . 1 1   
2^2,1^2| . . . . . . 1
2,1^4  | . . . 1 . 1 . 
1^6    | . . . 1 . . . 
</pre></div>

<p>Once you have a decomposition matrix it is often nice to be able to print it. The on screen version is often good enough; There are also functions for converting <strong class="pkg">Hecke</strong> decomposition matrices into <strong class="pkg">GAP</strong> matrices and vice versa (see <code class="func">MatrixDecompositionMatrix</code> (<a href="chap3_mj.html#X7FDC65328102C1B9"><span class="RefLink">3.5-7</span></a>) and <code class="func">DecompositionMatrixMatrix</code> (<a href="chap3_mj.html#X86EBEBF680EBC98E"><span class="RefLink">3.5-8</span></a>)).</p>

<p>Using the function <code class="func">InducedDecompositionMatrix</code> (<a href="chap3_mj.html#X7D257389845738DB"><span class="RefLink">3.5-1</span></a>), it is possible to induce a decomposition matrix. See also <code class="func">SaveDecompositionMatrix</code> (<a href="chap3_mj.html#X78B0FF2079269138"><span class="RefLink">3.5-5</span></a>) and <code class="func">IsNewIndecomposable</code> (<a href="chap3_mj.html#X803A99987E501AC9"><span class="RefLink">3.5-2</span></a>), <code class="func">Specht</code> (<a href="chap3_mj.html#X7FE26921867C440A"><span class="RefLink">3.2-1</span></a>), <code class="func">Schur</code> (<a href="chap3_mj.html#X7B57DF517F73F00D"><span class="RefLink">3.2-7</span></a>), and <code class="func">CrystalDecompositionMatrix</code> (<a href="chap3_mj.html#X7F616CCE808FA11E"><span class="RefLink">3.2-9</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7F616CCE808FA11E" name="X7F616CCE808FA11E"></a></p>

<h5>3.2-9 CrystalDecompositionMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CrystalDecompositionMatrix</code>( <var class="Arg">H</var>, <var class="Arg">n</var>[, <var class="Arg">Ordering</var>] )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CrystalDecompositionMatrix</code>( <var class="Arg">H</var>, <var class="Arg">file</var>[, <var class="Arg">Ordering</var>] )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the crystal decomposition matrix <span class="SimpleMath">\(D\)</span> of <span class="SimpleMath">\(H(S_n)\)</span> where <span class="SimpleMath">\(H\)</span> is a Hecke algebra object returned by the function <code class="func">Specht</code> (<a href="chap3_mj.html#X7FE26921867C440A"><span class="RefLink">3.2-1</span></a>) (or <code class="func">Schur</code> (<a href="chap3_mj.html#X7B57DF517F73F00D"><span class="RefLink">3.2-7</span></a>) ).</p>

<p>This function is similar to <code class="func">DecompositionMatrix</code> (<a href="chap3_mj.html#X84F0F9E47D5EEBCF"><span class="RefLink">3.2-8</span></a>). The columns of decomposition matrices correspond to projective indecomposables; the columns of crystallized decomposition matrices correspond to the canonical basis elements of the Fock space (see <code class="func">Specht</code> (<a href="chap3_mj.html#X7FE26921867C440A"><span class="RefLink">3.2-1</span></a>)). Consequently, the entries in these matrices are polynomials (in <span class="SimpleMath">\(v\)</span>), and by specializing (i.e. setting <span class="SimpleMath">\(v\)</span> equal to <span class="SimpleMath">\(1\)</span>; see <code class="func">Specialized</code> (<a href="chap3_mj.html#X7A8E810C85A62DD6"><span class="RefLink">3.9-1</span></a>)), the decomposition matrices of <span class="SimpleMath">\(H\)</span> are obtained (see <code class="func">Specht</code> (<a href="chap3_mj.html#X7FE26921867C440A"><span class="RefLink">3.2-1</span></a>)). Crystallized decomposition matrices are defined only for Hecke algebras over a base field of characteristic zero. Unlike "normal" decomposition matrices, crystallized decomposition matrices cannot be induced.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CrystalDecompositionMatrix(Specht(3), 6);</span>
&lt;11x7 decomposition matrix&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(last);</span>
6      |   1                         
5,1    |   v   1                     
4,2    |   .   .   1                 
4,1^2  |   .   v   .   1             
3^2    |   .   v   .   .   1         
3,2,1  |   v v^2   .   v   v   1     
3,1^3  |   .   .   . v^2   .   v     
2^3    | v^2   .   .   .   .   v     
2^2,1^2|   .   .   .   .   .   .   1
2,1^4  |   .   .   .   .   v v^2   . 
1^6    |   .   .   .   . v^2   .   . 
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Specialized(last);   # set v equal to 1.</span>
&lt;11x7 decomposition matrix&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(last);</span>
6      | 1             
5,1    | 1 1           
4,2    | . . 1         
4,1^2  | . 1 . 1       
3^2    | . 1 . . 1     
3,2,1  | 1 1 . 1 1 1   
3,1^3  | . . . 1 . 1   
2^3    | 1 . . . . 1   
2^2,1^2| . . . . . . 1
2,1^4  | . . . . 1 1 . 
1^6    | . . . . 1 . . 
</pre></div>

<p>See also <code class="func">Specht</code> (<a href="chap3_mj.html#X7FE26921867C440A"><span class="RefLink">3.2-1</span></a>), <code class="func">Schur</code> (<a href="chap3_mj.html#X7B57DF517F73F00D"><span class="RefLink">3.2-7</span></a>), <code class="func">DecompositionMatrix</code> (<a href="chap3_mj.html#X84F0F9E47D5EEBCF"><span class="RefLink">3.2-8</span></a>) and <code class="func">Specialized</code> (<a href="chap3_mj.html#X7A8E810C85A62DD6"><span class="RefLink">3.9-1</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X829A23A97EE4C20E" name="X829A23A97EE4C20E"></a></p>

<h5>3.2-10 DecompositionNumber</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DecompositionNumber</code>( <var class="Arg">H</var>, <var class="Arg">mu</var>, <var class="Arg">nu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DecompositionNumber</code>( <var class="Arg">d</var>, <var class="Arg">mu</var>, <var class="Arg">nu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>This function attempts to calculate the decomposition multiplicity of <span class="SimpleMath">\(D(\nu)\)</span> in <span class="SimpleMath">\(S(\mu)\)</span> (equivalently, the multiplicity of <span class="SimpleMath">\(S(\mu)\)</span> in <span class="SimpleMath">\(P(\nu)\)</span>). If <span class="SimpleMath">\(P(\nu)\)</span> is known, we just look up the answer; if not <code class="func">DecompositionNumber</code> tries to calculate the answer using "row and column removal" (see <a href="chapBib_mj.html#biBJ">[Jam90, Theorem 6.18]</a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(6);; DecompositionNumber(H,[6,4,2],[6,6]);</span>
0
</pre></div>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7C5B169286EFC900" name="X7C5B169286EFC900"></a></p>

<h4>3.3 <span class="Heading">Partitions in <strong class="pkg">Hecke</strong></span></h4>

<p>Many of the functions in <strong class="pkg">Hecke</strong> take partitions as arguments. Partitions are usually represented by lists in <strong class="pkg">GAP</strong>. In <strong class="pkg">Hecke</strong>, all the functions which expect a partition will accept their argument either as a list or simply as a sequence of numbers. So, for example:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(4);; Print(MakeSpecht(MakePIM(H,6,4)),"\n");</span>
S(6,4) + S(6,3,1) + S(5,3,1,1) + S(3,3,2,1,1) + S(2,2,2,2,2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Print(MakeSpecht(MakePIM(H,[6,4])),"\n");</span>
S(6,4) + S(6,3,1) + S(5,3,1,1) + S(3,3,2,1,1) + S(2,2,2,2,2)
</pre></div>

<p>Some functions require more than one argument, but the convention still applies.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ECore(3, [6,4,2]);</span>
[ 6, 4, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ECore(3, 6,4,2);</span>
[ 6, 4, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GoodNodes(3, 6,4,2);</span>
[ fail, fail, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GoodNodes(3, [6,4,2]);</span>
[ fail, fail, 3 ]
</pre></div>

<p>Basically, it never hurts to put the extra brackets in, and they can be omitted so long as this is not ambiguous. One function where the brackets are needed is <code class="func">DecompositionNumber</code> (<a href="chap3_mj.html#X829A23A97EE4C20E"><span class="RefLink">3.2-10</span></a>) this is clear because the function takes two partitions as its arguments.</p>

<p><a id="X87A6E8DD85F3F020" name="X87A6E8DD85F3F020"></a></p>

<h4>3.4 <span class="Heading">Inducing and restricting modules</span></h4>

<p><strong class="pkg">Hecke</strong> provides four functions <code class="func">RInducedModule</code> (<a href="chap3_mj.html#X81D7F7A4812BB04D"><span class="RefLink">3.4-1</span></a>), <code class="func">RRestrictedModule</code> (<a href="chap3_mj.html#X783BC74E81A7D0E6"><span class="RefLink">3.4-3</span></a>), <code class="func">SInducedModule</code> (<a href="chap3_mj.html#X780709B3865BC344"><span class="RefLink">3.4-2</span></a>) and <code class="func">SRestrictedModule</code> (<a href="chap3_mj.html#X8041ABFA86D7A3EF"><span class="RefLink">3.4-4</span></a>) for inducing and restricting modules. All functions can be applied to Specht modules, PIMs, and simple modules. These functions all work by first rewriting all modules as a linear combination of Specht modules (or <span class="SimpleMath">\(q\)</span>-Weyl modules), and then inducing and restricting. Whenever possible the induced or restricted module will be written in the original basis.</p>

<p>All of these functions can also be applied to elements of the Fock space (see <code class="func">Specht</code> (<a href="chap3_mj.html#X7FE26921867C440A"><span class="RefLink">3.2-1</span></a>)); in which case they correspond to the action of the generators <span class="SimpleMath">\(E_i\)</span> and <span class="SimpleMath">\(F_i\)</span> of <span class="SimpleMath">\(U_q( sl^_{e})\)</span> on <span class="SimpleMath">\( F\)</span>. There is also a function <code class="func">InducedDecompositionMatrix</code> (<a href="chap3_mj.html#X7D257389845738DB"><span class="RefLink">3.5-1</span></a>) for inducing decomposition matrices.</p>

<p><a id="X81D7F7A4812BB04D" name="X81D7F7A4812BB04D"></a></p>

<h5>3.4-1 RInducedModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RInducedModule</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RInducedModule</code>( <var class="Arg">x</var>, <var class="Arg">r1</var>[, <var class="Arg">r2</var>, <var class="Arg">...</var>] )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the induced modules of the Specht modules, principal indecomposable modules, and simple modules (more accurately, their image in the Grothendieck ring).</p>

<p>There is an natural embedding of <span class="SimpleMath">\(H(S_n)\)</span> in <span class="SimpleMath">\(H(S_{n+1})\)</span> which in the usual way lets us define an <em>induced</em> <span class="SimpleMath">\(H(S_{n+1})\)</span>-module for every <span class="SimpleMath">\(H(S_n)\)</span>-module.</p>

<p>There is also a function <code class="func">SInducedModule</code> (<a href="chap3_mj.html#X780709B3865BC344"><span class="RefLink">3.4-2</span></a>) which provides a much faster way of <span class="SimpleMath">\(r\)</span>-inducing <span class="SimpleMath">\(s\)</span> times (and inducing <span class="SimpleMath">\(s\)</span> times).</p>

<p>Let <span class="SimpleMath">\(\mu\)</span> be a partition. Then the induced module <code class="code">RInducedModule(S(</code><span class="SimpleMath">\(\mu\)</span><code class="code">))</code> is easy to describe: it has the same composition factors as <span class="SimpleMath">\(\sum S(\nu)\)</span> where <span class="SimpleMath">\(\nu\)</span> runs over all partitions whose diagrams can be obtained by adding a single node to the diagram of <span class="SimpleMath">\(\mu\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(2,2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(RInducedModule(MakeSpecht(H,7,4,3,1)));</span>
S(8,4,3,1) + S(7,5,3,1) + S(7,4^2,1) + S(7,4,3,2) + S(7,4,3,1^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(RInducedModule(MakePIM(H,5,3,1)));</span>
P(6,3,1) + 2P(5,4,1) + P(5,3,2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(RInducedModule(MakeSimple(H,11,2,1)));</span>
# D(&lt;x&gt;), unable to rewrite &lt;x&gt; as a sum of simples
S(12,2,1) + S(11,3,1) + S(11,2^2) + S(11,2,1^2)
</pre></div>

<p>When inducing indecomposable modules and simple modules, <code class="func">RInducedModule</code> first rewrites these modules as a linear combination of Specht modules (using known decomposition matrices), and then induces this linear combination of Specht modules. If possible <strong class="pkg">Hecke</strong> then rewrites the induced module back in the original basis. Note that in the last example above, the decomposition matrix for <span class="SimpleMath">\(S_{15}\)</span> is not known by <strong class="pkg">Hecke</strong> this is why <code class="func">RInducedModule</code> was unable to rewrite this module in the <span class="SimpleMath">\(D\)</span>-basis.</p>

<p><em><span class="SimpleMath">\(r\)</span>-Induction</em></p>

<p>Two Specht modules <span class="SimpleMath">\(S(\mu)\)</span> and <span class="SimpleMath">\(S(\nu)\)</span> belong to the same block if and only if the corresponding partitions <span class="SimpleMath">\(\mu\)</span> and <span class="SimpleMath">\(\nu\)</span> have the same <span class="SimpleMath">\(e\)</span>-core <a href="chapBib_mj.html#biBJM2">[JM97]</a> (see <code class="func">ECore</code> (<a href="chap3_mj.html#X867496487DC35776"><span class="RefLink">3.8-1</span></a>)). Because the <span class="SimpleMath">\(e\)</span>-core of a partition is determined by its (multiset of) <span class="SimpleMath">\(e\)</span> -residues, if <span class="SimpleMath">\(S(\mu)\)</span> and <span class="SimpleMath">\(S(\nu)\)</span> appear in <code class="code">RInducedModule(S(</code><span class="SimpleMath">\(\tau\)</span><code class="code">))</code>, for some partition <span class="SimpleMath">\(\tau\)</span>, then <span class="SimpleMath">\(S(\mu)\)</span> and <span class="SimpleMath">\(S(nu)\)</span> belong to the same block if and only if <span class="SimpleMath">\(\mu\)</span> and <span class="SimpleMath">\(\nu\)</span> can be obtained by adding a node of the same <span class="SimpleMath">\(e\)</span>-residue to the diagram of <span class="SimpleMath">\(\tau\)</span>. The second form of <code class="func">RInducedModule</code> allows one to induce "within blocks" by only adding nodes of some fixed <span class="SimpleMath">\(e\)</span>-residue <span class="SimpleMath">\(r\)</span>; this is known as <em>r-induction</em>. Note that <span class="SimpleMath">\(0\leq r&lt;e\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(4);; Display(RInducedModule(MakeSpecht(H,5,2,1)));</span>
S(6,2,1) + S(5,3,1) + S(5,2^2) + S(5,2,1^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(RInducedModule(MakeSpecht(H,5,2,1),0));</span>
0S()
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(RInducedModule(MakeSpecht(H,5,2,1),1));</span>
S(6,2,1) + S(5,3,1) + S(5,2,1^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(RInducedModule(MakeSpecht(H,5,2,1),2));</span>
0S()
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(RInducedModule(MakeSpecht(H,5,2,1),3));</span>
S(5,2^2)
</pre></div>

<p>The function <code class="func">EResidueDiagram</code> (<a href="chap3_mj.html#X790D4ACF7930340F"><span class="RefLink">3.7-13</span></a>), prints the diagram of <span class="SimpleMath">\(\mu\)</span>, labeling each node with its <span class="SimpleMath">\(e\)</span>-residue. A quick check of this diagram confirms the answers above.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EResidueDiagram(H,5,2,1);</span>
   0   1   2   3   0
   3   0
   2
true
</pre></div>

<p><em>"Quantized" induction</em></p>

<p>When <code class="func">RInducedModule</code> is applied to the canonical basis elements <code class="code">MakeFockPIM(</code><span class="SimpleMath">\(\mu\)</span><code class="code">)</code> (or more generally elements of the Fock space; see <code class="func">Specht</code> (<a href="chap3_mj.html#X7FE26921867C440A"><span class="RefLink">3.2-1</span></a>)), a "quantum analogue" of induction is applied. More precisely, the function <code class="code">RInducedModule(</code><span class="SimpleMath">\(*,i\)</span><code class="code">)</code> corresponds to the action of the generator <span class="SimpleMath">\(F_i\)</span> of the quantum group <span class="SimpleMath">\(U_q( sl^_{e})\)</span> on <span class="SimpleMath">\( F\)</span> <a href="chapBib_mj.html#biBLLT">[LLT96]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(3);; x:=RInducedModule(MakeFockPIM(H,4,2),1,2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(x); Display(MakePIM(x));</span>
Sq(6,2) + vSq(4^2) + v^2Sq(4,2^2)
Pq(6,2)
</pre></div>

<p>See also <code class="func">SInducedModule</code> (<a href="chap3_mj.html#X780709B3865BC344"><span class="RefLink">3.4-2</span></a>), <code class="func">RRestrictedModule</code> (<a href="chap3_mj.html#X783BC74E81A7D0E6"><span class="RefLink">3.4-3</span></a>) and <code class="func">SRestrictedModule</code> (<a href="chap3_mj.html#X8041ABFA86D7A3EF"><span class="RefLink">3.4-4</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X780709B3865BC344" name="X780709B3865BC344"></a></p>

<h5>3.4-2 SInducedModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SInducedModule</code>( <var class="Arg">x</var>, <var class="Arg">s</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SInducedModule</code>( <var class="Arg">x</var>, <var class="Arg">s</var>, <var class="Arg">r</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>The function <code class="func">SInducedModule</code>, standing for "string induction", provides a more efficient way of <span class="SimpleMath">\(r\)</span>-inducing <span class="SimpleMath">\(s\)</span> times (and a way of inducing <span class="SimpleMath">\(s\)</span> times if the residue <span class="SimpleMath">\(r\)</span> is omitted); <span class="SimpleMath">\(r\)</span>-induction is explained in "<code class="func">RInducedModule</code> (<a href="chap3_mj.html#X81D7F7A4812BB04D"><span class="RefLink">3.4-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizeScreen([80,20]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(4);; Display(SInducedModule(MakePIM(H,5,2,1),3));</span>
P(8,2,1) + 3P(7,3,1) + 2P(7,2^2) + 6P(6,3,2) + 6P(6,3,1^2) + 3P(6,2,1^3) + 2P(\
5,3^2) + P(5,2^2,1^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(SInducedModule(MakePIM(H,5,2,1),3,1));</span>
P(6,3,1^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(RInducedModule(MakePIM(H,5,2,1),1,1,1));</span>
6P(6,3,1^2)
</pre></div>

<p>Note that the multiplicity of each summand of <code class="code">RInducedModule(</code><span class="SimpleMath">\(x,r,\ldots,r\)</span><code class="code">)</code> is divisible by <span class="SimpleMath">\(s!\)</span> and that <code class="func">SInducedModule</code> divides by this constant.</p>

<p>As with <code class="func">RInducedModule</code> (<a href="chap3_mj.html#X81D7F7A4812BB04D"><span class="RefLink">3.4-1</span></a>) this function can also be applied to elements of the Fock space (see <code class="func">Specht</code> (<a href="chap3_mj.html#X7FE26921867C440A"><span class="RefLink">3.2-1</span></a>)), in which case the quantum analogue of induction is used.</p>

<p>See also <code class="func">RInducedModule</code> (<a href="chap3_mj.html#X81D7F7A4812BB04D"><span class="RefLink">3.4-1</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X783BC74E81A7D0E6" name="X783BC74E81A7D0E6"></a></p>

<h5>3.4-3 RRestrictedModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RRestrictedModule</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RRestrictedModule</code>( <var class="Arg">x</var>, <var class="Arg">r1</var>[, <var class="Arg">r2</var>, <var class="Arg">...</var>] )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the corresponding module for <span class="SimpleMath">\(H(S_{n-1})\)</span> when given a module <span class="SimpleMath">\(x\)</span> for <span class="SimpleMath">\(H(S_n)\)</span></p>

<p>The restriction of the Specht module <span class="SimpleMath">\(S(\mu)\)</span> is the linear combination of Specht modules <span class="SimpleMath">\(\sum S(\nu)\)</span> where <span class="SimpleMath">\(\nu\)</span> runs over the partitions whose diagrams are obtained by deleting a node from the diagram of <span class="SimpleMath">\(\mu\)</span>. If only nodes of residue <span class="SimpleMath">\(r\)</span> are deleted then this corresponds to first restricting <span class="SimpleMath">\(S(\mu)\)</span> and then taking one of the block components of the restriction; this process is known as <em><span class="SimpleMath">\(r\)</span>-restriction</em> (cf. <span class="SimpleMath">\(r\)</span>-induction in <code class="func">RInducedModule</code> (<a href="chap3_mj.html#X81D7F7A4812BB04D"><span class="RefLink">3.4-1</span></a>)).</p>

<p>There is also a function <code class="func">SRestrictedModule</code> (<a href="chap3_mj.html#X8041ABFA86D7A3EF"><span class="RefLink">3.4-4</span></a>) which provides a faster way of <span class="SimpleMath">\(r\)</span>-restricting <span class="SimpleMath">\(s\)</span> times (and restricting <span class="SimpleMath">\(s\)</span> times).</p>

<p>When more than one residue if given to <code class="func">RRestrictedModule</code> it returns <code class="code">RRestrictedModule(</code><span class="SimpleMath">\(x,r_1,r_2,\ldots,r_k\)</span><code class="code">)</code>= <code class="code">RRestrictedModule( RRestrictedModule(</code><span class="SimpleMath">\(x,r_1\)</span><code class="code">)</code><span class="SimpleMath">\(,r_2,\ldots,r_k\)</span><code class="code">)</code> (cf. <code class="func">RInducedModule</code> (<a href="chap3_mj.html#X81D7F7A4812BB04D"><span class="RefLink">3.4-1</span></a>)).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(6);; Display(RRestrictedModule(MakePIM(H,5,3,2,1),4));</span>
2P(4,3,2,1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(RRestrictedModule(MakeSimple(H,5,3,2),1));</span>
D(5,2^2)
</pre></div>

<p><em>"Quantized" restriction</em></p>

<p>As with <code class="func">RInducedModule</code> (<a href="chap3_mj.html#X81D7F7A4812BB04D"><span class="RefLink">3.4-1</span></a>), when <code class="func">RRestrictedModule</code> is applied to the canonical basis elements <code class="code">MakeFockPIM(</code><span class="SimpleMath">\(\mu\)</span><code class="code">)</code> a quantum analogue of restriction is applied; this time, <code class="code">RRestrictedModule(</code><span class="SimpleMath">\(*,i\)</span><code class="code">)</code> corresponds to the action of the generator <span class="SimpleMath">\(E_i\)</span> of <span class="SimpleMath">\(U_q( sl^_{e})\)</span> on <span class="SimpleMath">\( F\)</span><a href="chapBib_mj.html#biBLLT">[LLT96]</a>.</p>

<p>See also <code class="func">RInducedModule</code> (<a href="chap3_mj.html#X81D7F7A4812BB04D"><span class="RefLink">3.4-1</span></a>), <code class="func">SInducedModule</code> (<a href="chap3_mj.html#X780709B3865BC344"><span class="RefLink">3.4-2</span></a>) and <code class="func">SRestrictedModule</code> (<a href="chap3_mj.html#X8041ABFA86D7A3EF"><span class="RefLink">3.4-4</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X8041ABFA86D7A3EF" name="X8041ABFA86D7A3EF"></a></p>

<h5>3.4-4 SRestrictedModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SRestrictedModule</code>( <var class="Arg">x</var>, <var class="Arg">s</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SRestrictedModule</code>( <var class="Arg">x</var>, <var class="Arg">s</var>, <var class="Arg">r</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>As with <code class="func">SInducedModule</code> (<a href="chap3_mj.html#X780709B3865BC344"><span class="RefLink">3.4-2</span></a>) this function provides a more efficient way of <span class="SimpleMath">\(r\)</span>-restricting <span class="SimpleMath">\(s\)</span> times, or restricting <span class="SimpleMath">\(s\)</span> times if the residue <span class="SimpleMath">\(r\)</span> is omitted (cf. <code class="func">SInducedModule</code> (<a href="chap3_mj.html#X780709B3865BC344"><span class="RefLink">3.4-2</span></a>)).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(6);; Display(SRestrictedModule(MakeSpecht(H,4,3,2),3));</span>
3S(4,2) + 2S(4,1^2) + 3S(3^2) + 6S(3,2,1) + 2S(2^3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(SRestrictedModule(MakePIM(H,5,4,1),2,4));</span>
P(4^2)
</pre></div>

<p>See also <code class="func">RInducedModule</code> (<a href="chap3_mj.html#X81D7F7A4812BB04D"><span class="RefLink">3.4-1</span></a>), <code class="func">SInducedModule</code> (<a href="chap3_mj.html#X780709B3865BC344"><span class="RefLink">3.4-2</span></a>) and <code class="func">RRestrictedModule</code> (<a href="chap3_mj.html#X783BC74E81A7D0E6"><span class="RefLink">3.4-3</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X79F430837BA7BAD2" name="X79F430837BA7BAD2"></a></p>

<h4>3.5 <span class="Heading">Operations on decomposition matrices</span></h4>

<p><strong class="pkg">Hecke</strong> is a package for computing decomposition matrices; this section describes the functions available for accessing these matrices directly. In addition to decomposition matrices, <strong class="pkg">Hecke</strong> also calculates the "crystallized decomposition matrices" of <a href="chapBib_mj.html#biBLLT">[LLT96]</a> and the "adjustment matrices" introduced by James <a href="chapBib_mj.html#biBJ">[Jam90]</a> (and Geck <a href="chapBib_mj.html#biBG">[Gec92]</a>).</p>

<p>Throughout <strong class="pkg">Hecke</strong> we place an emphasis on calculating the projective indecomposable modulesand hence upon the columns of decomposition matrices. This approach seems more efficient than the traditional approach of calculating decomposition matrices by rows; ideally both approaches should be combined (as is done by <code class="func">IsNewIndecomposable</code> (<a href="chap3_mj.html#X803A99987E501AC9"><span class="RefLink">3.5-2</span></a>)).</p>

<p>In principle, all decomposition matrices for all Hecke algebras defined over a field of characteristic zero are available from within <strong class="pkg">Hecke</strong>. In addition, the decomposition matrices for all <span class="SimpleMath">\(q\)</span>-Schur algebras with <span class="SimpleMath">\(n\leq10\)</span> and all values of <span class="SimpleMath">\(e\)</span> and the <span class="SimpleMath">\(p\)</span>-modular decomposition matrices of the symmetric groups <span class="SimpleMath">\(S_n\)</span> for <span class="SimpleMath">\(n&lt;15\)</span> are in the <strong class="pkg">Hecke</strong> library files.</p>

<p>If you are using <strong class="pkg">Hecke</strong> regularly to do calculations involving certain values of <span class="SimpleMath">\(e\)</span> it would be advantageous to have <strong class="pkg">Hecke</strong> calculate and save the first 20 odd decomposition matrices that you are interested in. So, for <span class="SimpleMath">\(e=4\)</span> use the commands:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(4);; for n in [8..20] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     SaveDecompositionMatrix(DecompositionMatrix(H,n));</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
</pre></div>

<p>Alternatively, you could save the crystallized decomposition matrices. Note that for <span class="SimpleMath">\(n&lt;2e\)</span> the decomposition matrices are known (by <strong class="pkg">Hecke</strong>) and easy to compute.</p>

<p><a id="X7D257389845738DB" name="X7D257389845738DB"></a></p>

<h5>3.5-1 InducedDecompositionMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InducedDecompositionMatrix</code>( <var class="Arg">d</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>If <span class="SimpleMath">\(d\)</span> is the decomposition matrix of <span class="SimpleMath">\(H(S_n)\)</span>, then <code class="code">InducedDecompositionMatrix(</code><span class="SimpleMath">\(d\)</span><code class="code">)</code> attempts to calculate the decomposition matrix of <span class="SimpleMath">\(H(S_{n+1})\)</span>. It does this by extracting each projective indecomposable from <span class="SimpleMath">\(d\)</span> and inducing these modules to obtain projective modules for <span class="SimpleMath">\(H(S_{n+1})\)</span>. <code class="func">InducedDecompositionMatrix</code> then tries to decompose these projectives using the function <code class="func">IsNewIndecomposable</code> (<a href="chap3_mj.html#X803A99987E501AC9"><span class="RefLink">3.5-2</span></a>). In general there will be columns of the decomposition matrix which <code class="func">InducedDecompositionMatrix</code> is unable to decompose and these will have to be calculated "by hand". <code class="func">InducedDecompositionMatrix</code> prints a list of those columns of the decomposition matrix which it is unable to calculate (this list is also printed by the function <code class="func">MissingIndecomposables</code> (<a href="chap3_mj.html#X8434DC7C8364CB54"><span class="RefLink">3.5-11</span></a>)).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d:=DecompositionMatrix(Specht(3,3),14);</span>
&lt;135x57 decomposition matrix&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InducedDecompositionMatrix(d);</span>
# Inducing....
The following projectives are missing from &lt;d&gt;:
    [ 15 ]  [ 8, 7 ]
&lt;176x70 decomposition matrix&gt;
</pre></div>

<p>Note that the missing indecomposables come in "pairs" which map to each other under the Mullineux map (see <code class="func">MullineuxMap</code> (<a href="chap3_mj.html#X7A6262B684185E3D"><span class="RefLink">3.7-3</span></a>)).</p>

<p>Almost all of the decomposition matrices included in <strong class="pkg">Hecke</strong> were calculated directly by <code class="func">InducedDecompositionMatrix</code>. When <span class="SimpleMath">\(n\)</span> is "small" <code class="func">InducedDecompositionMatrix</code> is usually able to return the full decomposition matrix for <span class="SimpleMath">\(H(S_n)\)</span>. Finally, although the <code class="func">InducedDecompositionMatrix</code> can also be applied to the decomposition matrices of the <span class="SimpleMath">\(q\)</span>-Schur algebras (see <code class="func">Schur</code> (<a href="chap3_mj.html#X7B57DF517F73F00D"><span class="RefLink">3.2-7</span></a>)), <code class="func">InducedDecompositionMatrix</code> is much less successful in inducing these decomposition matrices because it contains no special routines for dealing with the indecomposable modules of the <span class="SimpleMath">\(q\)</span>-Schur algebra which are indexed by <span class="SimpleMath">\(e\)</span>-singular partitions. Note also that we use a non-standard labeling of the decomposition matrices of <span class="SimpleMath">\(q\)</span>-Schur algebras; see <code class="func">Schur</code> (<a href="chap3_mj.html#X7B57DF517F73F00D"><span class="RefLink">3.2-7</span></a>).</p>

<p><a id="X803A99987E501AC9" name="X803A99987E501AC9"></a></p>

<h5>3.5-2 IsNewIndecomposable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsNewIndecomposable</code>( <var class="Arg">d</var>, <var class="Arg">x</var>[, <var class="Arg">mu</var>] )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if it is able to show that <span class="SimpleMath">\(x\)</span> is indecomposable (and this indecomposable is not already listed in <span class="SimpleMath">\(d\)</span>), and <code class="keyw">false</code> otherwise.</p>

<p><code class="func">IsNewIndecomposable</code> is the function which does all of the hard work when the function <code class="func">InducedDecompositionMatrix</code> (<a href="chap3_mj.html#X7D257389845738DB"><span class="RefLink">3.5-1</span></a>) is applied to decomposition matrices. <code class="func">IsNewIndecomposable</code> will also print a brief description of its findings, giving an upper and lower bound on the <em>first</em> decomposition number <span class="SimpleMath">\(\mu\)</span> for which it is unable to determine the multiplicity of <span class="SimpleMath">\(S(\mu)\)</span> in <span class="SimpleMath">\(x\)</span>.</p>

<p><code class="func">IsNewIndecomposable</code> works by running through all of the partitions <span class="SimpleMath">\(\nu\)</span> such that <span class="SimpleMath">\(P(\nu)\)</span> could be a summand of <span class="SimpleMath">\(x\)</span> and it uses various results, such as the <span class="SimpleMath">\(q\)</span>-Schaper theorem of <a href="chapBib_mj.html#biBJM2">[JM97]</a> (see <code class="func">Schaper</code> (<a href="chap3_mj.html#X820A908F8337F59C"><span class="RefLink">3.7-1</span></a>)), the Mullineux map (see <code class="func">MullineuxMap</code> (<a href="chap3_mj.html#X7A6262B684185E3D"><span class="RefLink">3.7-3</span></a>)) and inducing simple modules, to determine if <span class="SimpleMath">\(P(\nu)\)</span> does indeed split off. In addition, if <span class="SimpleMath">\(d\)</span> is the decomposition matrix for <span class="SimpleMath">\(H(S_n)\)</span> then <code class="func">IsNewIndecomposable</code> will probably use some of the decomposition matrices of <span class="SimpleMath">\(H(S_m)\)</span> for <span class="SimpleMath">\(m\leq n\)</span>, if they are known. Consequently it is a good idea to save decomposition matrices as they are calculated (see <code class="func">SaveDecompositionMatrix</code> (<a href="chap3_mj.html#X78B0FF2079269138"><span class="RefLink">3.5-5</span></a>)).</p>

<p>For example, in calculating the <span class="SimpleMath">\(2\)</span>-modular decomposition matrices of <span class="SimpleMath">\(S_{r}\)</span> the first projective which <code class="func">InducedDecompositionMatrix</code> (<a href="chap3_mj.html#X7D257389845738DB"><span class="RefLink">3.5-1</span></a>) is unable to calculate is <span class="SimpleMath">\(P(10)\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(2,2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d:=InducedDecompositionMatrix(DecompositionMatrix(H,9));;</span>
# Inducing.
# The following projectives are missing from &lt;d&gt;:
#  [ 10 ]
</pre></div>

<p>(In fact, given the above commands, <strong class="pkg">Hecke</strong> will return the full decomposition matrix for <span class="SimpleMath">\(S_{10}\)</span> because this matrix is in the library; these were the commands that were used to calculate the decomposition matrix in the library.)</p>

<p>By inducing <span class="SimpleMath">\(P(9)\)</span> we can find a projective <span class="SimpleMath">\(H\)</span>-module which contains <span class="SimpleMath">\(P(10)\)</span>. We can then use <code class="func">IsNewIndecomposable</code> to try and decompose this induced module into a sum of PIMs.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizeScreen([80,20]);; x:=RInducedModule(MakePIM(H,9),1);; Display(x);</span>
# P(&lt;x&gt;), unable to rewrite &lt;x&gt; as a sum of projectives
S(10) + S(9,1) + S(8,2) + 2S(8,1^2) + S(7,3) + 2S(7,1^3) + 3S(6,3,1) + 3S(6,2^\
2) + 4S(6,2,1^2) + 2S(6,1^4) + 4S(5,3,2) + 5S(5,3,1^2) + 5S(5,2^2,1) + 2S(5,1^\
5) + 2S(4^2,2) + 2S(4^2,1^2) + 2S(4,3^2) + 5S(4,3,1^3) + 2S(4,2^3) + 5S(4,2^2,\
1^2) + 4S(4,2,1^4) + 2S(4,1^6) + 2S(3^3,1) + 2S(3^2,2^2) + 4S(3^2,2,1^2) + 3S(\
3^2,1^4) + 3S(3,2^2,1^3) + 2S(3,1^7) + S(2^3,1^4) + S(2^2,1^6) + S(2,1^8) + S(\
1^10)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsNewIndecomposable(d,x);</span>
# The multiplicity of S(6,3,1) in P(10) is at least 1 and at most 2.
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(x);</span>
S(10) + S(9,1) + S(8,2) + 2S(8,1^2) + S(7,3) + 2S(7,1^3) + 2S(6,3,1) + 2S(6,2^\
2) + 3S(6,2,1^2) + 2S(6,1^4) + 3S(5,3,2) + 4S(5,3,1^2) + 4S(5,2^2,1) + 2S(5,1^\
5) + 2S(4^2,2) + 2S(4^2,1^2) + 2S(4,3^2) + 4S(4,3,1^3) + 2S(4,2^3) + 4S(4,2^2,\
1^2) + 3S(4,2,1^4) + 2S(4,1^6) + 2S(3^3,1) + 2S(3^2,2^2) + 3S(3^2,2,1^2) + 2S(\
3^2,1^4) + 2S(3,2^2,1^3) + 2S(3,1^7) + S(2^3,1^4) + S(2^2,1^6) + S(2,1^8) + S(\
1^10)
</pre></div>

<p>Notice that some of the coefficients of the Specht modules in <span class="SimpleMath">\(x\)</span> have changed; this is because <code class="func">IsNewIndecomposable</code> was able to determine that the multiplicity of <span class="SimpleMath">\(S(6,3,1)\)</span> was at most <span class="SimpleMath">\(2\)</span> and so it subtracted one copy of <span class="SimpleMath">\(P(6,3,1)\)</span> from <span class="SimpleMath">\(x\)</span>.</p>

<p>In this case, the multiplicity of <span class="SimpleMath">\(S(6,3,1)\)</span> in <span class="SimpleMath">\(P(10)\)</span> is easy to resolve because general theory says that this multiplicity must be odd. Therefore, <span class="SimpleMath">\(x-P(6,3,1)\)</span> is projective. After subtracting <span class="SimpleMath">\(P(6,3,1)\)</span> from <span class="SimpleMath">\(x\)</span> we again use <code class="func">IsNewIndecomposable</code> to see if <span class="SimpleMath">\(x\)</span> is now indecomposable. We can tell <code class="func">IsNewIndecomposable</code> that all of the multiplicities up to and including <span class="SimpleMath">\(S(6,3,1)\)</span> have already been checked by giving it the addition argument <span class="SimpleMath">\(\mu=[6,3,1]\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:=x-MakePIM(d,6,3,1);; IsNewIndecomposable(d,x,6,3,1);</span>
true
</pre></div>

<p>Consequently, <span class="SimpleMath">\(x=P(10)\)</span> and we add it to the decomposition matrix <span class="SimpleMath">\(d\)</span> (and save it).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddIndecomposable(d,x); SaveDecompositionMatrix(d);</span>
</pre></div>

<p>A full description of what <code class="func">IsNewIndecomposable</code> does can be found by reading the comments in <code class="file">specht.gi</code>. Any suggestions or improvements on this function would be especially welcome.</p>

<p>See also <code class="func">DecompositionMatrix</code> (<a href="chap3_mj.html#X84F0F9E47D5EEBCF"><span class="RefLink">3.2-8</span></a>) and <code class="func">InducedDecompositionMatrix</code> (<a href="chap3_mj.html#X7D257389845738DB"><span class="RefLink">3.5-1</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X802E811683E611EE" name="X802E811683E611EE"></a></p>

<h5>3.5-3 InvertDecompositionMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InvertDecompositionMatrix</code>( <var class="Arg">d</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: inverse of the (<span class="SimpleMath">\(e\)</span>-regular part of) <span class="SimpleMath">\(d\)</span>, where <span class="SimpleMath">\(d\)</span> is a decomposition matrix, or crystallized decomposition matrix, of a Hecke algebra or <span class="SimpleMath">\(q\)</span>-Schur algebra.</p>

<p>If part of the decomposition matrix <span class="SimpleMath">\(d\)</span> is unknown then <code class="func">InvertDecompositionMatrix</code> will invert as much of <span class="SimpleMath">\(d\)</span> as possible.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(4);; d:=CrystalDecompositionMatrix(H,5);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(InvertDecompositionMatrix(d));</span>
5    |   1                     
4,1  |   .   1                 
3,2  |  -v   .   1             
3,1^2|   .   .   .   1         
2^2,1| v^2   .  -v   .   1     
2,1^3|   .   .   .   .   .   1
</pre></div>

<p>See also <code class="func">DecompositionMatrix</code> (<a href="chap3_mj.html#X84F0F9E47D5EEBCF"><span class="RefLink">3.2-8</span></a>) and <code class="func">CrystalDecompositionMatrix</code> (<a href="chap3_mj.html#X7F616CCE808FA11E"><span class="RefLink">3.2-9</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X87B18FD97B2D8E80" name="X87B18FD97B2D8E80"></a></p>

<h5>3.5-4 AdjustmentMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AdjustmentMatrix</code>( <var class="Arg">dp</var>, <var class="Arg">d</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the adjustment matrix <span class="SimpleMath">\(a\)</span></p>

<p>James <a href="chapBib_mj.html#biBJ">[Jam90]</a> noticed and Geck <a href="chapBib_mj.html#biBG">[Gec92]</a> proved, that the decomposition matrices <span class="SimpleMath">\(dp\)</span> for Hecke algebras defined over fields of positive characteristic admit a factorization <span class="SimpleMath">\(dp = d \cdot a\)</span> where <span class="SimpleMath">\(d\)</span> is a decomposition matrix for a suitable Hecke algebra defined over a field of characteristic zero and <span class="SimpleMath">\(a\)</span> is the so-called <em>adjustment matrix</em>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(2);; Hp:=Specht(2,2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d:=DecompositionMatrix(H,13);; dp:=DecompositionMatrix(Hp,13);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a:=AdjustmentMatrix(dp,d);</span>
&lt;18x18 decomposition matrix&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(a);</span>
13     | 1                                   
12,1   | . 1                                 
11,2   | 1 . 1                               
10,3   | . . . 1                             
10,2,1 | . . . . 1                           
9,4    | 1 . 1 . . 1                         
9,3,1  | 2 . . . . . 1                       
8,5    | . 1 . . . . . 1                     
8,4,1  | 1 . . . . . . . 1                   
8,3,2  | . 2 . . . . . 1 . 1                 
7,6    | 1 . . . . 1 . . . . 1               
7,5,1  | . . . . . . 1 . . . . 1             
7,4,2  | 1 . 1 . . 1 . . . . 1 . 1           
7,3,2,1| . . . . . . . . . . . . . 1         
6,5,2  | . 1 . . . . . 1 . 1 . . . . 1       
6,4,3  | 2 . . . 1 . . . . . . . . . . 1     
6,4,2,1| . 2 . 1 . . . . . . . . . . . . 1   
5,4,3,1| 4 . 2 . . . . . . . . . . . . . . 1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MatrixDecompositionMatrix(dp)=</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          MatrixDecompositionMatrix(d)*MatrixDecompositionMatrix(a);</span>
true
</pre></div>

<p>In the last line we have checked our calculation.</p>

<p>See also <code class="func">DecompositionMatrix</code> (<a href="chap3_mj.html#X84F0F9E47D5EEBCF"><span class="RefLink">3.2-8</span></a>) and <code class="func">CrystalDecompositionMatrix</code> (<a href="chap3_mj.html#X7F616CCE808FA11E"><span class="RefLink">3.2-9</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X78B0FF2079269138" name="X78B0FF2079269138"></a></p>

<h5>3.5-5 SaveDecompositionMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SaveDecompositionMatrix</code>( <var class="Arg">d</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SaveDecompositionMatrix</code>( <var class="Arg">d</var>, <var class="Arg">filename</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>The function <code class="func">SaveDecompositionMatrix</code> saves the decomposition matrix <span class="SimpleMath">\(d\)</span>. After a decomposition matrix has been saved, the functions <code class="func">MakeSpecht</code> (<a href="chap3_mj.html#X7C92700882971537"><span class="RefLink">3.2-3</span></a>), <code class="func">MakePIM</code> (<a href="chap3_mj.html#X7C92700882971537"><span class="RefLink">3.2-3</span></a>) and <code class="func">MakeSimple</code> (<a href="chap3_mj.html#X7C92700882971537"><span class="RefLink">3.2-3</span></a>) will automatically access it as needed. So, for example, before saving <span class="SimpleMath">\(d\)</span> in order to retrieve the indecomposable <span class="SimpleMath">\(P(\mu)\)</span> from <span class="SimpleMath">\(d\)</span> it is necessary to type <code class="code">MakePIM(</code><span class="SimpleMath">\(d, \mu\)</span><code class="code">)</code>; once <span class="SimpleMath">\(d\)</span> has been saved, the command <code class="code">MakePIM(</code><span class="SimpleMath">\(\mu\)</span><code class="code">)</code> suffices.</p>

<p>Since <code class="func">InducedDecompositionMatrix</code> (<a href="chap3_mj.html#X7D257389845738DB"><span class="RefLink">3.5-1</span></a>) consults the decomposition matrices for smaller <span class="SimpleMath">\(n\)</span>, if they are available, it is advantageous to save decomposition matrices as they are calculated. For example, over a field of characteristic <span class="SimpleMath">\(5\)</span>, the decomposition matrices for the symmetric groups <span class="SimpleMath">\(S_n\)</span> with <span class="SimpleMath">\(n\leq 20\)</span> can be calculated as follows:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(5,5);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d:=DecompositionMatrix(H,9);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for r in [10..20] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     d:=InducedDecompositionMatrix(d);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     SaveDecompositionMatrix(d);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
# Inducing...
# Inducing....
# Inducing....
# Inducing.....
# Inducing......
# Inducing.......
# Inducing........
# Inducing..........
# Inducing............
# Inducing..............
# Inducing.................
</pre></div>

<p>If your Hecke algebra object <span class="SimpleMath">\(H\)</span> is defined using a non-standard valuation map (see <code class="func">Specht</code> (<a href="chap3_mj.html#X7FE26921867C440A"><span class="RefLink">3.2-1</span></a>)) then it is also necessary to set the string <span class="SimpleMath">\(HeckeRing\)</span>, or to supply the function with a <span class="SimpleMath">\(filename\)</span> before it will save your matrix. <code class="func">SaveDecompositionMatrix</code> will also save adjustment matrices and the various other matrices that appear in <strong class="pkg">Hecke</strong> (they can be read back in using <code class="func">DecompositionMatrix</code> (<a href="chap3_mj.html#X84F0F9E47D5EEBCF"><span class="RefLink">3.2-8</span></a>)). Each matrix has a default filename which you can over ride by supplying a <span class="SimpleMath">\(filename\)</span>. Using non-standard file names will stop <strong class="pkg">Hecke</strong> from automatically accessing these matrices in future. See also <code class="func">DecompositionMatrix</code> (<a href="chap3_mj.html#X84F0F9E47D5EEBCF"><span class="RefLink">3.2-8</span></a>) and <code class="func">CrystalDecompositionMatrix</code> (<a href="chap3_mj.html#X7F616CCE808FA11E"><span class="RefLink">3.2-9</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X84DD2D517FC1F905" name="X84DD2D517FC1F905"></a></p>

<h5>3.5-6 CalculateDecompositionMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CalculateDecompositionMatrix</code>( <var class="Arg">H</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p><code class="func">CalculateDecompositionMatrix</code> is similar to the function <code class="func">DecompositionMatrix</code> (<a href="chap3_mj.html#X84F0F9E47D5EEBCF"><span class="RefLink">3.2-8</span></a>) in that both functions try to return the decomposition matrix <span class="SimpleMath">\(d\)</span> of <span class="SimpleMath">\(H(S_n)\)</span>; the difference is that this function tries to calculate this matrix whereas the latter reads the matrix from the library files (in characteristic zero both functions apply the algorithm of <a href="chapBib_mj.html#biBLLT">[LLT96]</a> to compute <span class="SimpleMath">\(d\)</span>). In effect this function is only needed when working with Hecke algebras defined over fields of positive characteristic (or when you wish to avoid the libraries). For example, if you want to do calculations with the decomposition matrix of the symmetric group <span class="SimpleMath">\(S_{15}\)</span> over a field of characteristic two, <code class="func">DecompositionMatrix</code> (<a href="chap3_mj.html#X84F0F9E47D5EEBCF"><span class="RefLink">3.2-8</span></a>) returns fail whereas <code class="func">CalculateDecompositionMatrix</code> returns a part of the decomposition matrix.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(2,2);; d:=DecompositionMatrix(H,15);</span>
# This decomposition matrix is not known; use CalculateDecompositionMatrix()
# or InducedDecompositionMatrix() to calculate with this matrix.
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d:=CalculateDecompositionMatrix(H,15);;</span>
# Projective indecomposable P(6,4,3,2) not known.
# Projective indecomposable P(6,5,3,1) not known.
# Projective indecomposable P(6,5,4) not known.
# Projective indecomposable P(7,4,3,1) not known.
# Projective indecomposable P(7,5,2,1) not known.
# Projective indecomposable P(7,5,3) not known.
# Projective indecomposable P(7,6,2) not known.
# Projective indecomposable P(8,4,2,1) not known.
# Projective indecomposable P(8,4,3) not known.
# Projective indecomposable P(8,5,2) not known.
# Projective indecomposable P(8,6,1) not known.
# Projective indecomposable P(8,7) not known.
# Projective indecomposable P(9,3,2,1) not known.
# Projective indecomposable P(9,4,2) not known.
# Projective indecomposable P(9,5,1) not known.
# Projective indecomposable P(9,6) not known.
# Projective indecomposable P(10,3,2) not known.
# Projective indecomposable P(10,4,1) not known.
# Projective indecomposable P(10,5) not known.
# Projective indecomposable P(11,3,1) not known.
# Projective indecomposable P(11,4) not known.
# Projective indecomposable P(12,2,1) not known.
# Projective indecomposable P(12,3) not known.
# Projective indecomposable P(13,2) not known.
# Projective indecomposable P(14,1) not known.
# Projective indecomposable P(15) not known.
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizeScreen([80,20]);; MissingIndecomposables(d);</span>
The following projectives are missing from &lt;d&gt;:
    [ 15 ]  [ 14, 1 ]  [ 13, 2 ]  [ 12, 3 ]  [ 12, 2, 1 ]  [ 11, 4 ]  
[ 11, 3, 1 ]  [ 10, 5 ]  [ 10, 4, 1 ]  [ 10, 3, 2 ]  [ 9, 6 ]  [ 9, 5, 1 ]  
[ 9, 4, 2 ]  [ 9, 3, 2, 1 ]  [ 8, 7 ]  [ 8, 6, 1 ]  [ 8, 5, 2 ]  [ 8, 4, 3 ]  
[ 8, 4, 2, 1 ]  [ 7, 6, 2 ]  [ 7, 5, 3 ]  [ 7, 5, 2, 1 ]  [ 7, 4, 3, 1 ]  
[ 6, 5, 4 ]  [ 6, 5, 3, 1 ]  [ 6, 4, 3, 2 ]
</pre></div>

<p>Actually, you are much better starting with the decomposition matrix of <span class="SimpleMath">\(S_{14}\)</span> and then applying <code class="func">InducedDecompositionMatrix</code> (<a href="chap3_mj.html#X7D257389845738DB"><span class="RefLink">3.5-1</span></a>) to this matrix. See also <code class="func">DecompositionMatrix</code> (<a href="chap3_mj.html#X84F0F9E47D5EEBCF"><span class="RefLink">3.2-8</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7FDC65328102C1B9" name="X7FDC65328102C1B9"></a></p>

<h5>3.5-7 MatrixDecompositionMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MatrixDecompositionMatrix</code>( <var class="Arg">d</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the <strong class="pkg">GAP</strong> matrix corresponding to the <strong class="pkg">Hecke</strong> decomposition matrix <span class="SimpleMath">\(d\)</span></p>

<p>The rows and columns of <span class="SimpleMath">\(d\)</span> are sorted by the ordering stored in the internal algebra object of the matrix <span class="SimpleMath">\(d\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizeScreen([80,20]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MatrixDecompositionMatrix(DecompositionMatrix(Specht(3),5));</span>
[ [ 1, 0, 0, 0, 0 ], [ 0, 1, 0, 0, 0 ], [ 0, 1, 1, 0, 0 ], [ 0, 0, 0, 1, 0 ], 
  [ 1, 0, 0, 0, 1 ], [ 0, 0, 0, 0, 1 ], [ 0, 0, 1, 0, 0 ] ]
</pre></div>

<p>See also <code class="func">DecompositionMatrix</code> (<a href="chap3_mj.html#X84F0F9E47D5EEBCF"><span class="RefLink">3.2-8</span></a>) and <code class="func">DecompositionMatrixMatrix</code> (<a href="chap3_mj.html#X86EBEBF680EBC98E"><span class="RefLink">3.5-8</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X86EBEBF680EBC98E" name="X86EBEBF680EBC98E"></a></p>

<h5>3.5-8 DecompositionMatrixMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DecompositionMatrixMatrix</code>( <var class="Arg">H</var>, <var class="Arg">m</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the <strong class="pkg">Hecke</strong> decomposition matrix corresponding to the <strong class="pkg">GAP</strong> matrix <span class="SimpleMath">\(m\)</span></p>

<p>If <span class="SimpleMath">\(p\)</span> is the number of partitions of <span class="SimpleMath">\(n\)</span> and <span class="SimpleMath">\(r\)</span> the number of <span class="SimpleMath">\(e\)</span>-regular partitions of <span class="SimpleMath">\(n\)</span>, then <span class="SimpleMath">\(m\)</span> must be either <span class="SimpleMath">\(r\times r\)</span>, <span class="SimpleMath">\(p\times r\)</span> or <span class="SimpleMath">\(p\times p\)</span>. The rows and columns of <span class="SimpleMath">\(m\)</span> are assumed to be indexed by partitions sorted by the ordering stored in the algebra object <span class="SimpleMath">\(H\)</span> (see <code class="func">Specht</code> (<a href="chap3_mj.html#X7FE26921867C440A"><span class="RefLink">3.2-1</span></a>)).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m:=[ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 1, 0, 1, 0 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [ 0, 0, 0, 1 ], [ 0, 0, 1, 0 ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(DecompositionMatrixMatrix(H,m,4));</span>
4    | 1       
3,1  | . 1     
2^2  | 1 . 1   
2,1^2| . . . 1
1^4  | . . 1 . 
</pre></div>

<p>See also <code class="func">DecompositionMatrix</code> (<a href="chap3_mj.html#X84F0F9E47D5EEBCF"><span class="RefLink">3.2-8</span></a>) and <code class="func">MatrixDecompositionMatrix</code> (<a href="chap3_mj.html#X7FDC65328102C1B9"><span class="RefLink">3.5-7</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7B05627D83E6977E" name="X7B05627D83E6977E"></a></p>

<h5>3.5-9 AddIndecomposable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AddIndecomposable</code>( <var class="Arg">d</var>, <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p><code class="func">AddIndecomposable</code> inserts the indecomposable module <span class="SimpleMath">\(x\)</span> into the decomposition matrix <span class="SimpleMath">\(d\)</span>. If <span class="SimpleMath">\(d\)</span> already contains the indecomposable <span class="SimpleMath">\(d\)</span> then a warning is printed. The function <code class="func">AddIndecomposable</code> also calculates <code class="code">MullineuxMap(</code> <span class="SimpleMath">\(x\)</span><code class="code">)</code> (see <code class="func">MullineuxMap</code> (<a href="chap3_mj.html#X7A6262B684185E3D"><span class="RefLink">3.7-3</span></a>)) and adds this indecomposable to <span class="SimpleMath">\(d\)</span> (or checks to see that it agrees with the corresponding entry of <span class="SimpleMath">\(d\)</span> if this indecomposable is already in <span class="SimpleMath">\(d\)</span>).</p>

<p>See <code class="func">IsNewIndecomposable</code> (<a href="chap3_mj.html#X803A99987E501AC9"><span class="RefLink">3.5-2</span></a>) for an example. See also <code class="func">DecompositionMatrix</code> (<a href="chap3_mj.html#X84F0F9E47D5EEBCF"><span class="RefLink">3.2-8</span></a>) and <code class="func">CrystalDecompositionMatrix</code> (<a href="chap3_mj.html#X7F616CCE808FA11E"><span class="RefLink">3.2-9</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X79FA055E8250E6A2" name="X79FA055E8250E6A2"></a></p>

<h5>3.5-10 RemoveIndecomposable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RemoveIndecomposable</code>( <var class="Arg">d</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>The function <code class="func">RemoveIndecomposable</code> removes the column from <span class="SimpleMath">\(d\)</span> which corresponds to <span class="SimpleMath">\(P(\mu)\)</span>. This is sometimes useful when trying to calculate a new decomposition matrix using <strong class="pkg">Hecke</strong> and want to test a possible candidate for a yet to be identified PIM.</p>

<p>See also <code class="func">DecompositionMatrix</code> (<a href="chap3_mj.html#X84F0F9E47D5EEBCF"><span class="RefLink">3.2-8</span></a>) and <code class="func">CrystalDecompositionMatrix</code> (<a href="chap3_mj.html#X7F616CCE808FA11E"><span class="RefLink">3.2-9</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X8434DC7C8364CB54" name="X8434DC7C8364CB54"></a></p>

<h5>3.5-11 MissingIndecomposables</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MissingIndecomposables</code>( <var class="Arg">d</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>The function <code class="func">MissingIndecomposables</code> prints the list of partitions corresponding to the indecomposable modules which are not listed in <span class="SimpleMath">\(d\)</span>.</p>

<p>See also <code class="func">DecompositionMatrix</code> (<a href="chap3_mj.html#X84F0F9E47D5EEBCF"><span class="RefLink">3.2-8</span></a>) and <code class="func">CrystalDecompositionMatrix</code> (<a href="chap3_mj.html#X7F616CCE808FA11E"><span class="RefLink">3.2-9</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7A697AAA799BA7D4" name="X7A697AAA799BA7D4"></a></p>

<h4>3.6 <span class="Heading">Calculating dimensions</span></h4>

<p><strong class="pkg">Hecke</strong> has two functions for calculating the dimensions of modules of Hecke algebras; <code class="func">SimpleDimension</code> (<a href="chap3_mj.html#X828528747E4AC4C9"><span class="RefLink">3.6-1</span></a>) and <code class="func">SpechtDimension</code> (<a href="chap3_mj.html#X7B98631580E193BB"><span class="RefLink">3.6-2</span></a>). As yet, <strong class="pkg">Hecke</strong> does not know how to calculate the dimensions of modules for <span class="SimpleMath">\(q\)</span>-Schur algebras (these depend up on <span class="SimpleMath">\(q\)</span>).</p>

<p><a id="X828528747E4AC4C9" name="X828528747E4AC4C9"></a></p>

<h5>3.6-1 SimpleDimension</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimpleDimension</code>( <var class="Arg">d</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimpleDimension</code>( <var class="Arg">H</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimpleDimension</code>( <var class="Arg">H|d</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>In the first two forms, <code class="func">SimpleDimension</code> prints the dimensions of all of the simple modules specified by <span class="SimpleMath">\(d\)</span> or for the Hecke algebra <span class="SimpleMath">\(H(S_n)\)</span> respectively. If a partition <span class="SimpleMath">\(\mu\)</span> is supplied, as in the last form, then the dimension of the simple module <span class="SimpleMath">\(D(\mu)\)</span> is returned. At present the function is not implemented for the simple modules of the <span class="SimpleMath">\(q\)</span>-Schur algebras.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(6);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SimpleDimension(H,11,3);</span>
272
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d:=DecompositionMatrix(H,5);; SimpleDimension(d,3,2);</span>
5
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SimpleDimension(d);</span>
5     : 1
4,1   : 4
3,2   : 5
3,1^2 : 6
2^2,1 : 5
2,1^3 : 4
1^5   : 1
true
</pre></div>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7B98631580E193BB" name="X7B98631580E193BB"></a></p>

<h5>3.6-2 SpechtDimension</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpechtDimension</code>( <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the dimension of the Specht module <span class="SimpleMath">\(S(\mu)\)</span></p>

<p><span class="SimpleMath">\(\dim S(\mu)\)</span> is equal to the number of standard <span class="SimpleMath">\(\mu\)</span>-tableaux; the answer is given by the hook length formula (see <a href="chapBib_mj.html#biBJK">[JK81]</a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SpechtDimension(6,3,2,1);</span>
5632
</pre></div>

<p>See also <code class="func">SimpleDimension</code> (<a href="chap3_mj.html#X828528747E4AC4C9"><span class="RefLink">3.6-1</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X78F1DC277875BAFD" name="X78F1DC277875BAFD"></a></p>

<h4>3.7 <span class="Heading">Combinatorics on Young diagrams</span></h4>

<p>These functions range from the representation theoretic <span class="SimpleMath">\(q\)</span>-Schaper theorem and Kleshchev's algorithm for the Mullineux map through to simple combinatorial operations like adding and removing rim hooks from Young diagrams.</p>

<p><a id="X820A908F8337F59C" name="X820A908F8337F59C"></a></p>

<h5>3.7-1 Schaper</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Schaper</code>( <var class="Arg">H</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a linear combination of Specht modules which have the same composition factors as the sum of the modules in the "Jantzen filtration " of <span class="SimpleMath">\(S(\mu)\)</span>; see <a href="chapBib_mj.html#biBJM2">[JM97]</a>. In particular, if <span class="SimpleMath">\(\nu\)</span> strictly dominates <span class="SimpleMath">\(\mu\)</span> then <span class="SimpleMath">\(D(\nu)\)</span> is a composition factor of <span class="SimpleMath">\(S(\mu)\)</span> if and only if it is a composition factor of <code class="code">Schaper(</code><span class="SimpleMath">\(\mu\)</span><code class="code">)</code>.</p>

<p><code class="func">Schaper</code> uses the valuation map attached to <span class="SimpleMath">\(H\)</span> (see <code class="func">Specht</code> (<a href="chap3_mj.html#X7FE26921867C440A"><span class="RefLink">3.2-1</span></a>) and <a href="chapBib_mj.html#biBJM2">[JM97]</a>).</p>

<p>One way in which the <span class="SimpleMath">\(q\)</span>-Schaper theorem can be applied is as follows. Suppose that we have a projective module <span class="SimpleMath">\(x\)</span>, written as a linear combination of Specht modules and suppose that we are trying to decide whether the projective indecomposable <span class="SimpleMath">\(P(\mu)\)</span> is a direct summand of <span class="SimpleMath">\(x\)</span>. Then, providing that we know that <span class="SimpleMath">\(P(\nu)\)</span> is not a summand of <span class="SimpleMath">\(x\)</span> for all (<span class="SimpleMath">\(e\)</span>-regular) partitions <span class="SimpleMath">\(\nu\)</span> which strictly dominate <span class="SimpleMath">\(\mu\)</span> (see <code class="func">Dominates</code> (<a href="chap3_mj.html#X820388EF7C8333BA"><span class="RefLink">3.8-11</span></a>)), <span class="SimpleMath">\(P(\mu)\)</span> is a summand of <span class="SimpleMath">\(x\)</span> if and only if <code class="code">InnerProduct(Schaper( </code><span class="SimpleMath">\(H,\mu\)</span><code class="code">)</code>,<span class="SimpleMath">\(x\)</span><code class="code">)</code> is non-zero (note, in particular, that we don't need to know the indecomposable <span class="SimpleMath">\(P(\mu)\)</span> in order to perform this calculation).</p>

<p>The <span class="SimpleMath">\(q\)</span>-Schaper theorem can also be used to check for irreduciblity; in fact, this is the basis for the criterion employed by <code class="func">IsSimpleModule</code> (<a href="chap3_mj.html#X7FB82B3184287362"><span class="RefLink">3.7-2</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizeScreen([80,20]);; H:=Specht(2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(Schaper(H,9,5,3,2,1));</span>
S(17,2,1) - S(15,2,1^3) + S(13,2^3,1) - S(11,3^2,2,1) + S(10,4,3,2,1) - S(9,8,\
3) - S(9,8,1^3) + S(9,6,3,2) + S(9,6,3,1^2) + S(9,6,2^2,1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(Schaper(H,9,6,5,2));</span>
0S()
</pre></div>

<p>The last calculation shows that <span class="SimpleMath">\(S(9,6,5,2)\)</span> is irreducible when <span class="SimpleMath">\(R\)</span> is a field of characteristic zero and <span class="SimpleMath">\(e=2\)</span> (cf. <code class="code">IsSimpleModule(</code><span class="SimpleMath">\(H,9,6,5,2\)</span><code class="code">)</code>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7FB82B3184287362" name="X7FB82B3184287362"></a></p>

<h5>3.7-2 IsSimpleModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSimpleModule</code>( <var class="Arg">H</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if <span class="SimpleMath">\(S(\mu)\)</span> is simple and <code class="keyw">false</code> otherwise.</p>

<p><span class="SimpleMath">\(\mu\)</span> an <span class="SimpleMath">\(e\)</span>-regular partition.</p>

<p>This calculation uses the valuation function of <span class="SimpleMath">\(H\)</span>; see <code class="func">Specht</code> (<a href="chap3_mj.html#X7FE26921867C440A"><span class="RefLink">3.2-1</span></a>). Note that the criterion used by <code class="func">IsSimpleModule</code> is completely combinatorial; it is derived from the <span class="SimpleMath">\(q\)</span>-Schaper theorem <a href="chapBib_mj.html#biBJM2">[JM97]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSimpleModule(H,45,31,24);</span>
false
</pre></div>

<p>See also <code class="func">Schaper</code> (<a href="chap3_mj.html#X820A908F8337F59C"><span class="RefLink">3.7-1</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7A6262B684185E3D" name="X7A6262B684185E3D"></a></p>

<h5>3.7-3 MullineuxMap</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MullineuxMap</code>( <var class="Arg">e|H</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>The sign representation <span class="SimpleMath">\(D(1^n)\)</span> of the Hecke algebra is the (one dimensional) representation sending <span class="SimpleMath">\(T_w\)</span> to <span class="SimpleMath">\((-1)^{l(w)}\)</span>. The Hecke algebra <span class="SimpleMath">\(H\)</span> is not a Hopf algebra so there is no well defined action of <span class="SimpleMath">\(H\)</span> upon the tensor product of two <span class="SimpleMath">\(H\)</span>-modules; however, there is an outer automorphism <span class="SimpleMath">\(\#\)</span> of <span class="SimpleMath">\(H\)</span> which corresponds to tensoring with <span class="SimpleMath">\(D(1^n)\)</span>. This sends an irreducible module <span class="SimpleMath">\(D(\mu)\)</span> to an irreducible <span class="SimpleMath">\(D(\mu)^\#\cong D(\mu^\#)\)</span> for some <span class="SimpleMath">\(e\)</span>-regular partition <span class="SimpleMath">\(\mu^\#\)</span>. In the symmetric group case, Mullineux gave a conjectural algorithm for calculating <span class="SimpleMath">\(\mu^\#\)</span>; consequently the map sending <span class="SimpleMath">\(\mu\)</span> to <span class="SimpleMath">\(\mu^\#\)</span> is known as the <em>Mullineux map</em>.</p>

<p>Deep results of Kleshchev <a href="chapBib_mj.html#biBK">[Kle96]</a> for the symmetric group give another (proven) algorithm for calculating the partition <span class="SimpleMath">\(\mu^\#\)</span> (Ford and Kleshchev have deduced Mullineux's conjecture from this). Using the canonical basis, it was shown by <a href="chapBib_mj.html#biBLLT">[LLT96]</a> that the natural generalization of Kleshchev's algorithm to <span class="SimpleMath">\(H\)</span> gives the Mullineux map for Hecke algebras over fields of characteristic zero. The general case follows from this, so the Mullineux map is now known for all Hecke algebras.</p>

<p>Kleshchev's map is easy to describe; he proved that if <span class="SimpleMath">\(gns\)</span> is any good node sequence for <span class="SimpleMath">\(\mu\)</span>, then the sequence obtained from <span class="SimpleMath">\(gns\)</span> by replacing each residue <span class="SimpleMath">\(r\)</span> by <span class="SimpleMath">\(-r\bmod e\)</span> is a good node sequence for <span class="SimpleMath">\(\mu^\#\)</span> (see <code class="func">GoodNodeSequence</code> (<a href="chap3_mj.html#X85B290977A17D9EE"><span class="RefLink">3.7-8</span></a>)).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MullineuxMap(Specht(2),12,5,2);</span>
[ 12, 5, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MullineuxMap(Specht(4),12,5,2);</span>
[ 4, 4, 4, 2, 2, 1, 1, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MullineuxMap(Specht(6),12,5,2);</span>
[ 4, 3, 2, 2, 2, 2, 2, 1, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MullineuxMap(Specht(8),12,5,2);</span>
[ 3, 3, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MullineuxMap(Specht(10),12,5,2);</span>
[ 3, 3, 3, 3, 2, 1, 1, 1, 1, 1 ]
</pre></div>

<p>Returns: the image of <span class="SimpleMath">\(\mu\)</span> under the Mullineux map</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MullineuxMap</code>( <var class="Arg">d</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>The Mullineux map can also be calculated using a decomposition matrix. To see this recall that "tensoring" a Specht module <span class="SimpleMath">\(S(\mu)\)</span> with the sign representation yields a module isomorphic to the dual of <span class="SimpleMath">\(S(\lambda)\)</span>, where <span class="SimpleMath">\(\lambda\)</span> is the partition conjugate to <span class="SimpleMath">\(\mu\)</span>. It follows that <span class="SimpleMath">\(d_{\mu,\nu}=d_{\lambda,\nu^\#}\)</span> for all <span class="SimpleMath">\(e\)</span>-regular partitions <span class="SimpleMath">\(\nu\)</span>. Therefore, if <span class="SimpleMath">\(\mu\)</span> is the last partition in the lexicographic order such that <span class="SimpleMath">\(d_{\mu,\nu}\neq 0\)</span> then we must have <span class="SimpleMath">\(\nu^\#=\lambda\)</span>. The second form of <code class="func">MullineuxMap</code> uses <span class="SimpleMath">\(d\)</span> to calculate <span class="SimpleMath">\(\mu^\#\)</span> rather than the Kleshchev-<a href="chapBib_mj.html#biBLLT">[LLT96]</a> result.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MullineuxMap</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: returns <span class="SimpleMath">\(x^\#\)</span>, the image of <span class="SimpleMath">\(x\)</span> under <span class="SimpleMath">\(\#\)</span>.</p>

<p>Note that the above remarks show that <span class="SimpleMath">\(P(\mu)\)</span> is mapped to <span class="SimpleMath">\(P(\mu^\#)\)</span> via the Mullineux map; this observation is useful when calculating decomposition matrices (and is used by the function <code class="func">InducedDecompositionMatrix</code> (<a href="chap3_mj.html#X7D257389845738DB"><span class="RefLink">3.5-1</span></a>)).</p>

<p>See also <code class="func">GoodNodes</code> (<a href="chap3_mj.html#X7CE4D6487FD009B1"><span class="RefLink">3.7-6</span></a>) and <code class="func">GoodNodeSequence</code> (<a href="chap3_mj.html#X85B290977A17D9EE"><span class="RefLink">3.7-8</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7CC6C04482DD1E9D" name="X7CC6C04482DD1E9D"></a></p>

<h5>3.7-4 MullineuxSymbol</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MullineuxSymbol</code>( <var class="Arg">e|H</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the Mullineux symbol of the <span class="SimpleMath">\(e\)</span>-regular partition <span class="SimpleMath">\(\mu\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MullineuxSymbol(5,[8,6,5,5]);</span>
[ [ 10, 6, 5, 3 ], [ 4, 4, 3, 2 ] ]
</pre></div>

<p>See also <code class="func">PartitionMullineuxSymbol</code> (<a href="chap3_mj.html#X7826922879DD8D8A"><span class="RefLink">3.7-5</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7826922879DD8D8A" name="X7826922879DD8D8A"></a></p>

<h5>3.7-5 PartitionMullineuxSymbol</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PartitionMullineuxSymbol</code>( <var class="Arg">e|H</var>, <var class="Arg">ms</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the <span class="SimpleMath">\(e\)</span>-regular partition corresponding to the given Mullineux symbol <span class="SimpleMath">\(ms\)</span></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PartitionMullineuxSymbol(5, MullineuxSymbol(5,[8,6,5,5]) );</span>
[ 8, 6, 5, 5 ]
</pre></div>

<p>See also <code class="func">MullineuxSymbol</code> (<a href="chap3_mj.html#X7CC6C04482DD1E9D"><span class="RefLink">3.7-4</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7CE4D6487FD009B1" name="X7CE4D6487FD009B1"></a></p>

<h5>3.7-6 GoodNodes</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GoodNodes</code>( <var class="Arg">e|H</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list of the rows of <span class="SimpleMath">\(\mu\)</span> which end in a good node. The good node of residue <span class="SimpleMath">\(r\)</span> (if it exists) is the <span class="SimpleMath">\((r+1)\)</span>-st element in this list.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GoodNodes</code>( <var class="Arg">e|H</var>, <var class="Arg">mu</var>, <var class="Arg">r</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the number of the row which ends with the good node of residue <span class="SimpleMath">\(r\)</span> or <code class="keyw">fail</code> if there is no good node of residue <span class="SimpleMath">\(r\)</span>.</p>

<p>Given a partition and an integer <span class="SimpleMath">\(e\)</span>, Kleshchev [K] defined the notion of <em>good node</em> for each residue <span class="SimpleMath">\(r\)</span> (<span class="SimpleMath">\(0\leq r&lt;e\)</span>). When <span class="SimpleMath">\(e\)</span> is prime and <span class="SimpleMath">\(\mu\)</span> is <span class="SimpleMath">\(e\)</span>-regular, Kleshchev showed that the good nodes describe the restriction of the socle of <span class="SimpleMath">\(D(\mu)\)</span> in the symmetric group case. Brundan <a href="chapBib_mj.html#biBB">[Bru98]</a> has recently generalized this result to the Hecke algebra.</p>

<p>By definition, there is at most one good node for each residue <span class="SimpleMath">\(r\)</span> and this node is a removable node (in the diagram of <span class="SimpleMath">\(\mu\)</span>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GoodNodes(5,[5,4,3,2]);</span>
[ fail, fail, 2, fail, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GoodNodes(5,[5,4,3,2],0);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GoodNodes(5,[5,4,3,2],4);</span>
1
</pre></div>

<p>The good nodes also determine the Kleshchev-Mullineux map (see <code class="func">GoodNodeSequence</code> (<a href="chap3_mj.html#X85B290977A17D9EE"><span class="RefLink">3.7-8</span></a>) and <code class="func">MullineuxMap</code> (<a href="chap3_mj.html#X7A6262B684185E3D"><span class="RefLink">3.7-3</span></a>)). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X783B52458335975F" name="X783B52458335975F"></a></p>

<h5>3.7-7 NormalNodes</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NormalNodes</code>( <var class="Arg">e|H</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the numbers of the rows of <span class="SimpleMath">\(\mu\)</span> which end in one of Kleshchev's <a href="chapBib_mj.html#biBK">[Kle96]</a> normal nodes.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NormalNodes</code>( <var class="Arg">e|H</var>, <var class="Arg">mu</var>, <var class="Arg">r</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the rows corresponding to normal nodes of the specified residue.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NormalNodes(5,[6,5,4,4,3,2,1,1,1]);</span>
[ [ 1, 4 ], [  ], [  ], [ 2, 5 ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NormalNodes(5,[6,5,4,4,3,2,1,1,1],0);</span>
[ 1, 4 ]
</pre></div>

<p>See also <code class="func">GoodNodes</code> (<a href="chap3_mj.html#X7CE4D6487FD009B1"><span class="RefLink">3.7-6</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X85B290977A17D9EE" name="X85B290977A17D9EE"></a></p>

<h5>3.7-8 GoodNodeSequence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GoodNodeSequence</code>( <var class="Arg">e|H</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Given an <span class="SimpleMath">\(e\)</span>-regular partition <span class="SimpleMath">\(\mu\)</span> of <span class="SimpleMath">\(n\)</span>, a <em>good node sequence</em> for <span class="SimpleMath">\(\mu\)</span> is a sequence <span class="SimpleMath">\(gns\)</span> of <span class="SimpleMath">\(n\)</span> residues such that <span class="SimpleMath">\(\mu\)</span> has a good node of residue <span class="SimpleMath">\(r\)</span>, where <span class="SimpleMath">\(r\)</span> is the last residue in <span class="SimpleMath">\(gns\)</span> and the first <span class="SimpleMath">\(n-1\)</span> residues in <span class="SimpleMath">\(gns\)</span> are a good node sequence for the partition obtained from <span class="SimpleMath">\(\mu\)</span> by deleting its (unique) good node with residue <span class="SimpleMath">\(r\)</span> (see <code class="func">GoodNodes</code> (<a href="chap3_mj.html#X7CE4D6487FD009B1"><span class="RefLink">3.7-6</span></a>)). In general, <span class="SimpleMath">\(\mu\)</span> will have more than one good node sequence; however, any good node sequence uniquely determines <span class="SimpleMath">\(\mu\)</span> (see <code class="func">PartitionGoodNodeSequence</code> (<a href="chap3_mj.html#X7B704FE781A311E5"><span class="RefLink">3.7-9</span></a>)).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(4);; GoodNodeSequence(H,4,3,1);</span>
[ 0, 3, 1, 0, 2, 2, 1, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GoodNodeSequence(H,4,3,2);</span>
[ 0, 3, 1, 0, 2, 2, 1, 3, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GoodNodeSequence(H,4,4,2);</span>
[ 0, 3, 1, 0, 2, 2, 1, 3, 3, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GoodNodeSequence(H,5,4,2);</span>
[ 0, 3, 1, 0, 2, 2, 1, 3, 3, 2, 0 ]
</pre></div>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GoodNodeSequences</code>( <var class="Arg">e|H</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: list of all good node sequences for <span class="SimpleMath">\(\mu\)</span></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(4);; GoodNodeSequences(H,5,2,1);</span>
[ [ 0, 1, 2, 3, 3, 2, 0, 0 ], [ 0, 3, 1, 2, 2, 3, 0, 0 ], 
  [ 0, 1, 3, 2, 2, 3, 0, 0 ], [ 0, 1, 2, 3, 3, 0, 2, 0 ], 
  [ 0, 1, 2, 3, 0, 3, 2, 0 ], [ 0, 1, 2, 3, 3, 0, 0, 2 ], 
  [ 0, 1, 2, 3, 0, 3, 0, 2 ] ]
</pre></div>

<p>The good node sequences determine the Mullineux map (see <code class="func">GoodNodes</code> (<a href="chap3_mj.html#X7CE4D6487FD009B1"><span class="RefLink">3.7-6</span></a>) and <code class="func">MullineuxMap</code> (<a href="chap3_mj.html#X7A6262B684185E3D"><span class="RefLink">3.7-3</span></a>)). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7B704FE781A311E5" name="X7B704FE781A311E5"></a></p>

<h5>3.7-9 PartitionGoodNodeSequence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PartitionGoodNodeSequence</code>( <var class="Arg">e|H</var>, <var class="Arg">gns</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the unique <span class="SimpleMath">\(e\)</span>-regular partition corresponding to <span class="SimpleMath">\(gns\)</span> (or <code class="keyw">fail</code> if in fact <span class="SimpleMath">\(gns\)</span> is not a good node sequence).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(4);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PartitionGoodNodeSequence(H,0, 3, 1, 0, 2, 2, 1, 3, 3, 2);</span>
[ 4, 4, 2 ]
</pre></div>

<p>See also <code class="func">GoodNodes</code> (<a href="chap3_mj.html#X7CE4D6487FD009B1"><span class="RefLink">3.7-6</span></a>), <code class="func">GoodNodeSequence</code> (<a href="chap3_mj.html#X85B290977A17D9EE"><span class="RefLink">3.7-8</span></a>) and <code class="func">MullineuxMap</code> (<a href="chap3_mj.html#X7A6262B684185E3D"><span class="RefLink">3.7-3</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7A9DC101850008A2" name="X7A9DC101850008A2"></a></p>

<h5>3.7-10 GoodNodeLatticePath</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GoodNodeLatticePath</code>( <var class="Arg">e|H</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a sequence of partitions which give a path in the <span class="SimpleMath">\(e\)</span>-good partition lattice from the empty partition to <span class="SimpleMath">\(\mu\)</span>.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GoodNodeLatticePaths</code>( <var class="Arg">e|H</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the list of all paths in the <span class="SimpleMath">\(e\)</span>-good partition lattice which end in <span class="SimpleMath">\(\mu\)</span>.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LatticePathGoodNodeSequence</code>( <var class="Arg">e|H</var>, <var class="Arg">gns</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the path corresponding to a given good node sequence <span class="SimpleMath">\(gns\)</span></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GoodNodeLatticePath(3,3,2,1);</span>
[ [ 1 ], [ 1, 1 ], [ 2, 1 ], [ 2, 1, 1 ], [ 2, 2, 1 ], [ 3, 2, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GoodNodeLatticePaths(3,3,2,1);</span>
[ [ [ 1 ], [ 1, 1 ], [ 2, 1 ], [ 2, 1, 1 ], [ 2, 2, 1 ], [ 3, 2, 1 ] ], 
  [ [ 1 ], [ 1, 1 ], [ 2, 1 ], [ 2, 2 ], [ 2, 2, 1 ], [ 3, 2, 1 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GoodNodeSequence(4,6,3,2);</span>
[ 0, 3, 1, 0, 2, 2, 3, 3, 0, 1, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LatticePathGoodNodeSequence(4,last);</span>
[ [ 1 ], [ 1, 1 ], [ 2, 1 ], [ 2, 2 ], [ 3, 2 ], [ 3, 2, 1 ], [ 4, 2, 1 ], 
  [ 4, 2, 2 ], [ 5, 2, 2 ], [ 6, 2, 2 ], [ 6, 3, 2 ] ]
</pre></div>

<p>See also <code class="func">GoodNodes</code> (<a href="chap3_mj.html#X7CE4D6487FD009B1"><span class="RefLink">3.7-6</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7918D9DE7ACE2294" name="X7918D9DE7ACE2294"></a></p>

<h5>3.7-11 LittlewoodRichardsonRule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LittlewoodRichardsonRule</code>( <var class="Arg">mu</var>, <var class="Arg">nu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LittlewoodRichardsonCoefficient</code>( <var class="Arg">mu</var>, <var class="Arg">nu</var>, <var class="Arg">tau</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Given partitions <span class="SimpleMath">\(\mu\)</span> of <span class="SimpleMath">\(n\)</span> and <span class="SimpleMath">\(\nu\)</span> of <span class="SimpleMath">\(m\)</span> the module <span class="SimpleMath">\(S(\mu)\otimes S(\nu)\)</span> is naturally an <span class="SimpleMath">\(H(S_n\times S_m)\)</span>- module and, by inducing, we obtain an <span class="SimpleMath">\(H(S_{n+m})\)</span>-module. This module has the same composition factors as <span class="SimpleMath">\(\sum_{\nu} a_{\mu,\nu}^\lambda S(\lambda)\)</span>, where the sum runs over all partitions <span class="SimpleMath">\(\lambda\)</span> of <span class="SimpleMath">\(n+m\)</span> and the integers <span class="SimpleMath">\(a_{\mu,\nu}^\lambda\)</span> are the Littlewood-Richardson coefficients. The integers <span class="SimpleMath">\(a_{\mu,\nu}^\lambda\)</span> can be calculated using a straightforward combinatorial algorithm known as the Littlewood-Richardson rule (see <a href="chapBib_mj.html#biBJK">[JK81]</a>). The function <code class="func">LittlewoodRichardsonRule</code> returns an (unordered) list of partitions of <span class="SimpleMath">\(n+m\)</span> in which each partition <span class="SimpleMath">\(\lambda\)</span> occurs <span class="SimpleMath">\(a_{\mu,\nu}^\lambda\)</span> times. The Littlewood-Richardson coefficients are independent of <span class="SimpleMath">\(e\)</span>; they can be read more easily from the computation <span class="SimpleMath">\(S(\mu)\otimes S(\nu)\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizeScreen([80,20]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(0);; # the generic Hecke algebra with R=C[q]</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LittlewoodRichardsonRule([3,2,1],[4,2]);</span>
[ [ 4, 3, 2, 2, 1 ], [ 4, 3, 3, 1, 1 ], [ 4, 3, 3, 2 ], [ 4, 4, 2, 1, 1 ], 
  [ 4, 4, 2, 2 ], [ 4, 4, 3, 1 ], [ 5, 2, 2, 2, 1 ], [ 5, 3, 2, 1, 1 ], 
  [ 5, 3, 2, 2 ], [ 5, 4, 2, 1 ], [ 5, 3, 2, 1, 1 ], [ 5, 3, 3, 1 ], 
  [ 5, 4, 1, 1, 1 ], [ 5, 4, 2, 1 ], [ 5, 5, 1, 1 ], [ 5, 3, 2, 2 ], 
  [ 5, 3, 3, 1 ], [ 5, 4, 2, 1 ], [ 5, 4, 3 ], [ 5, 5, 2 ], [ 6, 2, 2, 1, 1 ],
  [ 6, 3, 1, 1, 1 ], [ 6, 3, 2, 1 ], [ 6, 4, 1, 1 ], [ 6, 2, 2, 2 ], 
  [ 6, 3, 2, 1 ], [ 6, 4, 2 ], [ 6, 3, 2, 1 ], [ 6, 3, 3 ], [ 6, 4, 1, 1 ], 
  [ 6, 4, 2 ], [ 6, 5, 1 ], [ 7, 2, 2, 1 ], [ 7, 3, 1, 1 ], [ 7, 3, 2 ], 
  [ 7, 4, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(MakeSpecht(H,3,2,1)*MakeSpecht(H,4,2));</span>
S(7,4,1) + S(7,3,2) + S(7,3,1^2) + S(7,2^2,1) + S(6,5,1) + 2S(6,4,2) + 2S(6,4,\
1^2) + S(6,3^2) + 3S(6,3,2,1) + S(6,3,1^3) + S(6,2^3) + S(6,2^2,1^2) + S(5^2,2\
) + S(5^2,1^2) + S(5,4,3) + 3S(5,4,2,1) + S(5,4,1^3) + 2S(5,3^2,1) + 2S(5,3,2^\
2) + 2S(5,3,2,1^2) + S(5,2^3,1) + S(4^2,3,1) + S(4^2,2^2) + S(4^2,2,1^2) + S(4\
,3^2,2) + S(4,3^2,1^2) + S(4,3,2^2,1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LittlewoodRichardsonCoefficient([3,2,1],[4,2],[5,4,2,1]);</span>
3
</pre></div>

<p>The function <code class="func">LittlewoodRichardsonCoefficient</code> returns a single Littlewood-Richardson coefficient (although you are really better off asking for all of them, since they will all be calculated anyway).</p>

<p>See also <code class="func">RInducedModule</code> (<a href="chap3_mj.html#X81D7F7A4812BB04D"><span class="RefLink">3.4-1</span></a>) and <code class="func">InverseLittlewoodRichardsonRule</code> (<a href="chap3_mj.html#X7B9901427D1CF6F4"><span class="RefLink">3.7-12</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7B9901427D1CF6F4" name="X7B9901427D1CF6F4"></a></p>

<h5>3.7-12 InverseLittlewoodRichardsonRule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InverseLittlewoodRichardsonRule</code>( <var class="Arg">tau</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list of all pairs of partitions <span class="SimpleMath">\([\mu,\nu]\)</span> such that the Littlewood-Richardson coefficient <span class="SimpleMath">\(a_{\mu,\nu}^\tau\)</span> is non-zero (see <code class="func">LittlewoodRichardsonRule</code> (<a href="chap3_mj.html#X7918D9DE7ACE2294"><span class="RefLink">3.7-11</span></a>)). The list returned is unordered and <span class="SimpleMath">\([\mu,\nu]\)</span> will appear <span class="SimpleMath">\(a_{\mu,\nu}^\tau\)</span> times in it.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizeScreen([80,20]);; InverseLittlewoodRichardsonRule(3,2,1);</span>
[ [ [  ], [ 3, 2, 1 ] ], [ [ 1 ], [ 3, 2 ] ], [ [ 1 ], [ 2, 2, 1 ] ], 
  [ [ 1 ], [ 3, 1, 1 ] ], [ [ 1, 1 ], [ 2, 2 ] ], [ [ 1, 1 ], [ 3, 1 ] ], 
  [ [ 1, 1 ], [ 2, 1, 1 ] ], [ [ 1, 1, 1 ], [ 2, 1 ] ], [ [ 2 ], [ 2, 2 ] ], 
  [ [ 2 ], [ 3, 1 ] ], [ [ 2 ], [ 2, 1, 1 ] ], [ [ 2, 1 ], [ 3 ] ], 
  [ [ 2, 1 ], [ 2, 1 ] ], [ [ 2, 1 ], [ 2, 1 ] ], [ [ 2, 1 ], [ 1, 1, 1 ] ], 
  [ [ 2, 1, 1 ], [ 2 ] ], [ [ 2, 1, 1 ], [ 1, 1 ] ], [ [ 2, 2 ], [ 2 ] ], 
  [ [ 2, 2 ], [ 1, 1 ] ], [ [ 2, 2, 1 ], [ 1 ] ], [ [ 3 ], [ 2, 1 ] ], 
  [ [ 3, 1 ], [ 2 ] ], [ [ 3, 1 ], [ 1, 1 ] ], [ [ 3, 1, 1 ], [ 1 ] ], 
  [ [ 3, 2 ], [ 1 ] ], [ [ 3, 2, 1 ], [  ] ] ]
</pre></div>

<p>See also <code class="func">LittlewoodRichardsonRule</code> (<a href="chap3_mj.html#X7918D9DE7ACE2294"><span class="RefLink">3.7-11</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X790D4ACF7930340F" name="X790D4ACF7930340F"></a></p>

<h5>3.7-13 EResidueDiagram</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EResidueDiagram</code>( <var class="Arg">H|e</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EResidueDiagram</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>The <span class="SimpleMath">\(e\)</span>-residue of the <span class="SimpleMath">\((i,j)\)</span>-th node in the diagram of a partition <span class="SimpleMath">\(\mu\)</span> is <span class="SimpleMath">\((j-i)\bmod e\)</span>. <code class="code">EResidueDiagram(</code><span class="SimpleMath">\(e, \mu\)</span><code class="code">)</code> prints the diagram of the partition <span class="SimpleMath">\(\mu\)</span> replacing each node with its <span class="SimpleMath">\(e\)</span>-residue. If <span class="SimpleMath">\(x\)</span> is a module then <code class="code">EResidueDiagram(</code><span class="SimpleMath">\(x\)</span><code class="code">)</code> prints the <span class="SimpleMath">\(e\)</span>-residue diagrams of all of the <span class="SimpleMath">\(e\)</span>-regular partitions appearing in <span class="SimpleMath">\(x\)</span> (such diagrams are useful when trying to decide how to restrict and induce modules and also in applying results such as the "Scattering theorem" of <a href="chapBib_mj.html#biBJM1">[JM96]</a>). It is not necessary to supply the integer <span class="SimpleMath">\(e\)</span> in this case because <span class="SimpleMath">\(x\)</span> "knows" the value of <span class="SimpleMath">\(e\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(2);; EResidueDiagram(MakeSpecht(MakePIM(H,7,5)));</span>
[ 7, 5 ]
   0   1   0   1   0   1   0
   1   0   1   0   1
[ 6, 5, 1 ]
   0   1   0   1   0   1
   1   0   1   0   1
   0
[ 5, 4, 2, 1 ]
   0   1   0   1   0
   1   0   1   0
   0   1
   1
# There are 3 2-regular partitions.
true
</pre></div>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7DE3773C78BC324C" name="X7DE3773C78BC324C"></a></p>

<h5>3.7-14 HookLengthDiagram</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HookLengthDiagram</code>( <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Prints the diagram of <span class="SimpleMath">\(\mu\)</span>, replacing each node with its hook length (see <a href="chapBib_mj.html#biBJK">[JK81]</a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HookLengthDiagram(11,6,3,2);</span>
  14  13  11   9   8   7   5   4   3   2   1
   8   7   5   3   2   1
   4   3   1
   2   1
true
</pre></div>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7F2ACCBF788A62E8" name="X7F2ACCBF788A62E8"></a></p>

<h5>3.7-15 RemoveRimHook</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RemoveRimHook</code>( <var class="Arg">mu</var>, <var class="Arg">row</var>, <var class="Arg">col</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the partition obtained from <span class="SimpleMath">\(\mu\)</span> by removing the <span class="SimpleMath">\((row, col)\)</span>-th rim hook from (the diagram of) <span class="SimpleMath">\(\mu\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RemoveRimHook([6,5,4],1,2);</span>
[ 4, 3, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RemoveRimHook([6,5,4],2,3);</span>
[ 6, 3, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HookLengthDiagram(6,5,4);</span>
   8   7   6   5   3   1
   6   5   4   3   1
   4   3   2   1
true
</pre></div>

<p>See also <code class="func">AddRimHook</code> (<a href="chap3_mj.html#X7CEA98C779BDBD1A"><span class="RefLink">3.7-16</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7CEA98C779BDBD1A" name="X7CEA98C779BDBD1A"></a></p>

<h5>3.7-16 AddRimHook</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AddRimHook</code>( <var class="Arg">mu</var>, <var class="Arg">r</var>, <var class="Arg">h</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list <span class="SimpleMath">\([\nu, l]\)</span> where <span class="SimpleMath">\(\nu\)</span> is the partition obtained from <span class="SimpleMath">\(\mu\)</span> by adding a rim hook of length <span class="SimpleMath">\(h\)</span> with its "foot" in the <span class="SimpleMath">\(r\)</span>-th row of (the diagram of) <span class="SimpleMath">\(\mu\)</span> and <span class="SimpleMath">\(l\)</span> is the leg length of the wrapped on rim hook (see, for example, <a href="chapBib_mj.html#biBJK">[JK81]</a>). If the resulting diagram <span class="SimpleMath">\(\nu\)</span> is not the diagram of a partition then <code class="keyw">fail</code> is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddRimHook([6,4,3],1,3);</span>
[ [ 9, 4, 3 ], 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddRimHook([6,4,3],2,3);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddRimHook([6,4,3],3,3);</span>
[ [ 6, 5, 5 ], 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddRimHook([6,4,3],4,3);</span>
[ [ 6, 4, 3, 3 ], 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddRimHook([6,4,3],5,3);</span>
fail
</pre></div>

<p>See also <code class="func">RemoveRimHook</code> (<a href="chap3_mj.html#X7F2ACCBF788A62E8"><span class="RefLink">3.7-15</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X8350934A7F9AB5BE" name="X8350934A7F9AB5BE"></a></p>

<h4>3.8 <span class="Heading">Operations on partitions</span></h4>

<p>This section contains functions for manipulating partitions and also several useful orderings on the set of partitions.</p>

<p><a id="X867496487DC35776" name="X867496487DC35776"></a></p>

<h5>3.8-1 ECore</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ECore</code>( <var class="Arg">e|H</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the <span class="SimpleMath">\(e\)</span>-core of the partition <span class="SimpleMath">\(\mu\)</span>.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EAbacus</code>( <var class="Arg">e|H</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>The <span class="SimpleMath">\(e\)</span>-core of a partition <span class="SimpleMath">\(\mu\)</span> is what remains after as many rim <span class="SimpleMath">\(e\)</span>-hooks as possible have been removed from the diagram of <span class="SimpleMath">\(\mu\)</span> (that this is well defined is not obvious; see <a href="chapBib_mj.html#biBJK">[JK81]</a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(6);; ECore(H,16,8,6,5,3,1);</span>
[ 4, 3, 1, 1 ]
</pre></div>

<p>The <span class="SimpleMath">\(e\)</span>-core is calculated here using James'; notation of an <em>abacus</em> there is also an <code class="func">EAbacus</code> function; but it is more "pretty" than useful.</p>

<p>See also <code class="func">IsECore</code> (<a href="chap3_mj.html#X8236220C87814790"><span class="RefLink">3.8-2</span></a>), <code class="func">EQuotient</code> (<a href="chap3_mj.html#X8538AAAF8628A725"><span class="RefLink">3.8-3</span></a>) and <code class="func">EWeight</code> (<a href="chap3_mj.html#X7C460635829E7ED0"><span class="RefLink">3.8-5</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X8236220C87814790" name="X8236220C87814790"></a></p>

<h5>3.8-2 IsECore</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsECore</code>( <var class="Arg">e|H</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if <span class="SimpleMath">\(\mu\)</span> is an <span class="SimpleMath">\(e\)</span>-core and <code class="keyw">false</code> otherwise.</p>

<p>See also <code class="func">ECore</code> (<a href="chap3_mj.html#X867496487DC35776"><span class="RefLink">3.8-1</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X8538AAAF8628A725" name="X8538AAAF8628A725"></a></p>

<h5>3.8-3 EQuotient</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EQuotient</code>( <var class="Arg">e|H</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the <span class="SimpleMath">\(e\)</span>-quotient of <span class="SimpleMath">\(\mu\)</span>; this is a sequence of <span class="SimpleMath">\(e\)</span> partitions whose definition can be found in <a href="chapBib_mj.html#biBJK">[JK81]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(8);; EQuotient(H,22,18,16,12,12,1,1);</span>
[ [ 1, 1 ], [  ], [  ], [  ], [  ], [ 2, 2 ], [  ], [ 1 ] ]
</pre></div>

<p>See also <code class="func">ECore</code> (<a href="chap3_mj.html#X867496487DC35776"><span class="RefLink">3.8-1</span></a>) and <code class="func">CombineEQuotientECore</code> (<a href="chap3_mj.html#X7F357B417D495B6F"><span class="RefLink">3.8-4</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7F357B417D495B6F" name="X7F357B417D495B6F"></a></p>

<h5>3.8-4 CombineEQuotientECore</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CombineEQuotientECore</code>( <var class="Arg">e|H</var>, <var class="Arg">q</var>, <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the partition which has <span class="SimpleMath">\(e\)</span>-quotient <span class="SimpleMath">\(q\)</span> and <span class="SimpleMath">\(e\)</span> -core <span class="SimpleMath">\(C\)</span>.</p>

<p>A partition is uniquely determined by its <span class="SimpleMath">\(e\)</span>-quotient and its <span class="SimpleMath">\(e\)</span> -core (see <code class="func">EQuotient</code> (<a href="chap3_mj.html#X8538AAAF8628A725"><span class="RefLink">3.8-3</span></a>) and <code class="func">ECore</code> (<a href="chap3_mj.html#X867496487DC35776"><span class="RefLink">3.8-1</span></a>)).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(11);; mu:=[100,98,57,43,12,1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q:=EQuotient(H,mu);</span>
[ [ 9 ], [  ], [  ], [  ], [  ], [  ], [ 3 ], [ 1 ], [ 9 ], [  ], [ 5 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C:=ECore(H,mu);</span>
[ 7, 2, 2, 1, 1, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CombineEQuotientECore(H,Q,C);</span>
[ 100, 98, 57, 43, 12, 1 ]
</pre></div>

<p>See also <code class="func">ECore</code> (<a href="chap3_mj.html#X867496487DC35776"><span class="RefLink">3.8-1</span></a>) and <code class="func">EQuotient</code> (<a href="chap3_mj.html#X8538AAAF8628A725"><span class="RefLink">3.8-3</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7C460635829E7ED0" name="X7C460635829E7ED0"></a></p>

<h5>3.8-5 EWeight</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EWeight</code>( <var class="Arg">e|H</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>The <span class="SimpleMath">\(e\)</span>-weight of a partition is the number of <span class="SimpleMath">\(e\)</span>-hooks which must be removed from the partition to reach the <span class="SimpleMath">\(e\)</span>-core (see <code class="func">ECore</code> (<a href="chap3_mj.html#X867496487DC35776"><span class="RefLink">3.8-1</span></a>)).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EWeight(6,[16,8,6,5,3,1]);</span>
5
</pre></div>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X86308F6C818B220C" name="X86308F6C818B220C"></a></p>

<h5>3.8-6 ERegularPartitions</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ERegularPartitions</code>( <var class="Arg">e|H</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the list of <span class="SimpleMath">\(e\)</span>-regular partitions of <span class="SimpleMath">\(n\)</span>, ordered reverse lexicographically (see <code class="func">Lexicographic</code> (<a href="chap3_mj.html#X8480188D81ECBD92"><span class="RefLink">3.8-13</span></a>)).</p>

<p>A partition <span class="SimpleMath">\(\mu=(\mu_1,\mu_2,\ldots)\)</span> is <em><span class="SimpleMath">\(e\)</span>-regular</em> if there is no integer <span class="SimpleMath">\(i\)</span> such that <span class="SimpleMath">\(\mu_i=\mu_{i+1}=\cdots=\mu_{i+e-1}&gt;0\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(3);; ERegularPartitions(H,6);</span>
[ [ 2, 2, 1, 1 ], [ 3, 2, 1 ], [ 3, 3 ], [ 4, 1, 1 ], [ 4, 2 ], [ 5, 1 ], 
  [ 6 ] ]
</pre></div>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7BEDA8F286ED5F20" name="X7BEDA8F286ED5F20"></a></p>

<h5>3.8-7 IsERegular</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsERegular</code>( <var class="Arg">e|H</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if <span class="SimpleMath">\(\mu\)</span> is <span class="SimpleMath">\(e\)</span>-regular and <code class="keyw">false</code> otherwise.</p>

<p>This functions requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7D131AF0839089BD" name="X7D131AF0839089BD"></a></p>

<h5>3.8-8 ConjugatePartition</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConjugatePartition</code>( <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the partition whose diagram is obtained by interchanging the rows and columns in the diagram of <span class="SimpleMath">\(\mu\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugatePartition(6,4,3,2);</span>
[ 4, 4, 3, 2, 1, 1 ]
</pre></div>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X8711CC56792711A7" name="X8711CC56792711A7"></a></p>

<h5>3.8-9 PartitionBetaSet</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PartitionBetaSet</code>( <var class="Arg">bn</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the partitions corresponding to the given set of beta numbers <span class="SimpleMath">\(bn\)</span>. Note in particular that <span class="SimpleMath">\(bn\)</span> must be a set of integers.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PartitionBetaSet([ 2, 3, 6, 8 ]);</span>
[ 5, 4, 2, 2 ]
</pre></div>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7EC4D0FA81B55391" name="X7EC4D0FA81B55391"></a></p>

<h5>3.8-10 ETopLadder</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ETopLadder</code>( <var class="Arg">e|H</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>The ladders in the diagram of a partition are the lines connecting nodes of constant <span class="SimpleMath">\(e\)</span>-residue, having slope <span class="SimpleMath">\(e-1\)</span> (see <a href="chapBib_mj.html#biBJK">[JK81]</a>). A new partition can be obtained from <span class="SimpleMath">\(\mu\)</span> by sliding all nodes up to the highest possible rungs on their ladders.</p>

<p>Returns: the partition obtained in this way; it is automatically <span class="SimpleMath">\(e\)</span>-regular (this partition is denoted <span class="SimpleMath">\(\mu^R\)</span> in <a href="chapBib_mj.html#biBJK">[JK81]</a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(4);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ETopLadder(H,1,1,1,1,1,1,1,1,1,1);</span>
[ 4, 3, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ETopLadder(6,1,1,1,1,1,1,1,1,1,1);</span>
[ 2, 2, 2, 2, 2 ]
</pre></div>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X820388EF7C8333BA" name="X820388EF7C8333BA"></a></p>

<h5>3.8-11 Dominates</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Dominates</code>( <var class="Arg">mu</var>, <var class="Arg">nu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if either <span class="SimpleMath">\(\mu\)</span>=<span class="SimpleMath">\(\nu\)</span> or <span class="SimpleMath">\(\forall i\geq 1: \sum_{j=1}^i\mu_j\geq\sum_{j=1}^i\nu_j\)</span> and <code class="keyw">false</code> otherwise.</p>

<p>The dominance ordering is an important partial order in the representation theory of Hecke algebra because <span class="SimpleMath">\(d_{\mu,\nu}=0\)</span> unless <span class="SimpleMath">\(\nu\)</span> dominates <span class="SimpleMath">\(\mu\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dominates([5,4],[4,4,1]);</span>
true
</pre></div>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X84DB1DD37AF227CF" name="X84DB1DD37AF227CF"></a></p>

<h5>3.8-12 LengthLexicographic</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LengthLexicographic</code>( <var class="Arg">mu</var>, <var class="Arg">nu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if the length of <span class="SimpleMath">\(\mu\)</span> is less than the length of <span class="SimpleMath">\(\nu\)</span> or if the length of <span class="SimpleMath">\(\mu\)</span> equals the length of <span class="SimpleMath">\(\nu\)</span> and <code class="code">Lexicographic(</code><span class="SimpleMath">\(\mu, \nu\)</span><code class="code">)</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p:=Partitions(6);;Sort(p,LengthLexicographic); p;</span>
[ [ 6 ], [ 5, 1 ], [ 4, 2 ], [ 3, 3 ], [ 4, 1, 1 ], [ 3, 2, 1 ], [ 2, 2, 2 ], 
  [ 3, 1, 1, 1 ], [ 2, 2, 1, 1 ], [ 2, 1, 1, 1, 1 ], [ 1, 1, 1, 1, 1, 1 ] ]
</pre></div>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X8480188D81ECBD92" name="X8480188D81ECBD92"></a></p>

<h5>3.8-13 Lexicographic</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Lexicographic</code>( <var class="Arg">mu</var>, <var class="Arg">nu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if <span class="SimpleMath">\(\mu\)</span> is lexicographically greater than or equal to <span class="SimpleMath">\(\nu\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p:=Partitions(6);;Sort(p,Lexicographic); p;</span>
[ [ 6 ], [ 5, 1 ], [ 4, 2 ], [ 4, 1, 1 ], [ 3, 3 ], [ 3, 2, 1 ], 
  [ 3, 1, 1, 1 ], [ 2, 2, 2 ], [ 2, 2, 1, 1 ], [ 2, 1, 1, 1, 1 ], 
  [ 1, 1, 1, 1, 1, 1 ] ]
</pre></div>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X78F41DF77D6F8292" name="X78F41DF77D6F8292"></a></p>

<h5>3.8-14 ReverseDominance</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ReverseDominance</code>( <var class="Arg">mu</var>, <var class="Arg">nu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if <span class="SimpleMath">\(\forall i&gt;0: \sum_{j\geq i}\mu_j &gt; \sum_{j\geq i}\nu_j\)</span>.</p>

<p>This is another total order on partitions which extends the dominance ordering (see <code class="func">Dominates</code> (<a href="chap3_mj.html#X820388EF7C8333BA"><span class="RefLink">3.8-11</span></a>)).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p:=Partitions(6);;Sort(p,ReverseDominance); p;</span>
[ [ 6 ], [ 5, 1 ], [ 4, 2 ], [ 3, 3 ], [ 4, 1, 1 ], [ 3, 2, 1 ], [ 2, 2, 2 ], 
  [ 3, 1, 1, 1 ], [ 2, 2, 1, 1 ], [ 2, 1, 1, 1, 1 ], [ 1, 1, 1, 1, 1, 1 ] ]
</pre></div>

<p>This is the ordering used by James in the appendix of his Springer lecture notes book.</p>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X83890936806E3A34" name="X83890936806E3A34"></a></p>

<h4>3.9 <span class="Heading">Miscellaneous functions on modules</span></h4>

<p>This section contains some functions for looking at the partitions in a given module for the Hecke algebras. Most of them are used internally by <strong class="pkg">Hecke</strong>.</p>

<p><a id="X7A8E810C85A62DD6" name="X7A8E810C85A62DD6"></a></p>

<h5>3.9-1 Specialized</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Specialized</code>( <var class="Arg">x</var>[, <var class="Arg">q</var>] )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Specialized</code>( <var class="Arg">d</var>[, <var class="Arg">q</var>] )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the corresponding element of the Grothendieck ring or the corresponding decomposition matrix of the Hecke algebra when given an element of the Fock space <span class="SimpleMath">\(x\)</span> (see <code class="func">Specht</code> (<a href="chap3_mj.html#X7FE26921867C440A"><span class="RefLink">3.2-1</span></a>)), or a crystallized decomposition matrix (see <code class="func">CrystalDecompositionMatrix</code> (<a href="chap3_mj.html#X7F616CCE808FA11E"><span class="RefLink">3.2-9</span></a>)), respectively.</p>

<p>By default the indeterminate <span class="SimpleMath">\(v\)</span> is specialized to <span class="SimpleMath">\(1\)</span>; however <span class="SimpleMath">\(v\)</span> can be specialized to any (integer) <span class="SimpleMath">\(q\)</span> by supplying a second argument.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizeScreen([80,20]);; H:=Specht(2);; x:=MakeFockPIM(H,6,2);; Display(x);</span>
Sq(6,2) + vSq(6,1^2) + vSq(5,3) + v^2Sq(5,1^3) + vSq(4,3,1) + v^2Sq(4,2^2) + (\
v^3+v)Sq(4,2,1^2) + v^2Sq(4,1^4) + v^2Sq(3^2,1^2) + v^3Sq(3,2^2,1) + v^3Sq(3,1\
^5) + v^3Sq(2^3,1^2) + v^4Sq(2^2,1^4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(Specialized(x));</span>
S(6,2) + S(6,1^2) + S(5,3) + S(5,1^3) + S(4,3,1) + S(4,2^2) + 2S(4,2,1^2) + S(\
4,1^4) + S(3^2,1^2) + S(3,2^2,1) + S(3,1^5) + S(2^3,1^2) + S(2^2,1^4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(Specialized(x,2));</span>
S(6,2) + 2S(6,1^2) + 2S(5,3) + 4S(5,1^3) + 2S(4,3,1) + 4S(4,2^2) + 10S(4,2,1^2\
) + 4S(4,1^4) + 4S(3^2,1^2) + 8S(3,2^2,1) + 8S(3,1^5) + 8S(2^3,1^2) + 16S(2^2,\
1^4)
</pre></div>

<p>An example of <code class="func">Specialized</code> being applied to a crystallized decomposition matrix can be found in <code class="func">CrystalDecompositionMatrix</code> (<a href="chap3_mj.html#X7F616CCE808FA11E"><span class="RefLink">3.2-9</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X8232C0A1846A27FB" name="X8232C0A1846A27FB"></a></p>

<h5>3.9-2 ERegulars</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ERegulars</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ERegulars</code>( <var class="Arg">d</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ListERegulars</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p><code class="code">ERegulars(</code><span class="SimpleMath">\(x\)</span><code class="code">)</code> prints a list of the <span class="SimpleMath">\(e\)</span>-regular partitions, together with multiplicities, which occur in the module <span class="SimpleMath">\(x\)</span>. <code class="code">ListERegulars(</code><span class="SimpleMath">\(x\)</span><code class="code">)</code> returns an actual list of these partitions rather than printing them.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(8);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:=MakeSpecht(RInducedModule(MakePIM(H,8,5,3)));; Display(x);</span>
S(9,5,3) + S(8,6,3) + S(8,5,4) + S(8,5,3,1) + S(6,5,3^2) + S(5^2,4,3) + S(5^2,\
3^2,1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ERegulars(x);</span>
[ 9, 5, 3 ]  [ 8, 6, 3 ]  [ 8, 5, 4 ]  [ 8, 5, 3, 1 ]  
[ 6, 5, 3, 3 ]  [ 5, 5, 4, 3 ]  [ 5, 5, 3, 3, 1 ]  
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(MakePIM(x));</span>
P(9,5,3) + P(8,6,3) + P(8,5,4) + P(8,5,3,1)
</pre></div>

<p>This example shows why these functions are useful: given a projective module <span class="SimpleMath">\(x\)</span>, as aboveand the list of <span class="SimpleMath">\(e\)</span>-regular partitions in <span class="SimpleMath">\(x\)</span> we know the possible indecomposable direct summands of <span class="SimpleMath">\(x\)</span>.</p>

<p>Note that it is not necessary to specify what <span class="SimpleMath">\(e\)</span> is when calling this function because <span class="SimpleMath">\(x\)</span> "knows" the value of <span class="SimpleMath">\(e\)</span>.</p>

<p>The function <code class="func">ERegulars</code> can also be applied to a decomposition matrix <span class="SimpleMath">\(d\)</span>; in this case it returns the unitriangular submatrix of <span class="SimpleMath">\(d\)</span> whose rows and columns are indexed by the <span class="SimpleMath">\(e\)</span>-regular partitions.</p>

<p>These function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X822E8193835DD1D9" name="X822E8193835DD1D9"></a></p>

<h5>3.9-3 SplitECores</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SplitECores</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list <span class="SimpleMath">\([b_1,\ldots,b_k]\)</span> where the Specht modules in each <span class="SimpleMath">\(b_i\)</span> all belong to the same block (i.e. they have the same <span class="SimpleMath">\(e\)</span>-core).</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SplitECores</code>( <var class="Arg">x</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the component of <span class="SimpleMath">\(x\)</span> which is in the same block as <span class="SimpleMath">\(\mu\)</span>.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SplitECores</code>( <var class="Arg">x</var>, <var class="Arg">y</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the component of <span class="SimpleMath">\(x\)</span> which is in the same block as <span class="SimpleMath">\(y\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(SplitECores(RInducedModule(MakeSpecht(H,5,3,1))));</span>
[ S(6,3,1) + S(5,3,2) + S(5,3,1,1), S(5,4,1) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(RInducedModule(MakeSpecht(H,5,3,1),0));</span>
S(5,4,1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(RInducedModule(MakeSpecht(H,5,3,1),1));</span>
S(6,3,1) + S(5,3,2) + S(5,3,1^2)
</pre></div>

<p>See also <code class="func">ECore</code> (<a href="chap3_mj.html#X867496487DC35776"><span class="RefLink">3.8-1</span></a>), <code class="func">RInducedModule</code> (<a href="chap3_mj.html#X81D7F7A4812BB04D"><span class="RefLink">3.4-1</span></a>) and <code class="func">RRestrictedModule</code> (<a href="chap3_mj.html#X783BC74E81A7D0E6"><span class="RefLink">3.4-3</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7E92948B80075E46" name="X7E92948B80075E46"></a></p>

<h5>3.9-4 Coefficient</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Coefficient</code>( <var class="Arg">x</var>, <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the coefficient of <span class="SimpleMath">\(S(\mu)\)</span> in <span class="SimpleMath">\(x\)</span> (resp. <span class="SimpleMath">\(D(\mu)\)</span>, or <span class="SimpleMath">\(P(\mu)\)</span>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizeScreen([80,20]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(3);; x:=MakeSpecht(MakePIM(H,7,3));; Display(x);</span>
S(7,3) + S(7,2,1) + S(6,2,1^2) + S(5^2) + S(5,2^2,1) + S(4^2,1^2) + S(4,3^2) +\
 S(4,3,2,1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Coefficient(x,5,2,2,1);</span>
1
</pre></div>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X79FB3FE67D55BCFA" name="X79FB3FE67D55BCFA"></a></p>

<h5>3.9-5 InnerProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InnerProduct</code>( <var class="Arg">x</var>, <var class="Arg">y</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Here <span class="SimpleMath">\(x\)</span> and <span class="SimpleMath">\(y\)</span> are some modules of the Hecke algebra (i.e. Specht modules, PIMS, or simple modules). <code class="func">InnerProduct</code> computes the standard inner product of these elements. This is sometimes a convenient way to compute decomposition numbers (for example).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H:=Specht(2);; InnerProduct(MakeSpecht(H,2,2,2,1), MakePIM(H,4,3));</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DecompositionNumber(H,[2,2,2,1],[4,3]);</span>
1
</pre></div>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7D473E167C866CEC" name="X7D473E167C866CEC"></a></p>

<h4>3.10 <span class="Heading">Semi-standard and standard tableaux</span></h4>

<p>These functions are not really part of <strong class="pkg">Hecke</strong> proper; however they are related and may well be of use to someone. Tableaux are represented by objects, that can be constructed from a list of lists.</p>

<p><a id="X7F0F9663796E6978" name="X7F0F9663796E6978"></a></p>

<h5>3.10-1 Tableau</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Tableau</code>( <var class="Arg">tab</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: tableau object corresponding to the given list of lists</p>

<p>This is the constructor for tableau objects. The first entry of the given argument list is the list corresponding to the first row of the tableau.</p>

<p><a id="X79ADB1B980D12A14" name="X79ADB1B980D12A14"></a></p>

<h5>3.10-2 SemiStandardTableaux</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SemiStandardTableaux</code>( <var class="Arg">mu</var>, <var class="Arg">nu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: list of the semistandard <span class="SimpleMath">\(\mu\)</span>-tableaux of type <span class="SimpleMath">\(\nu\)</span> <a href="chapBib_mj.html#biBJK">[JK81]</a></p>

<p><span class="SimpleMath">\(\mu\)</span> a partition, <span class="SimpleMath">\(\nu\)</span> a composition.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizeScreen([80,20]);; Display(SemiStandardTableaux([4,3],[1,1,1,2,2]));</span>
[ Tableau( [ [ 1, 2, 3, 4 ], [ 4, 5, 5 ] ] ), 
  Tableau( [ [ 1, 2, 3, 5 ], [ 4, 4, 5 ] ] ), 
  Tableau( [ [ 1, 2, 4, 4 ], [ 3, 5, 5 ] ] ), 
  Tableau( [ [ 1, 2, 4, 5 ], [ 3, 4, 5 ] ] ), 
  Tableau( [ [ 1, 3, 4, 4 ], [ 2, 5, 5 ] ] ), 
  Tableau( [ [ 1, 3, 4, 5 ], [ 2, 4, 5 ] ] ) ]
</pre></div>

<p>See also <code class="func">StandardTableaux</code> (<a href="chap3_mj.html#X7E51D6107DBE2A74"><span class="RefLink">3.10-3</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7E51D6107DBE2A74" name="X7E51D6107DBE2A74"></a></p>

<h5>3.10-3 StandardTableaux</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StandardTableaux</code>( <var class="Arg">mu</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: list of the standard <span class="SimpleMath">\(\mu\)</span>-tableaux</p>

<p><span class="SimpleMath">\(\mu\)</span> a partition</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizeScreen([80,20]);; Display(StandardTableaux(4,2));</span>
[ Tableau( [ [ 1, 2, 3, 4 ], [ 5, 6 ] ] ), 
  Tableau( [ [ 1, 2, 3, 5 ], [ 4, 6 ] ] ), 
  Tableau( [ [ 1, 2, 3, 6 ], [ 4, 5 ] ] ), 
  Tableau( [ [ 1, 2, 4, 5 ], [ 3, 6 ] ] ), 
  Tableau( [ [ 1, 2, 4, 6 ], [ 3, 5 ] ] ), 
  Tableau( [ [ 1, 2, 5, 6 ], [ 3, 4 ] ] ), 
  Tableau( [ [ 1, 3, 4, 5 ], [ 2, 6 ] ] ), 
  Tableau( [ [ 1, 3, 4, 6 ], [ 2, 5 ] ] ), 
  Tableau( [ [ 1, 3, 5, 6 ], [ 2, 4 ] ] ) ]
</pre></div>

<p>See also <code class="func">SemiStandardTableaux</code> (<a href="chap3_mj.html#X79ADB1B980D12A14"><span class="RefLink">3.10-2</span></a>). This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7869DA9A8198BD28" name="X7869DA9A8198BD28"></a></p>

<h5>3.10-4 ConjugateTableau</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConjugateTableau</code>( <var class="Arg">tab</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: tableau obtained from <span class="SimpleMath">\(tab\)</span> by interchangings its rows and columns</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(ConjugateTableau(Tableau([ [ 1, 3, 5, 6 ], [ 2, 4 ] ])));</span>
Standard Tableau:
1	2	
3	4	
5	
6	
</pre></div>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7E5351C27C9253D9" name="X7E5351C27C9253D9"></a></p>

<h5>3.10-5 ShapeTableau</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ShapeTableau</code>( <var class="Arg">tab</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the partition (or composition) obtained from <span class="SimpleMath">\(tab\)</span></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ShapeTableau( Tableau([ [ 1, 1, 2, 3 ], [ 4, 5 ] ]) );</span>
[ 4, 2 ]
</pre></div>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>

<p><a id="X7CABF92D7BF07DD1" name="X7CABF92D7BF07DD1"></a></p>

<h5>3.10-6 TypeTableau</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TypeTableau</code>( <var class="Arg">tab</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the type of the (semistandard) tableau <span class="SimpleMath">\(tab\)</span></p>

<p>The type of a tableau is, the composition <span class="SimpleMath">\(\sigma= (\sigma_1,\sigma_2,\ldots)\)</span> where <span class="SimpleMath">\(\sigma_i\)</span> is the number of entries in <span class="SimpleMath">\(tab\)</span> which are equal to <span class="SimpleMath">\(i\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizeScreen([80,20]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(SemiStandardTableaux([5,4,2],[4,3,0,1,3]),TypeTableau);</span>
[ [ 4, 3, 0, 1, 3 ], [ 4, 3, 0, 1, 3 ], [ 4, 3, 0, 1, 3 ], [ 4, 3, 0, 1, 3 ], 
  [ 4, 3, 0, 1, 3 ] ]
</pre></div>

<p>This function requires the package <strong class="pkg">hecke</strong> (see <code class="func">LoadPackage</code> (<a href="../../../doc/ref/chap76_mj.html#X79B373A77B29D1F5"><span class="RefLink">Reference: LoadPackage</span></a>)).</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
