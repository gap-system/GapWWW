<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (RCWA) - Chapter 2: Residue-Class-Wise Affine Mappings</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap2"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap2_mj.html">[MathJax on]</a></p>
<p><a id="X7FD73FCB8510050E" name="X7FD73FCB8510050E"></a></p>
<div class="ChapSects"><a href="chap2.html#X7FD73FCB8510050E">2 <span class="Heading">Residue-Class-Wise Affine Mappings</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X78ED07E37FC2BD46">2.1 <span class="Heading">Basic definitions</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X86BC55648302D643">2.2 <span class="Heading">Entering residue-class-wise affine mappings</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X86B611BD7EED62A1">2.2-1 ClassShift</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7896C5417E3692B4">2.2-2 ClassReflection</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X8716A75F7DD1C46B">2.2-3 ClassTransposition</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X87EB8C1C87F78A17">2.2-4 ClassRotation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X8799551B83644B37">2.2-5 <span class="Heading"> RcwaMapping (the general constructor) </span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7F1A559387D0226E">2.2-6 LocalizedRcwaMapping</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X78E796B8824C4FC8">2.3 <span class="Heading">Basic arithmetic for residue-class-wise affine mappings</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7C16D22C7BD40FDC">2.4 <span class="Heading">
  Attributes and properties of residue-class-wise affine mappings
</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7C21406085B69C30">2.4-1 LargestSourcesOfAffineMappings</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7D6D0F2783AD02F4">2.4-2 FixedPointsOfAffinePartialMappings</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7A2E308C860B46E3">2.4-3 Multpk</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7B1E53127D9AE52F">2.4-4 Determinant</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X8365EEEB82C946FD">2.4-5 Sign</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X8475F844869DD060">2.5 <span class="Heading">Factoring residue-class-wise affine permutations</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X829BA0537F2372FF">2.5-1 CTCSCRSplit</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X853885A182EC5104">2.5-2 FactorizationIntoCSCRCT</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X861C74E97AE5DA3B">2.5-3 PrimeSwitch</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X789CB69C7D97B0C4">2.5-4 mKnot</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X8141065381B0942B">2.6 <span class="Heading">
  Extracting roots of residue-class-wise affine mappings
</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X873692CE78433859">2.6-1 Root</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X8322C6848305EC4C">2.7 <span class="Heading">
  Special functions for non-bijective mappings
</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7AEFF16E86533633">2.7-1 RightInverse</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X87C5B9CA7E319233">2.7-2 CommonRightInverse</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X808D9EDF7BA27467">2.7-3 ImageDensity</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7A34724386A2E9F3">2.8 <span class="Heading">
  On trajectories and cycles of residue-class-wise affine mappings
</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7C72174D7CCB6348">2.8-1 <span class="Heading"> Trajectory (methods for rcwa mappings) </span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7FFD09837E934853">2.8-2 <span class="Heading">
    Trajectory (methods for rcwa mappings -- "accumulated coefficients")
  </span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7E0244A386744185">2.8-3 <span class="Heading"> IncreasingOn &amp; DecreasingOn (for an rcwa mapping) </span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X780841E07CAE7543">2.8-4 TransitionGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7F03CC4179424AA9">2.8-5 OrbitsModulo</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7F11051E866C197F">2.8-6 FactorizationOnConnectedComponents</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7B6833D67D916EF9">2.8-7 TransitionMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X81DBA2D58526BE7E">2.8-8 <span class="Heading"> Sources &amp; Sinks (of an rcwa mapping) </span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X80221A4D81AF7453">2.8-9 Loops</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X8773152E81A30123">2.8-10 GluckTaylorInvariant</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X84F6A29280E2F925">2.8-11 LikelyContractionCentre</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X81E0D8E3817B3D16">2.8-12 GuessedDivergence</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X86F0E0D17E6A9663">2.9 <span class="Heading">
  Saving memory -- the sparse representation of rcwa mappings
</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X879451B17AD78B07">2.9-1 SparseRepresentation</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X83FA71DD842377F0">2.10 <span class="Heading">The categories and families of rcwa mappings</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7927C13782729CE9">2.10-1 IsRcwaMapping</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X825DD365822934AF">2.10-2 RcwaMappingsFamily</a></span>
</div></div>
</div>

<h3>2 <span class="Heading">Residue-Class-Wise Affine Mappings</span></h3>

<p>This chapter contains the basic definitions, and it describes how to enter residue-class-wise affine mappings and how to compute with them.</p>

<p>How to compute with residue-class-wise affine groups is described in detail in the next chapter. The reader is encouraged to look there already after having read the first few pages of this chapter, and to look up definitions as he needs to.</p>

<p><a id="X78ED07E37FC2BD46" name="X78ED07E37FC2BD46"></a></p>

<h4>2.1 <span class="Heading">Basic definitions</span></h4>

<p>Residue-class-wise affine groups, or <em>rcwa</em> groups for short, are permutation groups whose elements are bijective residue-class-wise affine mappings.</p>

<p>A mapping <span class="SimpleMath">f: ℤ → ℤ</span> is called <em>residue-class-wise affine</em>, or for short an <em>rcwa</em> mapping, if there is a positive integer <span class="SimpleMath">m</span> such that the restrictions of <span class="SimpleMath">f</span> to the residue classes <span class="SimpleMath">r(m) ∈ ℤ/mℤ</span> are all affine, i.e. given by</p>

<p><center> <img src = "rcwamap.png" width = "366" height = "49" alt = "f|_r(m): n |-> (a_r(m) * n + b_r(m)) / c_r(m)" /> </center></p>

<p>for certain coefficients <span class="SimpleMath">a_r(m), b_r(m), c_r(m) ∈ ℤ</span> depending on <span class="SimpleMath">r(m)</span>. The smallest possible <span class="SimpleMath">m</span> is called the <em>modulus</em> of <span class="SimpleMath">f</span>. It is understood that all fractions are reduced, i.e. that <span class="SimpleMath">gcd( a_r(m), b_r(m), c_r(m) ) = 1</span>, and that <span class="SimpleMath">c_r(m) &gt; 0</span>. The lcm of the coefficients <span class="SimpleMath">a_r(m)</span> is called the <em>multiplier</em> of <span class="SimpleMath">f</span>, and the lcm of the coefficients <span class="SimpleMath">c_r(m)</span> is called the <em>divisor</em> of <span class="SimpleMath">f</span>.</p>

<p>It is easy to see that the residue-class-wise affine mappings of ℤ form a monoid under composition, and that the residue-class-wise affine permutations of ℤ form a countable subgroup of Sym(ℤ). We denote the former by Rcwa(ℤ), and the latter by RCWA(ℤ).</p>

<p>An rcwa mapping is called <em>tame</em> if the set of moduli of its powers is bounded, or equivalently if it permutes a partition of ℤ into finitely many residue classes on all of which it is affine. An rcwa group is called <em>tame</em> if there is a common such partition for all of its elements, or equivalently if the set of moduli of its elements is bounded. Rcwa mappings and -groups which are not tame are called <em>wild</em>. Tame rcwa mappings and -groups are something which one could call the "trivial cases" or "basic building blocks", while wild rcwa groups are the objects of primary interest.</p>

<p>The definitions of residue-class-wise affine mappings and -groups can be generalized in the obvious way to suitable rings other than ℤ. In fact, this package provides also some support for residue-class-wise affine groups over <span class="SimpleMath">ℤ^2</span>, over semilocalizations of ℤ and over univariate polynomial rings over finite fields. The ring <span class="SimpleMath">ℤ^2</span> has been chosen as an example of a suitable ring which is not a principal ideal domain, the semilocalizations of ℤ have been chosen as examples of rings with only finitely many prime elements, and the univariate polynomial rings over finite fields have been chosen as examples of rings with nonzero characteristic.</p>

<p><a id="X86BC55648302D643" name="X86BC55648302D643"></a></p>

<h4>2.2 <span class="Heading">Entering residue-class-wise affine mappings</span></h4>

<p>Entering an rcwa mapping of ℤ requires giving the modulus <span class="SimpleMath">m</span> and the coefficients <span class="SimpleMath">a_r(m)</span>, <span class="SimpleMath">b_r(m)</span> and <span class="SimpleMath">c_r(m)</span> for <span class="SimpleMath">r(m)</span> running over the residue classes (mod <span class="SimpleMath">m</span>).</p>

<p>This can be done easiest by <code class="code">RcwaMapping( <var class="Arg">coeffs</var> )</code>, where <var class="Arg">coeffs</var> is a list of <span class="SimpleMath">m</span> coefficient triples <code class="code">coeffs[</code><span class="SimpleMath">r+1</span><code class="code">] = [</code><span class="SimpleMath">a_r(m)</span>, <span class="SimpleMath">b_r(m)</span>, <span class="SimpleMath">c_r(m)</span><code class="code">]</code>, with <span class="SimpleMath">r</span> running from 0 to <span class="SimpleMath">m-1</span>.</p>

<p>If some coefficient <span class="SimpleMath">c_r(m)</span> is zero or if images of some integers under the mapping to be defined would not be integers, an error message is printed and a break loop is entered. For example, the coefficient triple <code class="code">[1,4,3]</code> is not allowed at the first position. The reason for this is that not all integers congruent to <span class="SimpleMath">1 ⋅ 0 + 4 = 4</span> mod <span class="SimpleMath">m</span> are divisible by 3.</p>

<p>For the general constructor for rcwa mappings, see <code class="func">RcwaMapping</code> (<a href="chap2.html#X8799551B83644B37"><span class="RefLink">2.2-5</span></a>).</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := RcwaMapping([[1,0,2],[3,1,2]]); # The Collatz mapping.</span>
&lt;rcwa mapping of Z with modulus 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ IsSurjective(T), IsInjective(T) ];</span>
[ true, false ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(T);</span>

Surjective rcwa mapping of Z with modulus 2

        /
        | n/2      if n in 0(2)
 n |-&gt; &lt;  (3n+1)/2 if n in 1(2)
        |
        \

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := RcwaMapping([[2,0,3],[4,-1,3],[4,1,3]]);</span>
&lt;rcwa mapping of Z with modulus 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsBijective(a);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(a); # This is Collatz' permutation:</span>

Rcwa permutation of Z with modulus 3

        /
        | 2n/3     if n in 0(3)
 n |-&gt; &lt;  (4n-1)/3 if n in 1(3)
        | (4n+1)/3 if n in 2(3)
        \

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Support(a);</span>
Z \ [ -1, 0, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Cycle(a,44);</span>
[ 44, 59, 79, 105, 70, 93, 62, 83, 111, 74, 99, 66 ]

</pre></div>

<p>There is computational evidence for the conjecture that any residue-class-wise affine permutation of ℤ can be factored into members of the following three series of permutations of particularly simple structure (cf. <code class="func">FactorizationIntoCSCRCT</code> (<a href="chap2.html#X853885A182EC5104"><span class="RefLink">2.5-2</span></a>)):</p>

<p><a id="X86B611BD7EED62A1" name="X86B611BD7EED62A1"></a></p>

<h5>2.2-1 ClassShift</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassShift</code>( <var class="Arg">r</var>, <var class="Arg">m</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassShift</code>( <var class="Arg">cl</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: the class shift <span class="SimpleMath">ν_r(m)</span>.</p>

<p>The <em>class shift</em> <span class="SimpleMath">ν_r(m)</span> is the rcwa mapping of ℤ which maps <span class="SimpleMath">n ∈ r(m)</span> to <span class="SimpleMath">n + m</span> and which fixes <span class="SimpleMath">ℤ ∖ r(m)</span> pointwise.</p>

<p>In the one-argument form, the argument <var class="Arg">cl</var> stands for the residue class <span class="SimpleMath">r(m)</span>. Enclosing the argument list in list brackets is permitted.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(ClassShift(5,12));</span>

Tame rcwa permutation of Z with modulus 12, of order infinity

        /
        | n+12 if n in 5(12)
 n |-&gt; &lt;  n    if n in Z \ 5(12)
        |
        \

</pre></div>

<p><a id="X7896C5417E3692B4" name="X7896C5417E3692B4"></a></p>

<h5>2.2-2 ClassReflection</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassReflection</code>( <var class="Arg">r</var>, <var class="Arg">m</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassReflection</code>( <var class="Arg">cl</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: the class reflection <span class="SimpleMath">ς_r(m)</span>.</p>

<p>The <em>class reflection</em> <span class="SimpleMath">ς_r(m)</span> is the rcwa mapping of ℤ which maps <span class="SimpleMath">n ∈ r(m)</span> to <span class="SimpleMath">-n + 2r</span> and which fixes <span class="SimpleMath">ℤ ∖ r(m)</span> pointwise, where it is understood that <span class="SimpleMath">0 ≤ r &lt; m</span>.</p>

<p>In the one-argument form, the argument <var class="Arg">cl</var> stands for the residue class <span class="SimpleMath">r(m)</span>. Enclosing the argument list in list brackets is permitted.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(ClassReflection(5,9));</span>

Rcwa permutation of Z with modulus 9, of order 2

        /
        | -n+10 if n in 5(9)
 n |-&gt; &lt;  n     if n in Z \ 5(9)
        |
        \

</pre></div>

<p><a id="X8716A75F7DD1C46B" name="X8716A75F7DD1C46B"></a></p>

<h5>2.2-3 ClassTransposition</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassTransposition</code>( <var class="Arg">r1</var>, <var class="Arg">m1</var>, <var class="Arg">r2</var>, <var class="Arg">m2</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassTransposition</code>( <var class="Arg">cl1</var>, <var class="Arg">cl2</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: the class transposition <span class="SimpleMath">τ_r_1(m_1),r_2(m_2)</span>.</p>

<p>Given two disjoint residue classes <span class="SimpleMath">r_1(m_1)</span> and <span class="SimpleMath">r_2(m_2)</span> of the integers, the <em>class transposition</em> <span class="SimpleMath">τ_r_1(m_1),r_2(m_2)</span> <span class="SimpleMath">∈</span> RCWA(ℤ) is defined as the involution which interchanges <span class="SimpleMath">r_1+km_1</span> and <span class="SimpleMath">r_2+km_2</span> for any integer <span class="SimpleMath">k</span> and which fixes all other points. It is understood that <span class="SimpleMath">m_1</span> and <span class="SimpleMath">m_2</span> are positive, that <span class="SimpleMath">0 ≤ r_1 &lt; m_1</span> and that <span class="SimpleMath">0 ≤ r_2 &lt; m_2</span>. For a <em>generalized class transposition</em>, the latter assumptions are not made.</p>

<p>The class transposition <span class="SimpleMath">τ_r_1(m_1),r_2(m_2)</span> interchanges the residue classes <span class="SimpleMath">r_1(m_1)</span> and <span class="SimpleMath">r_2(m_2)</span> and fixes the complement of their union pointwise.</p>

<p>In the four-argument form, the arguments <var class="Arg">r1</var>, <var class="Arg">m1</var>, <var class="Arg">r2</var> and <var class="Arg">m2</var> stand for <span class="SimpleMath">r_1</span>, <span class="SimpleMath">m_1</span>, <span class="SimpleMath">r_2</span> and <span class="SimpleMath">m_2</span>, respectively. In the two-argument form, the arguments <var class="Arg">cl1</var> and <var class="Arg">cl2</var> stand for the residue classes <span class="SimpleMath">r_1(m_1)</span> and <span class="SimpleMath">r_2(m_2)</span>, respectively. Enclosing the argument list in list brackets is permitted. The residue classes <span class="SimpleMath">r_1(m_1)</span> and <span class="SimpleMath">r_2(m_2)</span> are stored as an attribute <code class="code">TransposedClasses</code>.</p>

<p>A list of all class transpositions interchanging residue classes with moduli less than or equal to a given bound <var class="Arg">m</var> can be obtained by <code class="code">List(ClassPairs([<var class="Arg">P</var>],<var class="Arg">m</var>),ClassTransposition)</code>, where the function <code class="code">ClassPairs</code> returns a list of all 4-tuples <span class="SimpleMath">(r_1,m_1,r_2,m_2)</span> of integers corresponding to the unordered pairs of disjoint residue classes <span class="SimpleMath">r_1(m_1)</span> and <span class="SimpleMath">r_2(m_2)</span> with <span class="SimpleMath">m_1</span> and <span class="SimpleMath">m_2</span> less than or equal to the specified bound. If a list of primes is given as optional argument <var class="Arg">P</var>, then the returned list contains only those 4-tuples where all prime factors of <span class="SimpleMath">m_1</span> and <span class="SimpleMath">m_2</span> lie in <var class="Arg">P</var>. If the option <code class="code">divisors</code> is set, the returned list contains only the 4-tuples where <span class="SimpleMath">m_1</span> and <span class="SimpleMath">m_2</span> divide <var class="Arg">m</var>.</p>

<p>The function <code class="code">NrClassPairs(<var class="Arg">m</var>)</code> returns the length of the list <code class="code">ClassPairs(<var class="Arg">m</var>)</code>, where the result is computed much faster and without actually generating the list of tuples. Given a class transposition <var class="Arg">ct</var>, the corresponding 4-tuple can be obtained by <code class="code">ExtRepOfObj(<var class="Arg">ct</var>)</code></p>

<p>A class transposition can be written as a product of any given number <span class="SimpleMath">k</span> of class transpositions. Such a decomposition can be obtained by <code class="code">SplittedClassTransposition(<var class="Arg">ct</var>,<var class="Arg">k</var>)</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(ClassTransposition(1,2,8,10):CycleNotation:=false);</span>

Rcwa permutation of Z with modulus 10, of order 2

        /
        | 5n+3    if n in 1(2)
 n |-&gt; &lt;  (n-3)/5 if n in 8(10)
        | n       if n in 0(2) \ 8(10)
        \

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(ClassPairs(4),ClassTransposition);</span>
[ ( 0(2), 1(2) ), ( 0(2), 1(4) ), ( 0(2), 3(4) ), ( 0(3), 1(3) ), 
  ( 0(3), 2(3) ), ( 0(4), 1(4) ), ( 0(4), 2(4) ), ( 0(4), 3(4) ), 
  ( 1(2), 0(4) ), ( 1(2), 2(4) ), ( 1(3), 2(3) ), ( 1(4), 2(4) ), 
  ( 1(4), 3(4) ), ( 2(4), 3(4) ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrClassPairs(100);</span>
3528138
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SplittedClassTransposition(ClassTransposition(0,2,1,4),3);</span>
[ ( 0(6), 1(12) ), ( 2(6), 5(12) ), ( 4(6), 9(12) ) ]
</pre></div>

<p>The set of all class transpositions of the ring of integers generates the simple group CT(ℤ) mentioned in Chapter <a href="chap1.html#X83A8C2927FAE2C23"><span class="RefLink">1</span></a>. This group has a representation as a <strong class="pkg">GAP</strong> object -- see <code class="func">CT</code> (<a href="chap3.html#X7BD42D8481300E25"><span class="RefLink">3.1-9</span></a>). The set of all generalized class transpositions of ℤ generates a simple group as well, cf. <a href="chapBib.html#biBKohl09">[Koh10]</a>.</p>

<p>Class shifts, class reflections and class transpositions of rings <span class="SimpleMath">R</span> other than ℤ are defined in an entirely analogous way -- all one needs to do is to replace ℤ by <span class="SimpleMath">R</span> and to read <span class="SimpleMath">&lt;</span> and <span class="SimpleMath">≤</span> in the sense of the ordering used by <strong class="pkg">GAP</strong>. They can also be entered basically as described above -- just prepend the desired ring <span class="SimpleMath">R</span> to the argument list. Often also a sensible "default ring" (<span class="SimpleMath">→</span> <code class="code">DefaultRing</code> in the <strong class="pkg">GAP</strong> Reference Manual) is chosen if that optional first argument is omitted.</p>

<p>On rings which have more than two units, there is another basic series of rcwa permutations which generalizes class reflections:</p>

<p><a id="X87EB8C1C87F78A17" name="X87EB8C1C87F78A17"></a></p>

<h5>2.2-4 ClassRotation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassRotation</code>( <var class="Arg">r</var>, <var class="Arg">m</var>, <var class="Arg">u</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassRotation</code>( <var class="Arg">cl</var>, <var class="Arg">u</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: the class rotation <span class="SimpleMath">ρ_r(m),u</span>.</p>

<p>Given a residue class <span class="SimpleMath">r(m)</span> and a unit <span class="SimpleMath">u</span> of a suitable ring <span class="SimpleMath">R</span>, the <em>class rotation</em> <span class="SimpleMath">ρ_r(m),u</span> is the rcwa mapping which maps <span class="SimpleMath">n ∈ r(m)</span> to <span class="SimpleMath">un + (1-u)r</span> and which fixes <span class="SimpleMath">R ∖ r(m)</span> pointwise. Class rotations generalize class reflections, as we have <span class="SimpleMath">ρ_r(m),-1 = ς_r(m)</span>.</p>

<p>In the two-argument form, the argument <var class="Arg">cl</var> stands for the residue class <span class="SimpleMath">r(m)</span>. Enclosing the argument list in list brackets is permitted. The argument <var class="Arg">u</var> is stored as an attribute <code class="code">RotationFactor</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(ClassRotation(ResidueClass(Z_pi(2),2,1),1/3));</span>

Tame rcwa permutation of Z_( 2 ) with modulus 2, of order infinity

        /
        | 1/3 n + 2/3 if n in 1(2)
 n |-&gt; &lt;  n           if n in 0(2)
        |
        \

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := Indeterminate(GF(8),1);; SetName(x,"x");</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := PolynomialRing(GF(8),1);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cr := ClassRotation(1,x,Z(8)*One(R)); Support(cr);</span>
ClassRotation( 1(x), Z(2^3) )
1(x) \ [ 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(cr);</span>

Rcwa permutation of GF(2^3)[x] with modulus x, of order 7

        /
        | Z(2^3)*P + Z(2^3)^3 if P in 1(x)
 P |-&gt; &lt;  P                   otherwise
        |
        \

</pre></div>

<p><code class="code">IsClassShift</code>, <code class="code">IsClassReflection</code>, <code class="code">IsClassRotation</code>, <code class="code">IsClassTransposition</code> and <code class="code">IsGeneralizedClassTransposition</code> are properties which indicate whether a given rcwa mapping belongs to the corresponding series.</p>

<p>In the sequel we describe the general-purpose constructor for rcwa mappings. The constructor may look a bit technical on a first glance, but knowing all possible ways of entering an rcwa mapping is by no means necessary for understanding this manual or for using this package.</p>

<p><a id="X8799551B83644B37" name="X8799551B83644B37"></a></p>

<h5>2.2-5 <span class="Heading"> RcwaMapping (the general constructor) </span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RcwaMapping</code>( <var class="Arg">R</var>, <var class="Arg">m</var>, <var class="Arg">coeffs</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RcwaMapping</code>( <var class="Arg">R</var>, <var class="Arg">coeffs</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RcwaMapping</code>( <var class="Arg">coeffs</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RcwaMapping</code>( <var class="Arg">perm</var>, <var class="Arg">range</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RcwaMapping</code>( <var class="Arg">m</var>, <var class="Arg">values</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RcwaMapping</code>( <var class="Arg">pi</var>, <var class="Arg">coeffs</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RcwaMapping</code>( <var class="Arg">q</var>, <var class="Arg">m</var>, <var class="Arg">coeffs</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RcwaMapping</code>( <var class="Arg">P1</var>, <var class="Arg">P2</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RcwaMapping</code>( <var class="Arg">cycles</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RcwaMapping</code>( <var class="Arg">expression</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: an rcwa mapping.</p>

<p>In all cases the argument <var class="Arg">R</var> is the underlying ring, <var class="Arg">m</var> is the modulus and <var class="Arg">coeffs</var> is the coefficient list. A <em>coefficient list</em> for an rcwa mapping with modulus <span class="SimpleMath">m</span> consists of <span class="SimpleMath">|R/mR|</span> coefficient triples <code class="code">[</code><span class="SimpleMath">a_r(m)</span>, <span class="SimpleMath">b_r(m)</span>, <span class="SimpleMath">c_r(m)</span><code class="code">]</code>. Their ordering is determined by the ordering of the representatives of the residue classes (mod <span class="SimpleMath">m</span>) in the sorted list returned by <code class="code">AllResidues(<var class="Arg">R</var>, <var class="Arg">m</var>)</code>. In case <span class="SimpleMath">R = ℤ</span> this means that the coefficient triple for the residue class <span class="SimpleMath">0(m)</span> comes first and is followed by the one for <span class="SimpleMath">1(m)</span>, the one for <span class="SimpleMath">2(m)</span> and so on.</p>

<p>If one or several of the arguments <var class="Arg">R</var>, <var class="Arg">m</var> and <var class="Arg">coeffs</var> are omitted or replaced by other arguments, the former are either derived from the latter or default values are chosen. The meaning of the other arguments is defined in the detailed description of the particular methods given in the sequel. The above methods return the rcwa mapping</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p>of <var class="Arg">R</var> with modulus <var class="Arg">m</var> and coefficients <var class="Arg">coeffs</var>,</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p>of <var class="Arg">R</var> = ℤ or <var class="Arg">R</var> = <span class="SimpleMath">ℤ_(π)</span> with modulus <code class="code">Length(<var class="Arg">coeffs</var>)</code> and coefficients <var class="Arg">coeffs</var>,</p>

</dd>
<dt><strong class="Mark">(c)</strong></dt>
<dd><p>of <var class="Arg">R</var> = ℤ with modulus <code class="code">Length(<var class="Arg">coeffs</var>)</code> and coefficients <var class="Arg">coeffs</var>,</p>

</dd>
<dt><strong class="Mark">(d)</strong></dt>
<dd><p>of <var class="Arg">R</var> = ℤ, permuting any set <code class="code"><var class="Arg">range</var>+k*Length(<var class="Arg">range</var>)</code> like <var class="Arg">perm</var> permutes <var class="Arg">range</var>,</p>

</dd>
<dt><strong class="Mark">(e)</strong></dt>
<dd><p>of <var class="Arg">R</var> = ℤ with modulus <var class="Arg">m</var> and values given by a list <var class="Arg">val</var> of 2 pairs <code class="code">[</code>preimage<code class="code">, </code>image<code class="code">]</code> per residue class (mod <var class="Arg">m</var>),</p>

</dd>
<dt><strong class="Mark">(f)</strong></dt>
<dd><p>of <var class="Arg">R</var> = <span class="SimpleMath">ℤ_(π)</span> with modulus <code class="code">Length(<var class="Arg">coeffs</var>)</code> and coefficients <var class="Arg">coeffs</var> (the set of primes <span class="SimpleMath">π</span> which denotes the underlying ring is passed as argument <var class="Arg">pi</var>),</p>

</dd>
<dt><strong class="Mark">(g)</strong></dt>
<dd><p>of <var class="Arg">R</var> = GF(<var class="Arg">q</var>)[<var class="Arg">x</var>] with modulus <var class="Arg">m</var> and coefficients <var class="Arg">coeffs</var>,</p>

</dd>
<dt><strong class="Mark">(h)</strong></dt>
<dd><p>an rcwa permutation which induces a bijection between the partitions <var class="Arg">P1</var> and <var class="Arg">P2</var> of <var class="Arg">R</var> into residue classes and which is affine on the elements of <var class="Arg">P1</var>,</p>

</dd>
<dt><strong class="Mark">(i)</strong></dt>
<dd><p>an rcwa permutation with "residue class cycles" given by a list <var class="Arg">cycles</var> of lists of pairwise disjoint residue classes, each of which it permutes cyclically, or</p>

</dd>
<dt><strong class="Mark">(j)</strong></dt>
<dd><p>the rcwa permutation of ℤ given by the arithmetical expression <var class="Arg">expression</var> -- a string consisting of class transpositions (e.g. <code class="code">"(0(2),1(4))"</code>) or cycles permuting residue classes (e.g. <code class="code">"(0(2),1(8),3(4),5(8))"</code>), class shifts (e.g. <code class="code">"cs(4(6))"</code>, class reflections (e.g. <code class="code">"cr(3(4))"</code>), arithmetical operators (<code class="code">"*"</code>, <code class="code">"/"</code> and <code class="code">"^"</code>) and brackets (<code class="code">"("</code>, <code class="code">")"</code>),</p>

</dd>
</dl>
<p>respectively. The methods for the operation <code class="code">RcwaMapping</code> perform a number of argument checks, which can be skipped by using <code class="code">RcwaMappingNC</code> instead.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := PolynomialRing(GF(2),1);; x := X(GF(2),1);; SetName(x,"x");</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RcwaMapping(R,x+1,[[1,0,x+One(R)],[x+One(R),0,1]]*One(R));     # (a)</span>
&lt;rcwa mapping of GF(2)[x] with modulus x+1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RcwaMapping(Z_pi(2),[[1/3,0,1]]);                              # (b)</span>
Rcwa mapping of Z_( 2 ): n -&gt; 1/3 n
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := RcwaMapping([[2,0,3],[4,-1,3],[4,1,3]]);                  # (c)</span>
&lt;rcwa mapping of Z with modulus 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RcwaMapping((1,2,3),[1..4]);                                   # (d)</span>
( 1(4), 2(4), 3(4) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T = RcwaMapping(2,[[1,2],[2,1],[3,5],[4,2]]);                  # (e)</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RcwaMapping([2],[[1/3,0,1]]);                                  # (f)</span>
Rcwa mapping of Z_( 2 ): n -&gt; 1/3 n
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RcwaMapping(2,x+1,[[1,0,x+One(R)],[x+One(R),0,1]]*One(R));     # (g)</span>
&lt;rcwa mapping of GF(2)[x] with modulus x+1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a = RcwaMapping(List([[0,3],[1,3],[2,3]],ResidueClass),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   List([[0,2],[1,4],[3,4]],ResidueClass));       # (h)</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RcwaMapping([List([[0,2],[1,4],[3,8],[7,16]],ResidueClass)]);  # (i)</span>
( 0(2), 1(4), 3(8), 7(16) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Cycle(last,ResidueClass(0,2));</span>
[ 0(2), 1(4), 3(8), 7(16) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := RcwaMapping("((0(4),1(6))*cr(0(6)))^2/cs(2(8))");         # (j)</span>
&lt;rcwa permutation of Z with modulus 72&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g = (ClassTransposition(0,4,1,6) * ClassReflection(0,6))^2/</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ClassShift(2,8);</span>
true

</pre></div>

<p>Rcwa mappings of ℤ can be "translated" to rcwa mappings of some semilocalization <span class="SimpleMath">ℤ_(π)</span> of ℤ:</p>

<p><a id="X7F1A559387D0226E" name="X7F1A559387D0226E"></a></p>

<h5>2.2-6 LocalizedRcwaMapping</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LocalizedRcwaMapping</code>( <var class="Arg">f</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SemilocalizedRcwaMapping</code>( <var class="Arg">f</var>, <var class="Arg">pi</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: the rcwa mapping of <span class="SimpleMath">ℤ_(p)</span> respectively <span class="SimpleMath">ℤ_(π)</span> with the same coefficients as the rcwa mapping <var class="Arg">f</var> of ℤ.</p>

<p>The argument <var class="Arg">p</var> or <var class="Arg">pi</var> must be a prime or a set of primes, respectively. The argument <var class="Arg">f</var> must be an rcwa mapping of ℤ whose modulus is a power of <var class="Arg">p</var>, or whose modulus has only prime divisors which lie in <var class="Arg">pi</var>, respectively.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := RcwaMapping([[1,0,2],[3,1,2]]);; # The Collatz mapping.</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Cycle(LocalizedRcwaMapping(T,2),131/13);</span>
[ 131/13, 203/13, 311/13, 473/13, 716/13, 358/13, 179/13, 275/13, 
  419/13, 635/13, 959/13, 1445/13, 2174/13, 1087/13, 1637/13, 2462/13, 
  1231/13, 1853/13, 2786/13, 1393/13, 2096/13, 1048/13, 524/13, 262/13 ]

</pre></div>

<p>Rcwa mappings can be <code class="code">View</code>ed, <code class="code">Display</code>ed, <code class="code">Print</code>ed and written to a <code class="code">String</code>. The output of the <code class="code">View</code> method is kept reasonably short. In most cases it does not describe an rcwa mapping completely. In these cases the output is enclosed in brackets. There are options <code class="code">CycleNotation</code>, <code class="code">AsClassMapping</code>, <code class="code">PrintNotation</code> and <code class="code">AbridgedNotation</code> to take influence on how certain rcwa mappings are shown. These options can either be not set, set to <code class="code">true</code> or set to <code class="code">false</code>. If the option <code class="code">CycleNotation</code> is set, it is tried harder to write down an rcwa permutation of ℤ of finite order as a product of disjoint residue class cycles, if this is possible. If the option <code class="code">AsClassMapping</code> is set, <code class="code">Display</code> shows which residue classes are mapped to which by the affine partial mappings, and marks any loops. The option <code class="code">PrintNotation</code> influences the output in favour of <strong class="pkg">GAP</strong> - readability, and the option <code class="code">AbridgedNotation</code> can be used to abridge longer names like <code class="code">ClassShift</code>, <code class="code">ClassReflection</code> etc.. By default, the output of the methods for <code class="code">Display</code> and <code class="code">Print</code> describes an rcwa mapping in full. The <code class="code">Print</code>ed representation of an rcwa mapping is <strong class="pkg">GAP</strong> - readable if and only if the <code class="code">Print</code>ed representation of the elements of the underlying ring is so.</p>

<p>There is also an operation <code class="code">LaTeXStringRcwaMapping</code>, which takes as argument an rcwa mapping and returns a corresponding LaTeX string. The output makes use of the LaTeX macro package <strong class="pkg">amsmath</strong>. If the option <var class="Arg">Factorization</var> is set and the argument is bijective, a factorization into class shifts, class reflections, class transpositions and prime switches is printed (cf. <code class="func">FactorizationIntoCSCRCT</code> (<a href="chap2.html#X853885A182EC5104"><span class="RefLink">2.5-2</span></a>)). For rcwa mappings with modulus greater than 1, an indentation by <var class="Arg">Indentation</var> characters can be obtained by setting this option value accordingly.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Print(LaTeXStringRcwaMapping(T));</span>
n \ \mapsto \
\begin{cases}
  n/2      &amp; \text{if} \ n \in 0(2), \\
  (3n+1)/2 &amp; \text{if} \ n \in 1(2).
\end{cases}

</pre></div>

<p>There is an operation <code class="code">LaTeXAndXDVI</code> which displays an rcwa mapping in an <strong class="pkg">xdvi</strong> window. This works as follows: The string returned by <code class="code">LaTeXStringRcwaMapping</code> is inserted into a LaTeX template file. This file is LaTeX'ed, and the result is shown with <strong class="pkg">xdvi</strong>. Calling <code class="code">Display</code> with option <var class="Arg">xdvi</var> has the same effect. The operation <code class="code">LaTeXAndXDVI</code> is only available on UNIX systems, and requires suitable installations of LaTeX and <strong class="pkg">xdvi</strong>.</p>

<p><a id="X78E796B8824C4FC8" name="X78E796B8824C4FC8"></a></p>

<h4>2.3 <span class="Heading">Basic arithmetic for residue-class-wise affine mappings</span></h4>

<p>Testing rcwa mappings for equality requires only comparing their coefficient lists, hence is cheap. Rcwa mappings can be multiplied, thus there is a method for <code class="code">*</code>. Rcwa permutations can also be inverted, thus there is a method for <code class="code">Inverse</code>. The latter method is usually accessed by raising a mapping to a power with negative exponent. Multiplying, inverting and computing powers of tame rcwa mappings is cheap. Computing powers of wild mappings is usually expensive -- run time and memory requirements normally grow approximately exponentially with the exponent. How expensive multiplying a couple of wild mappings is, varies very much. In any case, the amount of memory required for storing an rcwa mapping is proportional to its modulus. Whether a given mapping is tame or wild can be determined by the operation <code class="code">IsTame</code>. There is a method for <code class="code">Order</code>, which can not only compute a finite order, but which can also detect infinite order.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := RcwaMapping([[1,0,2],[3,1,2]]);;          # The Collatz mapping.</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := RcwaMapping([[2,0,3],[4,-1,3],[4,1,3]]);; # Collatz' permutation.</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List([-4..4],k-&gt;Modulus(a^k));</span>
[ 256, 64, 16, 4, 1, 3, 9, 27, 81 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsTame(T) or IsTame(a);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsTame(ClassShift(0,1)) and IsTame(ClassTransposition(0,2,1,2));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T^2*a*T*a^-3;</span>
&lt;rcwa mapping of Z with modulus 768&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">(ClassShift(1,3)*ClassReflection(2,7))^1000000;</span>
&lt;rcwa permutation of Z with modulus 21&gt;

</pre></div>

<p>There are methods installed for <code class="code">IsInjective</code>, <code class="code">IsSurjective</code>, <code class="code">IsBijective</code> and <code class="code">Image</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ IsInjective(T), IsSurjective(T), IsBijective(a) ];</span>
[ false, true, true ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Image(RcwaMapping([[2,0,1]]));</span>
0(2)

</pre></div>

<p>Images of elements, of finite sets of elements and of unions of finitely many residue classes of the source of an rcwa mapping can be computed with <code class="code">^</code>, the same symbol as used for exponentiation and conjugation. The same works for partitions of the source into a finite number of residue classes.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">15^T;</span>
23
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ResidueClass(1,2)^T;</span>
2(3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List([[0,3],[1,3],[2,3]],ResidueClass)^a;</span>
[ 0(2), 1(4), 3(4) ]

</pre></div>

<p>For computing preimages of elements under rcwa mappings, there are methods for <code class="code">PreImageElm</code> and <code class="code">PreImagesElm</code>. The preimage of a finite set of ring elements or of a union of finitely many residue classes under an rcwa mapping can be computed by <code class="code">PreImage</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreImagesElm(T,8);</span>
[ 5, 16 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreImage(T,ResidueClass(Integers,3,2));</span>
Z \ 0(6) U 2(6)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := [1];; l := [1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">while Length(M) &lt; 5000 do M := PreImage(T,M); Add(l,Length(M)); od; l;</span>
[ 1, 1, 2, 2, 4, 5, 8, 10, 14, 18, 26, 36, 50, 67, 89, 117, 157, 208, 
  277, 367, 488, 649, 869, 1154, 1534, 2039, 2721, 3629, 4843, 6458 ]

</pre></div>

<p>There is a method for the operation <code class="code">Support</code> for computing the support of an rcwa mapping. A synonym for <code class="code">Support</code> is <code class="code">MovedPoints</code>. The natural density of the support of an rcwa mapping of ℤ can be computed efficiently with the operation <code class="code">DensityOfSupport</code>. Likewise, the natural density of the set of fixed points of an rcwa mapping of ℤ can be computed efficiently with the operation <code class="code">DensityOfSetOfFixedPoints</code>. There is also a method for <code class="code">RestrictedPerm</code> for computing the restriction of an rcwa permutation to a union of residue classes which it fixes setwise.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List([a,a^2],Support);</span>
[ Z \ [ -1, 0, 1 ], Z \ [ -3, -2, -1, 0, 1, 2, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RestrictedPerm(ClassShift(0,2)*ClassReflection(1,2),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  ResidueClass(0,2));</span>
&lt;rcwa mapping of Z with modulus 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">last = ClassShift(0,2);</span>
true

</pre></div>

<p>Rcwa mappings can be added and subtracted pointwise. However, please note that the set of rcwa mappings of a ring does not form a ring under <code class="code">+</code> and <code class="code">*</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b := ClassShift(0,3) * a;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ Image((a + b)), Image((a - b)) ];</span>
[ 2(4), [ -2, 0 ] ]

</pre></div>

<p>There are operations <code class="code">Modulus</code> (abbreviated <code class="code">Mod</code>) and <code class="code">Coefficients</code> for retrieving the modulus and the coefficient list of an rcwa mapping. The meaning of the return values is as described in Section <a href="chap2.html#X86BC55648302D643"><span class="RefLink">2.2</span></a>.</p>

<p>General documentation for most operations mentioned in this section can be found in the <strong class="pkg">GAP</strong> reference manual. For rcwa mappings of rings other than ℤ, not for all operations applicable methods are available.</p>

<p>As in general a subring relation <span class="SimpleMath">R_1&lt;R_2</span> does <em>not</em> give rise to a natural embedding of RCWA(<span class="SimpleMath">R_1</span>) into RCWA(<span class="SimpleMath">R_2</span>), there is no coercion between rcwa mappings or rcwa groups over different rings.</p>

<p><a id="X7C16D22C7BD40FDC" name="X7C16D22C7BD40FDC"></a></p>

<h4>2.4 <span class="Heading">
  Attributes and properties of residue-class-wise affine mappings
</span></h4>

<p>A number of basic attributes and properties of an rcwa mapping are derived immediately from the coefficients of its affine partial mappings. This holds for example for the multiplier and the divisor. These two values are stored as attributes <code class="code">Multiplier</code> and <code class="code">Divisor</code>, or for short <code class="code">Mult</code> and <code class="code">Div</code>. The <em>prime set</em> of an rcwa mapping is the set of prime divisors of the product of its modulus and its multiplier. It is stored as an attribute <code class="code">PrimeSet</code>. The <em>maximal shift</em> of an rcwa mapping of ℤ is the maximum of the absolute values of its coefficients <span class="SimpleMath">b_r(m)</span> in the notation introduced in Section <a href="chap2.html#X78ED07E37FC2BD46"><span class="RefLink">2.1</span></a>. It is stored as an attribute <code class="code">MaximalShift</code>. An rcwa mapping is called <em>class-wise translating</em> if all of its affine partial mappings are translations, it is called <em>integral</em> if its divisor equals 1, and it is called <em>balanced</em> if its multiplier and its divisor have the same prime divisors. A class-wise translating mapping has the property <code class="code">IsClassWiseTranslating</code>, an integral mapping has the property <code class="code">IsIntegral</code> and a balanced mapping has the property <code class="code">IsBalanced</code>. An rcwa mapping of the ring of integers or of one of its semilocalizations is called <em>class-wise order-preserving</em> if and only if all coefficients <span class="SimpleMath">a_r(m)</span> (cf. Section <a href="chap2.html#X78ED07E37FC2BD46"><span class="RefLink">2.1</span></a>) in the numerators of the affine partial mappings are positive. The corresponding property is <code class="code">IsClassWiseOrderPreserving</code>. An rcwa mapping of ℤ is called <em>sign-preserving</em> if it does not map nonnegative integers to negative integers or vice versa. The corresponding property is <code class="code">IsSignPreserving</code>. All elements of the simple group CT(ℤ) generated by the set of all class transpositions are sign-preserving.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := RcwaMapping([[3,0,5],[9,1,5],[3,-1,5],[9,-2,5],[9,4,5]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsBijective(u);; Display(u);</span>

Rcwa permutation of Z with modulus 5

        /
        | 3n/5     if n in 0(5)
        | (9n+1)/5 if n in 1(5)
 n |-&gt; &lt;  (3n-1)/5 if n in 2(5)
        | (9n-2)/5 if n in 3(5)
        | (9n+4)/5 if n in 4(5)
        \

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Multiplier(u);</span>
9
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Divisor(u);</span>
5
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrimeSet(u);</span>
[ 3, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIntegral(u) or IsBalanced(u);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsClassWiseOrderPreserving(u) and IsSignPreserving(u);</span>
true

</pre></div>

<p>There are a couple of further attributes and operations related to the affine partial mappings of an rcwa mapping:</p>

<p><a id="X7C21406085B69C30" name="X7C21406085B69C30"></a></p>

<h5>2.4-1 LargestSourcesOfAffineMappings</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LargestSourcesOfAffineMappings</code>( <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: the coarsest partition of <code class="code">Source(<var class="Arg">f</var>)</code> on whose elements the rcwa mapping <var class="Arg">f</var> is affine.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LargestSourcesOfAffineMappings(ClassShift(3,7));</span>
[ Z \ 3(7), 3(7) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LargestSourcesOfAffineMappings(ClassReflection(0,1));</span>
[ Integers ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := RcwaMapping([[3,0,5],[9,1,5],[3,-1,5],[9,-2,5],[9,4,5]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( [ u, u^-1 ], LargestSourcesOfAffineMappings );</span>
[ [ 0(5), 1(5), 2(5), 3(5), 4(5) ], [ 0(3), 1(3), 2(9), 5(9), 8(9) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">kappa := ClassTransposition(2,4,3,4) * ClassTransposition(4,6,8,12)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          * ClassTransposition(3,4,4,6);</span>
&lt;rcwa permutation of Z with modulus 12&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LargestSourcesOfAffineMappings(kappa);</span>
[ 2(4), 1(4) U 0(12), 3(12) U 7(12), 4(12), 8(12), 11(12) ]

</pre></div>

<p><a id="X7D6D0F2783AD02F4" name="X7D6D0F2783AD02F4"></a></p>

<h5>2.4-2 FixedPointsOfAffinePartialMappings</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FixedPointsOfAffinePartialMappings</code>( <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a list of the sets of fixed points of the affine partial mappings of the rcwa mapping <var class="Arg">f</var> in the quotient field of its source.</p>

<p>The returned list contains entries for the restrictions of <var class="Arg">f</var> to all residue classes modulo <code class="code">Mod(<var class="Arg">f</var>)</code>. A list entry can either be an empty set, the source of <var class="Arg">f</var> or a set of cardinality 1. The ordering of the entries corresponds to the ordering of the residues in <code class="code">AllResidues(Source(<var class="Arg">f</var>),<var class="Arg">m</var>)</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FixedPointsOfAffinePartialMappings(ClassShift(0,2));</span>
[ [  ], Rationals ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List([1..3],k-&gt;FixedPointsOfAffinePartialMappings(T^k));</span>
[ [ [ 0 ], [ -1 ] ], [ [ 0 ], [ 1 ], [ 2 ], [ -1 ] ], 
  [ [ 0 ], [ -7 ], [ 2/5 ], [ -5 ], [ 4/5 ], [ 1/5 ], [ -10 ], [ -1 ] ] ]

</pre></div>

<p><a id="X7A2E308C860B46E3" name="X7A2E308C860B46E3"></a></p>

<h5>2.4-3 Multpk</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Multpk</code>( <var class="Arg">f</var>, <var class="Arg">p</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: the union of the residue classes <span class="SimpleMath">r(m)</span> such that <span class="SimpleMath">p^k||a_r(m)</span> if <span class="SimpleMath">k ≥ 0</span>, and the union of the residue classes <span class="SimpleMath">r(m)</span> such that <span class="SimpleMath">p^k||c_r(m)</span> if <span class="SimpleMath">k ≤ 0</span>. In this context, <span class="SimpleMath">m</span> denotes the modulus of <var class="Arg">f</var>, and <span class="SimpleMath">a_r(m)</span> and <span class="SimpleMath">c_r(m)</span> denote the coefficients of <var class="Arg">f</var> as introduced in Section <a href="chap2.html#X78ED07E37FC2BD46"><span class="RefLink">2.1</span></a>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := RcwaMapping([[1,0,2],[3,1,2]]);; # The Collatz mapping.</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ Multpk(T,2,-1), Multpk(T,3,1) ];</span>
[ Integers, 1(2) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := RcwaMapping([[3,0,5],[9,1,5],[3,-1,5],[9,-2,5],[9,4,5]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ Multpk(u,3,0), Multpk(u,3,1), Multpk(u,3,2), Multpk(u,5,-1) ];</span>
[ [  ], 0(5) U 2(5), Z \ 0(5) U 2(5), Integers ]

</pre></div>

<p>There are attributes <code class="code">ClassWiseOrderPreservingOn</code>, <code class="code">ClassWiseConstantOn</code> and <code class="code">ClassWiseOrderReversingOn</code> which store the union of the residue classes (mod <code class="code">Mod(<var class="Arg">f</var>)</code>) on which an rcwa mapping <var class="Arg">f</var> of ℤ or of a semilocalization thereof is class-wise order-preserving, class-wise constant or class-wise order-reversing, respectively.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List([ClassTransposition(1,2,0,4),ClassShift(2,3),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         ClassReflection(2,5)],ClassWiseOrderPreservingOn);</span>
[ Integers, Integers, Z \ 2(5) ]

</pre></div>

<p>Also there are attributes <code class="code">ShiftsUpOn</code> and <code class="code">ShiftsDownOn</code> which store the union of the residue classes (mod <code class="code">Mod(<var class="Arg">f</var>)</code>) on which an rcwa mapping <var class="Arg">f</var> of ℤ induces affine mappings <span class="SimpleMath">n ↦ n + c</span> for <span class="SimpleMath">c &gt; 0</span>, respectively, <span class="SimpleMath">c &lt; 0</span>.</p>

<p>Finally, there are epimorphisms from the subgroup of RCWA(ℤ) formed by all class-wise order-preserving elements to (ℤ,+) and from RCWA(ℤ) itself to the cyclic group of order 2, respectively:</p>

<p><a id="X7B1E53127D9AE52F" name="X7B1E53127D9AE52F"></a></p>

<h5>2.4-4 Determinant</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Determinant</code>( <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the determinant of the rcwa mapping <var class="Arg">f</var> of ℤ.</p>

<p>The <em>determinant</em> of an affine mapping <span class="SimpleMath">n ↦ (an+b)/c</span> whose source is a residue class <span class="SimpleMath">r(m)</span> is defined by <span class="SimpleMath">b/|a|m</span>. This definition is extended additively to determinants of rcwa mappings.</p>

<p>Let <span class="SimpleMath">f</span> be an rcwa mapping of the integers, and let <span class="SimpleMath">m</span> denote its modulus. Using the notation <span class="SimpleMath">f|_r(m): n ↦ (a_r(m) ⋅ n + b_r(m))/c_r(m)</span> for the affine partial mappings, the <em>determinant</em> det(<span class="SimpleMath">f</span>) of <span class="SimpleMath">f</span> is given by</p>

<p><center> <img src = "det.png" width = "177" height = "58" alt = "sum_{r(m) in Z/mZ} b_{r(m)}/(|a_{r(m)}| \cdot m)."/> </center></p>

<p>The determinant mapping is an epimorphism from the group of all class-wise order-preserving rcwa permutations of ℤ to (ℤ,+), see <a href="chapBib.html#biBKohl05">[Koh05]</a>, Theorem 2.11.9.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List([ClassTransposition(0,4,5,12),ClassShift(3,7)],Determinant);</span>
[ 0, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Determinant(ClassTransposition(0,4,5,12)*ClassShift(3,7)^100);   </span>
100

</pre></div>

<p><a id="X8365EEEB82C946FD" name="X8365EEEB82C946FD"></a></p>

<h5>2.4-5 Sign</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Sign</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: the sign of the rcwa permutation <var class="Arg">g</var> of ℤ.</p>

<p>Let <span class="SimpleMath">σ</span> be an rcwa permutation of the integers, and let <span class="SimpleMath">m</span> denote its modulus. Using the notation <span class="SimpleMath">σ|_r(m): n ↦ (a_r(m) ⋅ n + b_r(m))/c_r(m)</span> for the affine partial mappings, the <em>sign</em> of <span class="SimpleMath">σ</span> is defined by</p>

<p><center> <img src = "sgn.png" width = "284" height = "63" alt = "(-1)^(det(sigma) + sum_{r(m): \ a_{r(m)} &lt; 0} (m - 2r)/m)."/> </center></p>

<p>The sign mapping is an epimorphism from RCWA(ℤ) to the group <span class="SimpleMath">ℤ^×</span> of units of ℤ, see <a href="chapBib.html#biBKohl05">[Koh05]</a>, Theorem 2.12.8. Therefore the kernel of the sign mapping is a normal subgroup of RCWA(ℤ) of index 2. The simple group CT(ℤ) is a subgroup of this kernel.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List([ClassTransposition(3,4,2,6),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         ClassShift(0,3),ClassReflection(2,5)],Sign);</span>
[ 1, -1, -1 ]

</pre></div>

<p><a id="X8475F844869DD060" name="X8475F844869DD060"></a></p>

<h4>2.5 <span class="Heading">Factoring residue-class-wise affine permutations</span></h4>

<p>Factoring group elements into the members of some "nice" set of generators is often helpful. In this section we describe an operation which attempts to solve this problem for the group RCWA(ℤ). Elements of finitely generated rcwa groups can be factored into generators "as usual", see <code class="func">PreImagesRepresentative</code> (<a href="chap3.html#X8463E34286344F06"><span class="RefLink">3.2-3</span></a>).</p>

<p><a id="X829BA0537F2372FF" name="X829BA0537F2372FF"></a></p>

<h5>2.5-1 CTCSCRSplit</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CTCSCRSplit</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list of 3 rcwa permutations <span class="SimpleMath">a</span>, <span class="SimpleMath">b</span> and <span class="SimpleMath">c</span> whose product equals <var class="Arg">g</var>, where <span class="SimpleMath">a</span> fixes the nonnegative integers setwise, <span class="SimpleMath">b</span> is integral and class-wise order-preserving and <span class="SimpleMath">c</span> is integral.</p>

<p>Assuming the hypothesis that CT(ℤ) is the group of all rcwa permutations of ℤ which fix the nonnegative integers setwise, <span class="SimpleMath">a</span> is always an element of CT(ℤ).</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := ClassTransposition(0,4,1,6)*ClassShift(2,5)*ClassReflection(2,3);</span>
&lt;rcwa permutation of Z with modulus 180&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">facts := CTCSCRSplit(g);</span>
[ &lt;rcwa permutation of Z with modulus 60&gt;, ClassShift( 2(30) ), 
  ClassReflection( 2(3) ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Product(facts) = g;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(facts,IsSignPreserving);</span>
[ true, false, false ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(facts,IsIntegral);</span>
[ false, true, true ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(facts,IsClassWiseOrderPreserving);</span>
[ true, true, false ]

</pre></div>

<p><a id="X853885A182EC5104" name="X853885A182EC5104"></a></p>

<h5>2.5-2 FactorizationIntoCSCRCT</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FactorizationIntoCSCRCT</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Factorization</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a factorization of the rcwa permutation <var class="Arg">g</var> of ℤ into class shifts, class reflections and class transpositions, provided that such a factorization exists and the method finds it.</p>

<p>The method may return <code class="code">fail</code>, stop with an error message or run into an infinite loop. If it returns a result, this result is always correct.</p>

<p>The problem of obtaining a factorization as described is algorithmically difficult, and this factorization routine is currently perhaps the most sophisticated part of the <strong class="pkg">RCWA</strong> package. Information about the progress of the factorization process can be obtained by setting the info level of the Info class <code class="func">InfoRCWA</code> (<a href="chap9.html#X7BAF5F4986288983"><span class="RefLink">9.5-1</span></a>) to 2.</p>

<p>By default, prime switches (<span class="SimpleMath">→</span> <code class="func">PrimeSwitch</code> (<a href="chap2.html#X861C74E97AE5DA3B"><span class="RefLink">2.5-3</span></a>)) are taken as one factor. If the option <var class="Arg">ExpandPrimeSwitches</var> is set, they are each decomposed into the 6 class transpositions given in the definition.</p>

<p>By default, the factoring process begins with splitting off factors from the right. This can be changed by setting the option <var class="Arg">Direction</var> to <code class="code">"from the left"</code>.</p>

<p>By default, a reasonably coarse respected partition of the integral mapping occurring in the final stage of the algorithm is computed. This can be suppressed by setting the option <var class="Arg">ShortenPartition</var> equal to <code class="code">false</code>.</p>

<p>By default, at the end it is checked whether the product of the determined factors indeed equals <var class="Arg">g</var>. This check can be suppressed by setting the option <var class="Arg">NC</var>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Factorization(Comm(ClassShift(0,3)*ClassReflection(1,2),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                      ClassShift(0,2)));</span>
[ ClassReflection( 2(3) ), ClassShift( 2(6) )^-1, ( 0(6), 2(6) ), 
  ( 0(6), 5(6) ) ]

</pre></div>

<p>For purposes of demonstrating the capabilities of the factorization routine, in Section <a href="chap7.html#X86C2BAE3876985A6"><span class="RefLink">7.2</span></a> Collatz' permutation is factored. Lothar Collatz has investigated this permutation in 1932. Its cycle structure is unknown so far.</p>

<p>The permutations of the following kind play an important role in factoring rcwa permutations of ℤ into class shifts, class reflections and class transpositions:</p>

<p><a id="X861C74E97AE5DA3B" name="X861C74E97AE5DA3B"></a></p>

<h5>2.5-3 PrimeSwitch</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PrimeSwitch</code>( <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PrimeSwitch</code>( <var class="Arg">p</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PrimeSwitch</code>( <var class="Arg">p</var>, <var class="Arg">r</var>, <var class="Arg">m</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PrimeSwitch</code>( <var class="Arg">p</var>, <var class="Arg">cl</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: in the first form the <em>prime switch</em> <span class="SimpleMath">σ_p := τ_0(8),1(2p) ⋅ τ_4(8),-1(2p) ⋅ τ_0(4),1(2p) ⋅ τ_2(4),-1(2p) ⋅ τ_2(2p),1(4p) ⋅ τ_4(2p),2p+1(4p)</span>, in the second form the restriction of <span class="SimpleMath">σ_p</span> by <span class="SimpleMath">n ↦ kn</span>, and in the third and fourth form the <em>prime switch</em> <span class="SimpleMath">σ_p,r(m) := τ_r_1(m/2),r_2(m) ⋅ τ_r_2(m),r_1(pm/2) ⋅ τ_r(m/2),r_1(pm/2)</span>. In the latter case, <var class="Arg">cl</var> is the residue class <span class="SimpleMath">r(m)</span>, the residue <span class="SimpleMath">r_1</span> is <span class="SimpleMath">1-(r mod 2)</span>, and <span class="SimpleMath">r_2</span> is defined by the equality <span class="SimpleMath">r(m) ∪ r_2(m) = r(m/2)</span>.</p>

<p>For an odd prime <span class="SimpleMath">p</span>, the prime switch <span class="SimpleMath">σ_p</span> is an rcwa permutation of ℤ with modulus <span class="SimpleMath">4p</span>, multiplier <span class="SimpleMath">p</span> and divisor 2. The prime switch <span class="SimpleMath">σ_p,r(m)</span> has multiplier <span class="SimpleMath">p</span> and divisor 2, and the class where the multiplication by <span class="SimpleMath">p</span> occurs is just <span class="SimpleMath">r(m)</span>. The key mathematical property of a prime switch is that it is a product of class transpositions whose multiplier and divisor are coprime.</p>

<p>Prime switches can be distinguished from other rcwa mappings by their <strong class="pkg">GAP</strong> property <code class="code">IsPrimeSwitch</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(PrimeSwitch(3));</span>

Wild rcwa permutation of Z with modulus 12

        /
        | (3n+4)/2 if n in 2(4)
        | n-1      if n in 5(6) U 8(12)
        | n+1      if n in 1(6)
 n |-&gt; &lt;  n/2      if n in 0(12)
        | n-3      if n in 4(12)
        | n        if n in 3(6)
        |
        \

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(PrimeSwitch(3):AsClassMapping);</span>

Wild rcwa permutation of Z with modulus 12

  0(12) -&gt; 0(6)  loop
   1(6) -&gt; 2(6)
   2(4) -&gt; 5(6)
   3(6) -&gt; 3(6)  id
  4(12) -&gt; 1(12)
   5(6) -&gt; 4(6)
  8(12) -&gt; 7(12)

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Factorization(PrimeSwitch(3));</span>
[ ( 1(6), 0(8) ), ( 5(6), 4(8) ), ( 0(4), 1(6) ), ( 2(4), 5(6) ), 
  ( 2(6), 1(12) ), ( 4(6), 7(12) ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(PrimeSwitch(5,3,4));</span>

Wild rcwa permutation of Z with modulus 20

        /
        | n+1     if n in 0(2)
        | 5n-5    if n in 3(4)
 n |-&gt; &lt;  (n-1)/2 if n in 1(4) \ 1(20)
        | n-1     if n in 1(20)
        |
        \

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Multpk(PrimeSwitch(5,3,4),5,1);</span>
3(4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrimeSwitch(5,3,4) = PrimeSwitch(5,ResidueClass(3,4));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Factorization(PrimeSwitch(5,3,4));</span>
[ ( 0(2), 1(4) ), ( 1(4), 0(10) ), ( 1(2), 0(10) ) ]

</pre></div>

<p>Obtaining a factorization of an rcwa permutation into class shifts, class reflections and class transpositions is particularly difficult if multiplier and divisor are coprime. A prototype of permutations which have this property has been introduced in a different context in <a href="chapBib.html#biBKeller99">[Kel99]</a>:</p>

<p><a id="X789CB69C7D97B0C4" name="X789CB69C7D97B0C4"></a></p>

<h5>2.5-4 mKnot</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; mKnot</code>( <var class="Arg">m</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: the permutation <span class="SimpleMath">g_m</span> as defined in <a href="chapBib.html#biBKeller99">[Kel99]</a>.</p>

<p>The argument <var class="Arg">m</var> must be an odd integer greater than 1.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(mKnot(5));</span>

Wild rcwa permutation of Z with modulus 5

        /
        | 6n/5     if n in 0(5)
        | (4n+1)/5 if n in 1(5)
 n |-&gt; &lt;  (6n-2)/5 if n in 2(5)
        | (4n+3)/5 if n in 3(5)
        | (6n-4)/5 if n in 4(5)
        \

</pre></div>

<p>In his article, Timothy P. Keller shows that a permutation of this type cannot have infinitely many cycles of any given finite length.</p>

<p><a id="X8141065381B0942B" name="X8141065381B0942B"></a></p>

<h4>2.6 <span class="Heading">
  Extracting roots of residue-class-wise affine mappings
</span></h4>

<p><a id="X873692CE78433859" name="X873692CE78433859"></a></p>

<h5>2.6-1 Root</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Root</code>( <var class="Arg">f</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: an rcwa mapping <code class="code">g</code> such that <code class="code">g^<var class="Arg">k</var>=<var class="Arg">f</var></code>, provided that such a mapping exists and that there is a method available which can determine it.</p>

<p>Currently, extracting roots is implemented for rcwa permutations of finite order.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Root(ClassTransposition(0,2,1,2),100);</span>
( 0(8), 2(8), 4(8), 6(8), 1(8), 3(8), 5(8), 7(8) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(last:CycleNotation:=false);</span>

Tame rcwa permutation of Z with modulus 8

        /
        | n+2 if n in Z \ 6(8) U 7(8)
 n |-&gt; &lt;  n-5 if n in 6(8)
        | n-7 if n in 7(8)
        \

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">last^100 = ClassTransposition(0,2,1,2);</span>
true

</pre></div>

<p><a id="X8322C6848305EC4C" name="X8322C6848305EC4C"></a></p>

<h4>2.7 <span class="Heading">
  Special functions for non-bijective mappings
</span></h4>

<p><a id="X7AEFF16E86533633" name="X7AEFF16E86533633"></a></p>

<h5>2.7-1 RightInverse</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RightInverse</code>( <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a right inverse of the injective rcwa mapping <var class="Arg">f</var>, i.e. a mapping <span class="SimpleMath">g</span> such that <var class="Arg">f</var><span class="SimpleMath">g</span> = 1.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">twice := 2*IdentityRcwaMappingOfZ;</span>
Rcwa mapping of Z: n -&gt; 2n
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">twice * RightInverse(twice);</span>
IdentityMapping( Integers )

</pre></div>

<p><a id="X87C5B9CA7E319233" name="X87C5B9CA7E319233"></a></p>

<h5>2.7-2 CommonRightInverse</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CommonRightInverse</code>( <var class="Arg">l</var>, <var class="Arg">r</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a mapping <span class="SimpleMath">d</span> such that <var class="Arg">l</var><span class="SimpleMath">d</span> = <var class="Arg">r</var><span class="SimpleMath">d</span> = 1.</p>

<p>The mappings <var class="Arg">l</var> and <var class="Arg">r</var> must be injective, and their images must form a partition of their source.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">twice := 2*IdentityRcwaMappingOfZ; twiceplus1 := twice+1;</span>
Rcwa mapping of Z: n -&gt; 2n
Rcwa mapping of Z: n -&gt; 2n + 1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(CommonRightInverse(twice,twiceplus1));</span>

Rcwa mapping of Z with modulus 2

        /
        | n/2     if n in 0(2)
 n |-&gt; &lt;  (n-1)/2 if n in 1(2)
        |
        \

</pre></div>

<p><a id="X808D9EDF7BA27467" name="X808D9EDF7BA27467"></a></p>

<h5>2.7-3 ImageDensity</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ImageDensity</code>( <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: the <em>image density</em> of the rcwa mapping <var class="Arg">f</var>.</p>

<p>In the notation introduced in the definition of an rcwa mapping, the <em>image density</em> of an rcwa mapping <span class="SimpleMath">f</span> is defined by 1/m <span class="SimpleMath">∑_r(m) ∈ R/mR |R/c_r(m)R|/|R/a_r(m)R|</span>. The image density of an injective rcwa mapping is <span class="SimpleMath">≤ 1</span>, and the image density of a surjective rcwa mapping is <span class="SimpleMath">≥ 1</span> (this can be seen easily). Thus in particular the image density of a bijective rcwa mapping is 1.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := RcwaMapping([[1,0,2],[3,1,2]]);; # The Collatz mapping.</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( [ T, ClassShift(0,1), RcwaMapping([[2,0,1]]) ], ImageDensity );</span>
[ 4/3, 1, 1/2 ]

</pre></div>

<p>Given an rcwa mapping <code class="code">f</code>, the function <code class="code">InjectiveAsMappingFrom</code> returns a set <code class="code">S</code> such that the restriction of <code class="code">f</code> to <code class="code">S</code> is injective, and such that the image of <code class="code">S</code> under <code class="code">f</code> is the entire image of <code class="code">f</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InjectiveAsMappingFrom(T);</span>
0(2)

</pre></div>

<p><a id="X7A34724386A2E9F3" name="X7A34724386A2E9F3"></a></p>

<h4>2.8 <span class="Heading">
  On trajectories and cycles of residue-class-wise affine mappings
</span></h4>

<p><strong class="pkg">RCWA</strong> provides various methods to compute trajectories of rcwa mappings:</p>

<p><a id="X7C72174D7CCB6348" name="X7C72174D7CCB6348"></a></p>

<h5>2.8-1 <span class="Heading"> Trajectory (methods for rcwa mappings) </span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Trajectory</code>( <var class="Arg">f</var>, <var class="Arg">n</var>, <var class="Arg">length</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Trajectory</code>( <var class="Arg">f</var>, <var class="Arg">n</var>, <var class="Arg">length</var>, <var class="Arg">m</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Trajectory</code>( <var class="Arg">f</var>, <var class="Arg">n</var>, <var class="Arg">terminal</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Trajectory</code>( <var class="Arg">f</var>, <var class="Arg">n</var>, <var class="Arg">terminal</var>, <var class="Arg">m</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the first <var class="Arg">length</var> iterates in the trajectory of the rcwa mapping <var class="Arg">f</var> starting at <var class="Arg">n</var>, respectively the initial part of the trajectory of the rcwa mapping <var class="Arg">f</var> starting at <var class="Arg">n</var> which ends at the first occurrence of an iterate in the set <var class="Arg">terminal</var>. If the argument <var class="Arg">m</var> is given, the iterates are reduced (mod <var class="Arg">m</var>).</p>

<p>To save memory when computing long trajectories containing huge iterates, the reduction (mod <var class="Arg">m</var>) is done each time before storing an iterate. In place of the ring element <var class="Arg">n</var>, the methods also accept a finite set of ring elements or a union of residue classes.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := RcwaMapping([[1,0,2],[3,1,2]]);; # The Collatz mapping.</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Trajectory(T,27,15); Trajectory(T,27,20,5);</span>
[ 27, 41, 62, 31, 47, 71, 107, 161, 242, 121, 182, 91, 137, 206, 103 ]
[ 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 3, 0, 3, 0, 0, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Trajectory(T,15,[1]); Trajectory(T,15,[1],2);</span>
[ 15, 23, 35, 53, 80, 40, 20, 10, 5, 8, 4, 2, 1 ]
[ 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Trajectory(T,ResidueClass(Integers,3,0),Integers);</span>
[ 0(3), 0(3) U 5(9), 0(3) U 5(9) U 7(9) U 8(27), 
  &lt;union of 20 residue classes (mod 27) (6 classes)&gt;, 
  &lt;union of 73 residue classes (mod 81)&gt;, Z \ 10(81) U 37(81), Integers ]

</pre></div>

<p><a id="X7FFD09837E934853" name="X7FFD09837E934853"></a></p>

<h5>2.8-2 <span class="Heading">
    Trajectory (methods for rcwa mappings -- "accumulated coefficients")
  </span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Trajectory</code>( <var class="Arg">f</var>, <var class="Arg">n</var>, <var class="Arg">length</var>, <var class="Arg">whichcoeffs</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Trajectory</code>( <var class="Arg">f</var>, <var class="Arg">n</var>, <var class="Arg">terminal</var>, <var class="Arg">whichcoeffs</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: either the list <code class="code">c</code> of triples of coprime coefficients such that for any <code class="code">k</code> it holds that <code class="code"><var class="Arg">n</var>^(<var class="Arg">f</var>^(k-1)) = (c[k][1]*<var class="Arg">n</var> + c[k][2])/c[k][3]</code> or the last entry of that list, depending on whether <var class="Arg">whichcoeffs</var> is <code class="code">"AllCoeffs"</code> or <code class="code">"LastCoeffs"</code>.</p>

<p>The meanings of the arguments <var class="Arg">length</var> and <var class="Arg">terminal</var> are the same as in the methods for the operation <code class="code">Trajectory</code> described above. In general, computing only the last coefficient triple (<var class="Arg">whichcoeffs</var> = <code class="code">"LastCoeffs"</code>) needs considerably less memory than computing the entire list.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Trajectory(T,27,[1],"LastCoeffs");</span>
[ 36472996377170786403, 195820718533800070543, 1180591620717411303424 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">(last[1]*27+last[2])/last[3];</span>
1

</pre></div>

<p>When dealing with problems like the <span class="SimpleMath">3n+1</span>-Conjecture or when determining the degree of transitivity of the natural action of an rcwa group on its underlying ring, an important task is to determine the residue classes whose elements get larger or smaller when applying a given rcwa mapping:</p>

<p><a id="X7E0244A386744185" name="X7E0244A386744185"></a></p>

<h5>2.8-3 <span class="Heading"> IncreasingOn &amp; DecreasingOn (for an rcwa mapping) </span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IncreasingOn</code>( <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DecreasingOn</code>( <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: the union of all residue classes <span class="SimpleMath">r(m)</span> such that <span class="SimpleMath">|R/a_r(m)R| &gt; |R/c_r(m)R|</span> or <span class="SimpleMath">|R/a_r(m)R| &lt; |R/c_r(m)R|</span>, respectively, where <span class="SimpleMath">R</span> denotes the source, <span class="SimpleMath">m</span> denotes the modulus and <span class="SimpleMath">a_r(m)</span>, <span class="SimpleMath">b_r(m)</span> and <span class="SimpleMath">c_r(m)</span> denote the coefficients of <var class="Arg">f</var> as introduced in Section <a href="chap2.html#X78ED07E37FC2BD46"><span class="RefLink">2.1</span></a>.</p>

<p>If the argument is an rcwa mapping of ℤ in sparse representation, an option <code class="code">classes</code> is interpreted; if set, the step of forming the union of the residue classes in question is omitted, and the list of residue classes is returned instead of their union. This may save time and memory if the modulus is large.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List([1..3],k-&gt;IncreasingOn(T^k));</span>
[ 1(2), 3(4), 3(4) U 1(8) U 6(8) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List([1..3],k-&gt;DecreasingOn(T^k));</span>
[ 0(2), Z \ 3(4), 0(4) U 2(8) U 5(8) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := RcwaMapping([[2,0,3],[4,-1,3],[4,1,3]]);; # Collatz' permutation</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List([-2..2],k-&gt;IncreasingOn(a^k));</span>
[ Z \ 1(8) U 7(8), 0(2), [  ], Z \ 0(3), 1(9) U 4(9) U 5(9) U 8(9) ]

</pre></div>

<p>We assign certain directed graphs to rcwa mappings, which encode the order in which trajectories may traverse the residue classes modulo some modulus:</p>

<p><a id="X780841E07CAE7543" name="X780841E07CAE7543"></a></p>

<h5>2.8-4 TransitionGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TransitionGraph</code>( <var class="Arg">f</var>, <var class="Arg">m</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: the transition graph of the rcwa mapping <var class="Arg">f</var> for modulus <var class="Arg">m</var>.</p>

<p>The <em>transition graph</em> <span class="SimpleMath">Γ_f,m</span> of <span class="SimpleMath">f</span> for modulus <span class="SimpleMath">m</span> is defined as follows:</p>

<ol>
<li><p>The vertices are the residue classes (mod <span class="SimpleMath">m</span>).</p>

</li>
<li><p>There is an edge from <span class="SimpleMath">r_1(m)</span> to <span class="SimpleMath">r_2(m)</span> if and only if there is some <span class="SimpleMath">n ∈ r_1(m)</span> such that <span class="SimpleMath">n^f ∈ r_2(m)</span>.</p>

</li>
</ol>
<p>The assignment of the residue classes (mod <span class="SimpleMath">m</span>) to the vertices of the graph corresponds to the ordering of the residues in <code class="code">AllResidues(Source(<var class="Arg">f</var>),<var class="Arg">m</var>)</code>. The result is returned in the format used by the package <strong class="pkg">GRAPE</strong> <a href="chapBib.html#biBGRAPE">[Soi16]</a>.</p>

<p>There are a couple of operations and attributes which are based on these graphs:</p>

<p><a id="X7F03CC4179424AA9" name="X7F03CC4179424AA9"></a></p>

<h5>2.8-5 OrbitsModulo</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OrbitsModulo</code>( <var class="Arg">f</var>, <var class="Arg">m</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: the partition of <code class="code">AllResidues(Source(<var class="Arg">f</var>),<var class="Arg">m</var>)</code> corresponding to the weakly connected components of the transition graph of the rcwa mapping <var class="Arg">f</var> for modulus <var class="Arg">m</var>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrbitsModulo(ClassTransposition(0,2,1,4),8);</span>
[ [ 0, 1, 4 ], [ 2, 5, 6 ], [ 3 ], [ 7 ] ]

</pre></div>

<p><a id="X7F11051E866C197F" name="X7F11051E866C197F"></a></p>

<h5>2.8-6 FactorizationOnConnectedComponents</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FactorizationOnConnectedComponents</code>( <var class="Arg">f</var>, <var class="Arg">m</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: the set of restrictions of the rcwa mapping <var class="Arg">f</var> to the weakly connected components of its transition graph <span class="SimpleMath">Γ_f,m</span>.</p>

<p>The product of the returned mappings is <var class="Arg">f</var>. They have pairwise disjoint supports, hence any two of them commute.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sigma := ClassTransposition(1,4,2,4)  * ClassTransposition(1,4,3,4)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          * ClassTransposition(3,9,6,18) * ClassTransposition(1,6,3,9);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(FactorizationOnConnectedComponents(sigma,36),Support);</span>
[ 33(36) U 34(36) U 35(36), 9(36) U 10(36) U 11(36), 
  &lt;union of 23 residue classes (mod 36)&gt; \ [ -6, 3 ] ]

</pre></div>

<p><a id="X7B6833D67D916EF9" name="X7B6833D67D916EF9"></a></p>

<h5>2.8-7 TransitionMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TransitionMatrix</code>( <var class="Arg">f</var>, <var class="Arg">m</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: the transition matrix of the rcwa mapping <var class="Arg">f</var> for modulus <var class="Arg">m</var>.</p>

<p>Let <span class="SimpleMath">M</span> be this matrix. Then for any two residue classes <span class="SimpleMath">r_1(m), r_2(m) ∈ R/mR</span>, the entry <span class="SimpleMath">M_r_1(m),r_2(m)</span> is defined by</p>

<p><center> <img src = "transmat.png" width = "599" height = "47" alt = "(see the PDF version of the manual),"/> </center> where <span class="SimpleMath">hatm</span> is the product of <var class="Arg">m</var> and the square of the modulus of <var class="Arg">f</var>. The assignment of the residue classes (mod <var class="Arg">m</var>) to the rows and columns of the matrix corresponds to the ordering of the residues in <code class="code">AllResidues(Source(<var class="Arg">f</var>),<var class="Arg">m</var>)</code>.</p>

<p>The transition matrix is a weighted adjacency matrix of the corresponding transition graph <code class="code">TransitionGraph(<var class="Arg">f</var>,<var class="Arg">m</var>)</code>. The sums of the rows of a transition matrix are always equal to 1.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := RcwaMapping([[1,0,2],[3,1,2]]);; # The Collatz mapping.</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(TransitionMatrix(T^3,3));</span>
[ [  1/8,  1/4,  5/8 ],
  [    0,  1/4,  3/4 ],
  [    0,  3/8,  5/8 ] ]

</pre></div>

<p><a id="X81DBA2D58526BE7E" name="X81DBA2D58526BE7E"></a></p>

<h5>2.8-8 <span class="Heading"> Sources &amp; Sinks (of an rcwa mapping) </span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Sources</code>( <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Sinks</code>( <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a list of unions of residue classes modulo the modulus <span class="SimpleMath">m</span> of the rcwa mapping <var class="Arg">f</var>, as described below.</p>

<p>The returned list contains an entry for any strongly connected component of the transition graph of <var class="Arg">f</var> for modulus <code class="code">Mod(<var class="Arg">f</var>)</code> which has only outgoing edges ("source") or which has only ingoing edges ("sink"), respectively. The list entry corresponding to such a component is the union of the vertices belonging to it.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := ClassTransposition(0,2,1,2)*ClassTransposition(0,2,1,4);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Sources(g); Sinks(g);</span>
[ 0(4) ]
[ 1(4) ]

</pre></div>

<p><a id="X80221A4D81AF7453" name="X80221A4D81AF7453"></a></p>

<h5>2.8-9 Loops</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Loops</code>( <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: if <var class="Arg">f</var> is bijective, the list of non-isolated vertices of the transition graph of <var class="Arg">f</var> for modulus <code class="code">Mod(<var class="Arg">f</var>)</code> which carry a loop. In general, the list of vertices of that transition graph which carry a loop, but which <var class="Arg">f</var> does not fix setwise.</p>

<p>The returned list may also include supersets of the named residue classes instead if <var class="Arg">f</var> is affine even on these.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Loops(ClassTransposition(0,2,1,2)*ClassTransposition(0,2,1,4));</span>
[ 0(4), 1(4) ]

</pre></div>

<p>There is a nice invariant of trajectories of the Collatz mapping:</p>

<p><a id="X8773152E81A30123" name="X8773152E81A30123"></a></p>

<h5>2.8-10 GluckTaylorInvariant</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GluckTaylorInvariant</code>( <var class="Arg">a</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: the invariant defined in <a href="chapBib.html#biBGluckTaylor02">[GT02]</a>. This is <span class="SimpleMath">(∑_i=1^l a_i ⋅ a_i mod l + 1)/(∑_i=1^l a_i^2)</span>, where <span class="SimpleMath">l</span> denotes the length of <var class="Arg">a</var>.</p>

<p>The argument <var class="Arg">a</var> must be a list of integers. In <a href="chapBib.html#biBGluckTaylor02">[GT02]</a> it is shown that if <var class="Arg">a</var> is a trajectory of the `original' Collatz mapping <span class="SimpleMath">n</span> <span class="SimpleMath">↦</span> (<span class="SimpleMath">n/2</span> if <span class="SimpleMath">n</span> even, <span class="SimpleMath">3n+1</span> if <span class="SimpleMath">n</span> odd) starting at an odd integer <span class="SimpleMath">≥ 3</span> and ending at 1, then the invariant lies in the interval <span class="SimpleMath">]9/13,5/7[</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := RcwaMapping([[1,0,2],[3,1,1]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List([3,5..49],n-&gt;Float(GluckTaylorInvariant(Trajectory(C,n,[1]))));</span>
[ 0.701053, 0.696721, 0.708528, 0.707684, 0.706635, 0.695636, 0.711769,
  0.699714, 0.707409, 0.693833, 0.710432, 0.706294, 0.714242, 0.699935,
  0.714242, 0.705383, 0.706591, 0.698198, 0.712222, 0.714242, 0.709048,
  0.69612, 0.714241, 0.701076 ]

</pre></div>

<p>Quite often one can make certain "educated guesses" on the overall behaviour of the trajectories of a given rcwa mapping. For example it is reasonably straightforward to make the conjecture that all trajectories of the Collatz mapping eventually enter the finite set <span class="SimpleMath">{-136, -91, -82, -68, -61, -55, -41, -37, -34, -25, -17, -10, -7, -5, -1, 0, 1, 2 }</span>, or that "on average" the next number in a trajectory of the Collatz mapping is smaller than the preceding one by a factor of <span class="SimpleMath">sqrt3/2</span>. However it is clear that such guesses can be wrong, and that they therefore cannot be used to prove anything. Nevertheless they can sometimes be useful:</p>

<p><a id="X84F6A29280E2F925" name="X84F6A29280E2F925"></a></p>

<h5>2.8-11 LikelyContractionCentre</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LikelyContractionCentre</code>( <var class="Arg">f</var>, <var class="Arg">maxn</var>, <var class="Arg">bound</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list of ring elements (see below).</p>

<p>This operation tries to compute the <em>contraction centre</em> of the rcwa mapping <var class="Arg">f</var>. Assuming its existence this is the unique finite subset <span class="SimpleMath">S_0</span> of the source of <var class="Arg">f</var> on which <var class="Arg">f</var> induces a permutation and which intersects non-trivially with any trajectory of <var class="Arg">f</var>. The mapping <var class="Arg">f</var> is assumed to be <em>contracting</em>, i.e. to have such a contraction centre. As in general contraction centres are likely not computable, the methods for this operation are probabilistic and may return wrong results. The argument <var class="Arg">maxn</var> is a bound on the starting value and <var class="Arg">bound</var> is a bound on the elements of the trajectories to be searched. If the limit <var class="Arg">bound</var> is exceeded, an Info message on Info level 3 of <code class="code">InfoRCWA</code> is given.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := RcwaMapping([[1,0,2],[3,1,2]]);; # The Collatz mapping.</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S0 := LikelyContractionCentre(T,100,1000);</span>
#I  Warning: `LikelyContractionCentre' is highly probabilistic.
The returned result can only be regarded as a rough guess.
See ?LikelyContractionCentre for more information.
[ -136, -91, -82, -68, -61, -55, -41, -37, -34, -25, -17, -10, -7, -5, 
  -1, 0, 1, 2 ]

</pre></div>

<p><a id="X81E0D8E3817B3D16" name="X81E0D8E3817B3D16"></a></p>

<h5>2.8-12 GuessedDivergence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GuessedDivergence</code>( <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a floating point value which is intended to be a rough guess on how fast the trajectories of the rcwa mapping <var class="Arg">f</var> diverge (return value greater than 1) or converge (return value smaller than 1).</p>

<p>Nothing particular is guaranteed.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GuessedDivergence(T);</span>
#I  Warning: GuessedDivergence: no particular return value is guaranteed.
0.866025

</pre></div>

<p><a id="X86F0E0D17E6A9663" name="X86F0E0D17E6A9663"></a></p>

<h4>2.9 <span class="Heading">
  Saving memory -- the sparse representation of rcwa mappings
</span></h4>

<p>It is quite common that an rcwa mapping with large modulus has only few distinct affine partial mappings. In this case the "standard" representation which stores a coefficient triple for each residue class modulo the modulus is unsuitable. For this reason there is a second representation of rcwa mappings, the "sparse" representation. Depending on the rcwa mappings involved, using this representation may speed up computations and reduce memory requirements by orders of magnitude. For rcwa mappings with almost as many distinct affine partial mappings as there are residue classes modulo the modulus, using sparse representation makes computations slower and more memory-consuming. Presently, the sparse representation is only available for rcwa mappings of ℤ.</p>

<p>The sparse representation of an rcwa mapping consists of the modulus and a list of 5-tuples <span class="SimpleMath">(r,m,a_r(m),b_r(m),c_r(m))</span> of integers. Any such 5-tuple specifies the coefficients of the restriction <span class="SimpleMath">n ↦ (a_r(m) ⋅ n + b_r(m))/c_r(m)</span> of the mapping to a residue class <span class="SimpleMath">r(m)</span>. The <span class="SimpleMath">r(m)</span> are chosen to form the coarsest possible partition of ℤ into residue classes such that the restriction of the mapping to any of them is affine. Also the list of coefficient tuples is sorted, all <span class="SimpleMath">c_r(m)</span> are positive and <span class="SimpleMath">gcd(c_r(m),gcd(a_r(m),b_r(m))) = 1</span>. This way the coefficient list of an rcwa mapping of ℤ is unique.</p>

<p>Changing the representation of rcwa mappings does not change their behaviour with respect to "<code class="code">=</code>" and "<code class="code">&lt;</code>" The product of two rcwa mappings in sparse representation is in sparse representation again, just like the product of two rcwa mappings in standard representation is in standard representation. Also, inverses are in the same representation. The product of two rcwa mappings in different representation may be in any of the representations of the factors.</p>

<p><a id="X879451B17AD78B07" name="X879451B17AD78B07"></a></p>

<h5>2.9-1 SparseRepresentation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SparseRepresentation</code>( <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SparseRep</code>( <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StandardRepresentation</code>( <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StandardRep</code>( <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: the rcwa mapping <var class="Arg">f</var> in sparse, respectively, standard representation.</p>

<p>Appropriate attribute values and properties are copied over to the rcwa mapping in the "new" representation.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := ClassTransposition(1,2,4,6);</span>
( 1(2), 4(6) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b := ClassTransposition(1,3,2,6);</span>
( 1(3), 2(6) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := ClassTransposition(2,3,4,6);</span>
( 2(3), 4(6) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := (b*a*c)^2*a;</span>
&lt;rcwa permutation of Z with modulus 288&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h := SparseRep(g);</span>
&lt;rcwa permutation of Z with modulus 288 and 21 affine parts&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g = h;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Coefficients(h);</span>
[ [ 0, 6, 1, 0, 1 ], [ 1, 3, 16, -1, 3 ], [ 2, 96, 9, 14, 16 ], 
  [ 3, 24, 9, 5, 4 ], [ 5, 24, 3, 1, 4 ], [ 8, 36, 2, -7, 9 ], 
  [ 9, 48, 27, 29, 8 ], [ 11, 24, 9, 5, 4 ], [ 14, 48, 27, 38, 8 ], 
  [ 15, 24, 27, 19, 4 ], [ 17, 48, 9, 7, 8 ], [ 20, 72, 3, 4, 4 ], 
  [ 21, 24, 1, -3, 6 ], [ 23, 24, 27, 19, 4 ], [ 26, 48, 3, 2, 8 ], 
  [ 32, 36, 4, -11, 9 ], [ 33, 48, 9, 7, 8 ], [ 38, 48, 9, 10, 8 ], 
  [ 41, 48, 27, 29, 8 ], [ 50, 96, 27, 58, 16 ], [ 56, 72, 1, 0, 4 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h^2;</span>
&lt;rcwa permutation of Z with modulus 13824 and 71 affine parts&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h^3;</span>
&lt;rcwa permutation of Z with modulus 663552 and 201 affine parts&gt;

</pre></div>

<p>Memory consumption may differ a lot between sparse- and standard representation:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MemoryUsage(h^3);               # on a 64-bit machine</span>
18254
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MemoryUsage(StandardRep(h^3));  # on a 64-bit machine</span>
42467894
</pre></div>

<p><a id="X83FA71DD842377F0" name="X83FA71DD842377F0"></a></p>

<h4>2.10 <span class="Heading">The categories and families of rcwa mappings</span></h4>

<p><a id="X7927C13782729CE9" name="X7927C13782729CE9"></a></p>

<h5>2.10-1 IsRcwaMapping</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsRcwaMapping</code>( <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsRcwaMappingOfZ</code>( <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsRcwaMappingOfZ_pi</code>( <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsRcwaMappingOfGFqx</code>( <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> if <var class="Arg">f</var> is an rcwa mapping, an rcwa mapping of the ring of integers, an rcwa mapping of a semilocalization of the ring of integers or an rcwa mapping of a polynomial ring in one variable over a finite field, respectively, and <code class="code">false</code> otherwise.</p>

<p>Often the same methods can be used for rcwa mappings of the ring of integers and of its semilocalizations. For this reason there is a category <code class="code">IsRcwaMappingOfZOrZ_pi</code> which is the union of <code class="code">IsRcwaMappingOfZ</code> and <code class="code">IsRcwaMappingOfZ_pi</code>. The internal representation of rcwa mappings is called <code class="code">IsRcwaMappingStandardRep</code>. There are methods available for <code class="code">ExtRepOfObj</code> and <code class="code">ObjByExtRep</code>.</p>

<p><a id="X825DD365822934AF" name="X825DD365822934AF"></a></p>

<h5>2.10-2 RcwaMappingsFamily</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RcwaMappingsFamily</code>( <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: the family of rcwa mappings of the ring <var class="Arg">R</var>.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
