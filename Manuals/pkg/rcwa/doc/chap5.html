<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (RCWA) - Chapter 5: 
  Residue-Class-Wise Affine Mappings, Groups and Monoids over ℤ^2
</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap5"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap4.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap6.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap5_mj.html">[MathJax on]</a></p>
<p><a id="X788EB00B82897762" name="X788EB00B82897762"></a></p>
<div class="ChapSects"><a href="chap5.html#X788EB00B82897762">5 <span class="Heading">
  Residue-Class-Wise Affine Mappings, Groups and Monoids over <span class="SimpleMath">ℤ^2</span>
</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap5.html#X781907CA785CC7AC">5.1 <span class="Heading">
  The definition of residue-class-wise affine mappings of <span class="SimpleMath">ℤ^d</span>
</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap5.html#X7A39FCF08030AB9B">5.2 <span class="Heading">
  Entering residue-class-wise affine mappings of <span class="SimpleMath">ℤ^2</span>
</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5.html#X790649618012C606">5.2-1 <span class="Heading">
    RcwaMapping (the general constructor; methods for <span class="SimpleMath">ℤ^2</span>)
  </span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5.html#X7B450EE17B465E02">5.2-2 <span class="Heading"> ClassTransposition (for <span class="SimpleMath">ℤ^2</span>) </span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5.html#X828438127DDAEBB4">5.2-3 <span class="Heading"> ClassRotation (for <span class="SimpleMath">ℤ^2</span>) </span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5.html#X7A14A8F48247E651">5.2-4 <span class="Heading"> ClassShift (for <span class="SimpleMath">ℤ^2</span>) </span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap5.html#X8531E39785FFF8A7">5.3 <span class="Heading">
  Methods for residue-class-wise affine mappings of <span class="SimpleMath">ℤ^2</span>
</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5.html#X8408B7837C9EED36">5.3-1 ProjectionsToCoordinates</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap5.html#X83A1752F7BE9CE85">5.4 <span class="Heading">
  Methods for residue-class-wise affine groups and -monoids over <span class="SimpleMath">ℤ^2</span>
</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5.html#X79A8F9AD7E839862">5.4-1 <span class="Heading">
    IsomorphismRcwaGroup (Embeddings of SL(2,ℤ) and GL(2,ℤ))
  </span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5.html#X812135EB87527F01">5.4-2 <span class="Heading"> DrawGrid </span></a>
</span>
</div></div>
</div>

<h3>5 <span class="Heading">
  Residue-Class-Wise Affine Mappings, Groups and Monoids over <span class="SimpleMath">ℤ^2</span>
</span></h3>

<p>This chapter describes how to compute with residue-class-wise affine mappings of <span class="SimpleMath">ℤ^2</span> and with groups and monoids formed by them.</p>

<p>The rings on which we have defined residue-class-wise affine mappings so far have all been principal ideal domains, and it has been crucial that all nontrivial principal ideals had finite index. However, the rings <span class="SimpleMath">ℤ^d</span>, <span class="SimpleMath">d &gt; 1</span> are not principal ideal domains. Furthermore, their principal ideals have infinite index. Therefore as moduli of residue-class-wise affine mappings we can only use lattices of full rank, for these are precisely the ideals of <span class="SimpleMath">ℤ^d</span> of finite index. However, on the other hand we can also be more permissive and look at <span class="SimpleMath">ℤ^d</span> not as a ring, but rather as a free ℤ-module. The consequence of this is that then an affine mapping of <span class="SimpleMath">ℤ^d</span> is not just given by <span class="SimpleMath">v ↦ (av+b)/c</span> for some <span class="SimpleMath">a, b, c ∈ ℤ^d</span>, but rather by <span class="SimpleMath">v ↦ (vA+b)/c</span>, where <span class="SimpleMath">A ∈ ℤ^d × d</span>. Also for technical reasons concerning the implementation in <strong class="pkg">GAP</strong>, looking at <span class="SimpleMath">ℤ^d</span> as a free ℤ-module is preferable -- in <strong class="pkg">GAP</strong>, <code class="code">Integers^d</code> is not a ring, and multiplying lists of integers means forming their scalar product.</p>

<p><a id="X781907CA785CC7AC" name="X781907CA785CC7AC"></a></p>

<h4>5.1 <span class="Heading">
  The definition of residue-class-wise affine mappings of <span class="SimpleMath">ℤ^d</span>
</span></h4>

<p>Let <span class="SimpleMath">d ∈ ℕ</span>. We call a mapping <span class="SimpleMath">f: ℤ^d → ℤ^d</span> <em>residue-class-wise affine</em> if there is a lattice <span class="SimpleMath">L = ℤ^d M</span> where <span class="SimpleMath">M ∈ ℤ^d × d</span> is a matrix of full rank, such that the restrictions of <span class="SimpleMath">f</span> to the residue classes <span class="SimpleMath">r + L ∈ ℤ^d/L</span> are all affine. This means that for any residue class <span class="SimpleMath">r + L ∈ ℤ^d/L</span>, there is a matrix <span class="SimpleMath">A_r+L ∈ ℤ^d × d</span>, a vector <span class="SimpleMath">b_r+L ∈ ℤ^d</span> and a positive integer <span class="SimpleMath">c_r+L</span> such that the restriction of <span class="SimpleMath">f</span> to <span class="SimpleMath">r + L</span> is given by <span class="SimpleMath">f|_r + L: r + L → ℤ^d, v ↦ (v ⋅ A_r+L + b_r+L)/c_r+L</span>. For reasons of uniqueness, we assume that <span class="SimpleMath">L</span> is chosen maximal with respect to inclusion, and that no prime factor of <span class="SimpleMath">c_r+L</span> divides all coefficients of <span class="SimpleMath">A_r+L</span> and <span class="SimpleMath">b_r+L</span>.</p>

<p>We call the lattice <span class="SimpleMath">L</span> the <em>modulus</em> of <span class="SimpleMath">f</span>, written Mod(<span class="SimpleMath">f</span>). Further we define the <em>prime set</em> of <span class="SimpleMath">f</span> as the set of all primes which divide the determinant of at least one of the coefficients <span class="SimpleMath">A_r+L</span> or which divide the determinant of <span class="SimpleMath">M</span>, and we call the mapping <span class="SimpleMath">f</span> <em>class-wise translating</em> if all coefficients <span class="SimpleMath">A_r+L</span> are identity matrices and all coefficients <span class="SimpleMath">c_r+L</span> are equal to 1.</p>

<p>For the sake of simplicity, we identify a lattice with the Hermite normal form of the matrix by whose rows it is spanned.</p>

<p><a id="X7A39FCF08030AB9B" name="X7A39FCF08030AB9B"></a></p>

<h4>5.2 <span class="Heading">
  Entering residue-class-wise affine mappings of <span class="SimpleMath">ℤ^2</span>
</span></h4>

<p>Residue-class-wise affine mappings of <span class="SimpleMath">ℤ^2</span> can be entered using the general constructor <code class="func">RcwaMapping</code> (<a href="chap2.html#X8799551B83644B37"><span class="RefLink">2.2-5</span></a>) or the more specialized functions <code class="func">ClassTransposition</code> (<a href="chap2.html#X8716A75F7DD1C46B"><span class="RefLink">2.2-3</span></a>), <code class="func">ClassRotation</code> (<a href="chap2.html#X87EB8C1C87F78A17"><span class="RefLink">2.2-4</span></a>) and <code class="func">ClassShift</code> (<a href="chap2.html#X86B611BD7EED62A1"><span class="RefLink">2.2-1</span></a>). The arguments differ only slightly.</p>

<p><a id="X790649618012C606" name="X790649618012C606"></a></p>

<h5>5.2-1 <span class="Heading">
    RcwaMapping (the general constructor; methods for <span class="SimpleMath">ℤ^2</span>)
  </span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RcwaMapping</code>( <var class="Arg">R</var>, <var class="Arg">L</var>, <var class="Arg">coeffs</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RcwaMapping</code>( <var class="Arg">P1</var>, <var class="Arg">P2</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RcwaMapping</code>( <var class="Arg">cycles</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RcwaMapping</code>( <var class="Arg">f</var>, <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: an rcwa mapping of <span class="SimpleMath">ℤ^2</span>.</p>

<p>The above methods return</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p>the rcwa mapping of <code class="code"><var class="Arg">R</var> = Integers^2</code> with modulus <var class="Arg">L</var> and coefficients <var class="Arg">coeffs</var>,</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p>an rcwa permutation which induces a bijection between the partitions <var class="Arg">P1</var> and <var class="Arg">P2</var> of <span class="SimpleMath">ℤ^2</span> into residue classes and which is affine on the elements of <var class="Arg">P1</var>,</p>

</dd>
<dt><strong class="Mark">(c)</strong></dt>
<dd><p>an rcwa permutation with "residue class cycles" given by a list <var class="Arg">cycles</var> of lists of pairwise disjoint residue classes of <span class="SimpleMath">ℤ^2</span> each of which it permutes cyclically, and</p>

</dd>
<dt><strong class="Mark">(d)</strong></dt>
<dd><p>the rcwa mapping of <span class="SimpleMath">ℤ^2</span> whose projections to the coordinates are given by <var class="Arg">f</var> and <var class="Arg">g</var>,</p>

</dd>
</dl>
<p>respectively.</p>

<p>The modulus of an rcwa mapping of <span class="SimpleMath">ℤ^2</span> is a lattice of full rank. It is represented by a matrix <var class="Arg">L</var> in Hermite normal form, whose rows are the spanning vectors.</p>

<p>A coefficient list for an rcwa mapping of <span class="SimpleMath">ℤ^2</span> with modulus <var class="Arg">L</var> consists of <span class="SimpleMath">|det(<var class="Arg">L</var>)|</span> coefficient triples <code class="code">[</code><span class="SimpleMath">A_r+ℤ^2<var class="Arg">L</var></span>, <span class="SimpleMath">b_r+ℤ^2<var class="Arg">L</var></span>, <span class="SimpleMath">c_r+ℤ^2<var class="Arg">L</var></span><code class="code">]</code>. The entries <span class="SimpleMath">A_r+ℤ^2<var class="Arg">L</var></span> are <span class="SimpleMath">2 × 2</span> integer matrices, the <span class="SimpleMath">b_r+ℤ^2<var class="Arg">L</var></span> are elements of <span class="SimpleMath">ℤ^2</span>, i.e. lists of two integers, and the <span class="SimpleMath">c_r+ℤ^2<var class="Arg">L</var></span> are integers. The ordering of the coefficient triples is determined by the ordering of the representatives of the residue classes <span class="SimpleMath">r+ℤ^2<var class="Arg">L</var></span> in the sorted list returned by <code class="code">AllResidues(Integers^2,<var class="Arg">L</var>)</code>.</p>

<p>The methods for the operation <code class="code">RcwaMapping</code> perform a number of argument checks, which can be skipped by using <code class="code">RcwaMappingNC</code> instead.</p>

<p>Last but not least, regarding Method (d) it should be mentioned that only very special rcwa mappings of <span class="SimpleMath">ℤ^2</span> have projections to coordinates.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := Integers^2;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">twice := RcwaMapping(R,[[1,0],[0,1]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                          [[[[2,0],[0,2]],[0,0],1]]);       # method (a)</span>
Rcwa mapping of Z^2: (m,n) -&gt; (2m,2n)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[4,5]^twice;</span>
[ 8, 10 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">twice1 := RcwaMapping(R,[[1,0],[0,1]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                           [[[[2,0],[0,1]],[0,0],1]]);      # method (a)</span>
Rcwa mapping of Z^2: (m,n) -&gt; (2m,n)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[4,5]^twice1;</span>
[ 8, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Image(twice1);</span>
(0,0)+(2,0)Z+(0,1)Z
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hyperbolic := RcwaMapping(R,[[1,0],[0,2]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                               [[[[4,0],[0,1]],[0, 0],2],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                [[[4,0],[0,1]],[2,-1],2]]); # method (a)</span>
&lt;rcwa mapping of Z^2 with modulus (1,0)Z+(0,2)Z&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsBijective(hyperbolic);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(hyperbolic);</span>

Rcwa permutation of Z^2 with modulus (1,0)Z+(0,2)Z

            /
            | (2m,n/2)       if (m,n) in (0,0)+(1,0)Z+(0,2)Z
 (m,n) |-&gt; &lt;  (2m+1,(n-1)/2) if (m,n) in (0,1)+(1,0)Z+(0,2)Z
            |
            \

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Trajectory(hyperbolic,[0,10000],20);</span>
[ [ 0, 10000 ], [ 0, 5000 ], [ 0, 2500 ], [ 0, 1250 ], [ 0, 625 ], 
  [ 1, 312 ], [ 2, 156 ], [ 4, 78 ], [ 8, 39 ], [ 17, 19 ], [ 35, 9 ], 
  [ 71, 4 ], [ 142, 2 ], [ 284, 1 ], [ 569, 0 ], [ 1138, 0 ], 
  [ 2276, 0 ], [ 4552, 0 ], [ 9104, 0 ], [ 18208, 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P1 := AllResidueClassesModulo(R,[[2,1],[0,2]]);</span>
[ (0,0)+(2,1)Z+(0,2)Z, (0,1)+(2,1)Z+(0,2)Z, (1,0)+(2,1)Z+(0,2)Z,
  (1,1)+(2,1)Z+(0,2)Z ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P2 := AllResidueClassesModulo(R,[[1,0],[0,4]]);</span>
[ (0,0)+(1,0)Z+(0,4)Z, (0,1)+(1,0)Z+(0,4)Z, (0,2)+(1,0)Z+(0,4)Z,
  (0,3)+(1,0)Z+(0,4)Z ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := RcwaMapping(P1,P2);                                 # method (b)</span>
&lt;rcwa permutation of Z^2 with modulus (2,1)Z+(0,2)Z&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P1^g = P2;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(g:AsTable);</span>

Rcwa permutation of Z^2 with modulus (2,1)Z+(0,2)Z

   [m,n] mod (2,1)Z+(0,2)Z   |              Image of [m,n]
-----------------------------+-------------------------------------------
 [0,0]                       | [m/2,-m+2n]
 [0,1]                       | [m/2,-m+2n-1]
 [1,0]                       | [(m-1)/2,-m+2n+3]
 [1,1]                       | [(m-1)/2,-m+2n+2]

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">classes := List([[[0,0],[[2,1],[0,2]]],[[1,0],[[2,1],[0,4]]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    [[1,1],[[4,2],[0,4]]]],ResidueClass);</span>
[ (0,0)+(2,1)Z+(0,2)Z, (1,0)+(2,1)Z+(0,4)Z, (1,1)+(4,2)Z+(0,4)Z ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := RcwaMapping([classes]);                             # method (c)</span>
&lt;rcwa permutation of Z^2 with modulus (4,2)Z+(0,4)Z, of order 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Permutation(g,classes);</span>
(1,2,3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Support(g);</span>
(0,0)+(2,1)Z+(0,2)Z U (1,0)+(2,1)Z+(0,4)Z U (1,1)+(4,2)Z+(0,4)Z
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(g);</span>

Rcwa permutation of Z^2 with modulus (4,2)Z+(0,4)Z, of order 3

            /
            | (m+1,(-m+4n)/2)   if (m,n) in (0,0)+(2,1)Z+(0,2)Z
            | (2m-1,(m+2n+1)/2) if (m,n) in (1,0)+(2,1)Z+(0,4)Z
 (m,n) |-&gt; &lt;  ((m-1)/2,(n-1)/2) if (m,n) in (1,1)+(4,2)Z+(0,4)Z
            | (m,n)             otherwise
            |
            \

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := RcwaMapping(ClassTransposition(0,2,1,2),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    ClassReflection(0,2));                  # method (d)</span>
&lt;rcwa mapping of Z^2 with modulus (2,0)Z+(0,2)Z&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(g);</span>

Rcwa mapping of Z^2 with modulus (2,0)Z+(0,2)Z

            /
            | (m+1,-n) if (m,n) in (0,0)+(2,0)Z+(0,2)Z
            | (m+1,n)  if (m,n) in (0,1)+(2,0)Z+(0,2)Z
 (m,n) |-&gt; &lt;  (m-1,-n) if (m,n) in (1,0)+(2,0)Z+(0,2)Z
            | (m-1,n)  if (m,n) in (1,1)+(2,0)Z+(0,2)Z
            |
            \

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g^2;</span>
IdentityMapping( ( Integers^2 ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(ProjectionsToCoordinates(g),Factorization);</span>
[ [ ( 0(2), 1(2) ) ], [ ClassReflection( 0(2) ) ] ]

</pre></div>

<p><a id="X7B450EE17B465E02" name="X7B450EE17B465E02"></a></p>

<h5>5.2-2 <span class="Heading"> ClassTransposition (for <span class="SimpleMath">ℤ^2</span>) </span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassTransposition</code>( <var class="Arg">r1</var>, <var class="Arg">L1</var>, <var class="Arg">r2</var>, <var class="Arg">L2</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassTransposition</code>( <var class="Arg">cl1</var>, <var class="Arg">cl2</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: the class transposition <span class="SimpleMath">τ_r_1+ℤ^2L_1,r_2+ℤ^2L_2</span>.</p>

<p>Let <span class="SimpleMath">d ∈ ℕ</span>, and let <span class="SimpleMath">L_1, L_2 ∈ ℤ^d × d</span> be matrices of full rank which are in Hermite normal form. Further let <span class="SimpleMath">r_1 + ℤ^d L_1</span> and <span class="SimpleMath">r_2 + ℤ^d L_2</span> be disjoint residue classes, and assume that the representatives <span class="SimpleMath">r_1</span> and <span class="SimpleMath">r_2</span> are reduced modulo <span class="SimpleMath">ℤ^d L_1</span> and <span class="SimpleMath">ℤ^d L_2</span>, respectively. Then we define the <em>class transposition</em> <span class="SimpleMath">τ_r_1+ℤ^d L_1, r_2+ℤ^d L_2 ∈ Sym(ℤ^d)</span> as the involution which interchanges <span class="SimpleMath">r_1 + k L_1</span> and <span class="SimpleMath">r_2 + k L_2</span> for all <span class="SimpleMath">k ∈ ℤ^d</span>.</p>

<p>The class transposition <span class="SimpleMath">τ_r_1+ℤ^d L_1, r_2+ℤ^d L_2</span> interchanges the residue classes <span class="SimpleMath">r_1+ℤ^d L_1</span> and <span class="SimpleMath">r_2+ℤ^d L_2</span>, and fixes the complement of their union pointwise. The set of all class transpositions of <span class="SimpleMath">ℤ^d</span> generates the simple group CT(<span class="SimpleMath">ℤ^d</span>) (cf. <a href="chapBib.html#biBKohl13">[Koh13]</a>).</p>

<p>In the four-argument form, the arguments <var class="Arg">r1</var>, <var class="Arg">L1</var>, <var class="Arg">r2</var> and <var class="Arg">L2</var> stand for <span class="SimpleMath">r_1</span>, <span class="SimpleMath">L_1</span>, <span class="SimpleMath">r_2</span> and <span class="SimpleMath">L_2</span>, respectively. In the two-argument form, the arguments <var class="Arg">cl1</var> and <var class="Arg">cl2</var> stand for the residue classes <span class="SimpleMath">r_1+ℤ^2 L_1</span> and <span class="SimpleMath">r_2+ℤ^2 L_2</span>, respectively. Enclosing the argument list in list brackets is permitted. The residue classes <span class="SimpleMath">r_1+ℤ^2 L_1</span> and <span class="SimpleMath">r_2+ℤ^2 L_2</span> are stored as an attribute <code class="code">TransposedClasses</code>.</p>

<p>There is also a method for <code class="code">SplittedClassTransposition</code> available for class transpositions of <span class="SimpleMath">ℤ^2</span>. This method takes as first argument the class transposition, and as second argument a list of two integers. These integers are the numbers of parts into which the class transposition is to be sliced in each dimension. Note that the product of the returned class transpositions is not always equal to the class transposition passed as first argument. However this equality holds if the first entry of the second argument is 1.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ct := ClassTransposition([0,0],[[2,1],[0,2]],[1,0],[[2,1],[0,4]]);</span>
( (0,0)+(2,1)Z+(0,2)Z, (1,0)+(2,1)Z+(0,4)Z )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(ct);</span>

Rcwa permutation of Z^2 with modulus (2,1)Z+(0,4)Z, of order 2

            /
            | (m+1,(-m+4n)/2)  if (m,n) in (0,0)+(2,1)Z+(0,2)Z
 (m,n) |-&gt; &lt;  (m-1,(m+2n-1)/4) if (m,n) in (1,0)+(2,1)Z+(0,4)Z
            | (m,n)            otherwise
            \

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransposedClasses(ct);</span>
[ (0,0)+(2,1)Z+(0,2)Z, (1,0)+(2,1)Z+(0,4)Z ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ct = ClassTransposition(last);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SplittedClassTransposition(ct,[1,2]);</span>
[ ( (0,0)+(2,1)Z+(0,4)Z, (1,0)+(2,1)Z+(0,8)Z ), 
  ( (0,2)+(2,1)Z+(0,4)Z, (1,4)+(2,1)Z+(0,8)Z ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Product(last) = ct;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SplittedClassTransposition(ct,[2,1]);</span>
[ ( (0,0)+(4,0)Z+(0,2)Z, (1,0)+(4,2)Z+(0,4)Z ), 
  ( (2,1)+(4,0)Z+(0,2)Z, (3,1)+(4,2)Z+(0,4)Z ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Product(last) = ct;</span>
false

</pre></div>

<p><a id="X828438127DDAEBB4" name="X828438127DDAEBB4"></a></p>

<h5>5.2-3 <span class="Heading"> ClassRotation (for <span class="SimpleMath">ℤ^2</span>) </span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassRotation</code>( <var class="Arg">r</var>, <var class="Arg">L</var>, <var class="Arg">u</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassRotation</code>( <var class="Arg">cl</var>, <var class="Arg">u</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: the class rotation <span class="SimpleMath">ρ_r(m),u</span>.</p>

<p>Let <span class="SimpleMath">d ∈ ℕ</span>. Given a residue class <span class="SimpleMath">r+ℤ^dL</span> and a matrix <span class="SimpleMath">u ∈ GL(d,ℤ)</span>, the <em>class rotation</em> <span class="SimpleMath">ρ_r+ℤ^dL,u</span> is the rcwa mapping which maps <span class="SimpleMath">v ∈ r+ℤ^dL</span> to <span class="SimpleMath">vu + r(1-u)</span> and which fixes <span class="SimpleMath">ℤ^d ∖ r+ℤ^dL</span> pointwise. In the two-argument form, the argument <var class="Arg">cl</var> stands for the residue class <span class="SimpleMath">r+ℤ^dL</span>. Enclosing the argument list in list brackets is permitted. The argument <var class="Arg">u</var> is stored as an attribute <code class="code">RotationFactor</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">interchange := ClassRotation([0,0],[[1,0],[0,1]],[[0,1],[1,0]]);</span>
ClassRotation( Z^2, [ [ 0, 1 ], [ 1, 0 ] ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(interchange);</span>
Rcwa permutation of Z^2: (m,n) -&gt; (n,m)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">classes := AllResidueClassesModulo(Integers^2,[[2,1],[0,3]]);</span>
[ (0,0)+(2,1)Z+(0,3)Z, (0,1)+(2,1)Z+(0,3)Z, (0,2)+(2,1)Z+(0,3)Z, 
  (1,0)+(2,1)Z+(0,3)Z, (1,1)+(2,1)Z+(0,3)Z, (1,2)+(2,1)Z+(0,3)Z ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">transvection := ClassRotation(classes[5],[[1,1],[0,1]]);</span>
ClassRotation((1,1)+(2,1)Z+(0,3)Z,[[1,1],[0,1]])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(transvection);</span>

Tame rcwa permutation of Z^2 with modulus (2,1)Z+(0,3)Z, of order infinity

            /
            | (m,(3m+2n-3)/2) if (m,n) in (1,1)+(2,1)Z+(0,3)Z
 (m,n) |-&gt; &lt;  (m,n)           otherwise
            |
            \

</pre></div>

<p><a id="X7A14A8F48247E651" name="X7A14A8F48247E651"></a></p>

<h5>5.2-4 <span class="Heading"> ClassShift (for <span class="SimpleMath">ℤ^2</span>) </span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassShift</code>( <var class="Arg">r</var>, <var class="Arg">L</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassShift</code>( <var class="Arg">cl</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: the class shift <span class="SimpleMath">ν_r+ℤ^dL,k</span>.</p>

<p>Let <span class="SimpleMath">d ∈ ℕ</span>. Given a residue class <span class="SimpleMath">r+ℤ^dL</span> and an integer <span class="SimpleMath">k ∈ {1, dots, d}</span>, the <em>class shift</em> <span class="SimpleMath">ν_r+ℤ^dL,k</span> is the rcwa mapping which maps <span class="SimpleMath">v ∈ r+ℤ^dL</span> to <span class="SimpleMath">v + L_k</span> and which fixes <span class="SimpleMath">ℤ^d ∖ r+ℤ^dL</span> pointwise. Here <span class="SimpleMath">L_k</span> denotes the <span class="SimpleMath">k</span>th row of <span class="SimpleMath">L</span>.</p>

<p>In the two-argument form, the argument <var class="Arg">cl</var> stands for the residue class <span class="SimpleMath">r+ℤ^dL</span>. Enclosing the argument list in list brackets is permitted.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">shift1 := ClassShift([0,0],[[1,0],[0,1]],1);</span>
ClassShift( Z^2, 1 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(shift1);</span>
Tame rcwa permutation of Z^2: (m,n) -&gt; (m+1,n)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s := ClassShift(ResidueClass([1,1],[[2,1],[0,2]]),2);</span>
ClassShift((1,1)+(2,1)Z+(0,2)Z,2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(s);</span>

Tame rcwa permutation of Z^2 with modulus (2,1)Z+(0,2)Z, of order infinity

            /
            | (m,n+2) if (m,n) in (1,1)+(2,1)Z+(0,2)Z
 (m,n) |-&gt; &lt;  (m,n)   if (m,n) in (0,0)+(2,0)Z+(0,1)Z U 
            |                     (1,0)+(2,1)Z+(0,2)Z
            \

</pre></div>

<p>As for other rings, class transpositions, class rotations and class shifts of <span class="SimpleMath">ℤ^2</span> have the distinguishing properties <code class="code">IsClassTransposition</code>, <code class="code">IsClassRotation</code> and <code class="code">IsClassShift</code>.</p>

<p><a id="X8531E39785FFF8A7" name="X8531E39785FFF8A7"></a></p>

<h4>5.3 <span class="Heading">
  Methods for residue-class-wise affine mappings of <span class="SimpleMath">ℤ^2</span>
</span></h4>

<p>There are methods available for rcwa mappings of <span class="SimpleMath">ℤ^2</span> for the following general operations:</p>


<dl>
<dt><strong class="Mark"> Output </strong></dt>
<dd><p><code class="code">View</code>, <code class="code">Display</code>, <code class="code">Print</code>, <code class="code">String</code>, <code class="code">LaTeXStringRcwaMapping</code>, <code class="code">LaTeXAndXDVI</code>.</p>

</dd>
<dt><strong class="Mark"> Access to components </strong></dt>
<dd><p><code class="code">Modulus</code>, <code class="code">Coefficients</code>.</p>

</dd>
<dt><strong class="Mark"> Attributes </strong></dt>
<dd><p><code class="code">Support</code> / <code class="code">MovedPoints</code>, <code class="code">Order</code>, <code class="code">Multiplier</code>, <code class="code">Divisor</code>, <code class="code">PrimeSet</code>, <code class="code">One</code>, <code class="code">Zero</code>.</p>

</dd>
<dt><strong class="Mark"> Properties </strong></dt>
<dd><p><code class="code">IsInjective</code>, <code class="code">IsSurjective</code>, <code class="code">IsBijective</code>, <code class="code">IsTame</code>, <code class="code">IsIntegral</code>, <code class="code">IsBalanced</code>, <code class="code">IsClassWiseOrderPreserving</code>, <code class="code">IsOne</code>, <code class="code">IsZero</code>.</p>

</dd>
<dt><strong class="Mark"> Action on <span class="SimpleMath">ℤ^d</span> </strong></dt>
<dd><p><code class="code">^</code> (for points / finite sets / residue class unions), <code class="code">Trajectory</code>, <code class="code">ShortCycles</code>, <code class="code">Multpk</code>, <code class="code">ClassWiseOrderPreservingOn</code>, <code class="code">ClassWiseOrderReversingOn</code>, <code class="code">ClassWiseConstantOn</code>.</p>

</dd>
<dt><strong class="Mark"> Arithmetical operations </strong></dt>
<dd><p><code class="code">=</code>, <code class="code">*</code> (multiplication / composition and multiplication by a <span class="SimpleMath">2 × 2</span> matrix or an integer), <code class="code">^</code> (exponentiation and conjugation), <code class="code">Inverse</code>, <code class="code">+</code> (addition of a constant).</p>

</dd>
</dl>
<p>The above operations are documented either in the <strong class="pkg">GAP</strong> Reference Manual or earlier in this manual. The operations which are special for rcwa mappings of <span class="SimpleMath">ℤ^2</span> are described in the sequel.</p>

<p><a id="X8408B7837C9EED36" name="X8408B7837C9EED36"></a></p>

<h5>5.3-1 ProjectionsToCoordinates</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ProjectionsToCoordinates</code>( <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: the projections of the rcwa mapping <var class="Arg">f</var> of <span class="SimpleMath">ℤ^2</span> to the coordinates if such projections exist, and <code class="code">fail</code> otherwise.</p>

<p>An rcwa mapping can be projected to the first / second coordinate if and only if the first / second coordinate of the image of a point depends only on the first / second coordinate of the preimage. Note that this is a very strong and restrictive condition.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := RcwaMapping(ClassTransposition(0,2,1,2),ClassReflection(0,2));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(f);</span>

Rcwa mapping of Z^2 with modulus (2,0)Z+(0,2)Z

            /
            | (m+1,-n) if (m,n) in (0,0)+(2,0)Z+(0,2)Z
            | (m+1,n)  if (m,n) in (0,1)+(2,0)Z+(0,2)Z
 (m,n) |-&gt; &lt;  (m-1,-n) if (m,n) in (1,0)+(2,0)Z+(0,2)Z
            | (m-1,n)  if (m,n) in (1,1)+(2,0)Z+(0,2)Z
            |
            \

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(ProjectionsToCoordinates(f),Factorization);</span>
[ [ ( 0(2), 1(2) ) ], [ ClassReflection( 0(2) ) ] ]

</pre></div>

<p><a id="X83A1752F7BE9CE85" name="X83A1752F7BE9CE85"></a></p>

<h4>5.4 <span class="Heading">
  Methods for residue-class-wise affine groups and -monoids over <span class="SimpleMath">ℤ^2</span>
</span></h4>

<p>Residue-class-wise affine groups over <span class="SimpleMath">ℤ^2</span> can be entered by <code class="code">Group</code>, <code class="code">GroupByGenerators</code> and <code class="code">GroupWithGenerators</code>, like any groups in <strong class="pkg">GAP</strong>. Likewise, residue-class-wise affine monoids over <span class="SimpleMath">ℤ^2</span> can be entered by <code class="code">Monoid</code> and <code class="code">MonoidByGenerators</code>. The groups RCWA(<span class="SimpleMath">ℤ^2</span>) and CT(<span class="SimpleMath">ℤ^2</span>) are entered as <code class="code">RCWA(Integers^2)</code> and <code class="code">CT(Integers^2)</code>, respectively. The monoid Rcwa(<span class="SimpleMath">ℤ^2</span>) is entered as <code class="code">Rcwa(Integers^2)</code>.</p>

<p>There are methods provided for the operations <code class="code">Size</code>, <code class="code">IsIntegral</code>, <code class="code">IsClassWiseTranslating</code>, <code class="code">IsTame</code>, <code class="code">Modulus</code>, <code class="code">Multiplier</code> and <code class="code">Divisor</code>.</p>

<p>There are methods for <code class="func">IsomorphismRcwaGroup</code> (<a href="chap3.html#X7EB8A301790290C7"><span class="RefLink">3.1-1</span></a>) which embed the groups SL(2,ℤ) and GL(2,ℤ) into RCWA(<span class="SimpleMath">ℤ^2</span>) in such a way that the support of the image is a specified residue class:</p>

<p><a id="X79A8F9AD7E839862" name="X79A8F9AD7E839862"></a></p>

<h5>5.4-1 <span class="Heading">
    IsomorphismRcwaGroup (Embeddings of SL(2,ℤ) and GL(2,ℤ))
  </span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismRcwaGroup</code>( <var class="Arg">sl2z</var>, <var class="Arg">cl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismRcwaGroup</code>( <var class="Arg">gl2z</var>, <var class="Arg">cl</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a monomorphism from <var class="Arg">sl2z</var> respectively <var class="Arg">gl2z</var> to RCWA(<span class="SimpleMath">ℤ^2</span>), such that the support of the image is the residue class <var class="Arg">cl</var> and the generators are affine on <var class="Arg">cl</var>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sl := SL(2,Integers);</span>
SL(2,Integers)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := IsomorphismRcwaGroup(sl,ResidueClass([1,0],[[2,2],[0,3]]));</span>
[ [ [ 0, 1 ], [ -1, 0 ] ], [ [ 1, 1 ], [ 0, 1 ] ] ] -&gt; 
[ ClassRotation((1,0)+(2,2)Z+(0,3)Z,[[0,1],[-1,0]]), 
  ClassRotation((1,0)+(2,2)Z+(0,3)Z,[[1,1],[0,1]]) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Support(Image(phi));</span>
(1,0)+(2,2)Z+(0,3)Z
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gl := GL(2,Integers);</span>
GL(2,Integers)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := IsomorphismRcwaGroup(gl,ResidueClass([1,0],[[2,2],[0,3]]));</span>
[ [ [ 0, 1 ], [ 1, 0 ] ], [ [ -1, 0 ], [ 0, 1 ] ], 
  [ [ 1, 1 ], [ 0, 1 ] ] ] -&gt; 
[ ClassRotation((1,0)+(2,2)Z+(0,3)Z,[[0,1],[1,0]]), 
  ClassRotation((1,0)+(2,2)Z+(0,3)Z,[[-1,0],[0,1]]), 
  ClassRotation((1,0)+(2,2)Z+(0,3)Z,[[1,1],[0,1]]) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[[-47,-37],[61,48]]^phi;</span>
ClassRotation((1,0)+(2,2)Z+(0,3)Z,[[-47,-37],[61,48]])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(last:AsTable);</span>

Rcwa permutation of Z^2 with modulus (2,2)Z+(0,3)Z, of order 6

   [m,n] mod (2,2)Z+(0,3)Z   |              Image of [m,n]
-----------------------------+-------------------------------------------
 [0,0] [0,1] [0,2] [1,1]     |
 [1,2]                       | [m,n]
 [1,0]                       | [(-263m+122n+266)/3,(-1147m+532n+1147)/6]

</pre></div>

<p>The function <code class="func">DrawOrbitPicture</code> (<a href="chap3.html#X7D9DFAC97F9F0891"><span class="RefLink">3.3-3</span></a>) can also be used to depict orbits under the action of rcwa groups over <span class="SimpleMath">ℤ^2</span>. Further there is a function which depicts residue class unions of <span class="SimpleMath">ℤ^2</span> and partitions of <span class="SimpleMath">ℤ^2</span> into such:</p>

<p><a id="X812135EB87527F01" name="X812135EB87527F01"></a></p>

<h5>5.4-2 <span class="Heading"> DrawGrid </span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DrawGrid</code>( <var class="Arg">U</var>, <var class="Arg">yrange</var>, <var class="Arg">xrange</var>, <var class="Arg">filename</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DrawGrid</code>( <var class="Arg">P</var>, <var class="Arg">yrange</var>, <var class="Arg">xrange</var>, <var class="Arg">filename</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: nothing.</p>

<p>This function depicts the residue class union <var class="Arg">U</var> of <span class="SimpleMath">ℤ^2</span> or the partition <var class="Arg">P</var> of <span class="SimpleMath">ℤ^2</span> into residue class unions, respectively. The arguments <var class="Arg">yrange</var> and <var class="Arg">xrange</var> are the coordinate ranges of the rectangular snippet to be drawn, and the argument <var class="Arg">filename</var> is the name, i.e. the full path name, of the output file. If the first argument is a residue class union, the output picture is black-and-white, where black pixels represent members of <var class="Arg">U</var> and white pixels represent non-members. If the first argument is a partition of <span class="SimpleMath">ℤ^2</span> into residue class unions, the produced picture is colored, and different colors are used to denote membership in different parts.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap4.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap6.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
