<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (PatternClass) - Chapter 6: Pattern Classes</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap6"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap5_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap7_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap6.html">[MathJax off]</a></p>
<p><a id="X85A198CB7EBA4BDE" name="X85A198CB7EBA4BDE"></a></p>
<div class="ChapSects"><a href="chap6_mj.html#X85A198CB7EBA4BDE">6 <span class="Heading">Pattern Classes</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6_mj.html#X843CB33182B8E477">6.1 <span class="Heading">Transducers</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7A2DA7017E4F6BC4">6.1-1 Transducer</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7EB2EA8C78DA1F74">6.1-2 DeletionTransducer</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X85711F837F30E225">6.1-3 TransposedTransducer</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7BBBA46E84BDD089">6.1-4 InvolvementTransducer</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7E41CAC57CE71CB1">6.1-5 CombineAutTransducer</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6_mj.html#X7CFEC6DB7CA880CC">6.2 <span class="Heading">From Class to Basis and vice versa</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7FD8B2357CAAFC0B">6.2-1 BasisAutomaton</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X78BD24D7828004E8">6.2-2 ClassAutomaton</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X856A6F5085BAA7C3">6.2-3 BoundedClassAutomaton</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X82D67FC587793580">6.2-4 ClassAutFromBaseEncoding</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X80CBBEE08239B1B1">6.2-5 ClassAutFromBase</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X877C8457804E4B45">6.2-6 ExpandAlphabet</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6_mj.html#X8218BF7787571EE0">6.3 <span class="Heading">Direct Sum of Regular Classes</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7DC869E27CC3BFE0">6.3-1 ClassDirectSum</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6_mj.html#X80F7EB16817DDB99">6.4 <span class="Heading">Statistical Inspections</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X82004197784C17F8">6.4-1 Spectrum</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7E07D0B882DD9033">6.4-2 NumberAcceptedWords</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7BAE229C84A45841">6.4-3 AutStateTransitionMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7DF05204860111D5">6.4-4 AcceptedWords</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7C80854A872A5665">6.4-5 AcceptedWordsR</a></span>
</div></div>
</div>

<h3>6 <span class="Heading">Pattern Classes</span></h3>

<p>Permutation pattern classes can be determined using their corresponding basis. The basis of a pattern class is the anti-chain of the class, under the order of containment. A permutation <span class="SimpleMath">\(\pi\)</span> contains another permutation <span class="SimpleMath">\(\sigma\)</span> (of shorter length) if there is a subsequence in <span class="SimpleMath">\(\pi\)</span>, which is isomorphic to <span class="SimpleMath">\(\sigma\)</span>.</p>

<p>With the rational language of the rank encoded class, it is also possible to find the rational language of the basis and vice versa. Several specific kinds of transducers are used in this process. <a href="chapBib_mj.html#biBRegCloSetPerms">[AAR03]</a></p>

<p><a id="X843CB33182B8E477" name="X843CB33182B8E477"></a></p>

<h4>6.1 <span class="Heading">Transducers</span></h4>

<p><a id="X7A2DA7017E4F6BC4" name="X7A2DA7017E4F6BC4"></a></p>

<h5>6.1-1 Transducer</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Transducer</code>( <var class="Arg">states</var>, <var class="Arg">init</var>, <var class="Arg">transitions</var>, <var class="Arg">accepting</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: A record that represents a transducer.</p>

<p>A transducer is essentially an automaton, where running through the process does not determine whether the input is accepted, but the input is translated to another language, over a different alphabet.</p>

<p>Formally a transducer is a six-tuple with: <span class="SimpleMath">\(Q\)</span> being the set of states, <span class="SimpleMath">\(S\)</span> the input alphabet, <span class="SimpleMath">\(G\)</span> the output alphabet, <span class="SimpleMath">\(I \in Q\)</span> the start state, <span class="SimpleMath">\(A \subseteq Q\)</span> the set of accept states, and with the transition function <span class="SimpleMath">\(f: Q \times (S \cup \{e\}) \rightarrow Q \times (G \cup \{e\})\)</span>, where <span class="SimpleMath">\(e\)</span> is the empty word.</p>

<p>In this function the transducer is stored by defining how many states there are, which one (by index) is the start or initial state, the transitions are of the form <code class="code">[inputletter,outputletter,fromstate,tostate]</code> and a list of accept states. The input and output alphabet are determined by the input and output letters on the transitions.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">trans:=Transducer(3,1,[[1,2,1,2],[1,2,2,2],[2,2,1,3],[2,2,2,3],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1,1,3,3],[2,2,3,3]],[2]);</span>
rec( accepting := [ 2 ], initial := 1, states := 3, 
  transitions := [ [ 1, 2, 1, 2 ], [ 1, 2, 2, 2 ], [ 2, 2, 1, 3 ], 
      [ 2, 2, 2, 3 ], [ 1, 1, 3, 3 ], [ 2, 2, 3, 3 ] ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"></span></pre></div>

<p>This transducer can be visualised as the following graph: <br><center><img src="img/trans.jpg" WIDTH=241 HEIGHT=296 ></center><br></p>

<p><a id="X7EB2EA8C78DA1F74" name="X7EB2EA8C78DA1F74"></a></p>

<h5>6.1-2 DeletionTransducer</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DeletionTransducer</code>( <var class="Arg">k</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: A transducer over <code class="code">k</code>+1 states.</p>

<p>A deletion transducer is a transducer that deletes one letter of a rank encoded permutation and returns the correct rank encoding of the new permutation. The deletion transducer over <code class="code">k</code> deletes letters over the set of all rank encoded permutations with highest rank <code class="code">k</code>. Specifically, running through a deletion transducer with a rank encoded permutation, of highest rank <code class="code">k</code>, will lead to the set of all rank encoded permutations that have one letter of the initial permutation removed. It is important to note that computing these shorter permutations with the transducer, is done by reading the input permutation from right to left. For example the deletion transducer with <code class="code">k</code>=3, looks as follows:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DeletionTransducer(3);</span>
rec( accepting := [ 1 .. 3 ], initial := 4, states := 4, 
  transitions := [ [ 1, 1, 4, 4 ], [ 1, 0, 4, 1 ], [ 2, 1, 1, 1 ], 
      [ 1, 1, 1, 2 ], [ 3, 2, 1, 1 ], [ 1, 1, 2, 3 ], [ 1, 1, 3, 3 ], 
      [ 2, 2, 4, 4 ], [ 2, 0, 4, 2 ], [ 3, 2, 2, 2 ], [ 2, 2, 2, 3 ], 
      [ 2, 2, 3, 3 ], [ 3, 3, 4, 4 ], [ 3, 0, 4, 3 ], [ 3, 3, 3, 3 ] ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"></span></pre></div>

<p><br><center><img src="img/dt3.jpg" WIDTH=288 HEIGHT=317 ></center><br></p>

<p><a id="X85711F837F30E225" name="X85711F837F30E225"></a></p>

<h5>6.1-3 TransposedTransducer</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TransposedTransducer</code>( <var class="Arg">t</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: A new transducer with interchanged input and output letters on each transition.</p>

<p>A transducer is transposed when all origins and destinations of transitions are left the same as before but the input and output letters on each transition are interchanged. Taking the deletion transducer from above, its transpose looks as follows:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransposedTransducer(DeletionTransducer(3));</span>
rec( accepting := [ 1 .. 3 ], initial := 4, states := 4, 
  transitions := [ [ 1, 1, 4, 4 ], [ 0, 1, 4, 1 ], [ 1, 2, 1, 1 ], 
      [ 1, 1, 1, 2 ], [ 2, 3, 1, 1 ], [ 1, 1, 2, 3 ], [ 1, 1, 3, 3 ], 
      [ 2, 2, 4, 4 ], [ 0, 2, 4, 2 ], [ 2, 3, 2, 2 ], [ 2, 2, 2, 3 ], 
      [ 2, 2, 3, 3 ], [ 3, 3, 4, 4 ], [ 0, 3, 4, 3 ], [ 3, 3, 3, 3 ] ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"></span></pre></div>

<p><br><center><img src="img/dtt3.jpg" WIDTH=293 HEIGHT=319 ></center><br></p>

<p><a id="X7BBBA46E84BDD089" name="X7BBBA46E84BDD089"></a></p>

<h5>6.1-4 InvolvementTransducer</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InvolvementTransducer</code>( <var class="Arg">k</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: A transducer over <code class="code">k</code>+1 states, with a <code class="code">k</code> sized alphabet.</p>

<p>An involvement transducer is a transducer over <code class="code">k</code>+1 states, and deletes any number of letters in a rank encoded permutation, of rank at most <code class="code">k</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InvolvementTransducer(3);</span>
rec( accepting := [ 1 .. 4 ], initial := 4, states := 4, 
  transitions := [ [ 1, 1, 1, 2 ], [ 1, 0, 1, 3 ], [ 2, 1, 1, 1 ], 
      [ 2, 0, 1, 3 ], [ 3, 2, 1, 1 ], [ 3, 0, 1, 1 ], [ 1, 1, 2, 4 ], 
      [ 1, 0, 2, 1 ], [ 2, 2, 2, 4 ], [ 2, 0, 2, 2 ], [ 3, 2, 2, 2 ], 
      [ 3, 0, 2, 2 ], [ 1, 1, 3, 2 ], [ 1, 0, 3, 3 ], [ 2, 1, 3, 1 ], 
      [ 2, 0, 3, 3 ], [ 3, 1, 3, 3 ], [ 3, 0, 3, 3 ], [ 1, 1, 4, 4 ], 
      [ 1, 0, 4, 1 ], [ 2, 2, 4, 4 ], [ 2, 0, 4, 2 ], [ 3, 3, 4, 4 ], 
      [ 3, 0, 4, 4 ] ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"></span></pre></div>

<p><br><center><img src="img/it3.jpg" WIDTH=318 HEIGHT=331 ></center><br></p>

<p><a id="X7E41CAC57CE71CB1" name="X7E41CAC57CE71CB1"></a></p>

<h5>6.1-5 CombineAutTransducer</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CombineAutTransducer</code>( <var class="Arg">aut</var>, <var class="Arg">trans</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: An automaton consisting of a combination of <code class="code">aut</code> and <code class="code">trans</code>.</p>

<p>Combining automata and transducers is done over the natural "translation" of the by the automaton accepted language through the transducer and then building a new automaton that accepts the new language. The function <code class="code">CombineAutTransducer</code> does this process and returns the new non-deterministic automaton.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a:=Automaton("det",1,1,[[1]],[1],[1]);</span>
&lt; deterministic automaton on 1 letters with 1 states &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AutToRatExp(a);</span>
a*
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:=Transducer(2,1,[[1,2,1,2],[2,1,1,2],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1,1,2,1],[2,2,2,1]],[1]);</span>
rec( accepting := [ 1 ], initial := 1, states := 2, 
  transitions := [ [ 1, 2, 1, 2 ], [ 2, 1, 1, 2 ], [ 1, 1, 2, 1 ], 
      [ 2, 2, 2, 1 ] ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">res:=CombineAutTransducer(a,t);</span>
&lt; non deterministic automaton on 2 letters with 2 states &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AutToRatExp(res);</span>
(ba)*
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(res);</span>
   |  1       2
-------------------
 a |         [ 1 ]   
 b | [ 2 ]           
Initial state:   [ 1 ]
Accepting state: [ 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"></span></pre></div>

<p><a id="X7CFEC6DB7CA880CC" name="X7CFEC6DB7CA880CC"></a></p>

<h4>6.2 <span class="Heading">From Class to Basis and vice versa</span></h4>

<p><a id="X7FD8B2357CAAFC0B" name="X7FD8B2357CAAFC0B"></a></p>

<h5>6.2-1 BasisAutomaton</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BasisAutomaton</code>( <var class="Arg">a</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: An automaton that accepts the rank encoded permutations of the basis of the input automaton <code class="code">a</code>.</p>

<p>Every pattern class has a basis that consists of the smallest set of permutations which do not belong to the class. Using</p>

<p class="center">\[B(L)=(L^{r} D^{t})^{r} \cap L^{c}\]</p>

<p>it is possible using the deletion transducer <span class="SimpleMath">\(D\)</span> and the language of rank encoded permutations <span class="SimpleMath">\(L\)</span> to find the language of the rank encoded permutations of the basis <span class="SimpleMath">\(B(L)\)</span>, and thus the basis.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:=Parstacks(2,2);</span>
[ [ 2, 4 ], [ 3, 6 ], [ 2 ], [ 5, 6 ], [ 4 ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">xa:=GraphToAut(x,1,6);</span>
&lt; epsilon automaton on 5 letters with 66 states &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ma:=MinimalAutomaton(xa);</span>
&lt; deterministic automaton on 4 letters with 9 states &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(ma);</span>
   |  1  2  3  4  5  6  7  8  9  
--------------------------------
 a |  1  2  1  3  2  2  6  6  3  
 b |  3  2  3  3  4  3  6  9  3  
 c |  9  2  9  4  6  6  4  9  9  
 d |  8  2  8  7  5  5  7  8  8  
Initial state:   [ 1 ]
Accepting state: [ 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ba:=BasisAutomaton(ma);</span>
&lt; deterministic automaton on 4 letters with 9 states &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(ba);</span>
   |  1  2  3  4  5  6  7  8  9  
--------------------------------
 a |  2  2  1  3  4  2  2  2  2  
 b |  2  2  2  2  2  4  1  2  8  
 c |  2  2  2  2  2  2  1  2  2  
 d |  2  2  2  9  2  2  5  6  2  
Initial state:    [ 7 ]
Accepting states: [ 1, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AutToRatExp(ba);</span>
d(a(dbdb)*aaU@)UbUc
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"></span></pre></div>

<p>Ignoring the trailing <code class="code">UbUc</code> which essentially are noise, the basis of the pattern class indicates which permutations are avoided in this particular class. The shortest permutation in the basis, looking at the rational expression, is <span class="SimpleMath">\(daaa\)</span>, which can be translated to 4111 and decoded to the permutation 4123.</p>

<p><a id="X78BD24D7828004E8" name="X78BD24D7828004E8"></a></p>

<h5>6.2-2 ClassAutomaton</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassAutomaton</code>( <var class="Arg">a</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The automaton that accepts permutations of the class in their rank encoding.</p>

<p>The function <code class="code">ClassAutomaton</code> does the reverse process of <code class="code">BasisAutomaton</code>. Namely it takes the automaton that represents the language of the rank encoded basis of a permutation class, and using the formula</p>

<p class="center">\[L=B_{k} \cap ((B(L)^{r} I^{t})^{c} )^{r}\]</p>

<p>returns the automaton that accepts the rank encoded permutations of the class. In the formula, <span class="SimpleMath">\(B_{k}\)</span> is the automaton that accepts all permutations of any length with highest rank <span class="SimpleMath">\(k\)</span>, <span class="SimpleMath">\(B(L)\)</span> is the automaton that represents the basis and <span class="SimpleMath">\(I\)</span> is the involement transducer.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">xa:=Automaton("det",9,4,[[2,2,1,3,4,2,2,2,2],[2,2,2,2,2,4,1,2,8],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2,2,2,2,2,2,1,2,2],[2,2,2,9,2,2,5,6,2]],[7],[1,5]); </span>
&lt; deterministic automaton on 4 letters with 9 states &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ca:=ClassAutomaton(xa); </span>
&lt; deterministic automaton on 4 letters with 9 states &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(ca);</span>
   |  1  2  3  4  5  6  7  8  9  
--------------------------------
 a |  1  2  1  3  2  2  6  6  3  
 b |  3  2  3  3  4  3  6  9  3  
 c |  9  2  9  4  6  6  4  9  9  
 d |  8  2  8  7  5  5  7  8  8  
Initial state:   [ 1 ]
Accepting state: [ 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPossibleGraphAut(ca);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"></span></pre></div>

<p><a id="X856A6F5085BAA7C3" name="X856A6F5085BAA7C3"></a></p>

<h5>6.2-3 BoundedClassAutomaton</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BoundedClassAutomaton</code>( <var class="Arg">k</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: An automaton that accepts all rank encoded permutations, with highest rank being <code class="code">k</code>.</p>

<p>The bounded class automaton, is an automaton that accepts all rank encoded permutations, of any length, with highest rank <code class="code">k</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BoundedClassAutomaton(3);</span>
&lt; deterministic automaton on 3 letters with 3 states &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(last);</span>
   |  1  2  3  
--------------
 a |  1  1  2  
 b |  2  2  2  
 c |  3  3  3  
Initial state:   [ 1 ]
Accepting state: [ 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"></span></pre></div>

<p><a id="X82D67FC587793580" name="X82D67FC587793580"></a></p>

<h5>6.2-4 ClassAutFromBaseEncoding</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassAutFromBaseEncoding</code>( <var class="Arg">base</var>, <var class="Arg">k</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The class automaton from a list of rank encoded basis permutations.</p>

<p>Given the permutations in the basis, in their rank encoded form, and the bound of the rank of the permutations of the class, <code class="code">ClassAutFromBaseEncoding</code> builds the automaton that accepts rank encoded permutations of the class.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassAutFromBaseEncoding([[4,1,1,1]],4); </span>
&lt; deterministic automaton on 4 letters with 7 states &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(last);</span>
   |  1  2  3  4  5  6  7  
--------------------------
 a |  1  2  1  3  2  2  6  
 b |  3  2  3  3  4  3  4  
 c |  4  2  4  4  6  6  4  
 d |  7  2  7  7  5  5  7  
Initial state:   [ 1 ]
Accepting state: [ 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"></span></pre></div>

<p><a id="X80CBBEE08239B1B1" name="X80CBBEE08239B1B1"></a></p>

<h5>6.2-5 ClassAutFromBase</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassAutFromBase</code>( <var class="Arg">perms</var>, <var class="Arg">k</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The class automaton from a list of permutations of the basis.</p>

<p>Taking <code class="code">perms</code> which is the list of permutations in the basis and <code class="code">k</code> an integer which indicates the highest rank in the encoded permutations of the class, <code class="code">ClassAutFromBase</code> constructs the automaton that accepts the language of rank encoded permutations of the class.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassAutFromBase([[4,1,2,3]],4);</span>
&lt; deterministic automaton on 4 letters with 7 states &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(last);</span>
   |  1  2  3  4  5  6  7  
--------------------------
 a |  1  2  1  3  2  2  6  
 b |  3  2  3  3  4  3  4  
 c |  4  2  4  4  6  6  4  
 d |  7  2  7  7  5  5  7  
Initial state:   [ 1 ]
Accepting state: [ 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"></span></pre></div>

<p><a id="X877C8457804E4B45" name="X877C8457804E4B45"></a></p>

<h5>6.2-6 ExpandAlphabet</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExpandAlphabet</code>( <var class="Arg">a</var>, <var class="Arg">newAlphabet</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The automaton <code class="code">a</code>, over the alphabet of size <code class="code">newAlphabet</code>.</p>

<p>Given an automaton and the size of the new alphabet, which has to be bigger than the size of the alphabet in <code class="code">a</code> , <code class="code">ExpandAlphabet</code> changes the automaton <code class="code">a</code> to contain an alphabet of size <code class="code">newAlphabet</code>. The new letters have no transitions within the automaton.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">aut:=Automaton("det",3,2,[[2,2,3],[3,3,3]],[1],[3]);</span>
&lt; deterministic automaton on 2 letters with 3 states &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(aut);</span>
   |  1  2  3  
--------------
 a |  2  2  3  
 b |  3  3  3  
Initial state:   [ 1 ]
Accepting state: [ 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExpandAlphabet(aut,4);</span>
&lt; deterministic automaton on 4 letters with 3 states &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(last);</span>
   |  1  2  3  
--------------
 a |  2  2  3  
 b |  3  3  3  
 c |           
 d |           
Initial state:   [ 1 ]
Accepting state: [ 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"></span></pre></div>

<p><a id="X8218BF7787571EE0" name="X8218BF7787571EE0"></a></p>

<h4>6.3 <span class="Heading">Direct Sum of Regular Classes</span></h4>

<p>It is obvious that the direct sum of two rational pattern classes is also rational. But the skew sum of two rational pattern classes does not imply that the resulting pattern class is rational, because if the second class in the sum has infinitely many permutations, the alphabet of the skew sum class will be infinite and thusly the resulting class will not be rational.</p>

<p><a id="X7DC869E27CC3BFE0" name="X7DC869E27CC3BFE0"></a></p>

<h5>6.3-1 ClassDirectSum</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ClassDirectSum</code>( <var class="Arg">aut1</var>, <var class="Arg">aut2</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: An automaton that corresponds to the direct sum of <code class="code">aut1</code> with <code class="code">aut2</code>.</p>

<p><code class="code">ClassDirectSum</code> builds the concatenation automaton of <code class="code">aut1</code> with <code class="code">aut2</code>, which corresponds to the pattern class <code class="code">aut1</code> <span class="SimpleMath">\(\oplus\)</span> <code class="code">aut2</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a:=BasisAutomaton(GraphToAut(Parstacks(2,2),1,6));  </span>
&lt; deterministic automaton on 4 letters with 9 states &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AutToRatExp(a);                                     </span>
d(a(dbdb)*aaU@)UbUc
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b:=MinimalAutomaton(GraphToAut(Seqstacks(2,2),1,6));</span>
&lt; deterministic automaton on 3 letters with 3 states &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AutToRatExp(b);                                     </span>
((cc*(aUb)Ub)(cc*(aUb)Ub)*aUa)*
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ab:=ClassDirectSum(a,b);                            </span>
&lt; deterministic automaton on 4 letters with 11 states &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AutToRatExp(ab);                                    </span>
((d(acUc)c*(aUb)Ud(abUb))(cc*(aUb)Ub)*aUda(d(bdbd)*bdbaaUa)UbUc)((cc*(aUb)U\
b)(cc*(aUb)Ub)*aUa)*Ud(aU@)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"></span></pre></div>

<p><a id="X80F7EB16817DDB99" name="X80F7EB16817DDB99"></a></p>

<h4>6.4 <span class="Heading">Statistical Inspections</span></h4>

<p>It is of interest to see what permutations and how many of different length are accepted by the class, respectively the basis.</p>

<p>In this section, the examples will be inspecting the basis automaton of the token passing network containing 2 stacks of capacity 2, which are situated in parallel to each other.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:=Parstacks(2,2);</span>
[ [ 2, 4 ], [ 3, 6 ], [ 2 ], [ 5, 6 ], [ 4 ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">xa:=GraphToAut(x,1,6);</span>
&lt; epsilon automaton on 5 letters with 66 states &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ma:=MinimalAutomaton(xa);</span>
&lt; deterministic automaton on 4 letters with 9 states &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ba:=BasisAutomaton(ma);</span>
&lt; deterministic automaton on 4 letters with 9 states &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AutToRatExp(ba);</span>
d(a(dbdb)*aaU@)UbUc
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"></span></pre></div>

<p><a id="X82004197784C17F8" name="X82004197784C17F8"></a></p>

<h5>6.4-1 Spectrum</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Spectrum</code>( <var class="Arg">aut</var>[, <var class="Arg">int</var>] )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: A list indicating how many words of each length from 1 to <code class="code">int</code> or 15 (default) are accepted by the automaton.</p>

<p>Each entry in the returned list indicates how many words of length the index of the entry are accepted by the automaton <code class="code">aut</code>. The length of the list is by default 15, but if this is too much or too little the second optional argument regulates the length of the list.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Spectrum(ba);</span>
[ 3, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Spectrum(ba,20);</span>
[ 3, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"></span></pre></div>

<p><a id="X7E07D0B882DD9033" name="X7E07D0B882DD9033"></a></p>

<h5>6.4-2 NumberAcceptedWords</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NumberAcceptedWords</code>( <var class="Arg">aut</var>, <var class="Arg">len</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The number of words of length <code class="code">len</code> accepted by the automaton <code class="code">aut</code>.</p>

<p>Given the automaton <code class="code">aut</code> and the integer <code class="code">len</code>, <code class="code">NumberAcceptedWords</code> determines how many words of length <code class="code">len</code> are accepted by the automaton.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NumberAcceptedWords(ba,1);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NumberAcceptedWords(ba,16);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"></span></pre></div>

<p><a id="X7BAE229C84A45841" name="X7BAE229C84A45841"></a></p>

<h5>6.4-3 AutStateTransitionMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AutStateTransitionMatrix</code>( <var class="Arg">aut</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: A matrix containing the number of transitions between states of the automaton <code class="code">aut</code>.</p>

<p>In the matrix computed by <code class="code">AutStateTransitionMatrix</code> the rows are indexed by the state the transitions are originating from, the columnns are indexed by the states the transitions are ending at. Each entry <span class="SimpleMath">\(a_{i,j}\)</span> of the matrix represents the number of transitions from the state <span class="SimpleMath">\(i\)</span> to the state <span class="SimpleMath">\(j\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AutStateTransitionMatrix(ba);</span>
[ [ 0, 4, 0, 0, 0, 0, 0, 0, 0 ], [ 0, 4, 0, 0, 0, 0, 0, 0, 0 ], 
  [ 1, 3, 0, 0, 0, 0, 0, 0, 0 ], [ 0, 2, 1, 0, 0, 0, 0, 0, 1 ], 
  [ 0, 3, 0, 1, 0, 0, 0, 0, 0 ], [ 0, 3, 0, 1, 0, 0, 0, 0, 0 ], 
  [ 2, 1, 0, 0, 1, 0, 0, 0, 0 ], [ 0, 3, 0, 0, 0, 1, 0, 0, 0 ], 
  [ 0, 3, 0, 0, 0, 0, 0, 1, 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"></span></pre></div>

<p><a id="X7DF05204860111D5" name="X7DF05204860111D5"></a></p>

<h5>6.4-4 AcceptedWords</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AcceptedWords</code>( <var class="Arg">aut</var>, <var class="Arg">int</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: All words of length <code class="code">int</code> that are accepted by the automaton <code class="code">aut</code>.</p>

<p><code class="code">AcceptedWords</code> outputs all permutations accepted by the automaton <code class="code">aut</code>, which have length <code class="code">int</code>, in a list. The permutations are output in their rank encoding.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AcceptedWords(ba,1);</span>
[ [ 2 ], [ 3 ], [ 4 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AcceptedWords(ba,16);</span>
[ [ 4, 1, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 1, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"></span></pre></div>

<p><a id="X7C80854A872A5665" name="X7C80854A872A5665"></a></p>

<h5>6.4-5 AcceptedWordsR</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AcceptedWordsR</code>( <var class="Arg">aut</var>, <var class="Arg">int1</var>[, <var class="Arg">int2</var>] )</td><td class="tdright">( function )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AcceptedWordsReversed</code>( <var class="Arg">aut</var>, <var class="Arg">int1</var>[, <var class="Arg">int2</var>] )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The list of all by the automaton accepted words of length <code class="code">int1</code>, where each word is written in reverse.</p>

<p>The functions <code class="code">AcceptedWordsR</code> and <code class="code">AcceptedWordsReversed</code> are synonymous and take the following arguments; an automaton <code class="code">aut</code>, an integer <code class="code">int1</code> which indicates the length of the words that are accepted by the <code class="code">aut</code> and another integer <code class="code">int2</code> which is optional and represents the initial state of <code class="code">aut</code>. The return value of these functions is the list containing all permutations of length <code class="code">int1</code> that are accepted by <code class="code">aut</code>. The permutations are rank encoded and written in reverse.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AcceptedWordsR(ba,1);</span>
[ [ 2 ], [ 3 ], [ 4 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AcceptedWordsReversed(ba,16); </span>
[ [ 1, 1, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 1, 4 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"></span></pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap5_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap7_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
