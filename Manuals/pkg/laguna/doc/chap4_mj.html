<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (LAGUNA) - Chapter 4: LAGUNA functions</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap4"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap3_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap4.html">[MathJax off]</a></p>
<p><a id="X7F79B2207E293F2B" name="X7F79B2207E293F2B"></a></p>
<div class="ChapSects"><a href="chap4_mj.html#X7F79B2207E293F2B">4 <span class="Heading"><strong class="pkg">LAGUNA</strong> functions</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4_mj.html#X7B473F157842958E">4.1 <span class="Heading">General functions for group algebras</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X861A702283A667DF">4.1-1 IsGroupAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X82DBCA8F7DB21AC5">4.1-2 IsFModularGroupAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X849599E07C38A739">4.1-3 IsPModularGroupAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7C966B177BB62C72">4.1-4 UnderlyingGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X8534C18E7EA81CB8">4.1-5 UnderlyingRing</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X790470C48340E8F7">4.1-6 UnderlyingField</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4_mj.html#X81DC99ED7AC03E46">4.2 <span class="Heading">Operations with group algebra elements</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7B689C0284AC4296">4.2-1 Support</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X8401D79C8678D3FA">4.2-2 CoefficientsBySupport</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X81DD298A7C06EC82">4.2-3 TraceOfMagmaRingElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X780769238600AFD1">4.2-4 Length</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X86FA17BE858F2245">4.2-5 Augmentation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X83A318C887B3E735">4.2-6 PartialAugmentations</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X81EB2A0A8756372B">4.2-7 Involution</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X82D0BA3D7D3994F6">4.2-8 IsSymmetric</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7990BD877E89A9EC">4.2-9 IsUnitary</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X85CBFBAE78DE72E8">4.2-10 IsUnit</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X82EC4F49877D6EB1">4.2-11 InverseOp</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7FD01F52845445EC">4.2-12 BicyclicUnitOfType1</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X8631AD178508D219">4.2-13 BassCyclicUnit</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4_mj.html#X841733AB86D30446">4.3 <span class="Heading">Important attributes of group algebras</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7F7FD75E84BEE0EF">4.3-1 AugmentationHomomorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7B21DB3E7CD80983">4.3-2 AugmentationIdeal</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X850C29907A509533">4.3-3 RadicalOfAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X8292BEFC7922E773">4.3-4 WeightedBasis</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X84B25D3A812A8A2E">4.3-5 AugmentationIdealPowerSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X8567023A821E39A6">4.3-6 AugmentationIdealNilpotencyIndex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7C0D5F3C842302EC">4.3-7 AugmentationIdealOfDerivedSubgroupNilpotencyIndex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X837294D57E415E37">4.3-8 LeftIdealBySubgroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4_mj.html#X863248708784F94C">4.4 <span class="Heading">Computations with the unit group</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X817D5AC78754527F">4.4-1 NormalizedUnitGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7D40E42A7B678598">4.4-2 PcNormalizedUnitGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7E08F6E87C586A36">4.4-3 NaturalBijectionToPcNormalizedUnitGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X83715EF37B9FA94A">4.4-4 NaturalBijectionToNormalizedUnitGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X84D64AF17941FA7F">4.4-5 Embedding</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X853C045B7BA6A580">4.4-6 Units</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7E67BDA77E5E6077">4.4-7 PcUnits</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7F2532888184CB22">4.4-8 IsGroupOfUnitsOfMagmaRing</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7EF9BF297A9412AB">4.4-9 IsUnitGroupOfGroupRing</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X82AC131384191CCE">4.4-10 IsNormalizedUnitGroupOfGroupRing</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X82DCA8A57D0D1114">4.4-11 UnderlyingGroupRing</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7A0FFABC86F89517">4.4-12 UnitarySubgroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X859F07AE7A4D317B">4.4-13 BicyclicUnitGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7A39E44D87CDF7B0">4.4-14 GroupBases</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4_mj.html#X783C1A3D86A6656B">4.5 <span class="Heading">The Lie algebra of a group algebra</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7827B4158459DEA0">4.5-1 LieAlgebraByDomain</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7AA7DA6082639B23">4.5-2 IsLieAlgebraByAssociativeAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X85F4712B84624DB8">4.5-3 UnderlyingAssociativeAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X84050A268514F2EE">4.5-4 NaturalBijectionToLieAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X821DAFD585EA1DF3">4.5-5 NaturalBijectionToAssociativeAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X78C26E3F80E55AC2">4.5-6 IsLieAlgebraOfGroupRing</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X87CCD17A790BE256">4.5-7 UnderlyingGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X833439F7846784B5">4.5-8 Embedding</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X8111F58E7DE3E25C">4.5-9 LieCentre</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7C95C0057C977747">4.5-10 LieDerivedSubalgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7F97D08F7B738ADE">4.5-11 IsLieAbelian</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X859FF1B3812B8FCC">4.5-12 IsLieSolvable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X78452F4E875A62A8">4.5-13 IsLieNilpotent</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X8504EC257B764BA6">4.5-14 IsLieMetabelian</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7EEAA09F818CE548">4.5-15 IsLieCentreByMetabelian</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7C8EBFF5805F8C51">4.5-16 CanonicalBasis</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X83026DFF8461B96D">4.5-17 IsBasisOfLieAlgebraOfGroupRing</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X804ADF0280F67CDC">4.5-18 StructureConstantsTable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X87E9411284D1A346">4.5-19 LieUpperNilpotencyIndex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7D71DF0579FBE1C9">4.5-20 LieLowerNilpotencyIndex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7E5950517F0CDB47">4.5-21 LieDerivedLength</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4_mj.html#X7B16423A7FBED034">4.6 <span class="Heading">Other commands</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X85CE6B407910F768">4.6-1 SubgroupsOfIndexTwo</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7AFBD42180787A07">4.6-2 DihedralDepth</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7D7CD02F803FFC08">4.6-3 DimensionBasis</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X84B7C6A38473722F">4.6-4 LieDimensionSubgroups</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7B2EAF81791D6C68">4.6-5 LieUpperCodimensionSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7E5804B881DE4FF2">4.6-6 LAGInfo</a></span>
</div></div>
</div>

<h3>4 <span class="Heading"><strong class="pkg">LAGUNA</strong> functions</span></h3>

<p><a id="X7B473F157842958E" name="X7B473F157842958E"></a></p>

<h4>4.1 <span class="Heading">General functions for group algebras</span></h4>

<p><a id="X861A702283A667DF" name="X861A702283A667DF"></a></p>

<h5>4.1-1 IsGroupAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsGroupAlgebra</code>( <var class="Arg">KG</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>A group ring over a field is called a group algebra. For a group ring <var class="Arg">KG</var>, <code class="code">IsGroupAlgebra</code> returns <code class="keyw">true</code>, if the underlying ring of <var class="Arg">KG</var> is a field; <code class="keyw">false</code> is returned otherwise. This property will be set automatically for every group ring created by the function <code class="code">GroupRing</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsGroupAlgebra( GroupRing( GF( 2 ), DihedralGroup( 16 ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsGroupAlgebra( GroupRing( Integers, DihedralGroup( 16 ) ) );</span>
false      

</pre></div>

<p><a id="X82DBCA8F7DB21AC5" name="X82DBCA8F7DB21AC5"></a></p>

<h5>4.1-2 IsFModularGroupAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFModularGroupAlgebra</code>( <var class="Arg">KG</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>A group algebra <span class="SimpleMath">\(KG\)</span> over a field <span class="SimpleMath">\(K\)</span> is called <em>modular</em>, if the characteristic of the field <span class="SimpleMath">\(K\)</span> divides the order of some element in <span class="SimpleMath">\(G\)</span>. For a group algebra <var class="Arg">KG</var> of a finite group <span class="SimpleMath">\(G\)</span>, <code class="code">IsModularGroupAlgebra</code> returns <code class="keyw">true</code>, if <var class="Arg">KG</var> is modular according to this definition; <code class="keyw">false</code> is returned otherwise. This property will be set automatically for every group algebra, created by the function <code class="code">GroupRing</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsFModularGroupAlgebra( GroupRing( GF( 2 ), SymmetricGroup( 6 ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsFModularGroupAlgebra( GroupRing( GF( 2 ), CyclicGroup( 3 ) ) );</span>
false  

</pre></div>

<p><a id="X849599E07C38A739" name="X849599E07C38A739"></a></p>

<h5>4.1-3 IsPModularGroupAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPModularGroupAlgebra</code>( <var class="Arg">KG</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>A group algebra <span class="SimpleMath">\(KG\)</span> is said to be <span class="SimpleMath">\(p\)</span>-modular, if <span class="SimpleMath">\(K\)</span> is a field of characteristic <span class="SimpleMath">\(p\)</span> and <span class="SimpleMath">\(G\)</span> is a finite <span class="SimpleMath">\(p\)</span>-group for the same prime <span class="SimpleMath">\(p\)</span>. For a group algebra <var class="Arg">KG</var> of a finite group <span class="SimpleMath">\(G\)</span>, <code class="code">IsPModularGroupAlgebra</code> returns <code class="keyw">true</code>, if <var class="Arg">KG</var> is <span class="SimpleMath">\(p\)</span>-modular according to this definition; <code class="keyw">false</code> is returned otherwise. This property will be set automatically for every group algebra, created by the function <code class="code">GroupRing</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPModularGroupAlgebra( GroupRing( GF( 2 ), DihedralGroup( 16 ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPModularGroupAlgebra( GroupRing( GF( 2 ), SymmetricGroup( 6 ) ) );</span>
false        

</pre></div>

<p><a id="X7C966B177BB62C72" name="X7C966B177BB62C72"></a></p>

<h5>4.1-4 UnderlyingGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingGroup</code>( <var class="Arg">KG</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: the underlying group of a group ring</p>

<p>This attribute stores the underlying group of a group ring <var class="Arg">KG</var>. In fact, it refers to the attribute <code class="code">UnderlyingMagma</code> which returns the same result, and was introduced for group rings for convenience, and for teaching purposes.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KG := GroupRing( GF ( 2 ), DihedralGroup( 16 ) );</span>
&lt;algebra-with-one over GF(2), with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := UnderlyingGroup( KG );</span>
&lt;pc group of size 16 with 4 generators&gt;  

</pre></div>

<p><a id="X8534C18E7EA81CB8" name="X8534C18E7EA81CB8"></a></p>

<h5>4.1-5 UnderlyingRing</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingRing</code>( <var class="Arg">KG</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: the underlying ring of a group ring</p>

<p>This attribute stores the underlying ring of a group ring <var class="Arg">KG</var>. In fact, it refers to the attribute <code class="code">LeftActingDomain</code> which returns the same result, and was introduced for group rings for convenience, and for teaching purposes.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );</span>
&lt;algebra-with-one over GF(2), with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingRing( KG );</span>
GF(2)     

</pre></div>

<p><a id="X790470C48340E8F7" name="X790470C48340E8F7"></a></p>

<h5>4.1-6 UnderlyingField</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingField</code>( <var class="Arg">KG</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: the underlying field of a group algebra</p>

<p>This attribute stores the underlying field of a group algebra <var class="Arg">KG</var>. In fact, it refers to the attribute <code class="code">LeftActingDomain</code> which returns the same result, and was introduced for group algebras for convenience, and for teaching purposes.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );</span>
&lt;algebra-with-one over GF(2), with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingField( KG );</span>
GF(2)    

</pre></div>

<p><a id="X81DC99ED7AC03E46" name="X81DC99ED7AC03E46"></a></p>

<h4>4.2 <span class="Heading">Operations with group algebra elements</span></h4>

<p><a id="X7B689C0284AC4296" name="X7B689C0284AC4296"></a></p>

<h5>4.2-1 Support</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Support</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: support of x as a list of elements of the underlying group</p>

<p>Returns the support of a group ring element <var class="Arg">x</var>. The support of a non-zero element <span class="SimpleMath">\( x = \alpha_1 \cdot g_1 + \alpha_2 \cdot g_2 + \cdots + \alpha_k \cdot g_k\)</span> of a group ring is the list of elements <span class="SimpleMath">\(g_i \in G\)</span> for which the coefficient <span class="SimpleMath">\(\alpha_i\)</span> is non-zero. The support of the zero element of a group ring is defined to be the empty list. This method is also applicable to elements of magma rings.</p>


<div class="example"><pre>

# First we create an element x to use in in the series of examples.
# We map the minimal generating system of the group G to its group algebra
# and denote their images as a and b
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:=DihedralGroup(16);; KG:=GroupRing(GF(2),G);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := List( MinimalGeneratingSet( G ), g -&gt; g^Embedding( G, KG ) );</span>
[ (Z(2)^0)*f1, (Z(2)^0)*f2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := l[1]; b := l[2]; e := One( KG ); # we denote the identity by e</span>
(Z(2)^0)*f1
(Z(2)^0)*f2
(Z(2)^0)*&lt;identity&gt; of ...
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := ( e + a ) * ( e + b );</span>
(Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Support( x );</span>
[ &lt;identity&gt; of ..., f1, f2, f1*f2 ]     

</pre></div>

<p><a id="X8401D79C8678D3FA" name="X8401D79C8678D3FA"></a></p>

<h5>4.2-2 CoefficientsBySupport</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CoefficientsBySupport</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: coefficients of support elements as list of elements of the underlying ring</p>

<p>Returns a list that contains the coefficients corresponding to the elements of <code class="code">Support( x )</code> in the same order as the elements appear in <code class="code">Support( x )</code>. This method is also applicable to elements of magma rings.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x;</span>
(Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CoefficientsBySupport( x );</span>
[ Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0 ]   

</pre></div>

<p><a id="X81DD298A7C06EC82" name="X81DD298A7C06EC82"></a></p>

<h5>4.2-3 TraceOfMagmaRingElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TraceOfMagmaRingElement</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: an element of the underlying ring</p>

<p>Returns the trace of a group ring element <var class="Arg">x</var>. By definition, the trace of an element <span class="SimpleMath">\( x = \alpha_1 \cdot 1 + \alpha_2 \cdot g_2 + \cdots + \alpha_k \cdot g_k \)</span> is equal to <span class="SimpleMath">\(\alpha_1\)</span>, that is, the coefficient of the identity element in <span class="SimpleMath">\(G\)</span>. The trace of the zero element is zero. This method is also applicable to elements of magma rings.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x;</span>
(Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TraceOfMagmaRingElement( x );</span>
Z(2)^0        

</pre></div>

<p><a id="X780769238600AFD1" name="X780769238600AFD1"></a></p>

<h5>4.2-4 Length</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Length</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The length of an element of a group ring <var class="Arg">x</var> is defined as the number of elements in its support. This method is also applicable to elements of magma rings.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x;</span>
(Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( x );</span>
4     

</pre></div>

<p><a id="X86FA17BE858F2245" name="X86FA17BE858F2245"></a></p>

<h5>4.2-5 Augmentation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Augmentation</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: the sum of coefficients of a group ring element</p>

<p>The augmentation of a group ring element <span class="SimpleMath">\( x = \alpha_1 \cdot g_1 + \alpha_2 \cdot g_2 + \cdots + \alpha_k \cdot g_k\)</span> is the sum of its coefficients <span class="SimpleMath">\( \alpha_1 + \alpha_2 + \cdots + \alpha_k \)</span>. The method is also applicable to elements of magma rings.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x;</span>
(Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Augmentation( x );</span>
0*Z(2)     

</pre></div>

<p><a id="X83A318C887B3E735" name="X83A318C887B3E735"></a></p>

<h5>4.2-6 PartialAugmentations</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PartialAugmentations</code>( <var class="Arg">KG</var>, <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list of partial augmentations and a list of conjugacy class representatives</p>

<p>The partial augmentation of an element <span class="SimpleMath">\( x = \alpha_1 \cdot g_1 + \alpha_2 \cdot g_2 + \cdots + \alpha_k \cdot g_k\)</span> of the group ring <span class="SimpleMath">\(KG\)</span>, corresponding to the conjugacy class of an element <span class="SimpleMath">\(g\)</span> from the underlying group <span class="SimpleMath">\(G\)</span> is the sum of coefficients <span class="SimpleMath">\(\alpha_i\)</span> taken over all <span class="SimpleMath">\(g_i\)</span> such that <span class="SimpleMath">\(g_i\)</span> is conjugated to <span class="SimpleMath">\(g\)</span>. The function returns a list of two lists, the first one is a list of partial augmentations, and the second is a list of representatives of appropriate conjugacy classes of elements of the group <span class="SimpleMath">\(G\)</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">y := x + a*b^2;</span>
(Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2+(Z(2)^
0)*f1*f3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PartialAugmentations( KG, y );</span>
[ [ Z(2)^0, 0*Z(2), Z(2)^0, Z(2)^0 ], [ &lt;identity&gt; of ..., f1, f2, f1*f2 ] ]    

</pre></div>

<p><a id="X81EB2A0A8756372B" name="X81EB2A0A8756372B"></a></p>

<h5>4.2-7 Involution</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Involution</code>( <var class="Arg">x</var>[[, <var class="Arg">f</var>], <var class="Arg">s</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: an element of a group ring</p>

<p>Let <span class="SimpleMath">\(KG\)</span> be a group ring, <span class="SimpleMath">\(f\)</span> be a homomorphism from the group <span class="SimpleMath">\(G\)</span> to the unit group of the ring <span class="SimpleMath">\(K\)</span>. Furthermore, let <span class="SimpleMath">\(s\)</span> be a mapping <span class="SimpleMath">\(G \rightarrow G\)</span>, such that <span class="SimpleMath">\(s^2\)</span> is the identity mapping on <span class="SimpleMath">\(G\)</span> and for every element <span class="SimpleMath">\(g \in G\)</span> <span class="SimpleMath">\(f(g*s(g))\)</span> equals <span class="SimpleMath">\(f(s(g)*g)\)</span> and equals the identity element of the ring <span class="SimpleMath">\(K\)</span>. Then the involution of <span class="SimpleMath">\(KG\)</span> induced by <span class="SimpleMath">\(f\)</span> and <span class="SimpleMath">\(s\)</span> is defined by <span class="SimpleMath">\( \alpha_1 \cdot g_1 + \alpha_2 \cdot g_2 + \cdots + \alpha_k \cdot g_k \mapsto \alpha_1 \cdot f(g_1) \cdot s(g_1) + \alpha_2 \cdot f(g_2) \cdot s(g_2) + \cdots + \alpha_k \cdot f(g_k) \cdot s(g_k)\)</span>.</p>

<p>The method returns the image of <var class="Arg">x</var> under the involution of <span class="SimpleMath">\(KG\)</span> induced by <span class="SimpleMath">\(f\)</span> and <span class="SimpleMath">\(s\)</span>. If the mapping <span class="SimpleMath">\(f\)</span> is omitted, <span class="SimpleMath">\(f\)</span> is assumed to map everything to the identity element of the ring <span class="SimpleMath">\(K\)</span>. If both mappings are omitted, it returns the result of so-called classical involution, induced by the mapping <span class="SimpleMath">\( x \mapsto x^{-1}\)</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x;</span>
(Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Involution( x );</span>
(Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f1+(Z(2)^0)*f1*f2+(Z(2)^0)*f2*f3*f4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := List( MinimalGeneratingSet( G ), g -&gt; g^Embedding( G, KG ) );</span>
[ (Z(2)^0)*f1, (Z(2)^0)*f2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( l, Involution ); # check how involution acts on elements of G</span>
[ (Z(2)^0)*f1, (Z(2)^0)*f2*f3*f4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( l, g -&gt; g^-1 );</span>
[ (Z(2)^0)*f1, (Z(2)^0)*f2*f3*f4 ]     

</pre></div>

<p><a id="X82D0BA3D7D3994F6" name="X82D0BA3D7D3994F6"></a></p>

<h5>4.2-8 IsSymmetric</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSymmetric</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>An element of a group ring is called <em>symmetric</em> if it is fixed under the classical involution. This property is checked here.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSymmetric( x );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSymmetric( x * Involution( x ) );</span>
true     

</pre></div>

<p><a id="X7990BD877E89A9EC" name="X7990BD877E89A9EC"></a></p>

<h5>4.2-9 IsUnitary</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsUnitary</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>A unit of a group ring is called unitary if the classical involution inverts it. This property is checked here.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsUnitary(x);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l:=List(MinimalGeneratingSet(G),g -&gt; g^Embedding(G,KG));</span>
[ (Z(2)^0)*f1, (Z(2)^0)*f2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(l,IsUnitary); # check that elements of G are unitary</span>
[ true, true ]   

</pre></div>

<p><a id="X85CBFBAE78DE72E8" name="X85CBFBAE78DE72E8"></a></p>

<h5>4.2-10 IsUnit</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsUnit</code>( [<var class="Arg">KG</var>, ]<var class="Arg">x</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>This method improves a standard <strong class="pkg">GAP</strong> functionality for modular group algebras.</p>

<p>In the two-argument version the method returns <code class="keyw">true</code> if <var class="Arg">x</var> is an invertible element of the modular group algebra <var class="Arg">KG</var> and <code class="keyw">false</code> otherwise. This can be done very quickly by checking whether the augmentation of the element <var class="Arg">x</var> is non-zero.</p>

<p>If the first argument is omitted, then <strong class="pkg">LAGUNA</strong> constructs the group <span class="SimpleMath">\(H\)</span> generated by the support of <var class="Arg">x</var>, and, if this group is a finite <span class="SimpleMath">\(p\)</span>-group, then checks whether the coefficients of <var class="Arg">x</var> belong to a field <span class="SimpleMath">\(F\)</span> of characteristic <span class="SimpleMath">\(p\)</span>. If this is the case, then <code class="code">IsUnit( FH, x )</code> is called; otherwise, standard <strong class="pkg">GAP</strong> method is used.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x;</span>
(Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsUnit( KG, x ); # clearly, is not a unit due to augmentation zero</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">y := One( KG ) + x; # this should give a unit</span>
(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsUnit( KG, y );</span>
true       

</pre></div>

<p><a id="X82EC4F49877D6EB1" name="X82EC4F49877D6EB1"></a></p>

<h5>4.2-11 InverseOp</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InverseOp</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the inverse element of an element of a group ring</p>

<p>This method improves a standard <strong class="pkg">GAP</strong> functionality for modular group algebras. It calculates the inverse of a group algebra element. The user can also invoke this function by typing <code class="code"> x^-1 </code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">y;</span>
(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">y^-1;</span>
(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f3+(Z(2)^0)*f4+(Z(2)^0)*f1*f2+(Z(2)^
0)*f1*f3+(Z(2)^0)*f1*f4+(Z(2)^0)*f2*f4+(Z(2)^0)*f1*f2*f4+(Z(2)^0)*f2*f3*f4+(
Z(2)^0)*f1*f2*f3*f4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">y * y^-1;</span>
(Z(2)^0)*&lt;identity&gt; of ...    

</pre></div>

<p><a id="X7FD01F52845445EC" name="X7FD01F52845445EC"></a></p>

<h5>4.2-12 BicyclicUnitOfType1</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BicyclicUnitOfType1</code>( [<var class="Arg">KG</var>, ]<var class="Arg">a</var>, <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BicyclicUnitOfType2</code>( [<var class="Arg">KG</var>, ]<var class="Arg">a</var>, <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: an element of a group ring</p>

<p>let <span class="SimpleMath">\(a\)</span> be an element of order <span class="SimpleMath">\(n\)</span> of a group <span class="SimpleMath">\(G\)</span>. We put <span class="SimpleMath">\(\alpha = 1 + a + a^2 + ... +a^{n-1} \)</span>. Then <span class="SimpleMath">\((a-1)*g*\alpha\)</span> and <span class="SimpleMath">\(\alpha*g*(a-1)\)</span> are nilpotent of index two for any element <span class="SimpleMath">\(g\)</span> of the group <span class="SimpleMath">\(G\)</span> not containing in the normalizer <span class="SimpleMath">\(N_G(\langle a \rangle)\)</span>, and the units <span class="SimpleMath">\(u_{a,g} = 1 + (a-1) * g * \alpha \)</span> and <span class="SimpleMath">\(v_{a,g} = 1 + \alpha * g * (a-1) \)</span> are called <em>bicyclic units</em> of the 1st and 2nd type respectively. Note that <span class="SimpleMath">\(u_{a,g}\)</span> and <span class="SimpleMath">\(v_{a,g}\)</span> may coincide for some <span class="SimpleMath">\(a\)</span> and <span class="SimpleMath">\(g\)</span>, but in general this does not hold. In the three-argument version these methods construct bicyclic units of both types when <var class="Arg">a</var> and <var class="Arg">g</var> are elements of the underlying group <span class="SimpleMath">\(G\)</span> of a group ring <var class="Arg">KG</var>. The two-argument version accepts images of elements <var class="Arg">a</var> and <var class="Arg">g</var> from the underlying group in the group ring <span class="SimpleMath">\(KG\)</span> obtained using the mapping <code class="code">Embedding( G, KG )</code>. Note that it is not actually checked that <span class="SimpleMath">\(g\)</span> is not contained in <span class="SimpleMath">\(N_G(\langle a \rangle)\)</span>, because this is verified in <code class="func">BicyclicUnitGroup</code> (<a href="chap4_mj.html#X859F07AE7A4D317B"><span class="RefLink">4.4-13</span></a>).</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SmallGroup(32,6);</span>
&lt;pc group of size 32 with 5 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KG := GroupRing( GF(2), G );</span>
&lt;algebra-with-one over GF(2), with 5 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := MinimalGeneratingSet( G );</span>
[ f1, f2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g[1] in Normalizer( G, Subgroup( G, [g[2]] ) );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g[2] in Normalizer( G, Subgroup( G, [g[1]] ) );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := List( g, x -&gt; x^Embedding( G, KG ) );</span>
[ (Z(2)^0)*f1, (Z(2)^0)*f2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BicyclicUnitOfType1(g[1],g[2]) = BicyclicUnitOfType2(g[1],g[2]);</span>
false                                                                       

</pre></div>

<p><a id="X8631AD178508D219" name="X8631AD178508D219"></a></p>

<h5>4.2-13 BassCyclicUnit</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BassCyclicUnit</code>( [<var class="Arg">ZG</var>, ]<var class="Arg">g</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: an element of a group ring</p>

<p>Let <var class="Arg">g</var> be an element of order <span class="SimpleMath">\(n\)</span> of the group <span class="SimpleMath">\(G\)</span>, and 1 &lt; <var class="Arg">k</var> &lt; <span class="SimpleMath">\(n\)</span> be such that <var class="Arg">k</var> and <span class="SimpleMath">\(n\)</span> are coprime, then <var class="Arg">k</var>^Phi(<span class="SimpleMath">\(n\)</span>) is congruent to 1 modulo <span class="SimpleMath">\(n\)</span>. The unit b(g,k)= ( \sum_{j=0}^{k-1} g^j )^Phi(n) + ( (1-k^Phi(n))/n ) * Hat(g), where Hat(g) = g + g^2 + ... + g^n, is called a <em>Bass cyclic unit</em> of the integral group ring <var class="Arg">ZG</var>.</p>

<p>The three-argument version constructs the Bass cyclic unit <span class="SimpleMath">\(b(g,k)\)</span> for the element <var class="Arg">g</var> from the underlying group <span class="SimpleMath">\(G\)</span> of the group ring <var class="Arg">ZG</var>. The two-argument version accepts the image of <var class="Arg">g</var> in the group ring <span class="SimpleMath">\(ZG\)</span> obtained using the mapping <code class="code">Embedding( G, KG )</code>.</p>

<p>Remark that when <span class="SimpleMath">\(G\)</span> is a finite nilpotent group, the group generated by the Bass cyclic units contain a subgroup of finite index in the centre of the unit group of <var class="Arg">ZG</var> <a href="chapBib_mj.html#biBJePaSe96">[JPS96]</a>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := SymmetricGroup( 5 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZS := GroupRing( Integers, S );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := Embedding( S, ZS );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BassCyclicUnit( ZS, (1,3,2,5,4) , 3 );</span>
(1)*()+(-2)*(1,2,4,3,5)+(-2)*(1,3,2,5,4)+(3)*(1,4,5,2,3)+(1)*(1,5,3,4,2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BassCyclicUnit( (1,3,2,5,4)^f, 3 ); </span>
(1)*()+(-2)*(1,2,4,3,5)+(-2)*(1,3,2,5,4)+(3)*(1,4,5,2,3)+(1)*(1,5,3,4,2)

</pre></div>

<p><a id="X841733AB86D30446" name="X841733AB86D30446"></a></p>

<h4>4.3 <span class="Heading">Important attributes of group algebras</span></h4>

<p><a id="X7F7FD75E84BEE0EF" name="X7F7FD75E84BEE0EF"></a></p>

<h5>4.3-1 AugmentationHomomorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AugmentationHomomorphism</code>( <var class="Arg">KG</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a homomorphism from a group ring to the underlying ring</p>

<p>The mapping which maps an element of a group ring <span class="SimpleMath">\(KG\)</span> to its augmentation is a homomorphism from <span class="SimpleMath">\(KG\)</span> onto the ring <span class="SimpleMath">\(K\)</span>; see <code class="func">Augmentation</code> (<a href="chap4_mj.html#X86FA17BE858F2245"><span class="RefLink">4.2-5</span></a>). This attribute stores this homomorphism for the group ring <var class="Arg">KG</var>.</p>

<p>Please note that for calculation of the augmentation of an element of a group ring the user is strongly recommended to use <code class="func">Augmentation</code> (<a href="chap4_mj.html#X86FA17BE858F2245"><span class="RefLink">4.2-5</span></a>) which works much faster than <code class="code">AugmentationHomomorphism</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := GF( 2 ); G := SymmetricGroup( 3 ); FG := GroupRing( F, G );</span>
GF(2)
Sym( [ 1 .. 3 ] )
&lt;algebra-with-one over GF(2), with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e := Embedding( G,FG );</span>
&lt;mapping: SymmetricGroup( [ 1 .. 3 ] ) -&gt; AlgebraWithOne( GF(2), ... ) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := (1,2)^e; y := (1,3)^e;</span>
(Z(2)^0)*(1,2)
(Z(2)^0)*(1,3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := AugmentationHomomorphism( FG );</span>
[ (Z(2)^0)*(1,2,3), (Z(2)^0)*(1,2) ] -&gt; [ Z(2)^0, Z(2)^0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x^a; y^a; ( x + y )^a; # this is slower</span>
Z(2)^0
Z(2)^0
0*Z(2)   
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Augmentation(x); Augmentation(y); Augmentation( x + y ); # this is faster</span>
Z(2)^0
Z(2)^0
0*Z(2)   

</pre></div>

<p><a id="X7B21DB3E7CD80983" name="X7B21DB3E7CD80983"></a></p>

<h5>4.3-2 AugmentationIdeal</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AugmentationIdeal</code>( <var class="Arg">KG</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: an ideal of a group ring</p>

<p>If <span class="SimpleMath">\(KG\)</span> is a group ring, then its augmentation ideal <span class="SimpleMath">\(A\)</span> is generated by all elements of the form <span class="SimpleMath">\(g-1\)</span>, where <span class="SimpleMath">\(g \in G\)</span> \ { <span class="SimpleMath">\(1\)</span> }. The augmentation ideal consists of all elements of <span class="SimpleMath">\(FG\)</span> with augmentation <span class="SimpleMath">\(0\)</span>; see <code class="func">Augmentation</code> (<a href="chap4_mj.html#X86FA17BE858F2245"><span class="RefLink">4.2-5</span></a>). This method changes a standard <strong class="pkg">GAP</strong> functionality for modular group algebras and returns the augmentation ideal of a modular group algebra <var class="Arg">KG</var>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );</span>
&lt;algebra-with-one over GF(2), with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AugmentationIdeal( KG );</span>
&lt;two-sided ideal in &lt;algebra-with-one over GF(2), with 4 generators&gt;,
  (dimension 15)&gt;

</pre></div>

<p><a id="X850C29907A509533" name="X850C29907A509533"></a></p>

<h5>4.3-3 RadicalOfAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RadicalOfAlgebra</code>( <var class="Arg">KG</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: an ideal of a group algebra</p>

<p>This method improves a standard <strong class="pkg">GAP</strong> functionality for modular group algebras of finite <span class="SimpleMath">\(p\)</span>-groups. Since in this case the radical of the group algebra coincides with its augmentation ideal, this method simply checks if the algebra <var class="Arg">KG</var> is a <span class="SimpleMath">\(p\)</span>-modular group algebra, and, if yes, it returns the augmentation ideal; otherwise, the standard <strong class="pkg">GAP</strong> method will be used.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );</span>
&lt;algebra-with-one over GF(2), with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RadicalOfAlgebra( KG );</span>
&lt;two-sided ideal in &lt;algebra-with-one over GF(2), with 4 generators&gt;,
  (dimension 15)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RadicalOfAlgebra( KG ) = AugmentationIdeal( KG );</span>
true     

</pre></div>

<p><a id="X8292BEFC7922E773" name="X8292BEFC7922E773"></a></p>

<h5>4.3-4 WeightedBasis</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WeightedBasis</code>( <var class="Arg">KG</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a record of two components: weighted basis elements and their weights</p>

<p>The argument <var class="Arg">KG</var> must be a <span class="SimpleMath">\(p\)</span>-modular group algebra.</p>

<p>For a group algebra <span class="SimpleMath">\(KG\)</span>, let <span class="SimpleMath">\(A\)</span> denote the augmentation ideal, and assume that <span class="SimpleMath">\(c\)</span> is the smallest number such that <span class="SimpleMath">\(A^c=0\)</span>. Then a weighted basis of <span class="SimpleMath">\(KG\)</span> is some basis <span class="SimpleMath">\( b_1, \ldots, b_n \)</span> for the augmentation ideal <span class="SimpleMath">\(A\)</span>, for which there are indices <span class="SimpleMath">\( i_1=1, \ldots, i_{c-1} \)</span> such that <span class="SimpleMath">\( b_{i_k}, \ldots, b_n \)</span> is a basis for <span class="SimpleMath">\(A^k\)</span>. The weight of an element <span class="SimpleMath">\(b_i\)</span> of a weighted basis is the unique integer <span class="SimpleMath">\(w\)</span> such that <span class="SimpleMath">\(b_i\)</span> belongs to <span class="SimpleMath">\(w\)</span>-th power of <span class="SimpleMath">\(A\)</span> but does not belong to its <span class="SimpleMath">\((w+1)\)</span>-th power.</p>

<p>Note that this function actually constructs a basis for the <em>augmentation ideal</em> of <var class="Arg">KG</var> and not for <var class="Arg">KG</var> itself. Since the augmentation ideal has co-dimension 1 in <code class="code">KG</code>, a basis for <code class="code">KG</code> can be easily obtained by adjoining the identity element of the group.</p>

<p>The method returns a record whose basis entry is the basis and the weights entry is a list of the corresponding weights the of basis elements. See Section <a href="chap3_mj.html#X7B74767A849D921E"><span class="RefLink">3.3</span></a> for more details.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KG := GroupRing( GF( 2 ), ElementaryAbelianGroup( 4 ) );</span>
&lt;algebra-with-one over GF(2), with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">WeightedBasis( KG );</span>
rec( 
  weightedBasis := [ (Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f1, 
      (Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f2, 
      (Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2 ], 
  weights := [ 1, 1, 2 ] )

</pre></div>

<p><a id="X84B25D3A812A8A2E" name="X84B25D3A812A8A2E"></a></p>

<h5>4.3-5 AugmentationIdealPowerSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AugmentationIdealPowerSeries</code>( <var class="Arg">KG</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a list of ideals of a group algebra</p>

<p>The argument <var class="Arg">KG</var> is a <span class="SimpleMath">\(p\)</span>-modular group algebra. The method returns a list whose elements are the terms of the augmentation ideal filtration of <var class="Arg">KG</var>, that is <code class="code">AugmentationIdealPowerSeries(A)[i]</code> is the <span class="SimpleMath">\(i\)</span>-th power of the augmentation ideal of <var class="Arg">KG</var>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );</span>
&lt;algebra-with-one over GF(2), with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s := AugmentationIdealPowerSeries( KG );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s[2];</span>
&lt;algebra of dimension 13 over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(s,Dimension);</span>
[ 15, 13, 11, 9, 7, 5, 3, 1, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length(s);</span>
9

</pre></div>

<p><a id="X8567023A821E39A6" name="X8567023A821E39A6"></a></p>

<h5>4.3-6 AugmentationIdealNilpotencyIndex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AugmentationIdealNilpotencyIndex</code>( <var class="Arg">KG</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For the <span class="SimpleMath">\(p\)</span>-modular group algebra <var class="Arg">KG</var> the method returns the smallest number <span class="SimpleMath">\(n\)</span> such that <span class="SimpleMath">\(A^n=0\)</span>, where <span class="SimpleMath">\(A\)</span> is the augmentation ideal of <var class="Arg">KG</var>. This can be done using Jenning's theory without the explicit calculations of the powers of the augmentation ideal.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );</span>
&lt;algebra-with-one over GF(2), with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AugmentationIdealNilpotencyIndex( KG );</span>
9      

</pre></div>

<p><a id="X7C0D5F3C842302EC" name="X7C0D5F3C842302EC"></a></p>

<h5>4.3-7 AugmentationIdealOfDerivedSubgroupNilpotencyIndex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AugmentationIdealOfDerivedSubgroupNilpotencyIndex</code>( <var class="Arg">KG</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For the <span class="SimpleMath">\(p\)</span>-modular group algebra <var class="Arg">KG</var> this attribute stores the nilpotency index of the augmentation ideal of <span class="SimpleMath">\(KG'\)</span> where <span class="SimpleMath">\(G'\)</span> denotes the derived subgroup of <span class="SimpleMath">\(G\)</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );</span>
&lt;algebra-with-one over GF(2), with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AugmentationIdealOfDerivedSubgroupNilpotencyIndex( KG );</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DerivedSubgroup( UnderlyingGroup( KG ) );</span>
Group([ f3, f4 ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KD := GroupRing( GF( 2 ), D );</span>
&lt;algebra-with-one over GF(2), with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AugmentationIdealNilpotencyIndex( KD );</span>
4       

</pre></div>

<p><a id="X837294D57E415E37" name="X837294D57E415E37"></a></p>

<h5>4.3-8 LeftIdealBySubgroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LeftIdealBySubgroup</code>( <var class="Arg">KG</var>, <var class="Arg">H</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RightIdealBySubgroup</code>( <var class="Arg">KG</var>, <var class="Arg">H</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TwoSidedIdalBySubgroup</code>( <var class="Arg">KG</var>, <var class="Arg">H</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: an ideal of a group ring</p>

<p>Let <var class="Arg">KG</var> be a group ring of a group <span class="SimpleMath">\(G\)</span> over the ring <span class="SimpleMath">\(K\)</span>, and <var class="Arg">H</var> be a subgroup of <span class="SimpleMath">\(G\)</span>. Then the set <span class="SimpleMath">\(J_l(H)\)</span> of all elements of <var class="Arg">KG</var> of the form</p>

<p class="center">\[
         \sum_{h \in H} x_h(h-1)
         \]</p>

<p>is the left ideal in <var class="Arg">KG</var> generated by all elements <span class="SimpleMath">\(h-1\)</span> with <span class="SimpleMath">\(h\)</span> in <span class="SimpleMath">\(H\)</span>. The right ideal <span class="SimpleMath">\(J_r(H)\)</span> is defined analogously. These operations are used to consrtuct such ideals, taking into account the fact, that the ideal <span class="SimpleMath">\(J_l(H)\)</span> is two-sided if and only if <var class="Arg">H</var> is normal in <span class="SimpleMath">\(G\)</span>. An attempt of constructing two-sided ideal for a non-normal subgroup <var class="Arg">H</var> will lead to an error message.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KG := GroupRing( GF(2), DihedralGroup(16) );</span>
&lt;algebra-with-one over GF(2), with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := DihedralGroup(16);</span>
&lt;pc group of size 16 with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KG := GroupRing( GF(2), G );</span>
&lt;algebra-with-one over GF(2), with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DerivedSubgroup( G );</span>
Group([ f3, f4 ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LeftIdealBySubgroup( KG, D );</span>
&lt;two-sided ideal in &lt;algebra-with-one over GF(2), with 4 generators&gt;,
  (dimension 12)&gt;                              
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := Subgroup( G, [ GeneratorsOfGroup(G)[1] ]);</span>
Group([ f1 ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsNormal( G, H );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LeftIdealBySubgroup( KG, H );</span>
&lt;left ideal in &lt;algebra-with-one over GF(2), with 4 generators&gt;, (dimension 8
 )&gt;

</pre></div>

<p><a id="X863248708784F94C" name="X863248708784F94C"></a></p>

<h4>4.4 <span class="Heading">Computations with the unit group</span></h4>

<p><a id="X817D5AC78754527F" name="X817D5AC78754527F"></a></p>

<h5>4.4-1 NormalizedUnitGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NormalizedUnitGroup</code>( <var class="Arg">KG</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a group generated by group algebra elements</p>

<p>Determines the normalized unit group of a <span class="SimpleMath">\(p\)</span>-modular group algebra <var class="Arg">KG</var> over the field of <span class="SimpleMath">\(p\)</span> elements. Returns the normalized unit group as the group generated by certain elements of <var class="Arg">KG</var>; see Section <a href="chap3_mj.html#X7B74767A849D921E"><span class="RefLink">3.3</span></a> for more details.</p>

<p>For efficient computations the user is recommended to use <code class="func">PcNormalizedUnitGroup</code> (<a href="chap4_mj.html#X7D40E42A7B678598"><span class="RefLink">4.4-2</span></a>).</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );</span>
&lt;algebra-with-one over GF(2), with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V := NormalizedUnitGroup( KG );</span>
&lt;group of size 32768 with 15 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := GeneratorsOfGroup( V )[4];</span>
(Z(2)^0)*f3  

</pre></div>

<p><a id="X7D40E42A7B678598" name="X7D40E42A7B678598"></a></p>

<h5>4.4-2 PcNormalizedUnitGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PcNormalizedUnitGroup</code>( <var class="Arg">KG</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a group given by power-commutator presentation</p>

<p>The argument <var class="Arg">KG</var> is a <span class="SimpleMath">\(p\)</span>-modular group algebra over the field of <span class="SimpleMath">\(p\)</span> elements. <code class="code">PcNormalizedUnitGroup</code> returns the normalized unit group of <var class="Arg">KG</var> given by a power-commutator presentation. The generators in this polycyclic presentation correspond to the weighted basis elements of <var class="Arg">KG</var>. For more details, see Section <a href="chap3_mj.html#X7B74767A849D921E"><span class="RefLink">3.3</span></a>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W := PcNormalizedUnitGroup( KG );</span>
&lt;pc group of size 32768 with 15 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w := GeneratorsOfGroup( W )[4];</span>
f4       

</pre></div>

<p><a id="X7E08F6E87C586A36" name="X7E08F6E87C586A36"></a></p>

<h5>4.4-3 NaturalBijectionToPcNormalizedUnitGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalBijectionToPcNormalizedUnitGroup</code>( <var class="Arg">KG</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a homomorphism of groups</p>

<p>The normalised unit group of a <span class="SimpleMath">\(p\)</span>-modular group algebra <span class="SimpleMath">\(KG\)</span> over the field of <span class="SimpleMath">\(p\)</span> elements can be computed using two methods, namely <code class="func">NormalizedUnitGroup</code> (<a href="chap4_mj.html#X817D5AC78754527F"><span class="RefLink">4.4-1</span></a>) and <code class="func">PcNormalizedUnitGroup</code> (<a href="chap4_mj.html#X7D40E42A7B678598"><span class="RefLink">4.4-2</span></a>). These two methods return two different objects, and they can be used for different types of computations. The elements of <code class="code">NormalizedUnitGroup(KG)</code> are represented in their natural group algebra representation, and hence they can easily be identified in the group algebra. However, the more quickly constructed <code class="code">NormalizedUnitGroup(KG)</code> is often not suitable for further fast calculations. Hence one will have to use <code class="code">PcNormalizedUnitGroup(KG)</code> if one wants to find some group theoretic properties of the normalized unit group. This method returns the bijection from <code class="code">NormalizedUnitGroup(<var class="Arg">KG</var>)</code> onto <code class="code">PcNormalizedUnitGroup(<var class="Arg">KG</var>)</code>. This bijection can be used to map the result of a computation in <code class="code">PcNormalizedUnitGroup(<var class="Arg">KG</var>)</code> into <code class="code">NormalizedUnitGroup(<var class="Arg">KG</var>)</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := NaturalBijectionToPcNormalizedUnitGroup( KG );</span>
MappingByFunction( &lt;group of size 32768 with 15 generators&gt;, &lt;pc group of size\
 32768 with 15 generators&gt;, function( x ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := GeneratorsOfGroup( V )[4];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u^f;</span>
f4   
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsOfGroup( V )[4]^f = GeneratorsOfGroup( W )[4];</span>
true      

</pre></div>

<p><a id="X83715EF37B9FA94A" name="X83715EF37B9FA94A"></a></p>

<h5>4.4-4 NaturalBijectionToNormalizedUnitGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalBijectionToNormalizedUnitGroup</code>( <var class="Arg">KG</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a homomorphism of groups</p>

<p>For a <span class="SimpleMath">\(p\)</span>-modular group algebra <var class="Arg">KG</var> over the field of <span class="SimpleMath">\(p\)</span> elements this function returns the inverse of the mapping <code class="func">NaturalBijectionToPcNormalizedUnitGroup</code> (<a href="chap4_mj.html#X7E08F6E87C586A36"><span class="RefLink">4.4-3</span></a>)</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t := NaturalBijectionToNormalizedUnitGroup(KG);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w := GeneratorsOfGroup(W)[4];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w^t;</span>
(Z(2)^0)*f3    
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsOfGroup( W )[4]^t = GeneratorsOfGroup( V )[4];</span>
true     

</pre></div>

<p><a id="X84D64AF17941FA7F" name="X84D64AF17941FA7F"></a></p>

<h5>4.4-5 Embedding</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Embedding</code>( <var class="Arg">H</var>, <var class="Arg">V</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a homomorphism from an underlying group to a normalized unit group in pc-presentation</p>

<p>Let <var class="Arg">H</var> be a subgroup of a group <span class="SimpleMath">\(G\)</span> and <var class="Arg">V</var> be the normalized unit group of the group algebra <span class="SimpleMath">\(KG\)</span> given by the power-commutator presentation (see <code class="func">PcNormalizedUnitGroup</code> (<a href="chap4_mj.html#X7D40E42A7B678598"><span class="RefLink">4.4-2</span></a>). Then <code class="code">Embedding( H, V )</code> returns the homomorphism from <var class="Arg">H</var> to <var class="Arg">V</var>, which is the composition of <code class="code">Embedding( H, KG )</code> and <code class="code">NaturalBijectionToPcNormalizedUnitGroup( KG )</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := DihedralGroup( 16 );</span>
&lt;pc group of size 16 with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KG := GroupRing( GF( 2 ), G );</span>
&lt;algebra-with-one over GF(2), with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:=PcNormalizedUnitGroup( KG );</span>
&lt;pc group of size 32768 with 15 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ucs := UpperCentralSeries( V );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := Embedding( G, V );</span>
[ f1, f2, f3, f4 ] -&gt; [ f1, f2, f4, f8 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G1 := Image( f, G ); </span>
Group([ f1, f2, f4, f8 ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := Intersection( ucs[2], G1 ); # compute intersection in V(KG)</span>
Group([ f4, f8, f4*f8 ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T:=PreImage( f, H );             # find its preimage in G</span>
Group([ f3, f4, f3*f4 ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdGroup( T ); </span>
[ 4, 1 ]

</pre></div>

<p><a id="X853C045B7BA6A580" name="X853C045B7BA6A580"></a></p>

<h5>4.4-6 Units</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Units</code>( <var class="Arg">KG</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: the unit group of a group ring</p>

<p>This improves a standard <strong class="pkg">GAP</strong> functionality for modular group algebras of finite <span class="SimpleMath">\(p\)</span>-groups over the field of <span class="SimpleMath">\(p\)</span> elements. It returns the unit group of <var class="Arg">KG</var> as a direct product of <code class="code">Units(K)</code> and <code class="code">NormalizedUnitGroup(KG)</code>, where the latter is generated by certain elements of <var class="Arg">KG</var>; see Chapter <a href="chap3_mj.html#X7D9FCE3A8526ACBE"><span class="RefLink">3</span></a> for more details.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U := Units( KG );</span>
#I  LAGUNA package: Computing the unit group ...
&lt;group of size 32768 with 15 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsOfGroup( U )[5]; # now elements of U are already in KG</span>
(Z(2)^0)*f1+(Z(2)^0)*f3+(Z(2)^0)*f1*f3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FH := GroupRing( GF(3), SmallGroup(27,3) );</span>
&lt;algebra-with-one over GF(3), with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := Units( FH );</span>
#I  LAGUNA package: Computing the unit group ...
&lt;group of size 5083731656658 with 27 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := GeneratorsOfGroup( T )[1];</span>
DirectProductElement( [ Z(3), (Z(3)^0)*&lt;identity&gt; of ... ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x in FH;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x[1] * x[2] in FH; # how to get the corresponding element of FH</span>
true 

</pre></div>

<p><a id="X7E67BDA77E5E6077" name="X7E67BDA77E5E6077"></a></p>

<h5>4.4-7 PcUnits</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PcUnits</code>( <var class="Arg">KG</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a group given by power-commutator presentation</p>

<p>Returns the unit group of <var class="Arg">KG</var> as a direct product of <code class="code">Units(K)</code> and <code class="code">PcNormalizedUnitGroup(KG)</code>, where the latter is a group given by a polycyclic presentation. See Section <a href="chap3_mj.html#X7DCB12F48752C17E"><span class="RefLink">3.4</span></a> for more details.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W := PcUnits( KG );</span>
&lt;pc group of size 32768 with 15 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsOfGroup( W )[5];</span>
f5   
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FH := GroupRing( GF(3), SmallGroup(27,3) );</span>
&lt;algebra-with-one over GF(3), with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := PcUnits(FH);</span>
&lt;group of size 5083731656658 with 27 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := GeneratorsOfGroup( T )[2];</span>
DirectProductElement( [ Z(3)^0, f1 ] )                      

</pre></div>

<p><a id="X7F2532888184CB22" name="X7F2532888184CB22"></a></p>

<h5>4.4-8 IsGroupOfUnitsOfMagmaRing</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsGroupOfUnitsOfMagmaRing</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>This property will be automatically set <code class="keyw">true</code>, if <var class="Arg">U</var> is a group generated by some units of a magma ring, including <code class="code">Units(KG)</code> and <code class="code">NormalizedUnitgroup(KG)</code>. Otherwise this property will not be bound.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsGroupOfUnitsOfMagmaRing( NormalizedUnitGroup( KG ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsGroupOfUnitsOfMagmaRing( Units( KG ) );</span>
true     

</pre></div>

<p><a id="X7EF9BF297A9412AB" name="X7EF9BF297A9412AB"></a></p>

<h5>4.4-9 IsUnitGroupOfGroupRing</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsUnitGroupOfGroupRing</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>This property will be automatically set <code class="keyw">true</code>, if <var class="Arg">U</var> is the unit group of a <span class="SimpleMath">\(p\)</span>-modular group algebra, obtained either by <code class="code">Units(KG)</code> or by <code class="code">PcUnits(KG)</code>. Otherwise this property will not be bound.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsUnitGroupOfGroupRing( Units( KG ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsUnitGroupOfGroupRing( PcUnits( KG ) );</span>
true     

</pre></div>

<p><a id="X82AC131384191CCE" name="X82AC131384191CCE"></a></p>

<h5>4.4-10 IsNormalizedUnitGroupOfGroupRing</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsNormalizedUnitGroupOfGroupRing</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>This property will be automatically set <code class="keyw">true</code>, if <var class="Arg">U</var> is the normalized unit group of a <span class="SimpleMath">\(p\)</span>-modular group algebra, obtained either by <code class="code">NormalizedUnitGroup(KG)</code> or by <code class="code">PcNormalizedUnitGroup(KG)</code>. Otherwise this property will not be bound.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsNormalizedUnitGroupOfGroupRing( NormalizedUnitGroup( KG ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsNormalizedUnitGroupOfGroupRing( PcNormalizedUnitGroup( KG ) );</span>
true     

</pre></div>

<p><a id="X82DCA8A57D0D1114" name="X82DCA8A57D0D1114"></a></p>

<h5>4.4-11 UnderlyingGroupRing</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingGroupRing</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a group ring</p>

<p>If <var class="Arg">U</var> is the (normalized) unit group of a <span class="SimpleMath">\(p\)</span>-modular group algebra <span class="SimpleMath">\(KG\)</span> obtained using one of the functions <code class="code">Units(KG)</code>, <code class="code">PcUnits(KG)</code>, <code class="code">NormalizedUnitGroup(KG)</code> or <code class="code">PcNormalizedUnitGroup(KG)</code>, then the attribute <code class="code">UnderlyingGroupRing</code> stores <span class="SimpleMath">\(KG\)</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingGroupRing( Units( KG ) );</span>
&lt;algebra-with-one of dimension 16 over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingGroupRing( PcUnits( KG ) );</span>
&lt;algebra-with-one of dimension 16 over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingGroupRing( NormalizedUnitGroup( KG ) );</span>
&lt;algebra-with-one of dimension 16 over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingGroupRing( PcNormalizedUnitGroup( KG ) );</span>
&lt;algebra-with-one of dimension 16 over GF(2)&gt;

</pre></div>

<p><a id="X7A0FFABC86F89517" name="X7A0FFABC86F89517"></a></p>

<h5>4.4-12 UnitarySubgroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnitarySubgroup</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: the subgroup of the unit group</p>

<p>Let <var class="Arg">U</var> be the normalized unit group of a group ring in either natural (see <code class="func">NormalizedUnitGroup</code> (<a href="chap4_mj.html#X817D5AC78754527F"><span class="RefLink">4.4-1</span></a>)) or power-commutator (see <code class="func">PcNormalizedUnitGroup</code> (<a href="chap4_mj.html#X7D40E42A7B678598"><span class="RefLink">4.4-2</span></a>)) presentation. The attribute stores the unitary subgroup of <var class="Arg">U</var>, generated by all unitary units of <var class="Arg">U</var> (see <code class="func">IsUnitary</code> (<a href="chap4_mj.html#X7990BD877E89A9EC"><span class="RefLink">4.2-9</span></a>)). The method is straightforward, so it is not recommended to run it for large groups.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KG := GroupRing( GF( 2 ), DihedralGroup( 8 ) );</span>
&lt;algebra-with-one over GF(2), with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U := NormalizedUnitGroup( KG );</span>
&lt;group of size 128 with 7 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HU := UnitarySubgroup( U );</span>
&lt;group with 5 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdGroup( HU );</span>
[ 64, 261 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V := PcNormalizedUnitGroup( KG );</span>
&lt;pc group of size 128 with 7 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HV := UnitarySubgroup( V );</span>
Group([ f1, f2, f5, f6, f7 ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdGroup( HV );</span>
[ 64, 261 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Image(NaturalBijectionToPcNormalizedUnitGroup( KG ), HU ) = HV;</span>
true

</pre></div>

<p><a id="X859F07AE7A4D317B" name="X859F07AE7A4D317B"></a></p>

<h5>4.4-13 BicyclicUnitGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BicyclicUnitGroup</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: the subgroup of the unit group, generated by bicyclic units</p>

<p>Let <var class="Arg">U</var> be the normalized unit group of a group ring in either natural (see <code class="func">NormalizedUnitGroup</code> (<a href="chap4_mj.html#X817D5AC78754527F"><span class="RefLink">4.4-1</span></a>)) or power-commutator (see <code class="func">PcNormalizedUnitGroup</code> (<a href="chap4_mj.html#X7D40E42A7B678598"><span class="RefLink">4.4-2</span></a>)) presentation. The attribute stores the subgroup of <var class="Arg">U</var>, generated by all bicyclic units <span class="SimpleMath">\(u_{g,h}\)</span> and <span class="SimpleMath">\(v_{g,h}\)</span> (see <code class="func">BicyclicUnitOfType1</code> (<a href="chap4_mj.html#X7FD01F52845445EC"><span class="RefLink">4.2-12</span></a>) and <code class="func">BicyclicUnitOfType2</code> (<a href="chap4_mj.html#X7FD01F52845445EC"><span class="RefLink">4.2-12</span></a>)), where <span class="SimpleMath">\(g\)</span> and <span class="SimpleMath">\(h\)</span> run over the elements of the underlying group, and <span class="SimpleMath">\(h\)</span> do not belongs to the normalizer of <span class="SimpleMath">\( \langle g \rangle \)</span> in <span class="SimpleMath">\(G\)</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KG := GroupRing( GF( 2 ), DihedralGroup( 8 ) );</span>
&lt;algebra-with-one over GF(2), with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U := NormalizedUnitGroup( KG );</span>
&lt;group of size 128 with 7 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BU := BicyclicUnitGroup( U );</span>
&lt;group with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdGroup( BU );</span>
[ 4, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V := PcNormalizedUnitGroup( KG );</span>
&lt;pc group of size 128 with 7 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BV := BicyclicUnitGroup( V );</span>
Group([ f5*f6, f5*f7 ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdGroup( BV );</span>
[ 4, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Image( NaturalBijectionToPcNormalizedUnitGroup( KG ), BU ) = BV;</span>
true

</pre></div>

<p><a id="X7A39E44D87CDF7B0" name="X7A39E44D87CDF7B0"></a></p>

<h5>4.4-14 GroupBases</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GroupBases</code>( <var class="Arg">KG</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a list of lists of group rings elements</p>

<p>The subgroup <span class="SimpleMath">\(B\)</span> of the normalized unit group of the group algebra <span class="SimpleMath">\(KG\)</span> is called a <em>group basis</em>, if the elements of <span class="SimpleMath">\(B\)</span> are linearly independent over the field <span class="SimpleMath">\(K\)</span> and <span class="SimpleMath">\( KB=KG \)</span>. If <var class="Arg">KG</var> is a <span class="SimpleMath">\(p\)</span>-modular group algebra, then <code class="code">GroupBases</code> returns a list of representatives of the conjugacy classes of the group bases of the group algebra <var class="Arg">KG</var> in its normalised unit group.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D8 := DihedralGroup( 8 );</span>
&lt;pc group of size 8 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K := GF(2);</span>
GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KD8 := GroupRing( GF( 2 ), D8 );</span>
&lt;algebra-with-one over GF(2), with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gb := GroupBases( KD8 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( gb );</span>
32
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( gb[1] );</span>
8    
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gb[1][1];</span>
(Z(2)^0)*&lt;identity&gt; of ...
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll(gb, b -&gt; IdGroup(Group(b))=[8,3]);</span>
true

</pre></div>

<p><a id="X783C1A3D86A6656B" name="X783C1A3D86A6656B"></a></p>

<h4>4.5 <span class="Heading">The Lie algebra of a group algebra</span></h4>

<p><a id="X7827B4158459DEA0" name="X7827B4158459DEA0"></a></p>

<h5>4.5-1 LieAlgebraByDomain</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieAlgebraByDomain</code>( <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>This method takes a group algebra as its argument, and constructs its associated Lie algebra in which the product is the bracket operation: <span class="SimpleMath">\([a,b]=ab-ba\)</span>. It is recommended that the user never calls this method. The Lie algebra for an associative algebra should normally be created using <code class="code">LieAlgebra( A )</code>. When <code class="code">LieAlgebra</code> is first invoked, it constructs the Lie algebra for <var class="Arg">A</var> using <code class="code">LieAlgebraByDomain</code>. After that it stores this Lie algebra and simply returns it if <code class="code">LieAlgebra</code> is called again.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SymmetricGroup(3);; FG := GroupRing( GF( 2 ), G );</span>
&lt;algebra-with-one over GF(2), with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := LieAlgebra( FG );</span>
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;

</pre></div>

<p><a id="X7AA7DA6082639B23" name="X7AA7DA6082639B23"></a></p>

<h5>4.5-2 IsLieAlgebraByAssociativeAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLieAlgebraByAssociativeAlgebra</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>This category signifies that the Lie algebra <var class="Arg">L</var> was constructed as the Lie algebra associated with an associative algebra (this piece of information cannot be obtained later).</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KG := GroupRing( GF(3), DihedralGroup(16) );</span>
&lt;algebra-with-one over GF(3), with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := LieAlgebra ( KG );</span>
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLieAlgebraByAssociativeAlgebra( L );</span>
true

</pre></div>

<p><a id="X85F4712B84624DB8" name="X85F4712B84624DB8"></a></p>

<h5>4.5-3 UnderlyingAssociativeAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingAssociativeAlgebra</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: the underlying associative algebra of a Lie algebra</p>

<p>If a Lie algebra <var class="Arg">L</var> is constructed from an associative algebra, then it remembers this underlying associative algebra as one of its attributes.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KG := GroupRing( GF(2), DihedralGroup(16) ); </span>
&lt;algebra-with-one over GF(2), with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := LieAlgebra ( KG );</span>
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingAssociativeAlgebra( L );</span>
&lt;algebra-with-one over GF(2), with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">last = KG;</span>
true  

</pre></div>

<p><a id="X84050A268514F2EE" name="X84050A268514F2EE"></a></p>

<h5>4.5-4 NaturalBijectionToLieAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalBijectionToLieAlgebra</code>( <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a mapping</p>

<p>The natural linear bijection between the (isomorphic, but not equal) underlying vector spaces of an associative algebra <var class="Arg">A</var> and its associated Lie algebra is stored as an attribute of <var class="Arg">A</var>. Note that this is a vector space isomorphism between two algebras, but not an algebra isomorphism.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := GF( 2 ); G := SymmetricGroup( 3 ); FG := GroupRing( F, G );</span>
GF(2)
Sym( [ 1 .. 3 ] )
&lt;algebra-with-one over GF(2), with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t := NaturalBijectionToLieAlgebra( FG );; </span>
#I  LAGUNA package: Constructing Lie algebra ...
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := Random( FG );</span>
(Z(2)^0)*()+(Z(2)^0)*(2,3)+(Z(2)^0)*(1,2)+(Z(2)^0)*(1,2,3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a * a;                     # product in the associative algebra</span>
(Z(2)^0)*()+(Z(2)^0)*(2,3)+(Z(2)^0)*(1,2)+(Z(2)^0)*(1,2,3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b := a^t;</span>
LieObject( (Z(2)^0)*()+(Z(2)^0)*(2,3)+(Z(2)^0)*(1,2)+(Z(2)^0)*(1,2,3) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b * b; # product in the Lie algebra (commutator) - must be zero!</span>
LieObject( &lt;zero&gt; of ... )

</pre></div>

<p><a id="X821DAFD585EA1DF3" name="X821DAFD585EA1DF3"></a></p>

<h5>4.5-5 NaturalBijectionToAssociativeAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalBijectionToAssociativeAlgebra</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>This is the inverse of the previous linear bijection, stored as an attribute of the Lie algebra <var class="Arg">L</var>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SymmetricGroup(3); FG := GroupRing( GF( 2 ), G );</span>
Sym( [ 1 .. 3 ] )
&lt;algebra-with-one over GF(2), with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := LieAlgebra( FG );</span>
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s := NaturalBijectionToAssociativeAlgebra( L );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InverseGeneralMapping( s ) = NaturalBijectionToLieAlgebra( FG );</span>
true   

</pre></div>

<p><a id="X78C26E3F80E55AC2" name="X78C26E3F80E55AC2"></a></p>

<h5>4.5-6 IsLieAlgebraOfGroupRing</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLieAlgebraOfGroupRing</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>If a Lie algebra <var class="Arg">L</var> is constructed from an associative algebra which happens to be in fact a group ring, it has many nice properties that can be used for fast algorithms, so this information is stored as a property.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := GF( 2 ); G := SymmetricGroup( 3 ); FG := GroupRing( F, G );</span>
GF(2)
Sym( [ 1 .. 3 ] )
&lt;algebra-with-one over GF(2), with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := LieAlgebra( FG );</span>
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLieAlgebraOfGroupRing( L );</span>
true   

</pre></div>

<p><a id="X87CCD17A790BE256" name="X87CCD17A790BE256"></a></p>

<h5>4.5-7 UnderlyingGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingGroup</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: the underlying group</p>

<p>The underlying group of a Lie algebra <var class="Arg">L</var> that is constructed from a group ring is defined as the underlying group of this group ring; see <code class="func">UnderlyingGroup</code> (<a href="chap4_mj.html#X7C966B177BB62C72"><span class="RefLink">4.1-4</span></a>).</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := GF( 2 ); G := SymmetricGroup( 3 ); FG := GroupRing( F, G );</span>
GF(2)
Sym( [ 1 .. 3 ] )
&lt;algebra-with-one over GF(2), with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := LieAlgebra( FG );</span>
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingGroup( L );</span>
Sym( [ 1 .. 3 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LeftActingDomain( L );</span>
GF(2)   

</pre></div>

<p><a id="X833439F7846784B5" name="X833439F7846784B5"></a></p>

<h5>4.5-8 Embedding</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Embedding</code>( <var class="Arg">U</var>, <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a mapping, which is a composition of two mappings</p>

<p>Let <span class="SimpleMath">\(FG\)</span> be a group ring, let <var class="Arg">U</var> be a submagma of <span class="SimpleMath">\(G\)</span>, and let <var class="Arg">L</var> be the Lie algebra associated with <span class="SimpleMath">\(FG\)</span>. Then <code class="code">Embedding(<var class="Arg">U</var>, <var class="Arg">L</var> )</code> returns the obvious mapping from <var class="Arg">U</var> to <var class="Arg">L</var> (as the composition of the mappings <code class="code">Embedding( <var class="Arg">U</var>, FG )</code> and <code class="code">NaturalBijectionToLieAlgebra( FG )</code>).</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := GF( 2 ); G := SymmetricGroup( 3 ); FG := GroupRing( F, G );</span>
GF(2)
Sym( [ 1 .. 3 ] )
&lt;algebra-with-one over GF(2), with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := LieAlgebra( FG );</span>
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := Embedding( G, L );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">(1,2)^f + (1,3)^f;</span>
LieObject( (Z(2)^0)*(1,2)+(Z(2)^0)*(1,3) )   

</pre></div>

<p><a id="X8111F58E7DE3E25C" name="X8111F58E7DE3E25C"></a></p>

<h5>4.5-9 LieCentre</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieCentre</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a Lie algebra</p>

<p>The centre of the Lie algebra associated with a group ring corresponds to the centre of the underlying group ring, and it can be calculated very fast by considering the conjugacy classes of the group. This method returns the centre of <var class="Arg">L</var> using this idea.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SmallGroup( 256, 400 ); FG := GroupRing( GF( 2 ), G ); </span>
&lt;pc group of size 256 with 8 generators&gt;
&lt;algebra-with-one over GF(2), with 8 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := LieAlgebra( FG );</span>
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := LieCentre( L );</span>
&lt;Lie algebra of dimension 28 over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := LieDerivedSubalgebra( L );</span>
#I  LAGUNA package: Computing the Lie derived subalgebra ...
&lt;Lie algebra of dimension 228 over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := Dimension( C ); d := Dimension( D ); l := Dimension( L );</span>
28
228
256
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c + d = l; # This is always the case for Lie algebras of group algebras! </span>
true

</pre></div>

<p><a id="X7C95C0057C977747" name="X7C95C0057C977747"></a></p>

<h5>4.5-10 LieDerivedSubalgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieDerivedSubalgebra</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a Lie algebra</p>

<p>If <var class="Arg">L</var> is the Lie algebra associated with a group ring, then this method returns the Lie derived subalgebra of <var class="Arg">L</var>. This can be done very fast using the conjugacy classes of the underlying group.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SmallGroup( 256, 400 ); FG := GroupRing( GF( 2 ), G ); </span>
&lt;pc group of size 256 with 8 generators&gt;
&lt;algebra-with-one over GF(2), with 8 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := LieAlgebra( FG );</span>
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := LieCentre( L );</span>
&lt;Lie algebra of dimension 28 over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := LieDerivedSubalgebra( L );</span>
#I  LAGUNA package: Computing the Lie derived subalgebra ...    
&lt;Lie algebra of dimension 228 over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := Dimension( L ); c := Dimension( C ); d := Dimension( D );</span>
256
28
228
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c + d = l; # This is always the case for Lie algebras of group algebras!</span>
true

</pre></div>

<p><a id="X7F97D08F7B738ADE" name="X7F97D08F7B738ADE"></a></p>

<h5>4.5-11 IsLieAbelian</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLieAbelian</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>The Lie algebra <var class="Arg">L</var> of an associative algebra <span class="SimpleMath">\(A\)</span> is Lie abelian, if and only if <span class="SimpleMath">\(A\)</span> is abelian, so this method refers to <code class="code">IsAbelian( A )</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SymmetricGroup( 3 ); FG := GroupRing( GF( 2 ), G); </span>
Sym( [ 1 .. 3 ] )
&lt;algebra-with-one over GF(2), with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := LieAlgebra( FG );          </span>
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAbelian( G );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAbelian( L );    # This command should not be used for Lie algebras!</span>
true                    
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLieAbelian( L ); # Instead, IsLieAbelian is the correct command.</span>
false   

</pre></div>

<p><a id="X859FF1B3812B8FCC" name="X859FF1B3812B8FCC"></a></p>

<h5>4.5-12 IsLieSolvable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLieSolvable</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>In <a href="chapBib_mj.html#biBPPS73">[PPS73]</a> Passi, Passman, and Sehgal have classified all groups <span class="SimpleMath">\(G\)</span> such that the Lie algebra associated with the group ring is solvable. This method uses their classification, making it considerably faster than the more elementary method which just calculates Lie commutators.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SmallGroup( 256, 400 ); FG := GroupRing( GF( 2 ), G ); </span>
&lt;pc group of size 256 with 8 generators&gt;
&lt;algebra-with-one over GF(2), with 8 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := LieAlgebra( FG );</span>
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLieSolvable( L );                       # This is very fast.</span>
#I  LAGUNA package: Checking Lie solvability ...
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( LieDerivedSeries( L ), Dimension ); # This is very slow.</span>
#I  LAGUNA package: Computing the Lie derived subalgebra ...
[ 256, 228, 189, 71, 0 ]   

</pre></div>

<p><a id="X78452F4E875A62A8" name="X78452F4E875A62A8"></a></p>

<h5>4.5-13 IsLieNilpotent</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLieNilpotent</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>In <a href="chapBib_mj.html#biBPPS73">[PPS73]</a> Passi, Passman, and Sehgal have classified all groups <span class="SimpleMath">\(G\)</span> such that the Lie algebra associated with the group ring is Lie nilpotent. This method uses their classification, making it considerably faster than the more elementary method which just calculates Lie commutators.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SmallGroup( 256, 400 ); FG := GroupRing( GF( 2 ), G ); </span>
&lt;pc group of size 256 with 8 generators&gt;
&lt;algebra-with-one over GF(2), with 8 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := LieAlgebra( FG );</span>
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLieNilpotent( L );                           # This is very fast.</span>
#I  LAGUNA package: Checking Lie nilpotency ...
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( LieLowerCentralSeries( L ), Dimension ); # This is very slow.</span>
#I  LAGUNA package: Computing the Lie derived subalgebra ...
[ 256, 228, 222, 210, 191, 167, 138, 107, 76, 54, 29, 15, 6, 0 ]   

</pre></div>

<p><a id="X8504EC257B764BA6" name="X8504EC257B764BA6"></a></p>

<h5>4.5-14 IsLieMetabelian</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLieMetabelian</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>In <a href="chapBib_mj.html#biBLR86">[LR86]</a> Levin and Rosenberger have classified all groups <span class="SimpleMath">\(G\)</span> such that the Lie algebra associated with the group ring is Lie metabelian. This method uses their classification, making it considerably faster than the more elementary method which just calculates Lie commutators.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SmallGroup( 256, 400 ); FG := GroupRing( GF( 2 ), G ); </span>
&lt;pc group of size 256 with 8 generators&gt;
&lt;algebra-with-one over GF(2), with 8 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := LieAlgebra( FG );</span>
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLieMetabelian( L );</span>
false   

</pre></div>

<p><a id="X7EEAA09F818CE548" name="X7EEAA09F818CE548"></a></p>

<h5>4.5-15 IsLieCentreByMetabelian</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLieCentreByMetabelian</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>In <a href="chapBib_mj.html#biBRoss">[Ros02]</a> the third author of this package classified all groups <span class="SimpleMath">\(G\)</span> such that the Lie algebra associated with the group ring is Lie centre-by-metabelian. This method uses the classification, making it considerably faster than the more elementary method which just calculates Lie commutators.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SymmetricGroup( 3 ); FG := GroupRing( GF( 2 ), G ); </span>
Sym( [ 1 .. 3 ] )
&lt;algebra-with-one over GF(2), with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := LieAlgebra( FG );       </span>
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLieMetabelian( L );                                             </span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLieCentreByMetabelian( L );</span>
true   

</pre></div>

<p><a id="X7C8EBFF5805F8C51" name="X7C8EBFF5805F8C51"></a></p>

<h5>4.5-16 CanonicalBasis</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CanonicalBasis</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: basis of a Lie algebra</p>

<p>The canonical basis of a group algebra <span class="SimpleMath">\(FG\)</span> is formed by the elements of <span class="SimpleMath">\(G\)</span>. Here <var class="Arg">L</var> is the Lie algebra associated with <span class="SimpleMath">\(FG\)</span>, and the method returns the images of the elements of <span class="SimpleMath">\(G\)</span> in <var class="Arg">L</var>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SymmetricGroup( 3 ); FG := GroupRing( GF( 2 ), G ); </span>
Sym( [ 1 .. 3 ] )
&lt;algebra-with-one over GF(2), with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := LieAlgebra( FG );       </span>
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := CanonicalBasis( L );</span>
CanonicalBasis( &lt;Lie algebra of dimension 6 over GF(2)&gt; )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Elements( B );</span>
[ LieObject( (Z(2)^0)*() ), LieObject( (Z(2)^0)*(2,3) ),
  LieObject( (Z(2)^0)*(1,2) ), LieObject( (Z(2)^0)*(1,2,3) ),
  LieObject( (Z(2)^0)*(1,3,2) ), LieObject( (Z(2)^0)*(1,3) ) ]

</pre></div>

<p><a id="X83026DFF8461B96D" name="X83026DFF8461B96D"></a></p>

<h5>4.5-17 IsBasisOfLieAlgebraOfGroupRing</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsBasisOfLieAlgebraOfGroupRing</code>( <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>A basis <var class="Arg">B</var> has this property if the preimages of the basis vectors in the group algebra form a group. It can be verified if a basis has this property. This is important for the speed of the calculation of the structure constants table; see <code class="func">StructureConstantsTable</code> (<a href="chap4_mj.html#X804ADF0280F67CDC"><span class="RefLink">4.5-18</span></a>).</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SymmetricGroup( 3 ); FG := GroupRing( GF( 2 ), G ); </span>
Sym( [ 1 .. 3 ] )
&lt;algebra-with-one over GF(2), with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := LieAlgebra( FG );    </span>
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := CanonicalBasis( L );</span>
CanonicalBasis( &lt;Lie algebra of dimension 6 over GF(2)&gt; )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsBasisOfLieAlgebraOfGroupRing( B );</span>
true   

</pre></div>

<p><a id="X804ADF0280F67CDC" name="X804ADF0280F67CDC"></a></p>

<h5>4.5-18 StructureConstantsTable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StructureConstantsTable</code>( <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>A very fast implementation for calculating the structure constants table for the Lie algebra <code class="code">L</code> associated with a group ring with respect to its canonical basis <var class="Arg">B</var> using its special structure; see <code class="func">CanonicalBasis</code> (<a href="chap4_mj.html#X7C8EBFF5805F8C51"><span class="RefLink">4.5-16</span></a>).</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := CyclicGroup( 2 ); FG := GroupRing( GF( 2 ), G ); </span>
&lt;pc group of size 2 with 1 generators&gt;
&lt;algebra-with-one over GF(2), with 1 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := LieAlgebra( FG );</span>
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := CanonicalBasis( L );</span>
CanonicalBasis( &lt;Lie algebra of dimension 2 over GF(2)&gt; )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureConstantsTable( B );    </span>
#I  LAGUNA package: Computing the structure constants table ...   
[ [ [ [  ], [  ] ], [ [  ], [  ] ] ], [ [ [  ], [  ] ], [ [  ], [  ] ] ], -1, 
  0*Z(2) ]  

</pre></div>

<p><a id="X87E9411284D1A346" name="X87E9411284D1A346"></a></p>

<h5>4.5-19 LieUpperNilpotencyIndex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieUpperNilpotencyIndex</code>( <var class="Arg">KG</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>In a modular group algebra <span class="SimpleMath">\(KG\)</span> the <em>upper Lie power series</em> is defined as follows: <span class="SimpleMath">\(KG^{(1)}=KG\)</span>, <span class="SimpleMath">\(KG^{(n+1)}\)</span> is the associative ideal, generated by <span class="SimpleMath">\([KG^{(n)},KG]\)</span>. The upper Lie nilpotency index <span class="SimpleMath">\(t^L(G)\)</span> of the group algebra <span class="SimpleMath">\(KG\)</span> is defined to be the smallest number <span class="SimpleMath">\(n\)</span> such that <span class="SimpleMath">\(KG^{(n)}=0\)</span>. It can be calculated very fast using Lie dimension subgroups <a href="chapBib_mj.html#biBShalev91">[Sha91]</a>, that is, using only information about the underlying group; see <code class="func">LieDimensionSubgroups</code> (<a href="chap4_mj.html#X84B7C6A38473722F"><span class="RefLink">4.6-4</span></a>). This is why it is stored as an attribute of the group algebra <var class="Arg">KG</var> rather than that of its associated Lie algebra.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );</span>
&lt;algebra-with-one over GF(2), with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LieUpperNilpotencyIndex( KG );</span>
5      

</pre></div>

<p><a id="X7D71DF0579FBE1C9" name="X7D71DF0579FBE1C9"></a></p>

<h5>4.5-20 LieLowerNilpotencyIndex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieLowerNilpotencyIndex</code>( <var class="Arg">KG</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>In a modular group algebra <span class="SimpleMath">\(KG\)</span> the <em>lower Lie power series</em> is defined as follows: <span class="SimpleMath">\(KG^{[n]}\)</span> is the associative ideal, generated by all (left-normed) Lie-products <span class="SimpleMath">\([x_1, x_2, \dots, x_n]\)</span>, <span class="SimpleMath">\( x_i \in KG \)</span>. The lower Lie nilpotency index <span class="SimpleMath">\(t_L(G)\)</span> of the group algebra <span class="SimpleMath">\(KG\)</span> is defined to be the minimal smallest <span class="SimpleMath">\(n\)</span> such that <span class="SimpleMath">\(KG^{[n]}=0\)</span>. In <a href="chapBib_mj.html#biBDu">[Du92]</a> the Jennings' conjecture was proved, which means that the nilpotency class of the normalized unit group of the modular group algebra <span class="SimpleMath">\(KG\)</span> is equal to <span class="SimpleMath">\(t_L(G)-1\)</span>.</p>

<p>This allows to express lower Lie nilpotency index via the nilpotency class of the normalized unit group, and with its polycyclic presentation, provided by <strong class="pkg">LAGUNA</strong>, this will be faster than elementary calculations with Lie commutators. As the previous attribute, this index is also stored as an attribute of the group algebra <var class="Arg">KG</var>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );</span>
&lt;algebra-with-one over GF(2), with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LieLowerNilpotencyIndex( KG );</span>
5     

</pre></div>

<p><a id="X7E5950517F0CDB47" name="X7E5950517F0CDB47"></a></p>

<h5>4.5-21 LieDerivedLength</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieDerivedLength</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Let <span class="SimpleMath">\(L\)</span> be a Lie algebra. The <em>Lie derived series</em> of <span class="SimpleMath">\(L\)</span> is defined as follows: <span class="SimpleMath">\(\delta^{[0]}(L) = L\)</span> and <span class="SimpleMath">\(\delta^{[n]}(L) = [\delta^{[n-1]}(L), \delta^{[n-1]}(L)]\)</span>. <span class="SimpleMath">\(L\)</span> is called Lie solvable if there exists an integer <span class="SimpleMath">\(m\)</span> such that <span class="SimpleMath">\( \delta^{[m]}(L) = 0 \)</span>. In this case the integer <span class="SimpleMath">\(m\)</span> is called the <em>Lie derived length</em> of <span class="SimpleMath">\(L\)</span>, and it is returned by this function.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KG := GroupRing( GF ( 2 ), DihedralGroup( 16 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := LieAlgebra( KG );</span>
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LieDerivedLength( L );</span>
#I  LAGUNA package: Computing the Lie derived subalgebra ...
3                                                            

</pre></div>

<p><a id="X7B16423A7FBED034" name="X7B16423A7FBED034"></a></p>

<h4>4.6 <span class="Heading">Other commands</span></h4>

<p><a id="X85CE6B407910F768" name="X85CE6B407910F768"></a></p>

<h5>4.6-1 SubgroupsOfIndexTwo</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SubgroupsOfIndexTwo</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns a list of subgroups of <span class="SimpleMath">\(G\)</span> with index two. Such subgroups are important for the investigation of the Lie structure of the group algebra <span class="SimpleMath">\(KG\)</span> in the case of characteristic 2.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubgroupsOfIndexTwo( DihedralGroup( 16 ) );</span>
[ Group([ f3, f4, f1 ]), Group([ f3, f4, f2 ]), Group([ f3, f4, f1*f2 ]) ]

</pre></div>

<p><a id="X7AFBD42180787A07" name="X7AFBD42180787A07"></a></p>

<h5>4.6-2 DihedralDepth</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DihedralDepth</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>For a finite 2-group <var class="Arg">U</var>, the function returns its <em>dihedral depth</em>, which is defined to be the maximal number <span class="SimpleMath">\(d\)</span> such that <var class="Arg">U</var> contains a subgroup isomorphic to the dihedral group of order <span class="SimpleMath">\(2^{d+1}\)</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KD8 := GroupRing( GF(2), DihedralGroup( 8 ) );</span>
&lt;algebra-with-one over GF(2), with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UD8 := PcNormalizedUnitGroup( KD8 );</span>
&lt;pc group of size 128 with 7 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DihedralDepth( UD8 );</span>
2      

</pre></div>

<p><a id="X7D7CD02F803FFC08" name="X7D7CD02F803FFC08"></a></p>

<h5>4.6-3 DimensionBasis</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DimensionBasis</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: record with two components: `dimensionBasis' (list of group elements) and `weights' (list of weights)</p>

<p>For a finite <span class="SimpleMath">\(p\)</span>-group <var class="Arg">G</var>, returns its Jennings basis as it was described in Section <a href="chap3_mj.html#X7B74767A849D921E"><span class="RefLink">3.3</span></a>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := DihedralGroup( 16 );</span>
&lt;pc group of size 16 with 4 generators&gt;  
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DimensionBasis( G );</span>
rec( dimensionBasis := [ f1, f2, f3, f4 ], weights := [ 1, 1, 2, 4 ] )    

</pre></div>

<p><a id="X84B7C6A38473722F" name="X84B7C6A38473722F"></a></p>

<h5>4.6-4 LieDimensionSubgroups</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieDimensionSubgroups</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: list of subgroups</p>

<p>For a finite <span class="SimpleMath">\(p\)</span>-group <var class="Arg">G</var>, returns the series of its Lie dimension subgroups. The <span class="SimpleMath">\(m\)</span>-th Lie dimension subgroup <span class="SimpleMath">\( D_{(m)} \)</span> is the intersection of the group <span class="SimpleMath">\(G\)</span> and <span class="SimpleMath">\( 1+KG^{(m)} \)</span>, where <span class="SimpleMath">\(KG^{(m)}\)</span> is the <span class="SimpleMath">\(m\)</span>-th term of the upper Lie power series of <span class="SimpleMath">\(KG\)</span>; see <code class="func">LieUpperNilpotencyIndex</code> (<a href="chap4_mj.html#X87E9411284D1A346"><span class="RefLink">4.5-19</span></a>)</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := DihedralGroup( 16 );</span>
&lt;pc group of size 16 with 4 generators&gt;  
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LieDimensionSubgroups( G );</span>
[ &lt;pc group of size 16 with 4 generators&gt;, Group([ f3, f4 ]), Group([ f4 ]),
  Group([ &lt;identity&gt; of ... ]) ]     

</pre></div>

<p><a id="X7B2EAF81791D6C68" name="X7B2EAF81791D6C68"></a></p>

<h5>4.6-5 LieUpperCodimensionSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieUpperCodimensionSeries</code>( <var class="Arg">KG</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieUpperCodimensionSeries</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: list of subgroups</p>

<p>A notion of upper Lie codimension subgroups was introduced in <a href="chapBib_mj.html#biBCS">[CS06]</a>. For a finite <span class="SimpleMath">\(p\)</span>-group <var class="Arg">G</var>, <span class="SimpleMath">\(C_i\)</span> is the set of all elements <span class="SimpleMath">\(g\)</span> in <var class="Arg">G</var>, such that the Lie commutator <span class="SimpleMath">\([ g, g_1, ..., g_i ]\)</span> of the length <span class="SimpleMath">\(i+1\)</span> is equal to zero for all <span class="SimpleMath">\(g_1, ..., g_i\)</span> from <var class="Arg">G</var>, and <span class="SimpleMath">\( C_0 = {1} \)</span>. By Du's theorem (see <a href="chapBib_mj.html#biBDu">[Du92]</a>), <span class="SimpleMath">\(C_i\)</span> coincides with the intersection of <span class="SimpleMath">\(G\)</span> and the i-th term of the upper central series <span class="SimpleMath">\({1}=Z_0 &lt; Z_1 &lt; Z_2 &lt; ... &lt; Z_n = V(KG)\)</span> of the normalized unit group <span class="SimpleMath">\(V(KG)\)</span>. This fact is used in <strong class="pkg">LAGUNA</strong> to speed up computation of this series. Since <span class="SimpleMath">\(V(KG)\)</span> is involved in computation, for the first time the argiment should be the group ring <var class="Arg">KG</var>, but later you can also apply it to the group <var class="Arg">G</var> itself.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := DihedralGroup(16);</span>
&lt;pc group of size 16 with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KG := GroupRing( GF(2), G );</span>
&lt;algebra-with-one over GF(2), with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LieUpperCodimensionSeries( KG );</span>
[ Group([ f1, f2, f3, f4 ]), Group([ f3, f4, f3*f4 ]), Group([ f4 ]), 
  Group([ f4 ]), Group([  ]) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LieUpperCodimensionSeries( G );</span>
[ Group([ f1, f2, f3, f4 ]), Group([ f3, f4, f3*f4 ]), Group([ f4 ]), 
  Group([ f4 ]), Group([  ]) ]

</pre></div>

<p><a id="X7E5804B881DE4FF2" name="X7E5804B881DE4FF2"></a></p>

<h5>4.6-6 LAGInfo</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LAGInfo</code></td><td class="tdright">(&nbsp;info class&nbsp;)</td></tr></table></div>
<p><code class="code">LAGInfo</code> is a special Info class for <strong class="pkg">LAGUNA</strong> algorithms. It has 5 levels: 0, 1 (default), 2, 3 and 4. To change info level to <code class="code">k</code>, use command <code class="code">SetInfoLevel(LAGInfo, k)</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetInfoLevel( LAGInfo, 2 );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KD8 := GroupRing( GF( 2 ), DihedralGroup( 8 ) );</span>
&lt;algebra-with-one over GF(2), with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UD8 := PcNormalizedUnitGroup( KD8 );</span>
#I  LAGInfo: Computing the pc normalized unit group ...
#I  LAGInfo: Calculating weighted basis ...
#I  LAGInfo: Calculating dimension basis ...
#I  LAGInfo: dimension basis finished !
#I  LAGInfo: Weighted basis finished !
#I  LAGInfo: Computing the augmentation ideal filtration...
#I  LAGInfo: Filtration finished !
#I  LAGInfo: finished, converting to PcGroup
&lt;pc group of size 128 with 7 generators&gt;     

</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap3_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
