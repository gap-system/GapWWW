<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (quagroup) - Chapter 3: QuaGroup</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap3"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap3_mj.html">[MathJax on]</a></p>
<p><a id="X80C9BD6584865157" name="X80C9BD6584865157"></a></p>
<div class="ChapSects"><a href="chap3.html#X80C9BD6584865157">3 <span class="Heading">QuaGroup</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7C202C54806653DE">3.1 <span class="Heading">Global constants</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8748A60A7AB09B0C">3.1-1 QuantumField</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X87FCF1537A81E11D">3.1-2 _q</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X83804A6F84BB2387">3.2 <span class="Heading">Gaussian integers</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7985B6A67A30FDA1">3.2-1 GaussNumber</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7EF34AC07BDFEF20">3.2-2 GaussianFactorial</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7F1A5A457926F3CF">3.2-3 GaussianBinomial</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X87064F787DEA9E21">3.3 <span class="Heading">Roots and root systems</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X80D15C027BB8029B">3.3-1 RootSystem</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X79E8AE3A8739D11A">3.3-2 BilinearFormMatNF</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X853E620A79D796E7">3.3-3 PositiveRootsNF</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7D2E78B678C73E69">3.3-4 SimpleSystemNF</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7A5DFEAB7EC0D945">3.3-5 PositiveRootsInConvexOrder</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7A5BD2D77ED1BEDD">3.3-6 SimpleRootsAsWeights</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X798CE6777FC473DD">3.4 <span class="Heading">Weyl groups and their elements</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7D738A0E85CD5C14">3.4-1 ApplyWeylElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X792A49A8808D1C64">3.4-2 LengthOfWeylWord</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X83851E7D7ED84A48">3.4-3 LongestWeylWord</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X81FC70FA84F1B6E9">3.4-4 ReducedWordIterator</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8264626678D9F39A">3.4-5 ExchangeElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X84138DD47BBEA4E0">3.4-6 GetBraidRelations</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X800BB9837DCF1DBD">3.4-7 LongWords</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X81394E207F6AA6CF">3.5 <span class="Heading">Quantized enveloping algebras </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7C263EA87C6E4F8A">3.5-1 QuantizedUEA</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7E3D93D47AFDE8D4">3.5-2 ObjByExtRep</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8542B32A8206118C">3.5-3 ExtRepOfObj</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7879B74F7C77E930">3.5-4 QuantumParameter</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X82B42CD279854DFC">3.5-5 CanonicalMapping</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X87C302567A9B2AD3">3.5-6 WriteQEAToFile</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X874B8E4A83180063">3.5-7 ReadQEAFromFile</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X847A0459844B7A59">3.6 <span class="Heading"> Homomorphisms and automorphisms </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8185FE54820AA950">3.6-1 QEAHomomorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X81214E9B8532B06F">3.6-2 QEAAutomorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X79D886AB7B248F75">3.6-3 QEAAntiAutomorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X851AE6987871E0E8">3.6-4 AutomorphismOmega</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7E288BFE7FDF8BEA">3.6-5 AntiAutomorphismTau</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8576A5987AD999F0">3.6-6 BarAutomorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8277D87D7D81AE75">3.6-7 AutomorphismTalpha</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7DC17C2D8540FCED">3.6-8 DiagramAutomorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7857704878577048"><code>3.6-9 \*</code></a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X832B6D897BDBC8A3">3.7 <span class="Heading">Hopf algebra structure</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8245FA64874E085D">3.7-1 TensorPower</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X783144818681D2E6">3.7-2 UseTwistedHopfStructure</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X811565FF83FA4847">3.7-3 ComultiplicationMap</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7985B7EF7E31C4DF">3.7-4 AntipodeMap</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8361876D8770FC06">3.7-5 CounitMap</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X8183A6857B0C3633">3.8 <span class="Heading">Modules</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7ED0FA2980330CE1">3.8-1 HighestWeightModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B00688F82AACDD0">3.8-2 IrreducibleQuotient</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B080C0078370E99">3.8-3 HWModuleByTensorProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7C03DC018016B93B">3.8-4 DIYModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X854FA09F7E07D2D0">3.8-5 TensorProductOfAlgebraModules</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7F0AED7A85D603A2">3.8-6 HWModuleByGenerator</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8565D4CD82EB2503">3.8-7 InducedQEAModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8680D0D67BACAE16">3.8-8 GenericModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X82B42CD279854DFC">3.8-9 CanonicalMapping</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7DCD17BF7B76E7CA">3.8-10 U2Module</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7E1B059780BB2E09">3.8-11 MinusculeModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X79C8F1317C2E8C60">3.8-12 DualAlgebraModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X87EBE47D86292754">3.8-13 TrivialAlgebraModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7929063E7C428331">3.8-14 WeightsAndVectors</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7EEEBA347A816827">3.8-15 HighestWeightsAndVectors</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X799E7D5981B9F14A">3.8-16 RMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X78E533D2813BDA9E">3.8-17 IsomorphismOfTensorModules</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X87FF182B86367CC4">3.8-18 WriteModuleToFile</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7DD49D8282C516B9">3.8-19 ReadModuleFromFile</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X83BBB99685FB9FB7">3.9 <span class="Heading">The path model</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8025E1918067B03C">3.9-1 DominantLSPath</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X82EDAFAB7E81BD1F">3.9-2 Falpha</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X855C478587112804">3.9-3 Ealpha</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X820413E57DEDB0D1">3.9-4 LSSequence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8573A4077DB4659F">3.9-5 WeylWord</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7D06353282BE96C6">3.9-6 EndWeight</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8637218B80BDC906">3.9-7 CrystalGraph</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X827A177C8416C576">3.10 <span class="Heading"> Canonical bases </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8215C71E8361EE62">3.10-1 Falpha</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X814B1C7B7AF17B79">3.10-2 Ealpha</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7C8EBFF5805F8C51">3.10-3 CanonicalBasis</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8233212A79D722FB">3.10-4 PBWElements</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X81631585816C4CCD">3.10-5 MonomialElements</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X782174177D696504">3.10-6 Strings</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X842A5CC07C3E5848">3.10-7 PrincipalMonomial</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7C04F75683D0A512">3.10-8 StringMonomial</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7E67BE5D856C77DC">3.10-9 Falpha</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X855EFC817CFCE2C7">3.10-10 Ealpha</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X85A9229678572948">3.10-11 CrystalBasis</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X82CE52AB7E798902">3.10-12 CrystalVectors</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X80A534637D8F3210">3.10-13 Falpha</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B9C76BF841FA70B">3.10-14 Ealpha</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7D7607BB81ADF579">3.10-15 CrystalGraph</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7875070C85DD4E8E">3.11 <span class="Heading"> Universal enveloping algebras </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7E7B25307E6478CD">3.11-1 UEA</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7CA021E28527763E">3.11-2 UnderlyingLieAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8707EE2C8145701F">3.11-3 HighestWeightModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7AD80E5C7E015859">3.11-4 QUEAToUEAMap</a></span>
</div></div>
</div>

<h3>3 <span class="Heading">QuaGroup</span></h3>

<p>In this chapter we describe the functionality provided by <strong class="pkg">QuaGroup</strong>.</p>

<p><a id="X7C202C54806653DE" name="X7C202C54806653DE"></a></p>

<h4>3.1 <span class="Heading">Global constants</span></h4>

<p><a id="X8748A60A7AB09B0C" name="X8748A60A7AB09B0C"></a></p>

<h5>3.1-1 QuantumField</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QuantumField</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>This is the field <span class="SimpleMath">Q(q)</span> of rational functions in <span class="SimpleMath">q</span>, over <span class="SimpleMath">Q</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QuantumField;</span>
QuantumField
</pre></div>

<p><a id="X87FCF1537A81E11D" name="X87FCF1537A81E11D"></a></p>

<h5>3.1-2 _q</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; _q</code></td><td class="tdright">(&nbsp;global variable&nbsp;)</td></tr></table></div>
<p>This is an indeterminate; <var class="Arg">QuantumField</var> is the field of rational functions in this indeterminate. The identifier <var class="Arg">_q</var> is fixed once the package <strong class="pkg">QuaGroup</strong> is loaded. The symbol <var class="Arg">_q</var> is chosen (instead of <var class="Arg">q</var>) in order to avoid potential name clashes. We note that <var class="Arg">_q</var> is printed as <var class="Arg">q</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">_q;</span>
q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">_q in QuantumField;</span>
true
</pre></div>

<p><a id="X83804A6F84BB2387" name="X83804A6F84BB2387"></a></p>

<h4>3.2 <span class="Heading">Gaussian integers</span></h4>

<p><a id="X7985B6A67A30FDA1" name="X7985B6A67A30FDA1"></a></p>

<h5>3.2-1 GaussNumber</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GaussNumber</code>( <var class="Arg">n</var>, <var class="Arg">par</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>This function computes for the integer <var class="Arg">n</var> the Gaussian integer <span class="SimpleMath">[n]_v=<var class="Arg">par</var></span> (cf. Section <a href="chap2.html#X7AAC838B7CEB5E54"><span class="RefLink">2.1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GaussNumber( 4, _q );</span>
q^3+q+q^-1+q^-3
</pre></div>

<p><a id="X7EF34AC07BDFEF20" name="X7EF34AC07BDFEF20"></a></p>

<h5>3.2-2 GaussianFactorial</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GaussianFactorial</code>( <var class="Arg">n</var>, <var class="Arg">par</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>This function computes for the integer <var class="Arg">n</var> the Gaussian factorial <span class="SimpleMath">[n]!_v=<var class="Arg">par</var></span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GaussianFactorial( 3, _q );</span>
q^3+2*q+2*q^-1+q^-3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GaussianFactorial( 3, _q^2 );</span>
q^6+2*q^2+2*q^-2+q^-6
</pre></div>

<p><a id="X7F1A5A457926F3CF" name="X7F1A5A457926F3CF"></a></p>

<h5>3.2-3 GaussianBinomial</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GaussianBinomial</code>( <var class="Arg">n</var>, <var class="Arg">k</var>, <var class="Arg">par</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>This function computes for two integers <var class="Arg">n</var> and <var class="Arg">k</var> the Gaussian binomial <var class="Arg">n</var> choose <var class="Arg">k</var>, where the parameter <span class="SimpleMath">v</span> is replaced by <var class="Arg">par</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GaussianBinomial( 5, 2, _q^2 );</span>
q^12+q^8+2*q^4+2+2*q^-4+q^-8+q^-12
</pre></div>

<p><a id="X87064F787DEA9E21" name="X87064F787DEA9E21"></a></p>

<h4>3.3 <span class="Heading">Roots and root systems</span></h4>

<p>In this section we describe some functions for dealing with root systems. These functions supplement the ones already present in the <strong class="pkg">GAP</strong> library.</p>

<p><a id="X80D15C027BB8029B" name="X80D15C027BB8029B"></a></p>

<h5>3.3-1 RootSystem</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RootSystem</code>( <var class="Arg">type</var>, <var class="Arg">rank</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RootSystem</code>( <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">type</var> is a capital letter between <var class="Arg">"A"</var> and <var class="Arg">"G"</var>, and <var class="Arg">rank</var> is a positive integer (<span class="SimpleMath">≥ 1</span> if <var class="Arg">type="A"</var>, <span class="SimpleMath">≥ 2</span> if <var class="Arg">type="B"</var>, <var class="Arg">"C"</var>, <span class="SimpleMath">≥ 4</span> if <var class="Arg">type="D"</var>, <span class="SimpleMath">6,7,8</span> if <var class="Arg">type="E"</var>, <span class="SimpleMath">4</span> if <var class="Arg">type="F"</var>, and <span class="SimpleMath">2</span> if <var class="Arg">type="G"</var>). This function returns the root system of type <var class="Arg">type</var> and rank <var class="Arg">rank</var>. In the second form <var class="Arg">list</var> is a list of types and ranks, e.g., <var class="Arg">[ "B", 2, "F", 4, "D", 7 ]</var>.</p>

<p>The root system constructed by this function comes with he attributes <var class="Arg">PositiveRoots</var>, <var class="Arg">NegativeRoots</var>, <var class="Arg">SimpleSystem</var>, <var class="Arg">CartanMatrix</var>, <var class="Arg">BilinearFormMat</var>. Here the attribute <var class="Arg">SimpleSystem</var> contains a set of simple roots, written as unit vectors. <var class="Arg">PositiveRoots</var> is a list of the positive roots, written as linear combinations of the simple roots, and likewise for <var class="Arg">NegativeRoots</var>. <var class="Arg">CartanMatrix( R )</var> is the Cartan matrix of the root system <var class="Arg">R</var>, where the entry on position <span class="SimpleMath">( i, j )</span> is given by <span class="SimpleMath">⟨ α_i, α_j^∨⟩</span> where <span class="SimpleMath">α_i</span> is the <span class="SimpleMath">i</span>-th simple root. <var class="Arg">BilinearFormMat( R )</var> is the matrix of the bilinear form, where the entry on position <span class="SimpleMath">( i, j )</span> is given by <span class="SimpleMath">( α_i, α_j )</span> (see Section <a href="chap2.html#X81394E207F6AA6CF"><span class="RefLink">2.2</span></a>).</p>

<p><var class="Arg">WeylGroup( R )</var> returns the Weyl group of the root system <var class="Arg">R</var>. We refer to the <strong class="pkg">GAP</strong> reference manual for an overview of the functions for Weyl groups in the <strong class="pkg">GAP</strong> library. We mention the functions <var class="Arg">ConjugateDominantWeight( W, wt )</var> (returns the dominant weight in the <var class="Arg">W</var>-orbit of the weight <var class="Arg">wt</var>), and <var class="Arg">WeylOrbitIterator( W, wt )</var> (returns an iterator for the <var class="Arg">W</var>-orbit containing the weight <var class="Arg">wt</var>). We write weights as integral linear combinations of fundamental weights, so in <strong class="pkg">GAP</strong> weights are represented by lists of integers (of length equal to the rank of the root system).</p>

<p>Also we mention the function <var class="Arg">PositiveRootsAsWeights( R )</var> that returns the positive roots of <var class="Arg">R</var> written as weights, i.e., as linear combinations of the fundamental weights.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:=RootSystem( [ "B", 2, "F", 4, "E", 6 ] );</span>
&lt;root system of type B2 F4 E6&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( "A", 2 );</span>
&lt;root system of type A2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PositiveRoots( R );</span>
[ [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BilinearFormMat( R );</span>
[ [ 2, -1 ], [ -1, 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W:= WeylGroup( R );</span>
Group([ [ [ -1, 1 ], [ 0, 1 ] ], [ [ 1, 0 ], [ 1, -1 ] ] ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugateDominantWeight( W, [-3,2] );</span>
[ 2, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">o:= WeylOrbitIterator( W, [-3,2] );</span>
&lt;iterator&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># Using the iterator we can loop over the orbit:</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextIterator( o );</span>
[ 2, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextIterator( o );</span>
[ -1, -2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PositiveRootsAsWeights( R );</span>
[ [ 2, -1 ], [ -1, 2 ], [ 1, 1 ] ]
</pre></div>

<p><a id="X79E8AE3A8739D11A" name="X79E8AE3A8739D11A"></a></p>

<h5>3.3-2 BilinearFormMatNF</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BilinearFormMatNF</code>( <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>This is the matrix of the "normalized" bilinear form. This means that all diagonal entries are even, and 2 is the minimum value occurring on the diagonal. If <var class="Arg">R</var> is a root system constructed by <code class="func">RootSystem</code> (<a href="chap3.html#X80D15C027BB8029B"><span class="RefLink">3.3-1</span></a>), then this is equal to <var class="Arg">BilinearFormMat( R )</var>.</p>

<p><a id="X853E620A79D796E7" name="X853E620A79D796E7"></a></p>

<h5>3.3-3 PositiveRootsNF</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PositiveRootsNF</code>( <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>This is the list of positive roots of the root system <var class="Arg">R</var>, written as linear combinations of the simple roots. This means that the simple roots are unit vectors. If <var class="Arg">R</var> is a root system constructed by <code class="func">RootSystem</code> (<a href="chap3.html#X80D15C027BB8029B"><span class="RefLink">3.3-1</span></a>), then this is equal to <var class="Arg">PositiveRoots( R )</var>.</p>

<p>One of the reasons for writing the positive roots like this is the following. Let <var class="Arg">a, b</var> be two elements of <var class="Arg">PositiveRootsNF( R )</var>, and let <var class="Arg">B</var> be the matrix of the bilinear form. Then <var class="Arg">a*( B*b )</var> is the result of applying the bilinear form to <var class="Arg">a, b</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( SimpleLieAlgebra( "B", 2, Rationals ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PositiveRootsNF( R );</span>
[ [ 1, 0 ], [ 0, 1 ], [ 1, 1 ], [ 1, 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># We note that in this case PositiveRoots( R ) will give the</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># positive roots in a different format.</span>
</pre></div>

<p><a id="X7D2E78B678C73E69" name="X7D2E78B678C73E69"></a></p>

<h5>3.3-4 SimpleSystemNF</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimpleSystemNF</code>( <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>This is the list of simple roots of <var class="Arg">R</var>, written as unit vectors (this means that they are elements of <var class="Arg">PositiveRootsNF( R )</var>). If <var class="Arg">R</var> is a root system constructed by <code class="func">RootSystem</code> (<a href="chap3.html#X80D15C027BB8029B"><span class="RefLink">3.3-1</span></a>), then this is equal to <var class="Arg">SimpleSystem( R )</var>.</p>

<p><a id="X7A5DFEAB7EC0D945" name="X7A5DFEAB7EC0D945"></a></p>

<h5>3.3-5 PositiveRootsInConvexOrder</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PositiveRootsInConvexOrder</code>( <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>This function returns the positive roots of the root system <var class="Arg">R</var>, in the "convex" order. Let <span class="SimpleMath">w_0=s_1⋯ s_t</span> be a reduced expression of the longest element in the Weyl group. Then the <span class="SimpleMath">k</span>-th element of the list returned by this function is <span class="SimpleMath">s_1⋯ s_k-1(α_k)</span>. (Where the reduced expression used is the one returned by <var class="Arg">LongestWeylWord( R )</var>.) If <span class="SimpleMath">α</span>, <span class="SimpleMath">β</span> and <span class="SimpleMath">α+β</span> are positive roots, then <span class="SimpleMath">α+β</span> occurs between <span class="SimpleMath">α</span> and <span class="SimpleMath">β</span> (whence the name convex order).</p>

<p>In the output all roots are written in "normal form", i.e., as elements of <var class="Arg">PositiveRootsNF( R )</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( "G", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PositiveRootsInConvexOrder( R );</span>
[ [ 1, 0 ], [ 3, 1 ], [ 2, 1 ], [ 3, 2 ], [ 1, 1 ], [ 0, 1 ] ]
</pre></div>

<p><a id="X7A5BD2D77ED1BEDD" name="X7A5BD2D77ED1BEDD"></a></p>

<h5>3.3-6 SimpleRootsAsWeights</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimpleRootsAsWeights</code>( <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns the simple roots of the root system <var class="Arg">R</var>, written as linear combinations of the fundamental weights.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( "A", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SimpleRootsAsWeights( R );</span>
[ [ 2, -1 ], [ -1, 2 ] ]
</pre></div>

<p><a id="X798CE6777FC473DD" name="X798CE6777FC473DD"></a></p>

<h4>3.4 <span class="Heading">Weyl groups and their elements</span></h4>

<p>Now we describe a few functions that deal with reduced words in the Weyl group of the root system <var class="Arg">R</var>. These words are represented as lists of positive integers <span class="SimpleMath">i</span>, denoting the <span class="SimpleMath">i</span>-th simple reflection (which corresponds to the <span class="SimpleMath">i</span>-th element of <var class="Arg">SimpleSystem( R )</var>). For example <var class="Arg">[ 3, 2, 1, 3, 1 ]</var> represents the expression <span class="SimpleMath">s_3 s_2 s_1 s_3 s_1</span>.</p>

<p><a id="X7D738A0E85CD5C14" name="X7D738A0E85CD5C14"></a></p>

<h5>3.4-1 ApplyWeylElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ApplyWeylElement</code>( <var class="Arg">W</var>, <var class="Arg">wt</var>, <var class="Arg">wd</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">wd</var> is a (not necessarily reduced) word in the Weyl group <var class="Arg">W</var>, and <var class="Arg">wt</var> is a weight (written as integral linear combination of the simple weights). This function returns the result of applying <var class="Arg">wd</var> to <var class="Arg">wt</var>. For example, if <var class="Arg">wt=</var><span class="SimpleMath">μ</span>, and <var class="Arg">wd = [ 1, 2 ]</var> then this function returns <span class="SimpleMath">s_1s_2(μ)</span> (where <span class="SimpleMath">s_i</span> is the simple reflection corresponding to the <span class="SimpleMath">i</span>-th simple root).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W:= WeylGroup( RootSystem( "G", 2 ) ) ;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyWeylElement( W, [ -3, 7 ], [ 1, 1, 2, 1, 2 ] );</span>
[ 15, -11 ]
</pre></div>

<p><a id="X792A49A8808D1C64" name="X792A49A8808D1C64"></a></p>

<h5>3.4-2 LengthOfWeylWord</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LengthOfWeylWord</code>( <var class="Arg">W</var>, <var class="Arg">wd</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">wd</var> is a word in the Weyl group <var class="Arg">W</var>. This function returns the length of that word.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W:= WeylGroup( RootSystem( "F", 4 ) ) ;</span>
&lt;matrix group with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LengthOfWeylWord( W, [ 1, 3, 2, 4, 2 ] );</span>
3
</pre></div>

<p><a id="X83851E7D7ED84A48" name="X83851E7D7ED84A48"></a></p>

<h5>3.4-3 LongestWeylWord</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LongestWeylWord</code>( <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">R</var> is a root system. <var class="Arg">LongestWeylWord( R )</var> returns the longest word in the Weyl group of <var class="Arg">R</var>.</p>

<p>If this function is called for a root system <var class="Arg">R</var>, a reduced expression for the longest element in the Weyl group is calculated (the one which is the smallest in the lexicographical ordering). However, if you would like to work with a different reduced expression, then it is possible to set it by <var class="Arg">SetLongestWeylWord( R, wd )</var>, where <var class="Arg">wd</var> is a reduced expression of the longest element in the Weyl group. Note that you will have to do this before calling <var class="Arg">LongestWeylWord</var>, or any function that may call <var class="Arg">LongestWeylWord</var> (once the attribute is set, it will not be possible to change it). Note also that you must be sure that the word you give is in fact a reduced expression for the longest element in the Weyl group, as this is not checked (you can check this with <code class="func">LengthOfWeylWord</code> (<a href="chap3.html#X792A49A8808D1C64"><span class="RefLink">3.4-2</span></a>)).</p>

<p>We note that virtually all algorithms for quantized enveloping algebras depend on the choice of reduced expression for the longest element in the Weyl group (as the PBW-type basis depends on this).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( "G", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LongestWeylWord( R );</span>
[ 1, 2, 1, 2, 1, 2 ]
</pre></div>

<p><a id="X81FC70FA84F1B6E9" name="X81FC70FA84F1B6E9"></a></p>

<h5>3.4-4 ReducedWordIterator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ReducedWordIterator</code>( <var class="Arg">W</var>, <var class="Arg">wd</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">W</var> is a Weyl group, and <var class="Arg">wd</var> a reduced word. This function returns an iterator for the set of reduced words that represent the same element as <var class="Arg">wd</var>. The elements are output in ascending lexicographical order.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( "F", 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">it:= ReducedWordIterator( WeylGroup(R), LongestWeylWord(R) );</span>
&lt;iterator&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextIterator( it );</span>
[ 1, 2, 1, 3, 2, 1, 3, 2, 3, 4, 3, 2, 1, 3, 2, 3, 4, 3, 2, 1, 3, 2, 3, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k:= 1;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">while not IsDoneIterator( it ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">k:= k+1; w:= NextIterator( it );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k;</span>
2144892
</pre></div>

<p>So there are 2144892 reduced expressions for the longest element in the Weyl group of type <span class="SimpleMath">F_4</span>.</p>

<p><a id="X8264626678D9F39A" name="X8264626678D9F39A"></a></p>

<h5>3.4-5 ExchangeElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExchangeElement</code>( <var class="Arg">W</var>, <var class="Arg">wd</var>, <var class="Arg">ind</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">W</var> is a Weyl group, and <var class="Arg">wd</var> is a <em>reduced</em> word in <var class="Arg">W</var>, and <var class="Arg">ind</var> is an index between 1 and the rank of the root system. Let <var class="Arg">v</var> denote the word obtained from <var class="Arg">wd</var> by adding <var class="Arg">ind</var> at the end. This function <em>assumes</em> that the length of <var class="Arg">v</var> is one less than the length of <var class="Arg">wd</var>, and returns a reduced expression for <var class="Arg">v</var> that is obtained from <var class="Arg">wd</var> by deleting one entry. Nothing is guaranteed of the output if the length of <var class="Arg">v</var> is bigger than the length of <var class="Arg">wd</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( "G", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">wd:= LongestWeylWord( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExchangeElement( WeylGroup(R), wd, 1 );</span>
[ 2, 1, 2, 1, 2 ]
</pre></div>

<p><a id="X84138DD47BBEA4E0" name="X84138DD47BBEA4E0"></a></p>

<h5>3.4-6 GetBraidRelations</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GetBraidRelations</code>( <var class="Arg">W</var>, <var class="Arg">wd1</var>, <var class="Arg">wd2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">W</var> is a Weyl group, and <var class="Arg">wd1</var>, <var class="Arg">wd2</var> are two reduced words representing the same element in <var class="Arg">W</var>. This function returns a list of braid relations that can be applied to <var class="Arg">wd1</var> to obtain <var class="Arg">wd2</var>. Here a braid relation is represented as a list, with at the odd positions integers that represent positions in a word, and at the even positions the indices that are on those positions after applying the relation. For example, let <var class="Arg">wd</var> be the word <var class="Arg">[ 1, 2, 1, 3, 2, 1 ]</var> and let <var class="Arg">r = [ 3, 3, 4, 1 ]</var> be a relation. Then the result of applying <var class="Arg">r</var> to <var class="Arg">wd</var> is <var class="Arg">[ 1, 2, 3, 1, 2, 1]</var> (i.e., on the third position we put a 3, and on the fourth position a 1).</p>

<p>We note that the function does not check first whether <var class="Arg">wd1</var> and <var class="Arg">wd2</var> represent the same element in <var class="Arg">W</var>. If this is not the case, then an error will occur during the execution of the function, or it will produce wrong output.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( "A", 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">wd1:= LongestWeylWord( R );</span>
[ 1, 2, 1, 3, 2, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">wd2:= [ 1, 3, 2, 1, 3, 2 ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GetBraidRelations( WeylGroup(R), wd1, wd2 );</span>
[ [ 3, 3, 4, 1 ], [ 4, 2, 5, 1, 6, 2 ], [ 2, 3, 3, 2, 4, 3 ], [ 4, 1, 5, 3 ] ]
</pre></div>

<p><a id="X800BB9837DCF1DBD" name="X800BB9837DCF1DBD"></a></p>

<h5>3.4-7 LongWords</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LongWords</code>( <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For a root system <var class="Arg">R</var> this returns a list of triples (of length equal to the rank of <var class="Arg">R</var>). Let <var class="Arg">t</var> be the <var class="Arg">k</var>-th triple occurring in this list. The first element of <var class="Arg">t</var> is an expression for the longest element of the Weyl group, starting with <var class="Arg">k</var>. The second element is a list of braid relations, moving this expression to the value of <var class="Arg">LongestWeylWord( R )</var>. The third element is a list of braid relations performing the reverse transformation.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( "A", 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LongWords( R )[3];</span>
[ [ 3, 1, 2, 1, 3, 2 ], 
  [ [ 3, 3, 4, 1 ], [ 4, 2, 5, 1, 6, 2 ], [ 2, 3, 3, 2, 4, 3 ], 
      [ 4, 1, 5, 3 ], [ 1, 3, 2, 1 ] ], 
  [ [ 4, 3, 5, 1 ], [ 1, 1, 2, 3 ], [ 2, 2, 3, 3, 4, 2 ], 
      [ 4, 1, 5, 2, 6, 1 ], [ 3, 1, 4, 3 ] ] ]
</pre></div>

<p><a id="X81394E207F6AA6CF" name="X81394E207F6AA6CF"></a></p>

<h4>3.5 <span class="Heading">Quantized enveloping algebras </span></h4>

<p>In <strong class="pkg">QuaGroup</strong> we deal with two types of quantized enveloping algebra. First there are the quantized enveloping algebras defined over the field <code class="func">QuantumField</code> (<a href="chap3.html#X8748A60A7AB09B0C"><span class="RefLink">3.1-1</span></a>). We say that these algebras are "generic" quantized enveloping algebras, in <strong class="pkg">QuaGroup</strong> they have the category <var class="Arg">IsGenericQUEA</var>. Secondly, we deal with the quantized enveloping algebras that are defined over a different field.</p>

<p><a id="X7C263EA87C6E4F8A" name="X7C263EA87C6E4F8A"></a></p>

<h5>3.5-1 QuantizedUEA</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QuantizedUEA</code>( <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QuantizedUEA</code>( <var class="Arg">R</var>, <var class="Arg">F</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QuantizedUEA</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QuantizedUEA</code>( <var class="Arg">L</var>, <var class="Arg">F</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>In the first two forms <var class="Arg">R</var> is a root system. With only <var class="Arg">R</var> as input, the corresponding generic quantized enveloping algebra is constructed. It is stored as an attribute of <var class="Arg">R</var> (so that constructing it twice for the same root system yields the same object). Also the root system is stored in the quantized enveloping algebra as the attribute <var class="Arg">RootSystem</var>.</p>

<p>The attribute <var class="Arg">GeneratorsOfAlgebra</var> contains the generators of a PBW-type basis (see Section <a href="chap2.html#X83E7F39F7D16793B"><span class="RefLink">2.4</span></a>), that are constructed relative to the reduced expression for the longest element in the Weyl group that is contained in <var class="Arg">LongestWeylWord( R )</var>. We refer to <code class="func">ObjByExtRep</code> (<a href="chap3.html#X7E3D93D47AFDE8D4"><span class="RefLink">3.5-2</span></a>) for a description of the construction of elements of a quantized enveloping algebra.</p>

<p>The call <var class="Arg">QuantizedUEA( R, F, v )</var> returns the quantized universal enveloping algebra with quantum parameter <var class="Arg">v</var>, which must lie in the field <var class="Arg">F</var>. In this case the elements of <var class="Arg">GeneratorsOfAlgebra</var> are the images of the generators of the corresponding generic quantized enveloping algebra. This means that if <var class="Arg">v</var> is a root of unity, then the generators will not generate the whole algebra, but rather a finite dimensional subalgebra (as for instance <span class="SimpleMath">E_i^k=0</span> for <span class="SimpleMath">k</span> large enough). It is possible to construct elements that do not lie in this finite dimensional subalgebra using <code class="func">ObjByExtRep</code> (<a href="chap3.html#X7E3D93D47AFDE8D4"><span class="RefLink">3.5-2</span></a>).</p>

<p>In the last two cases <var class="Arg">L</var> must be a semisimple Lie algebra. The two calls are short for <var class="Arg">QuantizedUEA( RootSystem( L ) )</var> and <var class="Arg">QuantizedUEA( RootSystem( L ), F, v )</var> respectively.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># We construct the generic quantized enveloping algebra corresponding</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># to the root system of type A2+G2:</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( [ "A", 2, "G", 2 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( R );</span>
QuantumUEA( &lt;root system of type A2 G2&gt;, Qpar = q )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RootSystem( U );</span>
&lt;root system of type A2 G2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= GeneratorsOfAlgebra( U );</span>
[ F1, F2, F3, F4, F5, F6, F7, F8, F9, K1, (-q+q^-1)*[ K1 ; 1 ]+K1, K2, 
  (-q+q^-1)*[ K2 ; 1 ]+K2, K3, (-q+q^-1)*[ K3 ; 1 ]+K3, K4, 
  (-q^3+q^-3)*[ K4 ; 1 ]+K4, E1, E2, E3, E4, E5, E6, E7, E8, E9 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># These elements generate a PBW-type basis of U; the nine elements Fi,</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># and the nine elements Ei correspond to the roots listed in convex order:</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PositiveRootsInConvexOrder( R );</span>
[ [ 1, 0, 0, 0 ], [ 1, 1, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], 
  [ 0, 0, 3, 1 ], [ 0, 0, 2, 1 ], [ 0, 0, 3, 2 ], [ 0, 0, 1, 1 ], 
  [ 0, 0, 0, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># So, for example, F5 is an element of weight -[ 0, 0, 3, 1 ].</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># We can also multiply elements; the result is written on the PBW-basis:</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g[17]*g[4];</span>
(-1+q^-6)*F4*[ K4 ; 1 ]+(q^-3)*F4*K4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># Now we construct a non-generic quantized enveloping algebra:</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( "A", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( R, CF(3), E(3) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= GeneratorsOfAlgebra( U );</span>
[ F1, F2, F3, K1, (-E(3)+E(3)^2)*[ K1 ; 1 ]+K1, K2, 
  (-E(3)+E(3)^2)*[ K2 ; 1 ]+K2, E1, E2, E3 ]
</pre></div>

<p>As can be seen in the example, every element of <span class="SimpleMath">U</span> is written as a linear combination of monomials in the PBW-generators; the generators of <span class="SimpleMath">U^-</span> come first, then the generators of <span class="SimpleMath">U^0</span>, and finally the generators of <span class="SimpleMath">U^+</span>.</p>

<p><a id="X7E3D93D47AFDE8D4" name="X7E3D93D47AFDE8D4"></a></p>

<h5>3.5-2 ObjByExtRep</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ObjByExtRep</code>( <var class="Arg">fam</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">fam</var> is the elements family of a quantized enveloping algebra <var class="Arg">U</var>. Secondly, <var class="Arg">list</var> is a list describing an element of <var class="Arg">U</var>. We explain how this description works. First we describe an indexing system for the generators of <var class="Arg">U</var>. Let <var class="Arg">R</var> be the root system of <var class="Arg">U</var>. Let <var class="Arg">t</var> be the number of positive roots, and <var class="Arg">rank</var> the rank of the root system. Then the generators of <var class="Arg">U</var> are <var class="Arg">Fk</var>, <var class="Arg">Ki</var> (and its inverse), <var class="Arg">Ek</var>, for <var class="Arg">k=1...t</var>, <var class="Arg">i=1..rank</var>. (See Section <a href="chap2.html#X83E7F39F7D16793B"><span class="RefLink">2.4</span></a>; for the construction of the <var class="Arg">Fk</var>, <var class="Arg">Ek</var>, the value of <var class="Arg">LongestWeylWord( R )</var> is used.) Now the index of <var class="Arg">Fk</var> is <var class="Arg">k</var>, and the index of <var class="Arg">Ek</var> is <var class="Arg">t+rank+k</var>. Furthermore, elements of the algebra generated by the <var class="Arg">Ki</var>, and its inverse, are written as linear combinations of products of "binomials", as in Section <a href="chap2.html#X798D979F7A53E05D"><span class="RefLink">2.5</span></a>. The element</p>

<p class="pcenter"> K_i^{d}\begin{bmatrix} K_{i} \\ s \end{bmatrix} </p>

<p>(where <span class="SimpleMath">d=0,1</span>), is indexed as <var class="Arg">[ t+i, d ]</var> (what happens to the <var class="Arg">s</var> is described later). So an index is either an integer, or a list of two integers.</p>

<p>A monomial is a list of indices, each followed by an exponent. First come the indices of the <var class="Arg">Fk</var>, (<var class="Arg">1..t</var>), then come the lists of the form <var class="Arg">[ t+i, d ]</var>, and finally the indices of the <var class="Arg">Ek</var>. Each index is followed by an exponent. An index of the form <var class="Arg">[ t+i, d ]</var> is followed by the <var class="Arg">s</var> in the above formula.</p>

<p>The second argument of <var class="Arg">ObjByExtRep</var> is a list of monomials followed by coefficients. This function returns the element of <var class="Arg">U</var> described by this list.</p>

<p>Finally we remark that the element</p>

<p class="pcenter"> K_i^{d}\begin{bmatrix} K_{i} \\ s \end{bmatrix} </p>

<p>is printed as <var class="Arg">Ki[ Ki ; s ]</var> if <var class="Arg">d=1</var>, and as <var class="Arg">[ Ki ; s ]</var> if <var class="Arg">d=0</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem("A",2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fam:= ElementsFamily( FamilyObj( U ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">list:= [ [ 2, 3, [ 4, 0 ], 8, 6, 11 ], _q^2,    # monomial and coefficient</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ 1, 7, 3, 5, [ 5, 1 ], 3, 8, 9 ], _q^-1 + _q^2 ]; # monomial and coefficient</span>
[ [ 2, 3, [ 4, 0 ], 8, 6, 11 ], q^2, [ 1, 7, 3, 5, [ 5, 1 ], 3, 8, 9 ], 
  q^2+q^-1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ObjByExtRep( fam, list );</span>
(q^2)*F2^(3)*[ K1 ; 8 ]*E1^(11)+(q^2+q^-1)*F1^(7)*F3^(5)*K2[ K2 ; 3 ]*E3^(9)
</pre></div>

<p><a id="X8542B32A8206118C" name="X8542B32A8206118C"></a></p>

<h5>3.5-3 ExtRepOfObj</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExtRepOfObj</code>( <var class="Arg">elm</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>For the element <var class="Arg">elm</var> of a quantized enveloping algebra, this function returns the list that defines <var class="Arg">elm</var> (see <code class="func">ObjByExtRep</code> (<a href="chap3.html#X7E3D93D47AFDE8D4"><span class="RefLink">3.5-2</span></a>)).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem("A",2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= GeneratorsOfAlgebra(U);</span>
[ F1, F2, F3, K1, (-q+q^-1)*[ K1 ; 1 ]+K1, K2, (-q+q^-1)*[ K2 ; 1 ]+K2, E1, 
  E2, E3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExtRepOfObj( g[5] );</span>
[ [ [ 4, 0 ], 1 ], -q+q^-1, [ [ 4, 1 ], 0 ], 1 ]
</pre></div>

<p><a id="X7879B74F7C77E930" name="X7879B74F7C77E930"></a></p>

<h5>3.5-4 QuantumParameter</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QuantumParameter</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns the quantum parameter used in the definition of <var class="Arg">U</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem("A",2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U0:= QuantizedUEA( R, CF(3), E(3) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QuantumParameter( U0 );</span>
E(3)
</pre></div>

<p><a id="X82B42CD279854DFC" name="X82B42CD279854DFC"></a></p>

<h5>3.5-5 CanonicalMapping</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CanonicalMapping</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">U</var> is a quantized enveloping algebra. Let <var class="Arg">U0</var> denote the corresponding "generic" quantized enveloping algebra. This function returns the mapping <var class="Arg">U0 --&gt; U</var> obtained by mapping <var class="Arg">q</var> (which is the quantum parameter of <var class="Arg">U0</var>) to the quantum parameter of <var class="Arg">U</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem("A", 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( R, CF(5), E(5) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f:= CanonicalMapping( U );</span>
MappingByFunction( QuantumUEA( &lt;root system of type A
3&gt;, Qpar = q ), QuantumUEA( &lt;root system of type A3&gt;, Qpar = 
E(5) ), function( u ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U0:= Source( f );</span>
QuantumUEA( &lt;root system of type A3&gt;, Qpar = q )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= GeneratorsOfAlgebra( U0 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u:= g[18]*g[9]*g[6];</span>
(q^2)*F6*K2*E6+(q)*K2*[ K3 ; 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Image( f, u );</span>
(E(5)^2)*F6*K2*E6+(E(5))*K2*[ K3 ; 1 ]
</pre></div>

<p><a id="X87C302567A9B2AD3" name="X87C302567A9B2AD3"></a></p>

<h5>3.5-6 WriteQEAToFile</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteQEAToFile</code>( <var class="Arg">U</var>, <var class="Arg">file</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">U</var> is a quantized enveloping algebra, and file is a string containing the name of a file. This function writes some data to <var class="Arg">file</var>, that allows <code class="func">ReadQEAFromFile</code> (<a href="chap3.html#X874B8E4A83180063"><span class="RefLink">3.5-7</span></a>) to recover it.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem("A",3) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">WriteQEAToFile( U, "A3" );</span>
</pre></div>

<p><a id="X874B8E4A83180063" name="X874B8E4A83180063"></a></p>

<h5>3.5-7 ReadQEAFromFile</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ReadQEAFromFile</code>( <var class="Arg">file</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">file</var> is a string containing the name of a file, to which a quantized enveloping algebra has been written by <code class="func">WriteQEAToFile</code> (<a href="chap3.html#X87C302567A9B2AD3"><span class="RefLink">3.5-6</span></a>). This function recovers the quantized enveloping algebra.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem("A",3) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">WriteQEAToFile( U, "A3" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U0:= ReadQEAFromFile( "A3" );</span>
QuantumUEA( &lt;root system of type A3&gt;, Qpar = q )
</pre></div>

<p><a id="X847A0459844B7A59" name="X847A0459844B7A59"></a></p>

<h4>3.6 <span class="Heading"> Homomorphisms and automorphisms </span></h4>

<p>Here we describe functions for creating homomorphisms and (anti)-automorphisms of a quantized enveloping algebra.</p>

<p><a id="X8185FE54820AA950" name="X8185FE54820AA950"></a></p>

<h5>3.6-1 QEAHomomorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QEAHomomorphism</code>( <var class="Arg">U</var>, <var class="Arg">A</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">U</var> is a generic quantized enveloping algebra (i.e., with quantum parameter <var class="Arg">_q</var>), <var class="Arg">A</var> is an algebra with one over <var class="Arg">QuantumField</var>, and <var class="Arg">list</var> is a list of <var class="Arg">4*rank</var> elements of <var class="Arg">A</var> (where <var class="Arg">rank</var> is the rank of the root system of <var class="Arg">U</var>). On the first rank positions there are the images of the <span class="SimpleMath">F_α</span> (where the <span class="SimpleMath">α</span> are simple roots, listed in the order in which they occur in <var class="Arg">SimpleSystem( R )</var>). On the positions <var class="Arg">rank+1...2*rank</var> are the images of the <span class="SimpleMath">K_α</span>. On the positions <var class="Arg">2*rank+1...3*rank</var> are the images of the <span class="SimpleMath">K_α^-1</span>, and finally on the positions <var class="Arg">3*rank+1...4*rank</var> occur the images of the <span class="SimpleMath">E_α</span>.</p>

<p>This function returns the homomorphism <var class="Arg">U -&gt; A</var>, defined by this data. In the example below we construct a homomorphism from one quantized enveloping algebra into another. Both are constructed relative to the same root system, but with different reduced expressions for the longest element of the Weyl group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( "G", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetLongestWeylWord( R, [1,2,1,2,1,2] );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UR:= QuantizedUEA( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S:= RootSystem( "G", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetLongestWeylWord( S, [2,1,2,1,2,1] );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">US:= QuantizedUEA( S );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gS:= GeneratorsOfAlgebra( US );</span>
[ F1, F2, F3, F4, F5, F6, K1, (-q+q^-1)*[ K1 ; 1 ]+K1, K2, 
  (-q^3+q^-3)*[ K2 ; 1 ]+K2, E1, E2, E3, E4, E5, E6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SimpleSystem( R );</span>
[ [ 1, 0 ], [ 0, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PositiveRootsInConvexOrder( S );</span>
[ [ 0, 1 ], [ 1, 1 ], [ 3, 2 ], [ 2, 1 ], [ 3, 1 ], [ 1, 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># We see that the simple roots of R occur on positions 6 and 1</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># in the list PositiveRootsInConvexOrder( S ); This means that we</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># get the following list of images of the homomorphism:</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">imgs:= [ gS[6], gS[1],      # the images of the F_{\alpha}</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">gS[7], gS[9],                  # the images of the K_{\alpha}</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">gS[8], gS[10],                 # the images of the K_{\alpha}^{-1}</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">gS[16], gS[11] ];              # the images of the E_{\alpha}</span>
[ F6, F1, K1, K2, (-q+q^-1)*[ K1 ; 1 ]+K1, (-q^3+q^-3)*[ K2 ; 1 ]+K2, E6, E1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h:= QEAHomomorphism( UR, US, imgs );</span>
&lt;homomorphism: QuantumUEA( &lt;root system of type G
2&gt;, Qpar = q ) -&gt; QuantumUEA( &lt;root system of type G2&gt;, Qpar = q )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Image( h, GeneratorsOfAlgebra( UR )[3] );</span>
(q^10-q^6-q^4+1)*F1*F6^(2)+(q^6-q^2)*F2*F6+(q^4)*F4
</pre></div>

<p><a id="X81214E9B8532B06F" name="X81214E9B8532B06F"></a></p>

<h5>3.6-2 QEAAutomorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QEAAutomorphism</code>( <var class="Arg">U</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QEAAutomorphism</code>( <var class="Arg">U</var>, <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>In the first form <var class="Arg">U</var> is a generic quantized enveloping algebra (i.e., with quantum parameter <var class="Arg">_q</var>), and <var class="Arg">list</var> is a list of <var class="Arg">4*rank</var> elements of <var class="Arg">U</var> (where <var class="Arg">rank</var> is the rank of the corresponding root system). On the first <var class="Arg">rank</var> positions there are the images of the <span class="SimpleMath">F_α</span> (where the <span class="SimpleMath">α</span> are simple roots, listed in the order in which they occur in <var class="Arg">SimpleSystem( R )</var>). On the positions <var class="Arg">rank+1...2*rank</var> are the images of the <span class="SimpleMath">K_α</span>. On the positions <var class="Arg">2*rank+1...3*rank</var> are the images of the <span class="SimpleMath">K_α^-1</span>, and finally on the positions <var class="Arg">3*rank+1...4*rank</var> occur the images of the <span class="SimpleMath">E_α</span>.</p>

<p>In the second form <var class="Arg">U</var> is a non-generic quantized enveloping algebra, and <var class="Arg">f</var> is an automorphism of the corresponding generic quantized enveloping algebra. The corresponding automorphism of <var class="Arg">U</var> is constructed. In this case <var class="Arg">f</var> must not be the bar-automorphism of the corresponding generic quantized enveloping algebra (cf. <code class="func">BarAutomorphism</code> (<a href="chap3.html#X8576A5987AD999F0"><span class="RefLink">3.6-6</span></a>)), as this automorphism doesn't work in the non-generic case.</p>

<p>The image of an element <var class="Arg">x</var> under an automorphism <var class="Arg">f</var> is computed by <var class="Arg">Image( f, x )</var>. Note that there is no function for calculating pre-images (in general this seems to be a very hard task). If you want the inverse of an automorphism, you have to construct it explicitly (e.g., by <var class="Arg">QEAAutomorphism( U, list )</var>, where <var class="Arg">list</var> is a list of pre-images).</p>

<p>Below we construct the automorphism <span class="SimpleMath">ω</span> (cf. Section <a href="chap2.html#X81394E207F6AA6CF"><span class="RefLink">2.2</span></a>) of the quantized enveloping of type <span class="SimpleMath">A_3</span>, when the quantum parameter is <var class="Arg">_q</var>, and when the quantum parameter is a fifth root of unity.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># First we construct the quantized enveloping algebra:</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( "A", 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U0:= QuantizedUEA( R );</span>
QuantumUEA( &lt;root system of type A3&gt;, Qpar = q )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= GeneratorsOfAlgebra( U0 );</span>
[ F1, F2, F3, F4, F5, F6, K1, (-q+q^-1)*[ K1 ; 1 ]+K1, K2, 
  (-q+q^-1)*[ K2 ; 1 ]+K2, K3, (-q+q^-1)*[ K3 ; 1 ]+K3, E1, E2, E3, E4, E5, 
  E6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># Now, for instance, we map F_{\alpha} to E_{\alpha}, where \alpha</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># is a simple root. In order to find where those F_{\alpha}, E_{\alpha}</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># are in the list of generators, we look at the list of positive roots</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># in convex order:</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PositiveRootsInConvexOrder( R );</span>
[ [ 1, 0, 0 ], [ 1, 1, 0 ], [ 0, 1, 0 ], [ 1, 1, 1 ], [ 0, 1, 1 ], 
  [ 0, 0, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># So the simple roots occur on positions 1, 3, 6. This means that we</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># have the following list of images:</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">imgs:= [ g[13], g[15], g[18], g[8], g[10], g[12], g[7], g[9], g[11], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">g[1], g[3], g[6] ];</span>
[ E1, E3, E6, (-q+q^-1)*[ K1 ; 1 ]+K1, (-q+q^-1)*[ K2 ; 1 ]+K2, 
  (-q+q^-1)*[ K3 ; 1 ]+K3, K1, K2, K3, F1, F3, F6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f:= QEAAutomorphism( U0, imgs );</span>
&lt;automorphism of QuantumUEA( &lt;root system of type A3&gt;, Qpar = q )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Image( f, g[2] );</span>
(-q)*E2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># f induces an automorphism of any non-generic quantized enveloping</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># algebra with the same root system R:</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U1:= QuantizedUEA( R, CF(5), E(5) );</span>
QuantumUEA( &lt;root system of type A3&gt;, Qpar = E(5) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h:= QEAAutomorphism( U1, f );</span>
&lt;automorphism of QuantumUEA( &lt;root system of type A3&gt;, Qpar = E(5) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Image( h, GeneratorsOfAlgebra(U1)[7] );</span>
(-E(5)+E(5)^4)*[ K1 ; 1 ]+K1
</pre></div>

<p><a id="X79D886AB7B248F75" name="X79D886AB7B248F75"></a></p>

<h5>3.6-3 QEAAntiAutomorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QEAAntiAutomorphism</code>( <var class="Arg">U</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QEAAntiAutomorphism</code>( <var class="Arg">U</var>, <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>These are functions for constructing anti-automorphisms of quantized enveloping algebras. The same comments apply as for <code class="func">QEAAutomorphism</code> (<a href="chap3.html#X81214E9B8532B06F"><span class="RefLink">3.6-2</span></a>).</p>

<p><a id="X851AE6987871E0E8" name="X851AE6987871E0E8"></a></p>

<h5>3.6-4 AutomorphismOmega</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AutomorphismOmega</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>This is the automorphism <span class="SimpleMath">ω</span> (cf. Section <a href="chap2.html#X81394E207F6AA6CF"><span class="RefLink">2.2</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( "A", 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( R, CF(5), E(5) );</span>
QuantumUEA( &lt;root system of type A3&gt;, Qpar = E(5) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f:= AutomorphismOmega( U );</span>
&lt;automorphism of QuantumUEA( &lt;root system of type A3&gt;, Qpar = E(5) )&gt;
</pre></div>

<p><a id="X7E288BFE7FDF8BEA" name="X7E288BFE7FDF8BEA"></a></p>

<h5>3.6-5 AntiAutomorphismTau</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AntiAutomorphismTau</code>(  )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>This is the anti-automorphism <span class="SimpleMath">τ</span> (cf. Section <a href="chap2.html#X81394E207F6AA6CF"><span class="RefLink">2.2</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( "A", 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( R, CF(5), E(5) );</span>
QuantumUEA( &lt;root system of type A3&gt;, Qpar = E(5) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= AntiAutomorphismTau( U );</span>
&lt;anti-automorphism of QuantumUEA( &lt;root system of type A3&gt;, Qpar = E(5) )&gt;
</pre></div>

<p><a id="X8576A5987AD999F0" name="X8576A5987AD999F0"></a></p>

<h5>3.6-6 BarAutomorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BarAutomorphism</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>This is the automorphism <span class="SimpleMath">bar~</span> defined in Section <a href="chap2.html#X81394E207F6AA6CF"><span class="RefLink">2.2</span></a> Here <var class="Arg">U</var> must be a generic quantized enveloping algebra.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem(["A",2,"B",2]) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bar:= BarAutomorphism( U );</span>
&lt;automorphism of QuantumUEA( &lt;root system of type A2 B2&gt;, Qpar = q )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Image( bar, GeneratorsOfAlgebra( U )[5] );</span>
(q^2-q^-2)*F4*F7+F5
</pre></div>

<p><a id="X8277D87D7D81AE75" name="X8277D87D7D81AE75"></a></p>

<h5>3.6-7 AutomorphismTalpha</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AutomorphismTalpha</code>( <var class="Arg">U</var>, <var class="Arg">ind</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>This is the automorphism <span class="SimpleMath">T_α</span> (cf. Section <a href="chap2.html#X83E7F39F7D16793B"><span class="RefLink">2.4</span></a>), where <span class="SimpleMath">α</span> is the <var class="Arg">ind</var>-th simple root.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem( "B", 3 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f:=AutomorphismTalpha( U, 1 );</span>
&lt;automorphism of QuantumUEA( &lt;root system of type B3&gt;, Qpar = q )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a:= GeneratorsOfAlgebra( U )[3];</span>
F3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"> Image( f, a );</span>
F2
</pre></div>

<p><a id="X7DC17C2D8540FCED" name="X7DC17C2D8540FCED"></a></p>

<h5>3.6-8 DiagramAutomorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DiagramAutomorphism</code>( <var class="Arg">U</var>, <var class="Arg">perm</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>This is the automorphism of <var class="Arg">U</var> induced by a diagram automorphism of the underlying root system. The diagram automorphism is represented by the permutation <var class="Arg">perm</var>, which is the permutation of the simple roots performed by the diagram automorphism.</p>

<p>In the example below we construct the diagram automorphism of the root system of type <span class="SimpleMath">A_3</span>, which is represented by the permutation <var class="Arg">(1,3)</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( "A", 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f:= DiagramAutomorphism( U, (1,3) );</span>
&lt;automorphism of QuantumUEA( &lt;root system of type A3&gt;, Qpar = q )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= GeneratorsOfAlgebra( U );</span>
[ F1, F2, F3, F4, F5, F6, K1, (-q+q^-1)*[ K1 ; 1 ]+K1, K2, 
  (-q+q^-1)*[ K2 ; 1 ]+K2, K3, (-q+q^-1)*[ K3 ; 1 ]+K3, E1, E2, E3, E4, E5, 
  E6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Image( f, g[1] );</span>
F6
</pre></div>

<p><a id="X7857704878577048" name="X7857704878577048"></a></p>

<h5><code>3.6-9 \*</code></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; \*</code>( <var class="Arg">f</var>, <var class="Arg">h</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>We can compose automorphisms and anti-automorphisms using the infix <var class="Arg">*</var> operator. The result of composing two automorphisms is an automorphism. The result of composing an automorphism and an anti-automorphism is an anti-automorphism. The result of composing two anti-automorphisms is an automorphism.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem( "B", 3 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f:=AutomorphismTalpha( U, 1 );</span>
&lt;automorphism of QuantumUEA( &lt;root system of type B3&gt;, Qpar = q )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h:= AutomorphismOmega( U );</span>
&lt;automorphism of QuantumUEA( &lt;root system of type B3&gt;, Qpar = q )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f*h;</span>
&lt;automorphism of QuantumUEA( &lt;root system of type B3&gt;, Qpar = q )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= AntiAutomorphismTau( U );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T:= AutomorphismTalpha( U, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Tinv:= t*T*t;</span>
&lt;automorphism of QuantumUEA( &lt;root system of type B3&gt;, Qpar = q )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># (The last call may take a little while.)</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:= Image( T, GeneratorsOfAlgebra( U )[1] );</span>
(-q^4+1)*F1*F3+(-q^2)*F2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Image( Tinv, x );</span>
F1
</pre></div>

<p>According to <a href="chapBib.html#biBJ96">[Jan96]</a>, 8.14(10), <span class="SimpleMath">τ ∘ T_α ∘ τ</span> is the inverse of <span class="SimpleMath">T_α</span>.</p>

<p><a id="X832B6D897BDBC8A3" name="X832B6D897BDBC8A3"></a></p>

<h4>3.7 <span class="Heading">Hopf algebra structure</span></h4>

<p>Here we describe functions for dealing with the Hopf algebra structure of a quantized enveloping algebra. This structure enables us to construct tensor products, and dual modules of modules over a quantized enveloping algebra. We refer to the next section (Section <a href="chap3.html#X8183A6857B0C3633"><span class="RefLink">3.8</span></a>) for some functions for creating modules.</p>

<p><a id="X8245FA64874E085D" name="X8245FA64874E085D"></a></p>

<h5>3.7-1 TensorPower</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TensorPower</code>( <var class="Arg">U</var>, <var class="Arg">d</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">U</var> is a quantized universal enveloping algebra, and <var class="Arg">d</var> a non-negative integer. This function returns the associative algebra with underlying vector space the <var class="Arg">d</var>-fold tensor product of <var class="Arg">U</var> with itself. The product is defined component wise.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem( [ "B", 2 ] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T:= TensorPower( U, 3 );</span>
&lt;algebra over QuantumField, with 36 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= GeneratorsOfAlgebra( T );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:= g[1];</span>
1*(1&lt;x&gt;1&lt;x&gt;F1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">y:= g[30];</span>
1*(E2&lt;x&gt;1&lt;x&gt;1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x*y;</span>
1*(E2&lt;x&gt;1&lt;x&gt;F1)
</pre></div>

<p><a id="X783144818681D2E6" name="X783144818681D2E6"></a></p>

<h5>3.7-2 UseTwistedHopfStructure</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UseTwistedHopfStructure</code>( <var class="Arg">U</var>, <var class="Arg">f</var>, <var class="Arg">finv</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">U</var> is a quantized enveloping algebra, and <var class="Arg">f</var>, <var class="Arg">finv</var> two (anti-) automorphisms of <var class="Arg">U</var>, where <var class="Arg">finv</var> is the inverse of <var class="Arg">f</var>. After calling this function the Hopf structure on <var class="Arg">U</var> is used that is obtained from the "normal" Hopf structure (see Section <a href="chap2.html#X7DCC28DE7C626D33"><span class="RefLink">2.3</span></a>) by twisting it with <var class="Arg">f</var>.</p>

<p>A call to this function sets the attribute <var class="Arg">HopfStructureTwist</var>, which is the list <var class="Arg">[ f, finv ]</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem("A",2), CF(5), E(5) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= AntiAutomorphismTau( U );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UseTwistedHopfStructure( U, t, t );</span>
</pre></div>

<p><a id="X811565FF83FA4847" name="X811565FF83FA4847"></a></p>

<h5>3.7-3 ComultiplicationMap</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ComultiplicationMap</code>( <var class="Arg">U</var>, <var class="Arg">d</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>This is a homomorphism from the quantized enveloping algebra <var class="Arg">U</var> to the <var class="Arg">d</var>-fold tensor power of <var class="Arg">U</var> with itself. It is obtained by a repeated application of the comultiplication of <var class="Arg">U</var>. So for <var class="Arg">d=2</var> we get the comultiplication of <var class="Arg">U</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem("A",2), CF(5), E(5) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D:= ComultiplicationMap( U, 3 );</span>
&lt;Comultiplication of QuantumUEA( &lt;root system of type A2&gt;, Qpar = 
E(5) ), degree 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Image( D, GeneratorsOfAlgebra(U)[4] );</span>
1*(K1&lt;x&gt;K1&lt;x&gt;K1)
</pre></div>

<p><a id="X7985B7EF7E31C4DF" name="X7985B7EF7E31C4DF"></a></p>

<h5>3.7-4 AntipodeMap</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AntipodeMap</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>This is the antipode map of the quantized enveloping algebra <var class="Arg">U</var>, which is constructed as an anti-automorphism of <var class="Arg">U</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem("A",2), CF(5), E(5) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a:= AntipodeMap( U );</span>
&lt;anti-automorphism of QuantumUEA( &lt;root system of type A2&gt;, Qpar = E(5) )&gt;
</pre></div>

<p><a id="X8361876D8770FC06" name="X8361876D8770FC06"></a></p>

<h5>3.7-5 CounitMap</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CounitMap</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>This is the counit map of the quantized enveloping algebra <var class="Arg">U</var>, which is constructed as a function from <var class="Arg">U</var> to the ground field.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem("A",2), CF(5), E(5) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">co:= CounitMap( U );</span>
function( u ) ... end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:= GeneratorsOfAlgebra( U )[4];</span>
K1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">co( x );</span>
1
</pre></div>

<p><a id="X8183A6857B0C3633" name="X8183A6857B0C3633"></a></p>

<h4>3.8 <span class="Heading">Modules</span></h4>

<p>Here we describe some functions for constructing left modules over quantized enveloping algebras. We refer to the <strong class="pkg">GAP</strong> reference manual for an overview of basic functions for algebra modules, which are also applicable to the modules constructed by the functions described in this section. We mention <var class="Arg">MatrixOfAction</var>, <var class="Arg">DirectSumOfAlgebraModules</var>. The action of an element of the algebra on an element of the module is calculated by the infix operator <var class="Arg">^</var>.</p>

<p><a id="X7ED0FA2980330CE1" name="X7ED0FA2980330CE1"></a></p>

<h5>3.8-1 HighestWeightModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HighestWeightModule</code>( <var class="Arg">U</var>, <var class="Arg">wt</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">U</var> is a quantized universal enveloping algebra, and <var class="Arg">wt</var> a dominant weight (i.e., a list of length equal to the rank of the root system, consisting of non-negative integers). This function returns a finite-dimensional highest-weight module of highest weight <var class="Arg">wt</var> over <var class="Arg">U</var>. If <var class="Arg">U</var> is generic then this is the unique irreducible highest-weight module over <var class="Arg">U</var>. Otherwise it is the Weyl module, cf. Section <a href="chap2.html#X798D979F7A53E05D"><span class="RefLink">2.5</span></a>. In this last case the module is not necessarily irreducible.</p>

<p>Let <var class="Arg">V</var> denote the module returned by this function. The first basis element of the attribute <var class="Arg">Basis( V )</var> is a highest-weight vector; it is written as <var class="Arg">1*v0</var>. Other basis elements are written as, for example, <var class="Arg">F2*F9*v0</var>, which means that this vector is the result of letting the PBW-monomial <var class="Arg">F2*F9</var> act on the highest-weight vector.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem( [ "A", 2, "G", 2 ] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= HighestWeightModule( U, [ 0, 1, 0, 2 ] );</span>
&lt;231-dimensional left-module over QuantumUEA( &lt;root system of type A2 G
2&gt;, Qpar = q )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Basis( V )[1];</span>
1*v0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Basis(V)[23]+(_q^2+_q^-2)*Basis(V)[137];</span>
F3*F5*v0+(q^2+q^-2)*F8^(6)*v0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># We compute the action of an element on a vector:</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gg:= GeneratorsOfAlgebra( U );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:= gg[21]*gg[5];</span>
F5*E4+(-q^-1)*F6*K3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x^Basis(V)[1];</span>
(-q^-1)*F6*v0
</pre></div>

<p><a id="X7B00688F82AACDD0" name="X7B00688F82AACDD0"></a></p>

<h5>3.8-2 IrreducibleQuotient</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IrreducibleQuotient</code>( <var class="Arg">V</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">V</var> is a highest-weight module over a non-generic quantized enveloping algebra. This function returns the quotient of <var class="Arg">V</var> by the maximal submodule not containing the highest weight vector. This is not necessarily equal to <var class="Arg">V</var> if the quantum parameter is a root of 1.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( "A", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( R, CF(3), E(3) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= HighestWeightModule( U, [1,1] );</span>
&lt;8-dimensional left-module over QuantumUEA( &lt;root system of type A2&gt;, Qpar = 
E(3) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IrreducibleQuotient( V );</span>
&lt;7-dimensional left-module over QuantumUEA( &lt;root system of type A2&gt;, Qpar = 
E(3) )&gt;
</pre></div>

<p><a id="X7B080C0078370E99" name="X7B080C0078370E99"></a></p>

<h5>3.8-3 HWModuleByTensorProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HWModuleByTensorProduct</code>( <var class="Arg">U</var>, <var class="Arg">wt</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">U</var> must be a <em>generic</em> quantized enveloping algebra, and <var class="Arg">wt</var> a dominant weight. This function returns the irreducible highest-weight module with highest weight <var class="Arg">wt</var>. The algorithm uses tensor products (whence the name). On some inputs this algorithm is faster than the one use for <code class="func">HighestWeightModule</code> (<a href="chap3.html#X7ED0FA2980330CE1"><span class="RefLink">3.8-1</span></a>), on some inputs it is slower. I do not know any good heuristics.</p>

<p>The basis supplied with the module returned is the canonical basis.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem("G",2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= HWModuleByTensorProduct( U, [2,1] );</span>
&lt;189-dimensional left-module over QuantumUEA( &lt;root system of type G
2&gt;, Qpar = q )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># (This is a case where this algorithm is a lot faster.)</span>
</pre></div>

<p><a id="X7C03DC018016B93B" name="X7C03DC018016B93B"></a></p>

<h5>3.8-4 DIYModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DIYModule</code>( <var class="Arg">U</var>, <var class="Arg">V</var>, <var class="Arg">acts</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">U</var> is a generic quantized enveloping algebra, and <var class="Arg">V</var> is a vector space over the field <var class="Arg">QuantumField</var>. <var class="Arg">U</var> acts on <var class="Arg">V</var> and the action is described by the data in the list <var class="Arg">acts</var>. <var class="Arg">acts</var> is a list of lists, of length <var class="Arg">4*l</var>, where <var class="Arg">l</var> is the rank of the root system. <var class="Arg">acts</var> describes the actions of the generators <span class="SimpleMath">[F_1,...,F_l,K_1,...,K_l,K_1^-1,...,K_l^-1, E_1,...,E_l ]</span>. (Here <span class="SimpleMath">F_k</span> is the generator <span class="SimpleMath">F_α_k</span>, where <span class="SimpleMath">α_k</span> is the <span class="SimpleMath">k</span>-th simple root, and likewise for <span class="SimpleMath">E_k</span>.) The action of each generator is described by a list of length <var class="Arg">dim V</var>, giving the images of the basis elements of <var class="Arg">V</var>. If an image is zero then it may be omitted: in that case there is a "hole" in the list. This function returns the <var class="Arg">U</var>-module defined by the input.</p>

<p>Let <var class="Arg">R</var> be a root system of type <span class="SimpleMath">A_1</span>, and <var class="Arg">U</var> the corresponding quantized enveloping algebra (generated by <span class="SimpleMath">F, K, K^-1, E</span>). In the example below we construct the 2-dimensional <span class="SimpleMath">U</span>-module with basis vectors <span class="SimpleMath">v_1,v_2</span>, and <var class="Arg">U</var>-action given by <span class="SimpleMath">Fv_1 = v_2</span>, <span class="SimpleMath">Fv_2=0</span>, <span class="SimpleMath">Kv_1 = qv_1</span>, <span class="SimpleMath">Kv_2=q^-1v_2</span>, <span class="SimpleMath">Ev_1=0</span>, <span class="SimpleMath">Ev_2=v_1</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem("A",1) );</span>
QuantumUEA( &lt;root system of type A1&gt;, Qpar = q )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= QuantumField^2;</span>
( QuantumField^2 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v:= BasisVectors( Basis(V) );</span>
[ [ 1, 0 ], [ 0, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">acts:= [ [ v[2], 0*v[1] ], [ _q*v[1], _q^-1*v[2] ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ _q^-1*v[1], _q*v[2] ], [ 0*v[1], v[1] ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M:= DIYModule( U, V, acts );</span>
&lt;2-dimensional left-module over QuantumUEA( &lt;root system of type A
1&gt;, Qpar = q )&gt;
</pre></div>

<p><a id="X854FA09F7E07D2D0" name="X854FA09F7E07D2D0"></a></p>

<h5>3.8-5 TensorProductOfAlgebraModules</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TensorProductOfAlgebraModules</code>( <var class="Arg">V</var>, <var class="Arg">W</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TensorProductOfAlgebraModules</code>( <var class="Arg">V</var>, <var class="Arg">W</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">V</var> and <var class="Arg">W</var> are two modules over the same quantized enveloping algebra <var class="Arg">U</var>. This function constructs the tensor product of <var class="Arg">V</var> and <var class="Arg">W</var> (as a <var class="Arg">U</var>-module). For this the comultiplication map of <var class="Arg">U</var> is used (see <code class="func">ComultiplicationMap</code> (<a href="chap3.html#X811565FF83FA4847"><span class="RefLink">3.7-3</span></a>)).</p>

<p>In the second form list is a list of <var class="Arg">U</var>-modules. In that case the iterated tensor product is constructed.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem( [ "A", 2 ] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V1:= HighestWeightModule( U, [ 1, 0 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V2:= HighestWeightModule( U, [ 0, 1 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TensorProductOfAlgebraModules( V1, V2 );</span>
&lt;9-dimensional left-module over QuantumUEA( &lt;root system of type A
2&gt;, Qpar = q )&gt;
</pre></div>

<p><a id="X7F0AED7A85D603A2" name="X7F0AED7A85D603A2"></a></p>

<h5>3.8-6 HWModuleByGenerator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HWModuleByGenerator</code>( <var class="Arg">V</var>, <var class="Arg">v</var>, <var class="Arg">hw</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">V</var> is a module over a generic quantized enveloping algebra <var class="Arg">U</var>, <var class="Arg">v</var> is a highest-weight vector (i.e., all <span class="SimpleMath">E_α</span><var class="Arg">v=0</var>), of weight <var class="Arg">hw</var>, which must be dominant. This function returns a highest-weight module over <var class="Arg">U</var> isomorphic to the submodule of <var class="Arg">V</var> generated by <var class="Arg">v</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem("B",2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W1:= HighestWeightModule( U, [1,0] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W2:= HighestWeightModule( U, [0,1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T:= TensorProductOfAlgebraModules( W1, W2 );</span>
&lt;20-dimensional left-module over QuantumUEA( &lt;root system of type B
2&gt;, Qpar = q )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HWModuleByGenerator( T, Basis(T)[1], [1,1] );</span>
&lt;16-dimensional left-module over QuantumUEA( &lt;root system of type B
2&gt;, Qpar = q )&gt;
</pre></div>

<p><a id="X8565D4CD82EB2503" name="X8565D4CD82EB2503"></a></p>

<h5>3.8-7 InducedQEAModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InducedQEAModule</code>( <var class="Arg">U</var>, <var class="Arg">V</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">U</var> is a non-generic quantized enveloping algebra, and <var class="Arg">V</var> a module over the corresponding generic quantized enveloping algebra. This function returns the <var class="Arg">U</var>-module obtained from <var class="Arg">V</var> by setting <var class="Arg">_q</var> equal to the quantum parameter of <var class="Arg">U</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem("B",2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U0:= QuantizedUEA( R, CF(3), E(3) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= HighestWeightModule( U, [1,1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W:= InducedQEAModule( U0, V );</span>
&lt;16-dimensional left-module over QuantumUEA( &lt;root system of type B2&gt;, Qpar = 
E(3) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># This module is isomorphic to the one obtained by</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># HighestWeightModule( U0, [1,1] );</span>
</pre></div>

<p><a id="X8680D0D67BACAE16" name="X8680D0D67BACAE16"></a></p>

<h5>3.8-8 GenericModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GenericModule</code>( <var class="Arg">W</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For an induced module (see <code class="func">InducedQEAModule</code> (<a href="chap3.html#X8565D4CD82EB2503"><span class="RefLink">3.8-7</span></a>)) this function returns the corresponding module over the generic quantized enveloping algebra.</p>

<p><a id="X82B42CD279854DFC" name="X82B42CD279854DFC"></a></p>

<h5>3.8-9 CanonicalMapping</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CanonicalMapping</code>( <var class="Arg">W</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">W</var> is an induced module. Let <var class="Arg">V</var> be the corresponding generic module (<code class="func">GenericModule</code> (<a href="chap3.html#X8680D0D67BACAE16"><span class="RefLink">3.8-8</span></a>)). This function returns the map <var class="Arg">V --&gt; W</var>, that sets <var class="Arg">_q</var> equal to the quantum parameter of the acting algebra of <var class="Arg">W</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem("B",2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U0:= QuantizedUEA( R, CF(3), E(3) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= HighestWeightModule( U, [1,1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W:= InducedQEAModule( U0, V );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f:= CanonicalMapping( W );</span>
MappingByFunction( &lt;
16-dimensional left-module over QuantumUEA( &lt;root system of type B
2&gt;, Qpar = q )&gt;, &lt;
16-dimensional left-module over QuantumUEA( &lt;root system of type B2&gt;, Qpar = 
E(3) )&gt;, function( v ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Image( f, _q^2*Basis(V)[3] );</span>
(E(3)^2)*e.3
</pre></div>

<p><a id="X7DCD17BF7B76E7CA" name="X7DCD17BF7B76E7CA"></a></p>

<h5>3.8-10 U2Module</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; U2Module</code>( <var class="Arg">U</var>, <var class="Arg">hw</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">U</var> must be a quantized enveloping algebra of type <span class="SimpleMath">A_2</span>. This function returns the highest-weight module over <var class="Arg">U</var> of highest-weight <var class="Arg">hw</var> (which must be dominant). This function is generally a lot faster than <code class="func">HighestWeightModule</code> (<a href="chap3.html#X7ED0FA2980330CE1"><span class="RefLink">3.8-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem("A",2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A2Module( U, [4,7] );</span>
&lt;260-dimensional left-module over QuantumUEA( &lt;root system of type A
2&gt;, Qpar = q )&gt;
</pre></div>

<p><a id="X7E1B059780BB2E09" name="X7E1B059780BB2E09"></a></p>

<h5>3.8-11 MinusculeModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MinusculeModule</code>( <var class="Arg">U</var>, <var class="Arg">hw</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">U</var> must be a generic quantized enveloping algebra, and <var class="Arg">hw</var> a minuscule dominant weight. This function returns the highest-weight module over <var class="Arg">U</var> of highest-weight <var class="Arg">hw</var>. This function is generally somewhat faster than <code class="func">HighestWeightModule</code> (<a href="chap3.html#X7ED0FA2980330CE1"><span class="RefLink">3.8-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem("A",5) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MinusculeModule( U, [0,0,1,0,0] );</span>
&lt;20-dimensional left-module over QuantumUEA( &lt;root system of type A
5&gt;, Qpar = q )&gt;
</pre></div>

<p><a id="X79C8F1317C2E8C60" name="X79C8F1317C2E8C60"></a></p>

<h5>3.8-12 DualAlgebraModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DualAlgebraModule</code>( <var class="Arg">V</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">V</var> is a finite-dimensional left module over a quantized enveloping algebra <var class="Arg">U</var>. This function returns the dual space of <var class="Arg">V</var> as an algebra module. For this the antipode map of <var class="Arg">U</var> is used (see <code class="func">AntipodeMap</code> (<a href="chap3.html#X7985B7EF7E31C4DF"><span class="RefLink">3.7-4</span></a>)).</p>

<p>Let <var class="Arg">M</var> denote the module returned by this function. Then <var class="Arg">M</var> has as basis the dual basis with respect to <var class="Arg">Basis( V )</var>. An element of this basis is printed as <var class="Arg">F@v</var>, where <var class="Arg">v</var> is an element of <var class="Arg">Basis( V )</var>. This is the function which takes the value <var class="Arg">1</var> on <var class="Arg">v</var> and <var class="Arg">0</var> on all other basis elements. A general element of <var class="Arg">M</var> is a linear combination of these basis elements.</p>

<p>The elements of <var class="Arg">M</var> can be viewed as functions which take arguments. However, internally the elements of <var class="Arg">M</var> are represented as wrapped up functions. The function corresponding to an element <var class="Arg">m</var> of <var class="Arg">M</var> is obtained by <var class="Arg">ExtRepOfObj( m )</var> (the result of which is printed in the same way as <var class="Arg">m</var>, but is not equal to it).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem("A",2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= HighestWeightModule( U, [1,1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M:= DualAlgebraModule( V );</span>
&lt;8-dimensional left-module over QuantumUEA( &lt;root system of type A
2&gt;, Qpar = q )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u:= GeneratorsOfAlgebra( U )[2];</span>
F2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vv:= BasisVectors( Basis( M ) );</span>
[ (1)*F@1*v0, (1)*F@F1*v0, (1)*F@F3*v0, (1)*F@F1*F3*v0, (1)*F@F2*v0, 
  (1)*F@F1*F2*v0, (1)*F@F2*F3*v0, (1)*F@F2^(2)*v0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u^vv[3];</span>
&lt;zero function&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># (The zero of the dual space is printed as &lt;zero function&gt;).</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u^vv[4];</span>
(-q^5+q^3)*F@1*v0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># We get the function corresponding to a vector in M by using ExtRepOfObj:</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f:= ExtRepOfObj( vv[1] );</span>
(1)*F@1*v0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># We can calculate images of this function:</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( Basis(V), v -&gt; Image( f, v ) );</span>
[ 1, 0, 0, 0, 0, 0, 0, 0 ]
</pre></div>

<p><a id="X87EBE47D86292754" name="X87EBE47D86292754"></a></p>

<h5>3.8-13 TrivialAlgebraModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TrivialAlgebraModule</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns the trivial module over the quantized enveloping algebra <var class="Arg">U</var>. For this the counit map of <var class="Arg">U</var> is used.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem("A",2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= TrivialAlgebraModule( U );</span>
&lt;left-module over QuantumUEA( &lt;root system of type A2&gt;, Qpar = q )&gt;
</pre></div>

<p><a id="X7929063E7C428331" name="X7929063E7C428331"></a></p>

<h5>3.8-14 WeightsAndVectors</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WeightsAndVectors</code>( <var class="Arg">V</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">V</var> is a left module over a quantized enveloping algebra. <var class="Arg">WeightsAndVectors( V )</var> is a list of two lists; the first of these is a list of the weights of <var class="Arg">V</var>, the second a list of corresponding weight vectors. These are again grouped in lists: if the multiplicity of a weight is <var class="Arg">m</var>, then there are <var class="Arg">m</var> weight vectors, forming a basis of the corresponding weight space.</p>

<p>Modules constructed by <code class="func">HighestWeightModule</code> (<a href="chap3.html#X7ED0FA2980330CE1"><span class="RefLink">3.8-1</span></a>) come with this attribute set. There is a method installed for computing <var class="Arg">WeightsAndVectors( V )</var>, for modules <var class="Arg">V</var> over a generic quantized enveloping algebra, such that all basis vectors (i.e., all elements of <var class="Arg">Basis( V )</var>) are weight vectors.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem( "A", 2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= HighestWeightModule( U, [ 1, 1 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">WeightsAndVectors( V );</span>
[ [ [ 1, 1 ], [ -1, 2 ], [ 2, -1 ], [ 0, 0 ], [ -2, 1 ], [ 1, -2 ], 
      [ -1, -1 ] ], 
  [ [ 1*v0 ], [ F1*v0 ], [ F3*v0 ], [ F1*F3*v0, F2*v0 ], [ F1*F2*v0 ], 
      [ F2*F3*v0 ], [ F2^(2)*v0 ] ] ]
</pre></div>

<p><a id="X7EEEBA347A816827" name="X7EEEBA347A816827"></a></p>

<h5>3.8-15 HighestWeightsAndVectors</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HighestWeightsAndVectors</code>( <var class="Arg">V</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Is analogous to <code class="func">WeightsAndVectors</code> (<a href="chap3.html#X7929063E7C428331"><span class="RefLink">3.8-14</span></a>); now only the highest weights are listed along with the corresponding highest-weight vectors.</p>

<p>There is a method installed for this using <code class="func">WeightsAndVectors</code> (<a href="chap3.html#X7929063E7C428331"><span class="RefLink">3.8-14</span></a>); which means that it works if and only if <var class="Arg">WeightsAndVectors( V )</var> works.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem( [ "A", 2 ] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= HighestWeightModule( U, [ 1, 1 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HighestWeightsAndVectors( V );</span>
[ [ [ 1, 1 ] ], [ [ 1*v0 ] ] ]
</pre></div>

<p><a id="X799E7D5981B9F14A" name="X799E7D5981B9F14A"></a></p>

<h5>3.8-16 RMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RMatrix</code>( <var class="Arg">V</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">V</var> is a module over the a quantized enveloping algebra <var class="Arg">U</var>. This function returns the matrix of a linear map <span class="SimpleMath">θ : V⊗ V -&gt; V⊗ V</span> that is a solution to the quantum Yang-Baxter equation. We have that <span class="SimpleMath">θ∘ P</span> is an isomorphism of <var class="Arg">U</var>-modules, where <span class="SimpleMath">P :V⊗ V-&gt; V⊗ V</span> is the linear map such that <span class="SimpleMath">P(v⊗ w)=w⊗ v</span>. For more details we refer to <a href="chapBib.html#biBJ96">[Jan96]</a>, Chapter 7.</p>

<p>This function works for modules for which <code class="func">WeightsAndVectors</code> (<a href="chap3.html#X7929063E7C428331"><span class="RefLink">3.8-14</span></a>) works.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem("A",1) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= HighestWeightModule( U, [1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RMatrix( V );</span>
[ [ 1, 0, 0, 0 ], [ 0, q, -q^2+1, 0 ], [ 0, 0, q, 0 ], [ 0, 0, 0, 1 ] ]
</pre></div>

<p><a id="X78E533D2813BDA9E" name="X78E533D2813BDA9E"></a></p>

<h5>3.8-17 IsomorphismOfTensorModules</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismOfTensorModules</code>( <var class="Arg">V</var>, <var class="Arg">W</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">V</var>, <var class="Arg">W</var> are two modules over the same quantized enveloping algebra <var class="Arg">U</var>. This function returns a linear map <span class="SimpleMath">θ : V⊗ W-&gt; W⊗ V</span> that is an isomorphism of U-modules.</p>

<p>This function is only guaranteed to work correctly if the Hopf algebra structure is non-twisted (see <code class="func">UseTwistedHopfStructure</code> (<a href="chap3.html#X783144818681D2E6"><span class="RefLink">3.7-2</span></a>)).</p>

<p>This function works for modules for which <code class="func">WeightsAndVectors</code> (<a href="chap3.html#X7929063E7C428331"><span class="RefLink">3.8-14</span></a>) works.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem("B",2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= HighestWeightModule( U, [1,0] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W:= HighestWeightModule( U, [0,1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h:= IsomorphismOfTensorModules( V, W );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VW:= Source( h );</span>
&lt;20-dimensional left-module over QuantumUEA( &lt;root system of type B
2&gt;, Qpar = q )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Image( h, Basis(VW)[13] );</span>
q*(1*v0&lt;x&gt;F3*v0)+-q^2+1*(F4*v0&lt;x&gt;F2*v0)+-q^3+q^-1*(F3*v0&lt;x&gt;1*v0)
</pre></div>

<p><a id="X87FF182B86367CC4" name="X87FF182B86367CC4"></a></p>

<h5>3.8-18 WriteModuleToFile</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteModuleToFile</code>( <var class="Arg">V</var>, <var class="Arg">file</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">V</var> is a module over a quantized enveloping algebra, and <var class="Arg">file</var> is a string containing the name of a file. This function writes some data to <var class="Arg">file</var>, that allows <code class="func">ReadModuleFromFile</code> (<a href="chap3.html#X7DD49D8282C516B9"><span class="RefLink">3.8-19</span></a>) to recover it.</p>

<p>We remark that this function currently is only implemented for generic quantized enveloping algebras.</p>

<p><a id="X7DD49D8282C516B9" name="X7DD49D8282C516B9"></a></p>

<h5>3.8-19 ReadModuleFromFile</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ReadModuleFromFile</code>( <var class="Arg">file</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">file</var> is a string containing the name of a file, to which a module over a quantized enveloping algebra has been written by <code class="func">WriteModuleToFile</code> (<a href="chap3.html#X87FF182B86367CC4"><span class="RefLink">3.8-18</span></a>). This function recovers the module. More precisely: a new module is constructed that is isomorphic to the old one. In the process the algebra acting on the module is constructed anew (from data written to the file). This algebra can be accessed by <var class="Arg">LeftActingAlgebra( V )</var>.</p>

<p>We remark that this function currently is only implemented for generic quantized enveloping algebras.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem("A",3) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= HighestWeightModule( U, [1,1,1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">WriteModuleToFile( V, "A3mod" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W:= ReadModuleFromFile( "A3mod" );</span>
&lt;64-dimensional left-module over QuantumUEA( &lt;root system of type A
3&gt;, Qpar = q )&gt;
</pre></div>

<p><a id="X83BBB99685FB9FB7" name="X83BBB99685FB9FB7"></a></p>

<h4>3.9 <span class="Heading">The path model</span></h4>

<p>In this section we describe functions for dealing with the path model. We work only with LS-paths, which are represented by two lists, one of weights, and one of rationals (see Section <a href="chap2.html#X83BBB99685FB9FB7"><span class="RefLink">2.7</span></a>).</p>

<p><a id="X8025E1918067B03C" name="X8025E1918067B03C"></a></p>

<h5>3.9-1 DominantLSPath</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DominantLSPath</code>( <var class="Arg">R</var>, <var class="Arg">wt</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">R</var> is a root system, and <var class="Arg">wt</var> a dominant weight in the weight lattice of <var class="Arg">R</var>. This function returns the LS-path that is the line from the origin to <var class="Arg">wt</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( "G", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DominantLSPath( R, [1,3] );</span>
&lt;LS path of shape [ 1, 3 ] ending in [ 1, 3 ] &gt;
</pre></div>

<p><a id="X82EDAFAB7E81BD1F" name="X82EDAFAB7E81BD1F"></a></p>

<h5>3.9-2 Falpha</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Falpha</code>( <var class="Arg">path</var>, <var class="Arg">ind</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Is the result of applying the path operator <span class="SimpleMath">f_α_<var class="Arg">ind</var>}</span> to the LS-path <var class="Arg">path</var> (where <span class="SimpleMath">α_<var class="Arg">ind</var></span> is the <var class="Arg">ind</var>-th simple root).</p>

<p>The result is <var class="Arg">fail</var> if <span class="SimpleMath">f_α_<var class="Arg">ind</var>}</span><var class="Arg">(path)=0</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( "G", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p:=DominantLSPath( R, [1,3] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p1:=Falpha( p, 1 );</span>
&lt;LS path of shape [ 1, 3 ] ending in [ -1, 4 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Falpha( p1, 1 );</span>
fail
</pre></div>

<p><a id="X855C478587112804" name="X855C478587112804"></a></p>

<h5>3.9-3 Ealpha</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Ealpha</code>( <var class="Arg">path</var>, <var class="Arg">ind</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Is the result of applying the path operator <span class="SimpleMath">e_α_<var class="Arg">ind</var>}</span> to the LS-path <var class="Arg">path</var> (where <span class="SimpleMath">α_<var class="Arg">ind</var></span> is the <var class="Arg">ind</var>-th simple root).</p>

<p>The result is <var class="Arg">fail</var> if <span class="SimpleMath">e_α_<var class="Arg">ind</var>}</span><var class="Arg">(path)=0</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( "G", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p:=DominantLSPath( R, [1,3] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ealpha( p, 2 );</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p1:=Falpha( p, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ealpha( p1, 1 );</span>
&lt;LS path of shape [ 1, 3 ] ending in [ 1, 3 ] &gt;
</pre></div>

<p><a id="X820413E57DEDB0D1" name="X820413E57DEDB0D1"></a></p>

<h5>3.9-4 LSSequence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LSSequence</code>( <var class="Arg">path</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns the two sequences (of weights and rational numbers) that define the LS-path path.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( "G", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p:=DominantLSPath( R, [1,3] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p1:= Falpha( Falpha( p, 1 ), 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LSSequence( p1 );</span>
[ [ [ 11, -4 ], [ -1, 4 ] ], [ 0, 1/4, 1 ] ]
</pre></div>

<p><a id="X8573A4077DB4659F" name="X8573A4077DB4659F"></a></p>

<h5>3.9-5 WeylWord</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WeylWord</code>( <var class="Arg">path</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">path</var> is an LS-path in the orbit (under the root operators) of a dominant LS-path ending in the dominant weight <span class="SimpleMath">λ</span>. This means that the first direction of path is of the form <span class="SimpleMath">w(λ)</span> for some <span class="SimpleMath">w</span> in the Weyl group. This function returns a list <span class="SimpleMath">[i_1,..., i_m ]</span> such that <span class="SimpleMath">w=s_i_1⋯ s_i_m</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( "G", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p:=DominantLSPath( R, [1,3] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p1:= Falpha( Falpha( Falpha( p, 1 ), 2 ), 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">WeylWord( p1 );</span>
[ 1, 2, 1 ]
</pre></div>

<p><a id="X7D06353282BE96C6" name="X7D06353282BE96C6"></a></p>

<h5>3.9-6 EndWeight</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EndWeight</code>( <var class="Arg">path</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">path</var> is an LS-path; this function returns the weight that is the endpoint of path</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( "G", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p:=DominantLSPath( R, [1,3] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p1:= Falpha( Falpha( Falpha( p, 1 ), 2 ), 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EndWeight( p1 );</span>
[ 0, 3 ]
</pre></div>

<p><a id="X8637218B80BDC906" name="X8637218B80BDC906"></a></p>

<h5>3.9-7 CrystalGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CrystalGraph</code>( <var class="Arg">R</var>, <var class="Arg">wt</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function returns a record describing the crystal graph of the highest-weight module with highest weight <var class="Arg">wt</var>, over the quantized enveloping algebra corresponding to <var class="Arg">R</var>. It is computed using the path model. Therefore the points in the graph are LS-paths.</p>

<p>Denote the output by <var class="Arg">r</var>; then <var class="Arg">r.points</var> is the list of points of the graph. Furthermore, <var class="Arg">r.edges</var> is a list of edges of the graph; this is a list of elements of the form <var class="Arg">[ [ i, j ], u ]</var>. This means that there is an arrow from point <var class="Arg">i</var> (i.e., the point on position <var class="Arg">i</var> in <var class="Arg">r.points</var>) to point <var class="Arg">j</var>, with label <var class="Arg">u</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= RootSystem( "A", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CrystalGraph( R, [1,1] );</span>
rec( 
  edges := [ [ [ 1, 2 ], 1 ], [ [ 1, 3 ], 2 ], [ [ 2, 4 ], 2 ], 
      [ [ 3, 5 ], 1 ], [ [ 4, 6 ], 2 ], [ [ 5, 7 ], 1 ], [ [ 6, 8 ], 1 ], 
      [ [ 7, 8 ], 2 ] ], 
  points := [ &lt;LS path of shape [ 1, 1 ] ending in [ 1, 1 ] &gt;, 
      &lt;LS path of shape [ 1, 1 ] ending in [ -1, 2 ] &gt;, 
      &lt;LS path of shape [ 1, 1 ] ending in [ 2, -1 ] &gt;, 
      &lt;LS path of shape [ 1, 1 ] ending in [ 0, 0 ] &gt;, 
      &lt;LS path of shape [ 1, 1 ] ending in [ 0, 0 ] &gt;, 
      &lt;LS path of shape [ 1, 1 ] ending in [ 1, -2 ] &gt;, 
      &lt;LS path of shape [ 1, 1 ] ending in [ -2, 1 ] &gt;, 
      &lt;LS path of shape [ 1, 1 ] ending in [ -1, -1 ] &gt; ] )
</pre></div>

<p><a id="X827A177C8416C576" name="X827A177C8416C576"></a></p>

<h4>3.10 <span class="Heading"> Canonical bases </span></h4>

<p>Here we describe functions for computing the canonical basis of the negative part of a quantized enveloping algebra, and of a module.</p>

<p><a id="X8215C71E8361EE62" name="X8215C71E8361EE62"></a></p>

<h5>3.10-1 Falpha</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Falpha</code>( <var class="Arg">x</var>, <var class="Arg">ind</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">x</var> is a PBW-monomial in <span class="SimpleMath">U^-</span> (i.e., a monomial in the <span class="SimpleMath">F_α</span>, where <span class="SimpleMath">α</span> runs over the positive roots). This function returns the result of applying the <var class="Arg">ind</var>-th Kashiwara operator <span class="SimpleMath">widetildeF_α_<var class="Arg">ind</var>}</span> to <span class="SimpleMath">x</span> (cf. Section <a href="chap2.html#X78BE3EB980F0A295"><span class="RefLink">2.6</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem( "F", 4 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:= One( U );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Falpha( Falpha( x, 3 ), 2 );</span>
F3*F9
</pre></div>

<p><a id="X814B1C7B7AF17B79" name="X814B1C7B7AF17B79"></a></p>

<h5>3.10-2 Ealpha</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Ealpha</code>( <var class="Arg">x</var>, <var class="Arg">ind</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">x</var> is a PBW-monomial in <span class="SimpleMath">U^-</span> (i.e., a monomial in the <span class="SimpleMath">F_α</span>, where <span class="SimpleMath">α</span> runs over the positive roots). This function returns the result of applying the <var class="Arg">ind</var>-th Kashiwara operator <span class="SimpleMath">widetildeE_α_<var class="Arg">ind</var>}</span> to <span class="SimpleMath">x</span> (cf. Section <a href="chap2.html#X78BE3EB980F0A295"><span class="RefLink">2.6</span></a>). The result is <var class="Arg">fail</var> if <span class="SimpleMath">widetildeE_α_<var class="Arg">ind</var>}</span><var class="Arg">(x)=0</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem( "F", 4 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ealpha( One( U ), 2 );</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= GeneratorsOfAlgebra( U );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:= g[1]*g[4]*g[7]*g[17];</span>
F1*F4*F7*F17
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ealpha( x, 3 );</span>
F1*F2*F7*F17
</pre></div>

<p><a id="X7C8EBFF5805F8C51" name="X7C8EBFF5805F8C51"></a></p>

<h5>3.10-3 CanonicalBasis</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CanonicalBasis</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Is the canonical basis of the quantized universal enveloping algebra <var class="Arg">U</var>. When this is constructed nothing is computed. By using <code class="func">PBWElements</code> (<a href="chap3.html#X8233212A79D722FB"><span class="RefLink">3.10-4</span></a>), <code class="func">MonomialElements</code> (<a href="chap3.html#X81631585816C4CCD"><span class="RefLink">3.10-5</span></a>), <code class="func">Strings</code> (<a href="chap3.html#X782174177D696504"><span class="RefLink">3.10-6</span></a>) information about elements of the canonical basis can be obtained.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem( "F", 4 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B:= CanonicalBasis( U );</span>
&lt;canonical basis of QuantumUEA( &lt;root system of type F4&gt;, Qpar = q ) &gt;
</pre></div>

<p><a id="X8233212A79D722FB" name="X8233212A79D722FB"></a></p>

<h5>3.10-4 PBWElements</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PBWElements</code>( <var class="Arg">B</var>, <var class="Arg">rt</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">B</var> is the canonical basis of a quantized uea, and <var class="Arg">rt</var> a list of non-negative integers representing an element of the root lattice (e.g., if the simple roots are <span class="SimpleMath">α</span>, <span class="SimpleMath">β</span> and <var class="Arg">rt = [ 3, 2 ]</var>, then <var class="Arg">rt</var> represents <span class="SimpleMath">3α+2β</span>).</p>

<p>It is possible to add the option <var class="Arg">lowrank</var>, as follows <var class="Arg">PBWElements( B, rt :lowrank )</var>. In that case a somewhat different method will be used, that is significantly faster if the underlying root system has rank 2,3. It is about equally fast for ranks 4,5; and slower for ranks greater than 5.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem( "F", 4 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B:= CanonicalBasis( U );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PBWElements( B, [1,2,1,0] );</span>
[ F1*F3^(2)*F9, F1*F3*F7+(q^4)*F1*F3^(2)*F9, (q^4)*F1*F3^(2)*F9+F2*F3*F9, 
  (q^2)*F1*F3*F7+(q^6+q^2)*F1*F3^(2)*F9+(q^2)*F2*F3*F9+F2*F7, 
  (q^4)*F1*F3*F7+(q^8)*F1*F3^(2)*F9+(q^4)*F2*F3*F9+(q^2)*F2*F7+F3*F4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem("G",2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B:= CanonicalBasis( U );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PBWElements( B, [2,3] : lowrank );</span>
[ F1^(2)*F6^(3), F1*F5*F6^(2)+(q^10+q^8)*F1^(2)*F6^(3), 
  (q^2)*F1*F5*F6^(2)+(q^12+q^6)*F1^(2)*F6^(3)+F3*F6^(2), 
  (q^8)*F1*F5*F6^(2)+(q^18)*F1^(2)*F6^(3)+(q^6)*F3*F6^(2)+F5^(2)*F6 ]
</pre></div>

<p><a id="X81631585816C4CCD" name="X81631585816C4CCD"></a></p>

<h5>3.10-5 MonomialElements</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MonomialElements</code>( <var class="Arg">B</var>, <var class="Arg">rt</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>This does the same as <code class="func">PBWElements</code> (<a href="chap3.html#X8233212A79D722FB"><span class="RefLink">3.10-4</span></a>), except that the elements are written as linear combinations of monomials in the generators <span class="SimpleMath">F_α</span>, where <span class="SimpleMath">α</span> runs through the simple roots.</p>

<p>We remark that this information is also computed "behind the scenes" when calling <var class="Arg">PBWElements( B, rt )</var>. However, it is not computed if the option <var class="Arg">lowrank</var> is present in the call to <var class="Arg">PBWElements</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem( "F", 4 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B:= CanonicalBasis( U );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MonomialElements( B, [1,2,1,0] );</span>
[ F1*F3^(2)*F9, F1*F3*F9*F3+(-1)*F1*F3^(2)*F9, F3^(2)*F1*F9, F3*F1*F9*F3, 
  F3*F9*F3*F1+(-1)*F3^(2)*F1*F9 ]
</pre></div>

<p><a id="X782174177D696504" name="X782174177D696504"></a></p>

<h5>3.10-6 Strings</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Strings</code>( <var class="Arg">B</var>, <var class="Arg">rt</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">B</var>, <var class="Arg">rt</var> are the same as in <code class="func">PBWElements</code> (<a href="chap3.html#X8233212A79D722FB"><span class="RefLink">3.10-4</span></a>). This returns the list of strings corresponding to the elements of <var class="Arg">B</var> of weight <var class="Arg">rt</var> (cf. Section <a href="chap2.html#X78BE3EB980F0A295"><span class="RefLink">2.6</span></a>). For example, if on the <span class="SimpleMath">k</span>-th position of the list returned by this function we have <var class="Arg">[ 1, 2, 2, 3 ]</var>, then the principal monomial of the <span class="SimpleMath">k</span>-th element of <var class="Arg">PBWElements( B, rt )</var> is <span class="SimpleMath">widetildeF_1^2widetildeF_2^3(1)</span> (where <span class="SimpleMath">widetildeF_i</span> is the <span class="SimpleMath">i</span>-th Kashiwara operator).</p>

<p>We remark that this information is also computed "behind the scenes" when calling <var class="Arg">PBWElements( B, rt )</var>. However, it is not computed if the option <var class="Arg">lowrank</var> is present in the call to <var class="Arg">PBWElements</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem( "F", 4 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B:= CanonicalBasis( U );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Strings( B, [1,2,1,0] );</span>
[ [ 1, 1, 2, 2, 3, 1 ], [ 1, 1, 2, 1, 3, 1, 2, 1 ], [ 2, 2, 1, 1, 3, 1 ], 
  [ 2, 1, 1, 1, 3, 1, 2, 1 ], [ 2, 1, 3, 1, 2, 1, 1, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Falpha( Falpha( Falpha( Falpha( One(U), 3 ), 1 ), 2 ), 2 );</span>
F2*F3*F9
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PBWElements( B, [1,2,1,0] )[3];</span>
(q^4)*F1*F3^(2)*F9+F2*F3*F9
</pre></div>

<p><a id="X842A5CC07C3E5848" name="X842A5CC07C3E5848"></a></p>

<h5>3.10-7 PrincipalMonomial</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PrincipalMonomial</code>( <var class="Arg">u</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">u</var> is an element of the output of <code class="func">PBWElements</code> (<a href="chap3.html#X8233212A79D722FB"><span class="RefLink">3.10-4</span></a>). This function returns the unique monomial of <var class="Arg">u</var> that has coefficient 1.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem("G",2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B:= CanonicalBasis( U );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p:= PBWElements( B, [4,4] : lowrank )[4];</span>
(q^9)*F1^(2)*F3*F6^(3)+F1^(2)*F5^(2)*F6^(2)+(q^13+q^11+q^9)*F1^(3)*F5*F6^(
3)+(q^28+q^26+2*q^24+q^22+q^20)*F1^(4)*F6^(4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrincipalMonomial( p );</span>
F1^(2)*F5^(2)*F6^(2)
</pre></div>

<p><a id="X7C04F75683D0A512" name="X7C04F75683D0A512"></a></p>

<h5>3.10-8 StringMonomial</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StringMonomial</code>( <var class="Arg">u</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">u</var> is a monomial in the negative part of a quantized enveloping algebra, e.g., as output by <code class="func">PrincipalMonomial</code> (<a href="chap3.html#X842A5CC07C3E5848"><span class="RefLink">3.10-7</span></a>). This function computes the corresponding "string" (see Section <a href="chap2.html#X78BE3EB980F0A295"><span class="RefLink">2.6</span></a>). The strings are output in the same way as in <a href="chap3.html#X782174177D696504"><span class="RefLink">3.10-6</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem("G",2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B:= CanonicalBasis( U );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p:= PBWElements( B, [1,2] : lowrank )[2];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m:=PrincipalMonomial( p );</span>
F5*F6
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StringMonomial( m );</span>
[ 2, 2, 1, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Falpha( Falpha( Falpha( One(U), 1 ), 2 ), 2 );</span>
F5*F6
</pre></div>

<p><a id="X7E67BE5D856C77DC" name="X7E67BE5D856C77DC"></a></p>

<h5>3.10-9 Falpha</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Falpha</code>( <var class="Arg">V</var>, <var class="Arg">v</var>, <var class="Arg">ind</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">V</var> is a module over a quantized enveloping algebra, <var class="Arg">v</var> an element of it, and <var class="Arg">ind</var> an index between 1 and the rank of the root system. The function returns the result of applying the <var class="Arg">ind</var>-th Kashiwara operator <span class="SimpleMath">widetildeF_<var class="Arg">ind</var></span> to <var class="Arg">v</var>. Here the Kashiwara operators are different from the ones described in Section <a href="chap2.html#X78BE3EB980F0A295"><span class="RefLink">2.6</span></a>. We refer to <a href="chapBib.html#biBJ96">[Jan96]</a>, 9.2 for the definition of the operators used here.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem("B",2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= HighestWeightModule( U, [1,1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Falpha( V, Basis(V)[1], 1 );</span>
F1*v0
</pre></div>

<p><a id="X855EFC817CFCE2C7" name="X855EFC817CFCE2C7"></a></p>

<h5>3.10-10 Ealpha</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Ealpha</code>( <var class="Arg">V</var>, <var class="Arg">v</var>, <var class="Arg">ind</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">V</var> is a module over a quantized enveloping algebra, <var class="Arg">v</var> an element of it, and <var class="Arg">ind</var> an index between 1 and the rank of the root system. The function returns the result of applying the <var class="Arg">ind</var>-th Kashiwara operator <span class="SimpleMath">widetildeE_<var class="Arg">ind</var></span> to <var class="Arg">v</var>. Here the Kashiwara operators are different from the ones described in Section <a href="chap2.html#X78BE3EB980F0A295"><span class="RefLink">2.6</span></a>. We refer to <a href="chapBib.html#biBJ96">[Jan96]</a>, 9.2 for the definition of the operators used here.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem("B",2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= HighestWeightModule( U, [1,1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v:= Falpha( V, Basis(V)[2], 2 );</span>
(q^2)*F1*F4*v0+F2*v0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ealpha( V, v, 2 );</span>
F1*v0
</pre></div>

<p><a id="X85A9229678572948" name="X85A9229678572948"></a></p>

<h5>3.10-11 CrystalBasis</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CrystalBasis</code>( <var class="Arg">V</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">V</var> is a finite-dimensional left module over a quantized enveloping algebra. This function returns the canonical, or crystal basis of V (see Section <a href="chap2.html#X78BE3EB980F0A295"><span class="RefLink">2.6</span></a>).</p>

<p>This function only works for modules for which <code class="func">WeightsAndVectors</code> (<a href="chap3.html#X7929063E7C428331"><span class="RefLink">3.8-14</span></a>) works.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem( "B", 2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= HighestWeightModule( U, [1,1] );</span>
&lt;16-dimensional left-module over QuantumUEA( &lt;root system of type B
2&gt;, Qpar = q )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"> CrystalBasis( V );</span>
Basis( &lt;16-dimensional left-module over QuantumUEA( &lt;root system of type B
2&gt;, Qpar = q )&gt;, [ 1*v0, F1*v0, F4*v0, F1*F4*v0, (q^2)*F1*F4*v0+F2*v0, 
  F2*F4*v0, (q)*F2*F4*v0+F3*v0, (-q^-4)*F1*F2*v0, 
  (-q^-1)*F1*F3*v0+(-q^-3)*F2^(2)*v0, (-q^-2)*F2^(2)*v0, F3*F4*v0, 
  (-q^-4)*F2*F3*v0+(-q^-2)*F2^(2)*F4*v0, (-q^-2)*F2*F3*v0, (q^-4)*F2^(3)*v0, 
  (-q^-1)*F3^(2)*v0, (q^-5)*F2^(2)*F3*v0 ] )
</pre></div>

<p><a id="X82CE52AB7E798902" name="X82CE52AB7E798902"></a></p>

<h5>3.10-12 CrystalVectors</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CrystalVectors</code>( <var class="Arg">V</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">V</var> is a finite-dimensional left module over a quantized enveloping algebra. Let <var class="Arg">C</var> be the crystal basis of <var class="Arg">V</var> (i.e., output by <code class="func">CrystalBasis</code> (<a href="chap3.html#X85A9229678572948"><span class="RefLink">3.10-11</span></a>)). This function returns a list of cosets of the basis elements of <var class="Arg">C</var> modulo <span class="SimpleMath">qL</span>, where <span class="SimpleMath">L</span> is the <span class="SimpleMath">Z[q]</span>-lattice spanned by <var class="Arg">C</var>.</p>

<p>The coset of a vector <var class="Arg">v</var> is printed as <var class="Arg">&lt;v&gt;</var>.</p>

<p>The crystal vectors are used to construct the point set of the crystal graph of <var class="Arg">V</var> (<code class="func">CrystalGraph</code> (<a href="chap3.html#X7D7607BB81ADF579"><span class="RefLink">3.10-15</span></a>)).</p>

<p>This function only works for modules for which <code class="func">WeightsAndVectors</code> (<a href="chap3.html#X7929063E7C428331"><span class="RefLink">3.8-14</span></a>) works.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem( "B", 2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= HighestWeightModule( U, [1,1] );</span>
&lt;16-dimensional left-module over QuantumUEA( &lt;root system of type B
2&gt;, Qpar = q )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CrystalVectors( V );</span>
[ &lt;1*v0&gt;, &lt;F1*v0&gt;, &lt;F4*v0&gt;, &lt;F2*v0&gt;, &lt;F1*F4*v0&gt;, &lt;F3*v0&gt;, &lt;(-q^-4)*F1*F2*v0&gt;, 
  &lt;F2*F4*v0&gt;, &lt;F1*F3*v0&gt;, &lt;F3*F4*v0&gt;, &lt;(-q^-1)*F1*F3*v0+(-q^-3)*F2^(2)*v0&gt;, 
  &lt;(-q^-4)*F2*F3*v0+(-q^-2)*F2^(2)*F4*v0&gt;, &lt;F2^(2)*F4*v0&gt;, &lt;(q^-4)*F2^(3)*v0&gt;,
  &lt;(-q^-1)*F3^(2)*v0&gt;, &lt;(q^-5)*F2^(2)*F3*v0&gt; ]
</pre></div>

<p><a id="X80A534637D8F3210" name="X80A534637D8F3210"></a></p>

<h5>3.10-13 Falpha</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Falpha</code>( <var class="Arg">v</var>, <var class="Arg">ind</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">v</var> is a crystal vector, i.e., an element of <var class="Arg">CrystalVectors( V )</var>, where <var class="Arg">V</var> is a left module over a quantized enveloping algebra. This function returns the result of applying the <var class="Arg">ind</var>-th Kashiwara operator <span class="SimpleMath">widetildeF_α_<var class="Arg">ind</var>}</span> to v. The result is <var class="Arg">fail</var> if <span class="SimpleMath">widetildeF_α_<var class="Arg">ind</var>}</span><var class="Arg">(v)=0</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem( "B", 2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= HighestWeightModule( U, [1,1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c:=CrystalVectors( V );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Falpha( c[2], 2 );</span>
&lt;F2*v0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Falpha( c[3], 2 );</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Falpha( Falpha( Falpha( c[1], 1 ), 2 ), 1 );</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p:= DominantLSPath( RootSystem( "B", 2 ), [1,1] );</span>
&lt;LS path of shape [ 1, 1 ] ending in [ 1, 1 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Falpha( Falpha( Falpha( p, 1 ), 2 ), 1 );</span>
fail
</pre></div>

<p>The last part of this example is an illustration of the fact that the crystal graph of a highest-weight module can be obtained by the path method (see Section <a href="chap2.html#X83BBB99685FB9FB7"><span class="RefLink">2.7</span></a>).</p>

<p><a id="X7B9C76BF841FA70B" name="X7B9C76BF841FA70B"></a></p>

<h5>3.10-14 Ealpha</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Ealpha</code>( <var class="Arg">v</var>, <var class="Arg">ind</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">v</var> is a crystal vector, i.e., an element of <var class="Arg">CrystalVectors( V )</var>, where <var class="Arg">V</var> is a left module over a quantized enveloping algebra. This function returns the result of applying the <var class="Arg">ind</var>-th Kashiwara operator <span class="SimpleMath">widetildeE_α_<var class="Arg">ind</var>}</span> to v. The result is <var class="Arg">fail</var> if <span class="SimpleMath">widetildeE_α_<var class="Arg">ind</var>}</span><var class="Arg">(v)=0</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem( "B", 2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= HighestWeightModule( U, [1,1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c:=CrystalVectors( V );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ealpha( c[3], 1 );</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ealpha( c[3], 2 );</span>
&lt;1*v0&gt;
</pre></div>

<p><a id="X7D7607BB81ADF579" name="X7D7607BB81ADF579"></a></p>

<h5>3.10-15 CrystalGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CrystalGraph</code>( <var class="Arg">V</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns the crystal graph of the module <var class="Arg">V</var>. The points of this graph are the cosets output by <code class="func">CrystalVectors</code> (<a href="chap3.html#X82CE52AB7E798902"><span class="RefLink">3.10-12</span></a>). The edges work in the same way as in <code class="func">CrystalGraph</code> (<a href="chap3.html#X8637218B80BDC906"><span class="RefLink">3.9-7</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= QuantizedUEA( RootSystem("A",2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V1:= HighestWeightModule( U, [1,0] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V2:= HighestWeightModule( U, [0,1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W:= TensorProductOfAlgebraModules( V1, V2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CrystalGraph( W );</span>
rec( 
  edges := [ [ [ 1, 2 ], 1 ], [ [ 1, 3 ], 2 ], [ [ 2, 4 ], 2 ], 
      [ [ 3, 5 ], 1 ], [ [ 4, 6 ], 2 ], [ [ 5, 7 ], 1 ], [ [ 6, 8 ], 1 ], 
      [ [ 7, 8 ], 2 ] ], 
  points := [ &lt;1*(1*v0&lt;x&gt;1*v0)&gt;, &lt;1*(F1*v0&lt;x&gt;1*v0)&gt;, &lt;1*(1*v0&lt;x&gt;F3*v0)&gt;, 
      &lt;1*(1*v0&lt;x&gt;F2*v0)+q^-1*(F2*v0&lt;x&gt;1*v0)&gt;, 
      &lt;-q^-1*(1*v0&lt;x&gt;F2*v0)+q^-1*(F1*v0&lt;x&gt;F3*v0)&gt;, &lt;1*(F2*v0&lt;x&gt;F3*v0)&gt;, 
      &lt;-q^-1*(F1*v0&lt;x&gt;F2*v0)&gt;, &lt;-q^-1*(F2*v0&lt;x&gt;F2*v0)&gt;, 
      &lt;-q^-3*(1*v0&lt;x&gt;F2*v0)+-q^-1*(F1*v0&lt;x&gt;F3*v0)+1*(F2*v0&lt;x&gt;1*v0)&gt; ] )
</pre></div>

<p><a id="X7875070C85DD4E8E" name="X7875070C85DD4E8E"></a></p>

<h4>3.11 <span class="Heading"> Universal enveloping algebras </span></h4>

<p>Here we describe functions for connecting a quantized enveloping algebra to the corresponding universal enveloping algebra.</p>

<p><a id="X7E7B25307E6478CD" name="X7E7B25307E6478CD"></a></p>

<h5>3.11-1 UEA</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UEA</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>This function returns the universal enveloping algebra <var class="Arg">u</var> of the semisimple Lie algebra <var class="Arg">L</var>. The generators of <var class="Arg">u</var> are the generators of a Kostant lattice in the universal enveloping algebra (these generators are obtained from <var class="Arg">L</var> by <var class="Arg">LatticeGeneratorsInUEA( L )</var>, see the <strong class="pkg">GAP</strong> reference manual).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "B", 2, Rationals );</span>
&lt;Lie algebra of dimension 10 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u:= UEA( L );</span>
&lt;algebra over Rationals, with 10 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= GeneratorsOfAlgebra( u );</span>
[ y1, y2, y3, y4, x1, x2, x3, x4, ( h9/1 ), ( h10/1 ) ]
</pre></div>

<p><a id="X7CA021E28527763E" name="X7CA021E28527763E"></a></p>

<h5>3.11-2 UnderlyingLieAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingLieAlgebra</code>( <var class="Arg">u</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For a universal enveloping algebra <var class="Arg">u</var> constructed by <code class="func">UEA</code> (<a href="chap3.html#X7E7B25307E6478CD"><span class="RefLink">3.11-1</span></a>), this returns the corresponding semisimple Lie algebra</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "B", 2, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u:= UEA( L );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingLieAlgebra( u );</span>
&lt;Lie algebra of dimension 10 over Rationals&gt;
</pre></div>

<p><a id="X8707EE2C8145701F" name="X8707EE2C8145701F"></a></p>

<h5>3.11-3 HighestWeightModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HighestWeightModule</code>( <var class="Arg">u</var>, <var class="Arg">hw</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>For a universal enveloping algebra <var class="Arg">u</var> constructed by <code class="func">UEA</code> (<a href="chap3.html#X7E7B25307E6478CD"><span class="RefLink">3.11-1</span></a>), this returns the irreducible highest weight module over <var class="Arg">u</var> with highest weight <var class="Arg">hw</var>, which must be dominant. This module is the same as the corresponding highest weight module over the semisimple Lie algebra, but in this case the enveloping algebra <var class="Arg">u</var> acts.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "B", 2, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u:= UEA( L );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HighestWeightModule( u, [2,3] );</span>
&lt;140-dimensional left-module over &lt;algebra over Rationals, with 
10 generators&gt;&gt;
</pre></div>

<p><a id="X7AD80E5C7E015859" name="X7AD80E5C7E015859"></a></p>

<h5>3.11-4 QUEAToUEAMap</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QUEAToUEAMap</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">L</var> is a semisimple Lie algebra. Set <var class="Arg">u := UEA( L )</var>, and <var class="Arg">U := QuantizedUEA( L )</var> (so <var class="Arg">u, U</var> are the universal enveloping algebra, and "generic" quantized enveloping algebra of <var class="Arg">L</var> respectively). Then <var class="Arg">QUEAToUEAMap( L )</var> returns the algebra homomorphism from <var class="Arg">U</var> to <var class="Arg">u</var> obtained by mapping <var class="Arg">q</var> to <var class="Arg">1</var>, a generator <var class="Arg">Fi</var>, corresponding to a simple root to the generator <var class="Arg">yi</var> (corresponding to the same simple root), and likewise for <var class="Arg">Ei</var> and <var class="Arg">xi</var>. This means that <var class="Arg">Ki</var> is mapped to one, and <var class="Arg">[ Ki : s ]</var> to <var class="Arg">hi</var> choose <var class="Arg">s</var>.</p>

<p>The canonical basis of <var class="Arg">U</var> is mapped to the canonical basis of <var class="Arg">u</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SimpleLieAlgebra( "B", 2, Rationals );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f:= QUEAToUEAMap( L );</span>
&lt;mapping: QuantumUEA( &lt;root system of rank 
2&gt;, Qpar = q ) -&gt; Algebra( Rationals, [ y1, y2, y3, y4, x1, x2, x3, x4, 
  ( h9/1 ), ( h10/1 ) ] ) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U:= Source( f );</span>
QuantumUEA( &lt;root system of rank 2&gt;, Qpar = q )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u:= Range( f );</span>
&lt;algebra over Rationals, with 10 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B:= CanonicalBasis( U );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p:= PBWElements( B, [1,2] );</span>
[ F1*F4^(2), (q^3+q)*F1*F4^(2)+F2*F4, (q^4)*F1*F4^(2)+(q)*F2*F4+F3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pu:= List( p, x -&gt; Image( f, x ) );</span>
[ y1*y2^(2), 2*y1*y2^(2)+y2*y3-2*y4, y1*y2^(2)+y2*y3-1*y4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= HighestWeightModule( u, [2,1] );</span>
&lt;40-dimensional left-module over &lt;algebra over Rationals, with 10 generators&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( pu, x -&gt; x^Basis(V)[1] );</span>
[ 0*v0, y2*y3*v0-2*y4*v0, y2*y3*v0-1*y4*v0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># Which gives us a piece of the canonical basis of V.</span>
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
