<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (edim) - Chapter 1: The EDIM-Package</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap1"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap1.html">[MathJax off]</a></p>
<p><a id="X7AA826067CC8C395" name="X7AA826067CC8C395"></a></p>
<div class="ChapSects"><a href="chap1_mj.html#X7AA826067CC8C395">1 <span class="Heading">The <strong class="pkg">EDIM</strong>-Package</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X84D3F5E77E3BF046">1.1 <span class="Heading">Installation of the <strong class="pkg">EDIM</strong> package</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7AF83FEC7CD0311C">1.1-1 InfoEDIM</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X818BE04687230849">1.2 <span class="Heading"><span class="SimpleMath">\(p\)</span>-Parts of Elementary Divisors</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X813B0D73868CD751">1.2-1 ElementaryDivisorsPPartRk</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X82EC4724865F4DF9">1.2-2 ElementaryDivisorsPPartHavasSterling</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X80FF39C07E03D7EF">1.3 <span class="Heading">Inverse of Rational Matrices</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7A9656D47C4D2D16">1.3-1 InverseRatMat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X8302B31E86B3AFDB">1.3-2 RationalSolutionIntMat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X86DA61D978D2D889">1.3-3 ExponentSquareIntMatFullRank</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X7A6548FA7C837D27">1.4 <span class="Heading">All Elementary Divisors Using p-adic Method</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7B6A3B8486872B0C">1.4-1 ElementaryDivisorsSquareIntMatFullRank</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X821E30477A5DCE68">1.4-2 ElementaryDivisorsIntMatDeterminant</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X788047737FA04422">1.5 <span class="Heading">Gcd and Normal Forms Using LLL</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X799B1A5285D00859">1.5-1 GcdexIntLLL</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7C6AE6777B72F9D2">1.5-2 HermiteIntMatLLL</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X862962B7878A284F">1.5-3 HermiteIntMatLLLTrans</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X8626F15179C09798">1.5-4 SmithIntMatLLL</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X86094B1B7C87EBF6">1.5-5 SmithIntMatLLLTrans</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X832582857EB36B23">1.6 <span class="Heading">Utility Functions from the <strong class="pkg">EDIM</strong>-package</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7EC844F97C469C03">1.6-1 RatNumberFromModular</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X78518E1D81435762">1.6-2 InverseIntMatMod</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7CDF3D2081207080">1.6-3 HadamardBoundIntMat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7BAB977C7EB05067">1.6-4 CheapFactorsInt</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X8312EDA78209B4EA">1.6-5 RankMod</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X83FD1AAB7EB2E934">1.7 <span class="Heading">InverseRatMat - the Algorithm</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X791ED7D97F87FDFD">1.7-1 <span class="Heading">Rank of Integer Matrix</span></a>
</span>
</div></div>
</div>

<h3>1 <span class="Heading">The <strong class="pkg">EDIM</strong>-Package</span></h3>

<p><em>(Elementary Divisors and Integer Matrices, by Frank Lübeck)</em></p>

<p>This chapter describes the functions defined in the <strong class="pkg">GAP</strong>4 package <strong class="pkg">EDIM</strong>. The main functions implement variants of an algorithm for computing for a given prime <span class="SimpleMath">\(p\)</span> the <span class="SimpleMath">\(p\)</span>-parts of the elementary divisors of an integer matrix. These algorithms use a <span class="SimpleMath">\(p\)</span>-adic method and are described by the author in <a href="chapBib_mj.html#biBL98">[Lüb02]</a> (see <code class="func">ElementaryDivisorsPPartRk</code> (<a href="chap1_mj.html#X813B0D73868CD751"><span class="RefLink">1.2-1</span></a>)).</p>

<p>These functions were already applied to integer matrices of dimension greater than <span class="SimpleMath">\(11000\)</span> (which had many non-trivial elementary divisors which were products of small primes).</p>

<p>Furthermore there are functions for finding the biggest elementary divisor of an invertible integer matrix and the inverse of a rational invertible matrix (see <code class="func">ExponentSquareIntMatFullRank</code> (<a href="chap1_mj.html#X86DA61D978D2D889"><span class="RefLink">1.3-3</span></a>) and <code class="func">InverseRatMat</code> (<a href="chap1_mj.html#X7A9656D47C4D2D16"><span class="RefLink">1.3-1</span></a>)). These algorithms use <span class="SimpleMath">\(p\)</span>-adic approximations, explained in <a href="chap1_mj.html#X83FD1AAB7EB2E934"><span class="RefLink">1.7</span></a>.</p>

<p>Finally we distribute implementations of some other algorithms for finding elementary divisors or normal forms of integer matrices: A <span class="SimpleMath">\(p\)</span>-modular algorithm by Havas and Sterling from <a href="chapBib_mj.html#biBHS79">[HS79]</a> (see <code class="func">ElementaryDivisorsPPartHavasSterling</code> (<a href="chap1_mj.html#X82EC4724865F4DF9"><span class="RefLink">1.2-2</span></a>)) and LLL-based algorithms for extended greatest common divisors of integers (see <code class="func">GcdexIntLLL</code> (<a href="chap1_mj.html#X799B1A5285D00859"><span class="RefLink">1.5-1</span></a>)) and for Hermite normal forms of integer matrices with (very nice) transforming matrices (see <code class="func">HermiteIntMatLLL</code> (<a href="chap1_mj.html#X7C6AE6777B72F9D2"><span class="RefLink">1.5-2</span></a>)).</p>

<p>Please, send me an e-mail (<span class="URL"><a href="mailto:Frank.Luebeck@Math.RWTH-Aachen.De">Frank.Luebeck@Math.RWTH-Aachen.De</a></span>) if you have any questions, remarks, suggestions, etc. concerning this mini-package. Also, I would like to hear about applications of this package.</p>

<p>Frank Lübeck</p>

<p><a id="X84D3F5E77E3BF046" name="X84D3F5E77E3BF046"></a></p>

<h4>1.1 <span class="Heading">Installation of the <strong class="pkg">EDIM</strong> package</span></h4>

<p>To install this package first unpack it inside some GAP root directory in the subdirectory <code class="file">pkg</code> (see <a href="../../../doc/ref/chap76_mj.html#X82473E4B8756C6CD"><span class="RefLink">Reference: Installing a GAP Package</span></a>). Then the <strong class="pkg">EDIM</strong> package can already be loaded and used. But we strongly recommend to compile a kernel function as well during installation, otherwise the function <code class="func">ElementaryDivisorsPPartRkExpSmall</code> (<a href="chap1_mj.html#X813B0D73868CD751"><span class="RefLink">1.2-1</span></a>) will not be available.</p>

<p>To install the kernel function go to the directory <code class="file">pkg/EDIM-...</code> to which the package was extracted and call</p>

<p><code class="code">/bin/sh ./configure [path]</code></p>

<p>where <code class="code">path</code> is a path to the main <strong class="pkg">GAP</strong> root directory (if not given, the default <code class="file">../..</code> is assumed). Afterwards call <code class="code">make</code> to compile a binary file.</p>

<p>If you have installed several GAP kernels repeat these two steps for each of them. You can run a test of the installation by typing <code class="code">make test</code>.</p>

<p><a id="X7AF83FEC7CD0311C" name="X7AF83FEC7CD0311C"></a></p>

<h5>1.1-1 InfoEDIM</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InfoEDIM</code></td><td class="tdright">(&nbsp;info class&nbsp;)</td></tr></table></div>
<p>This is an <code class="keyw">Info</code> class for the <strong class="pkg">EDIM</strong>-package. By <code class="code">SetInfoLevel(InfoEDIM, 1);</code> you can switch on the printing of some information during the computations of certain <strong class="pkg">EDIM</strong>-functions.</p>

<p><a id="X818BE04687230849" name="X818BE04687230849"></a></p>

<h4>1.2 <span class="Heading"><span class="SimpleMath">\(p\)</span>-Parts of Elementary Divisors</span></h4>

<p>Here we explain the main functions of the package.</p>

<p><a id="X813B0D73868CD751" name="X813B0D73868CD751"></a></p>

<h5>1.2-1 ElementaryDivisorsPPartRk</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementaryDivisorsPPartRk</code>( <var class="Arg">A</var>, <var class="Arg">p</var>[, <var class="Arg">rk</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementaryDivisorsPPartRkI</code>( <var class="Arg">A</var>, <var class="Arg">p</var>, <var class="Arg">rk</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementaryDivisorsPPartRkII</code>( <var class="Arg">A</var>, <var class="Arg">p</var>, <var class="Arg">rk</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementaryDivisorsPPartRkExp</code>( <var class="Arg">A</var>, <var class="Arg">p</var>, <var class="Arg">rk</var>, <var class="Arg">exp</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementaryDivisorsPPartRkExpSmall</code>( <var class="Arg">A</var>, <var class="Arg">p</var>, <var class="Arg">rk</var>, <var class="Arg">exp</var>, <var class="Arg">il</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>These functions return a list <span class="SimpleMath">\([m_1, m_2, \ldots, m_r]\)</span> where <span class="SimpleMath">\(m_i\)</span> is the number of nonzero elementary divisors of <var class="Arg">A</var> divisible by <span class="SimpleMath">\(\textit{p}^i\)</span> (see <code class="func">ElementaryDivisorsMat</code> (<a href="../../../doc/ref/chap24_mj.html#X7AC4D74F81908109"><span class="RefLink">Reference: ElementaryDivisorsMat</span></a>) for a definition of the elementary divisors).</p>

<p>The algorithms for these functions are described in <a href="chapBib_mj.html#biBL98">[Lüb02]</a>.</p>

<p><var class="Arg">A</var> must be a matrix with integer entries, <var class="Arg">p</var> a prime, and <var class="Arg">rk</var> the rank of <var class="Arg">A</var> (as rational matrix). In the first version of the command <var class="Arg">rk</var> is computed, if it is not given.</p>

<p>The first version of the command delegates its job to the fourth version by trying growing values for <var class="Arg">exp</var>, see below.</p>

<p>The second and third versions implement the main algorithm described in <a href="chapBib_mj.html#biBL98">[Lüb02]</a> and a variation. Here <code class="func">ElementaryDivisorsPPartRkII</code> has a bit more overhead, but can be advantageous because the intermediate entries during the computation can be much smaller.</p>

<p>In the fourth form <var class="Arg">exp</var> must be an upper bound for the highest power of <var class="Arg">p</var> appearing in an elementary divisor of <var class="Arg">A</var>. This information allows reduction of matrix entries modulo <span class="SimpleMath">\(\textit{p}^{{\textit{exp+1}}}\)</span> during the computation.</p>

<p>If <var class="Arg">exp</var> is too small or the given <var class="Arg">rk</var> is too large the function returns <code class="keyw">fail</code>.</p>

<p>If <span class="SimpleMath">\(\textit{p}^{\textit{exp}}\)</span> is small enough we use internally a kernel function which can also be used directly in the fifth form of the command. There <var class="Arg">il</var> can be <span class="SimpleMath">\(0\)</span> or <span class="SimpleMath">\(1\)</span> where in the second case some information is printed during the computation.</p>

<p>More precisely, <code class="func">ElementaryDivisorsPPartRkExpSmall</code> is applicable when <span class="SimpleMath">\(\textit{p}^{{\textit{exp}+1}} &lt; 2^{{b-4}}\)</span> and <span class="SimpleMath">\((\textit{p}^{{\textit{exp}+1}} - 1)(p-1) &lt; 2^b\)</span> where <span class="SimpleMath">\(b=32\)</span> in a 32-bit version of <strong class="pkg">GAP</strong> and <span class="SimpleMath">\(b=64\)</span> in a 64-bit version of <strong class="pkg">GAP</strong>.</p>

<p>This last form of the function was already succesfully applied to dense matrices of rank up to <span class="SimpleMath">\(11000\)</span>.</p>

<p>Note that you have to compile a file (see <a href="chap1_mj.html#X84D3F5E77E3BF046"><span class="RefLink">1.1</span></a>) while installing this package, if you want to have this kernel function available.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ReadPackage("edim",  "tst/mat");</span>
Reading 242x242 integer matrix 'mat' with elementary divisors 'eldiv'.
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ElementaryDivisorsPPartRkI(mat, 2, 242); time; # mat has full rank</span>
[ 94, 78, 69, 57, 23, 23, 9, 2, 2, 0 ]
490
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ElementaryDivisorsPPartRkExpSmall(mat, 2, 242, 10, 0); time;</span>
[ 94, 78, 69, 57, 23, 23, 9, 2, 2, 0 ]
10
</pre></div>

<p><a id="X82EC4724865F4DF9" name="X82EC4724865F4DF9"></a></p>

<h5>1.2-2 ElementaryDivisorsPPartHavasSterling</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementaryDivisorsPPartHavasSterling</code>( <var class="Arg">A</var>, <var class="Arg">p</var>, <var class="Arg">d</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>For an integer matrix <var class="Arg">A</var> and a prime <var class="Arg">p</var> this function returns a list <span class="SimpleMath">\([m_1, m_2, \ldots, m_r]\)</span> where <span class="SimpleMath">\(m_i\)</span> is the number of nonzero elementary divisors of <var class="Arg">A</var> divisible by <span class="SimpleMath">\(\textit{p}^i\)</span>.</p>

<p>An upper bound <var class="Arg">d</var> for the highest power of <var class="Arg">p</var> appearing in an elementary divisor of <var class="Arg">A</var> must be given. Smaller <var class="Arg">d</var> improve the performance of the algorithm considerably.</p>

<p>This is an implementation of the modular algorithm described in <a href="chapBib_mj.html#biBHS79">[HS79]</a>.</p>

<p>We added a slight improvement: we divide the considered submatrices by the <var class="Arg">p</var>-part of the greatest common divisor of all entries (and lower the <var class="Arg">d</var> appropriately). This reduces the size of the entries and often shortens the pivot search.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ReadPackage("edim",  "tst/mat");</span>
Reading 242x242 integer matrix 'mat' with elementary divisors 'eldiv'.
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ElementaryDivisorsPPartHavasSterling(mat, 2, 10); time;</span>
[ 94, 78, 69, 57, 23, 23, 9, 2, 2 ]
1260
</pre></div>

<p><a id="X80FF39C07E03D7EF" name="X80FF39C07E03D7EF"></a></p>

<h4>1.3 <span class="Heading">Inverse of Rational Matrices</span></h4>

<p><a id="X7A9656D47C4D2D16" name="X7A9656D47C4D2D16"></a></p>

<h5>1.3-1 InverseRatMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InverseRatMat</code>( <var class="Arg">A</var>[, <var class="Arg">p</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function returns the inverse of an invertible matrix over the rational numbers.</p>

<p>It first computes the inverse modulo some prime <var class="Arg">p</var>, computes from this a <var class="Arg">p</var>-adic approximation to the inverse and finally constructs the rational entries from their <var class="Arg">p</var>-adic approximations. See section <a href="chap1_mj.html#X83FD1AAB7EB2E934"><span class="RefLink">1.7</span></a> for more details.</p>

<p>This seems to be better than <strong class="pkg">GAP</strong>'s standard Gauß algorithm (<code class="code">A^-1</code>) already for small matrices. (Try, e.g., <code class="code">RandomMat(20,20,[-10000..10000])</code> or <code class="code">RandomMat(100,100)</code>.)</p>

<p>The optional argument <var class="Arg">p</var> should be a prime such that <var class="Arg">A</var> modulo <var class="Arg">p</var> is invertible (default is <span class="SimpleMath">\(\textit{p}=251\)</span>). If <var class="Arg">A</var> is not invertible modulo <var class="Arg">p</var> then <var class="Arg">p</var> is automatically replaced by the next prime.</p>

<p><a id="X8302B31E86B3AFDB" name="X8302B31E86B3AFDB"></a></p>

<h5>1.3-2 RationalSolutionIntMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RationalSolutionIntMat</code>( <var class="Arg">A</var>, <var class="Arg">v</var>[, <var class="Arg">p</var>[, <var class="Arg">invA</var>]] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function returns the solution <span class="SimpleMath">\(x\)</span> of the system of linear equations <span class="SimpleMath">\(x \textit{A} = \textit{v}\)</span>.</p>

<p>Here, <var class="Arg">A</var> must be a matrix with integer entries which is invertible over the rationals and <var class="Arg">v</var> must be a vector with integer entries of the appropriate length.</p>

<p>The optional arguments are a prime <var class="Arg">p</var> such that <span class="SimpleMath">\(\textit{A} \pmod{p}\)</span> is invertible (if not given, <span class="SimpleMath">\(p = 251\)</span> is assumed) and the inverse <var class="Arg">invA</var> of <span class="SimpleMath">\(\textit{A} \pmod{p}\)</span>.</p>

<p>The solution is computed via <span class="SimpleMath">\(p\)</span>-adic approximation as explained in <a href="chap1_mj.html#X83FD1AAB7EB2E934"><span class="RefLink">1.7</span></a>.</p>

<p><a id="X86DA61D978D2D889" name="X86DA61D978D2D889"></a></p>

<h5>1.3-3 ExponentSquareIntMatFullRank</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExponentSquareIntMatFullRank</code>( <var class="Arg">A</var>[, <var class="Arg">p</var>[, <var class="Arg">nr</var>]] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function returns the biggest elementary divisor of a square integer matrix <var class="Arg">A</var> of full rank.</p>

<p>For such a matrix <var class="Arg">A</var> the least common multiple of the denominators of all entries of the inverse matrix <span class="SimpleMath">\(\textit{A}^{-1}\)</span> is exactly the biggest elementary divisor of <var class="Arg">A</var>.</p>

<p>This function is implemented by a slight modification of <code class="func">InverseRatMat</code> (<a href="chap1_mj.html#X7A9656D47C4D2D16"><span class="RefLink">1.3-1</span></a>). The third argument <var class="Arg">nr</var> tells the function to return the least common multiple of the first <var class="Arg">nr</var> rows of the rational inverse matrix only. Very often the function will already return the biggest elementary divisor with <span class="SimpleMath">\(\textit{nr}=2\)</span> or <span class="SimpleMath">\(3\)</span> (and the command without this argument would spend most time in checking, that this is correct).</p>

<p>The optional argument <var class="Arg">p</var> should be a prime such that <var class="Arg">A</var> modulo <var class="Arg">p</var> is invertible (default is <span class="SimpleMath">\(\textit{p}=251\)</span>). If <var class="Arg">A</var> is not invertible modulo <var class="Arg">p</var> then <var class="Arg">p</var> is automatically replaced by the next prime.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ReadPackage("edim",  "tst/mat");</span>
Reading 242x242 integer matrix 'mat' with elementary divisors 'eldiv'.
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inv := InverseRatMat(mat);; time;                      </span>
840
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExponentSquareIntMatFullRank(mat, 101, 3); # same as without the `3'</span>
115200
</pre></div>

<p><a id="X7A6548FA7C837D27" name="X7A6548FA7C837D27"></a></p>

<h4>1.4 <span class="Heading">All Elementary Divisors Using p-adic Method</span></h4>

<p>In the following two functions we put things together. In particular we handle the prime parts of the elementary divisors efficiently for primes appearing with low powers in the highest elementary divisor respectively determinant divisor.</p>

<p><a id="X7B6A3B8486872B0C" name="X7B6A3B8486872B0C"></a></p>

<h5>1.4-1 ElementaryDivisorsSquareIntMatFullRank</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementaryDivisorsSquareIntMatFullRank</code>( <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function returns a list of nonzero elementary divisors of an integer matrix <var class="Arg">A</var>.</p>

<p>Here we start with computing the biggest elementary divisor via <code class="func">ExponentSquareIntMatFullRank</code> (<a href="chap1_mj.html#X86DA61D978D2D889"><span class="RefLink">1.3-3</span></a>). If it runs into a problem because <var class="Arg">A</var> is singular modulo a choosen prime (it starts by default with 251) then the prime is automatically replaced by the next one.</p>

<p>The rest is done using <code class="func">ElementaryDivisorsPPartRkExp</code> (<a href="chap1_mj.html#X813B0D73868CD751"><span class="RefLink">1.2-1</span></a>) and <code class="func">RankMod</code> (<a href="chap1_mj.html#X8312EDA78209B4EA"><span class="RefLink">1.6-5</span></a>).</p>

<p>The function fails if the biggest elementary divisor cannot be completely factored and the non-factored part is not a divisor of the biggest elementary divisor only.</p>

<p>Note that this function may for many matrices not be the best choice for computing all elementary divisors. You may first try the standard <strong class="pkg">GAP</strong> library routines for Smith normal form instead of this function. Nevertheless remember <code class="func">ElementaryDivisorsSquareIntMatFullRank</code> for hard and big examples. It is particularly good when the largest elementary divisor is a very small factor of the determinant.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Collected(ElementaryDivisorsSquareIntMatFullRank(mat));      </span>
[ [ 1, 49 ], [ 3, 99 ], [ 6, 7 ], [ 30, 9 ], [ 60, 9 ], [ 120, 2 ], 
  [ 360, 10 ], [ 720, 22 ], [ 3600, 12 ], [ 14400, 14 ], 
  [ 28800, 7 ], [ 115200, 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">time;</span>
860
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">last2 = Collected(DiagonalOfMat(NormalFormIntMat(mat, 1).normal));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">time;</span>
5170
</pre></div>

<p><a id="X821E30477A5DCE68" name="X821E30477A5DCE68"></a></p>

<h5>1.4-2 ElementaryDivisorsIntMatDeterminant</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementaryDivisorsIntMatDeterminant</code>( <var class="Arg">A</var>, <var class="Arg">det</var>[, <var class="Arg">rk</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function returns a list of nonzero elementary divisors of an integer matrix <var class="Arg">A</var>.</p>

<p>Here <var class="Arg">det</var> must be an integer which is a multiple of the biggest determinant divisor of <var class="Arg">A</var>. If the matrix does not have full rank then its rank <var class="Arg">rk</var> must be given, too.</p>

<p>The argument <var class="Arg">det</var> can be given in the form of <code class="code">Collected(FactorsInt(<var class="Arg">det</var>))</code>.</p>

<p>This function handles prime divisors of <var class="Arg">det</var> with multiplicity smaller than 4 specially, for the other prime divisors <span class="SimpleMath">\(p\)</span> it delegates to <code class="func">ElementaryDivisorsPPartRkExp</code> (<a href="chap1_mj.html#X813B0D73868CD751"><span class="RefLink">1.2-1</span></a>) where the <var class="Arg">exp</var> argument is the multiplicity of the <span class="SimpleMath">\(p\)</span> in <var class="Arg">det</var>. (Note that this is not very good when <span class="SimpleMath">\(p\)</span> has actually a much smaller multiplicity in the largest elementary divisor.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ReadPackage("edim",  "tst/mat");</span>
Reading 242x242 integer matrix 'mat' with elementary divisors 'eldiv'.
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># not so good:</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ElementaryDivisorsIntMatDeterminant(mat,Product(eldiv)) = </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Concatenation([1..49]*0+1, eldiv); time;</span>
true
5490
</pre></div>

<p><a id="X788047737FA04422" name="X788047737FA04422"></a></p>

<h4>1.5 <span class="Heading">Gcd and Normal Forms Using LLL</span></h4>

<p>The <strong class="pkg">EDIM</strong>-mini package also contains implementations of an extended Gcd-algorithm for integers and a Hermite and Smith normal form algorithm for integer matrices using LLL-techiques. They are well described in the paper <a href="chapBib_mj.html#biBHMM98">[HMM98]</a> by Havas, Majewski and Matthews.</p>

<p>They are particularly useful if one wants to have the normal forms together with transforming matrices. These transforming matrices have spectacularly nice (i.e., "small") entries in cases of input matrices which are non-square or not of full rank (otherwise the transformation to the Hermite normal form is unique).</p>

<p>In detail:</p>

<p><a id="X799B1A5285D00859" name="X799B1A5285D00859"></a></p>

<h5>1.5-1 GcdexIntLLL</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GcdexIntLLL</code>( <var class="Arg">n1</var>, <var class="Arg">n2</var>, <var class="Arg">...</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function returns for integers <span class="SimpleMath">\(\textit{n1}, \textit{n2}, \ldots\)</span> a list <span class="SimpleMath">\([g, [c_1, c_2, \ldots]]\)</span>, where <span class="SimpleMath">\(g = c_1\textit{n1} + c_2\textit{n2} + \ldots\)</span> is the greatest common divisor of the <var class="Arg">ni</var>. Here all the <span class="SimpleMath">\(c_i\)</span> are usually very small.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GcdexIntLLL( 517, 244, -304, -872, -286, 854, 866, 224, -765, -38);</span>
[ 1, [ 0, 0, 0, 0, 1, 0, 1, 1, 1, 1 ] ]
</pre></div>

<p><a id="X7C6AE6777B72F9D2" name="X7C6AE6777B72F9D2"></a></p>

<h5>1.5-2 HermiteIntMatLLL</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HermiteIntMatLLL</code>( <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This returns the Hermite normal form of an integer matrix <var class="Arg">A</var> and uses the LLL-algorithm to avoid entry explosion.</p>

<p><a id="X862962B7878A284F" name="X862962B7878A284F"></a></p>

<h5>1.5-3 HermiteIntMatLLLTrans</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HermiteIntMatLLLTrans</code>( <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function returns a pair of matrices <span class="SimpleMath">\([H, L]\)</span> where <span class="SimpleMath">\(H = L \textit{A}\)</span> is the Hermite normal form of an integer matrix <var class="Arg">A</var>. The transforming matrix <span class="SimpleMath">\(L\)</span> can have surprisingly small entries.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ReadPackage("edim",  "tst/mat2");</span>
Reading 34x34 integer matrix 'mat2' with elementary divisors 'eldiv2'.
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tr := HermiteIntMatLLLTrans(mat2);; Maximum(List(Flat(tr[2]), AbsInt));</span>
606
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tr[2]*mat2 = tr[1];                                                </span>
true
</pre></div>

<p><a id="X8626F15179C09798" name="X8626F15179C09798"></a></p>

<h5>1.5-4 SmithIntMatLLL</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SmithIntMatLLL</code>( <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function returns the Smith normal form of an integer matrix <var class="Arg">A</var> using the LLL-algorithm to avoid entry explosion.</p>

<p><a id="X86094B1B7C87EBF6" name="X86094B1B7C87EBF6"></a></p>

<h5>1.5-5 SmithIntMatLLLTrans</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SmithIntMatLLLTrans</code>( <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function returns <span class="SimpleMath">\([S, L, R]\)</span> where <span class="SimpleMath">\(S = L \textit{A} R\)</span> is the Smith normal form of an integer matrix <var class="Arg">A</var>.</p>

<p>We apply the algorithm for Hermite normal form several times to get the Smith normal form, that is not in the paper <a href="chapBib_mj.html#biBHMM98">[HMM98]</a>. The transforming matrices need not be as nice as for the Hermite normal form.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ReadPackage("edim",  "tst/mat2");</span>
Reading 34x34 integer matrix 'mat2' with elementary divisors 'eldiv2'.
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tr := SmithIntMatLLLTrans(mat2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tr[2] * mat2 * tr[3] = tr[1];    </span>
true
</pre></div>

<p><a id="X832582857EB36B23" name="X832582857EB36B23"></a></p>

<h4>1.6 <span class="Heading">Utility Functions from the <strong class="pkg">EDIM</strong>-package</span></h4>

<p><a id="X7EC844F97C469C03" name="X7EC844F97C469C03"></a></p>

<h5>1.6-1 RatNumberFromModular</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RatNumberFromModular</code>( <var class="Arg">n</var>, <var class="Arg">k</var>, <var class="Arg">l</var>, <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function returns <span class="SimpleMath">\(r/s = \textit{x} \pmod{\textit{n}}\)</span>, if it exists. More precisely:</p>

<p><var class="Arg">n</var>, <var class="Arg">k</var>, <var class="Arg">l</var> must be positive integers with <span class="SimpleMath">\(2\textit{k}\textit{l} \leq \textit{n}\)</span> and <var class="Arg">x</var> an integer with <span class="SimpleMath">\(-\textit{n}/2 &lt; \textit{x} \leq \textit{n}/2\)</span>. If it exists this function returns a rational number <span class="SimpleMath">\(r/s\)</span> with <span class="SimpleMath">\(0 &lt; s &lt; \textit{l}\)</span>, <span class="SimpleMath">\(\gcd(s, \textit{n}) = 1\)</span>, <span class="SimpleMath">\(-\textit{k} &lt; r &lt; \textit{k}\)</span> and <span class="SimpleMath">\(r/s\)</span> congruent to <span class="SimpleMath">\(\textit{x} \pmod{\textit{n}}\)</span> (i.e., <span class="SimpleMath">\(\textit{n} \mid r - s \textit{x}\)</span>). Such an <span class="SimpleMath">\(r/s\)</span> is unique. The function returns <code class="keyw">fail</code> if such a number does not exist.</p>

<p><a id="X78518E1D81435762" name="X78518E1D81435762"></a></p>

<h5>1.6-2 InverseIntMatMod</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InverseIntMatMod</code>( <var class="Arg">A</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function returns an inverse matrix modulo a prime <var class="Arg">p</var> or <code class="keyw">fail</code>. More precisely:</p>

<p><var class="Arg">A</var> must be an integer matrix and <var class="Arg">p</var> a prime such that <var class="Arg">A</var> is invertible modulo <var class="Arg">p</var>. This function returns an integer matrix <var class="Arg">inv</var> with entries in the range <span class="SimpleMath">\(]-\textit{p}/2 \ldots \textit{p}/2]\)</span> such that <var class="Arg">inv</var><var class="Arg">A</var> reduced modulo p is the identity matrix.</p>

<p>It returns <code class="keyw">fail</code> if the inverse modulo <var class="Arg">p</var> does not exist. This function is particularly fast for primes smaller 256.</p>

<p><a id="X7CDF3D2081207080" name="X7CDF3D2081207080"></a></p>

<h5>1.6-3 HadamardBoundIntMat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HadamardBoundIntMat</code>( <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>The Hadamard bound for a square integer matrix <var class="Arg">A</var> is the product of Euclidean norms of the nonzero rows (or columns) of <var class="Arg">A</var>. It is an upper bound for the absolute value of the determinant of <var class="Arg">A</var>.</p>

<p><a id="X7BAB977C7EB05067" name="X7BAB977C7EB05067"></a></p>

<h5>1.6-4 CheapFactorsInt</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CheapFactorsInt</code>( <var class="Arg">n</var>[, <var class="Arg">nr</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function returns a list of factors of an integer <var class="Arg">n</var>, including "small" prime factors - here the optional argument <var class="Arg">nr</var> is the number of iterations for `FactorsRho' (default is 2000).</p>

<p>This is only a slight modification of the library function <code class="func">FactorsInt</code> (<a href="../../../doc/ref/chap14_mj.html#X82C989DB84744B36"><span class="RefLink">Reference: FactorsInt</span></a>) which avoids an error message when the number is not completely factored.</p>

<p><a id="X8312EDA78209B4EA" name="X8312EDA78209B4EA"></a></p>

<h5>1.6-5 RankMod</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RankMod</code>( <var class="Arg">A</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function returns the rank of an integer matrix <var class="Arg">A</var> modulo <var class="Arg">p</var>. Here <var class="Arg">p</var> must not necessarily be a prime. If it is not and this function returns an integer, then this is the rank of <var class="Arg">A</var> for all prime divisors of <var class="Arg">p</var>.</p>

<p>If during the computation a factorisation of <var class="Arg">p</var> is found (because some pivot entry has nontrivial greatest common divisor with <var class="Arg">p</var>) then the function is recursively applied to the found factors <code class="code">f_i</code> of <var class="Arg">p</var>. The result is then given in the form <code class="code">[[f_1, rk_1], [f_2, rk_2], ...]</code>.</p>

<p>The idea to make this function useful for non primes was to use it with large factors of the biggest elementary divisor of <var class="Arg">A</var> whose prime factorization cannot be found easily.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ReadPackage("edim",  "tst/mat");</span>
Reading 242x242 integer matrix 'mat' with elementary divisors 'eldiv'.
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RankMod(mat, 5);</span>
155
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RankMod(mat, (2*79*4001));</span>
[ [ 2, 148 ], [ 79, 242 ], [ 4001, 242 ] ]
</pre></div>

<p><a id="X83FD1AAB7EB2E934" name="X83FD1AAB7EB2E934"></a></p>

<h4>1.7 <span class="Heading">InverseRatMat - the Algorithm</span></h4>

<p>The idea is to recover a rational matrix from an <span class="SimpleMath">\(l\)</span>-adic approximation for some prime <span class="SimpleMath">\(l\)</span>. This description came out of discussions with Jürgen Müller. I thank John Cannon for pointing out that the basic idea already appeared in the paper <a href="chapBib_mj.html#biBD82">[Dix82]</a> of Dixon.</p>

<p>Let <span class="SimpleMath">\(A\)</span> be an invertible matrix over the rational numbers. By multiplying with a constant we may assume that its entries are in fact integers.</p>

<p>(1) We first describe how to find an <span class="SimpleMath">\(l\)</span>-adic approximation of <span class="SimpleMath">\(A^{-1}\)</span>. Find a prime <span class="SimpleMath">\(l\)</span> such that <span class="SimpleMath">\(A\)</span> is invertible modulo <span class="SimpleMath">\(l\)</span> and let <span class="SimpleMath">\(B\)</span> be the integer matrix with entries in the range <span class="SimpleMath">\(\left]-l/2,l/2\right]\)</span> such that <span class="SimpleMath">\(BA\)</span> is congruent to the identity matrix modulo <span class="SimpleMath">\(l\)</span>. (This can be computed fast by usual Gauß elimination.)</p>

<p>Now let <span class="SimpleMath">\(v \in ℤ^r\)</span> be a row vector. Define two sequences <span class="SimpleMath">\(v_i\)</span> and <span class="SimpleMath">\(x_i\)</span> of row vectors in <span class="SimpleMath">\(ℤ^r\)</span> by: <span class="SimpleMath">\(x_0 := 0 \in ℤ^r\)</span>, <span class="SimpleMath">\(v_0 := -v\)</span> and for <span class="SimpleMath">\(i &gt; 0\)</span> set <span class="SimpleMath">\(x_i\)</span> to the vector congruent to <span class="SimpleMath">\(-v_{i-1} B\)</span> modulo <span class="SimpleMath">\(l\)</span> having entries in the range <span class="SimpleMath">\(\left]-l/2, l/2\right]\)</span>. Then all entries of <span class="SimpleMath">\(x_i A + v_{i-1}\)</span> are divisible by <span class="SimpleMath">\(l\)</span> and we set <span class="SimpleMath">\(v_i := (1/l) \cdot (x_i A + v_{i-1})\)</span>.</p>

<p>Induction shows that for <span class="SimpleMath">\(y_i := \sum_{k=1}^{i} l^{k-1} x_k\)</span> we have <span class="SimpleMath">\(y_i A = v + l^i v_i\)</span> for all <span class="SimpleMath">\(i \geq 0\)</span>. Hence the sequence <span class="SimpleMath">\(y_i\)</span>, <span class="SimpleMath">\(i \geq 0\)</span>, gives an <span class="SimpleMath">\(l\)</span>-adic approximation to the vector <span class="SimpleMath">\(y \in ℚ^r\)</span> with <span class="SimpleMath">\(y A = v\)</span>.</p>

<p>(2) The second point is to show how we can get the vector <span class="SimpleMath">\(y\)</span> from a sufficiently good approximation <span class="SimpleMath">\(y_i\)</span>. Note that the sequence of <span class="SimpleMath">\(y_i\)</span> becomes constant for <span class="SimpleMath">\(i \geq i_0\)</span> if all entries of <span class="SimpleMath">\(y\)</span> are integers of absolute value smaller than <span class="SimpleMath">\(l^{i_0} / 2\)</span> because of our choice of representatives of residue classes modulo <span class="SimpleMath">\(l\)</span> in the interval <span class="SimpleMath">\(\left]-l/2, l/2\right]\)</span>.</p>

<p>More generally consider <span class="SimpleMath">\(a / b \in ℚ\)</span> with <span class="SimpleMath">\(b &gt; 0\)</span> and <span class="SimpleMath">\(a, b\)</span> coprime. Then there is for each <span class="SimpleMath">\(n \in ℕ\)</span> which is coprime to <span class="SimpleMath">\(b\)</span> a unique <span class="SimpleMath">\(c \in ℤ\)</span> with <span class="SimpleMath">\(-n / 2 &lt; c \leq n / 2\)</span> and <span class="SimpleMath">\(a \equiv c b \pmod{n}\)</span>. This <span class="SimpleMath">\(c\)</span> can be computed via the extended Euclidean algorithm applied to <span class="SimpleMath">\(b\)</span> and <span class="SimpleMath">\(n\)</span>.</p>

<p>Now let <span class="SimpleMath">\(n, \alpha, \beta \in ℕ\)</span> with <span class="SimpleMath">\(2 \alpha \beta \leq n\)</span>. Then the map <span class="SimpleMath">\(\{a/b \in ℚ \mid -\alpha \leq a \leq \alpha, 1 \leq b &lt; \beta \} \rightarrow \left]-n/2, n/2\right]\)</span>, <span class="SimpleMath">\(a/b \mapsto c\)</span> (defined as above) is injective (since for <span class="SimpleMath">\(a/b\)</span>, <span class="SimpleMath">\(a'/b'\)</span> in the above set we have <span class="SimpleMath">\(a b' - a' b \equiv 0 \pmod{n}\)</span> if and only if <span class="SimpleMath">\(a b' - a' b = 0\)</span>).</p>

<p>In practice we can use for any <span class="SimpleMath">\(c \in \left]-n/2, n/2\right]\)</span> a certain extended Euclidean algorithm applied to <span class="SimpleMath">\(n\)</span> and <span class="SimpleMath">\(c\)</span> to decide if <span class="SimpleMath">\(c\)</span> is in the image of the above map and to find the corresponding <span class="SimpleMath">\(a/b\)</span> if it exists.</p>

<p>(3) To put things together we apply (2) to the entries of the vectors <span class="SimpleMath">\(y_i\)</span> constructed in (1), choosing <span class="SimpleMath">\(n = l^i\)</span>, <span class="SimpleMath">\(\alpha = \sqrt{n}/2\)</span> and <span class="SimpleMath">\(\beta = \sqrt{n}\)</span>. If we have found this way a candidate for <span class="SimpleMath">\(y\)</span> we can easily check if it is correct by computing <span class="SimpleMath">\(y A\)</span>. If <span class="SimpleMath">\(\mu\)</span> is the maximal absolute value of all numerators and denominators of the entries of <span class="SimpleMath">\(y\)</span> it is clear from (2) that we will find <span class="SimpleMath">\(y\)</span> from <span class="SimpleMath">\(y_i\)</span> if <span class="SimpleMath">\(l^i &gt; 2 \mu^2\)</span>.</p>

<p>(4) If we take as <span class="SimpleMath">\(v\)</span> in (1) to(3) all standard unit vectors we clearly get the rows of <span class="SimpleMath">\(A^{-1}\)</span>. But we can do it better. Namely we can take as <span class="SimpleMath">\(v\)</span> the standard unit vectors multiplied by the least common multiple <span class="SimpleMath">\(\epsilon\)</span> of the denominators of the already computed entries of <span class="SimpleMath">\(A^{-1}\)</span>. In many examples this <span class="SimpleMath">\(\epsilon\)</span> actually equals <span class="SimpleMath">\(\epsilon_r\)</span> after the computation of the first or first few rows. Therefore we will often find quickly the next row of <span class="SimpleMath">\(A^{-1}\)</span> already in (1), because we find a <span class="SimpleMath">\(v_i = 0\)</span> such that the sequence of <span class="SimpleMath">\(y_i\)</span> becomes constant (<span class="SimpleMath">\(=y\)</span>).</p>

<p><a id="X791ED7D97F87FDFD" name="X791ED7D97F87FDFD"></a></p>

<h5>1.7-1 <span class="Heading">Rank of Integer Matrix</span></h5>

<p>The following strategy has shown to be useful in proving that some very big integer matrix is not invertible.</p>


<ul>
<li><p>Check the rank modulo some small primes, say with <code class="func">RankMod</code> (<a href="chap1_mj.html#X8312EDA78209B4EA"><span class="RefLink">1.6-5</span></a>).</p>

</li>
<li><p>If the rank seems less than the number of rows choose a prime <span class="SimpleMath">\(p\)</span>, a collection of lines which is linearly independent modulo <span class="SimpleMath">\(p\)</span>, and another line linearly dependend on these. Guess that this last line is also linearly dependend on the chosen collection over the rational numbers (maybe check modulo several small primes).</p>

</li>
<li><p>Find columns of the collection of lines which give an invertible matrix modulo some prime.</p>

</li>
<li><p>Then use <code class="func">RationalSolutionIntMat</code> (<a href="chap1_mj.html#X8302B31E86B3AFDB"><span class="RefLink">1.3-2</span></a>) with the invertible submatrix and corresponding entries of the linearly dependend row to prove this.</p>

</li>
</ul>
<p>Guessing the rank of a matrix from the rank modulo several primes, chosing a maximal set of lines which are linearly independent modulo some primes, and using <code class="func">RationalSolutionIntMat</code> (<a href="chap1_mj.html#X8302B31E86B3AFDB"><span class="RefLink">1.3-2</span></a>) with the remaining lines, one may also find the exact rank of a huge integer matrix.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
