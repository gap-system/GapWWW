<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (Automata) - Chapter 1: 
      Introduction
    </title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap1"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chapA.html">A</a>  <a href="chapB.html">B</a>  <a href="chapC.html">C</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap2.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap1_mj.html">[MathJax on]</a></p>
<p><a id="X7DFB63A97E67C0A1" name="X7DFB63A97E67C0A1"></a></p>
<div class="ChapSects"><a href="chap1.html#X7DFB63A97E67C0A1">1 <span class="Heading">
      Introduction
    </span></a>
</div>

<h3>1 <span class="Heading">
      Introduction
    </span></h3>

<p>In many situations an automaton is conveniently described through a diagram like the following</p>

<p><br><center><img src="aut1.gif"></center><br></p>

<p>This diagram describes a (deterministic) automaton with <span class="SimpleMath">3</span> states (the elements of the set <span class="SimpleMath">{1,2,3}).</span> The arrow pointing to the state <span class="SimpleMath">1</span> indicates that <span class="SimpleMath">1</span> is the initial state and the two circles around state <span class="SimpleMath">3</span> indicate that <span class="SimpleMath">3</span> is a final or accepting state. The set <span class="SimpleMath">{a,b}</span> is the <em>alphabet</em> of the automaton; its elements are called <em>letters</em> and are the labels of the edges of the diagram. The words <span class="SimpleMath">a</span> , <span class="SimpleMath">ab^2</span> , <span class="SimpleMath">b^5a^3b</span> are examples of words recognized by the automaton since they are labels of paths from the initial to the final state.</p>

<p>The set of words recognized by an automaton is called the <em>language</em> of the automaton. It is a rational language and may be represented through a rational expression. For instance,</p>


<div class="example"><pre>(aUb)(a(aUb)Ub(aUb))*</pre></div>

<p>is a rational expression representing the language of the above automaton.</p>

<p>Kleene's Theorem states that a language is rational if and only if it is the language of a finite automaton. Both directions of Kleene's Theorem can be proved constructively, and these algorithms, to go from an automaton to a rational expression and <em>vice-versa</em>, are implemented in this package.</p>

<p>Of course, one has to pay attention to the size of the output produced. When producing a deterministic automaton equivalent to a given rational expression one can obtain an optimal solution (the minimal automaton) using standard algorithms <a href="chapBib.html#biBAHU:74">[AHU74]</a>.</p>

<p>When producing a rational expression for the language of an automaton, and taking into account some reasonable measure for the size of a rational expression, to determine a minimal one is apparently computationally difficult. We use here some heuristic methods (to be published elsewhere) which in practice lead to very reasonable results.</p>

<p>The development of this work has benefited from the existence of AMoRE <a href="chapBib.html#biBAMORE:95">[MMP+95]</a>, a package written in <code class="code">C</code> to handle Automata, Monoids and Regular Expressions. In fact, its manual has been very useful and some of the algorithms implemented here are those implemented in AMoRE. In this package, unlike what happened with AMoRE, we do not have to worry about the monoid part in order to make it useful to semigroup theorists, since monoids are already implemented in <strong class="pkg">GAP</strong> and we may take advantage of this fact. We just need a function to compute the transition semigroup of an automaton.</p>

<p>The parts of this package that have not so directly to do with automata or rational expressions are put into appendices in this manual. Some words about these appendices follow.</p>

<p>Using the external program Graphviz <a href="chapBib.html#biBKoutsofiosNorth:2002">[DEG+02]</a> to graph visualization, one can visualize automata. This very convenient tool presently works easily under LINUX.</p>

<p>Given a finitely generated subgroup of the free group it is possible to compute a flower automaton and perform Stallings foldings over it in order to obtain an inverse automaton corresponding to the given subgroup.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap2.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chapA.html">A</a>  <a href="chapB.html">B</a>  <a href="chapC.html">C</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
