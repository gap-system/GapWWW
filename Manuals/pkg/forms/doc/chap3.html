<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (Forms) - Chapter 3: Background Theory on Forms</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap3"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap3_mj.html">[MathJax on]</a></p>
<p><a id="X79424B627CE11FCA" name="X79424B627CE11FCA"></a></p>
<div class="ChapSects"><a href="chap3.html#X79424B627CE11FCA">3 <span class="Heading">Background Theory on Forms</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X874CD5E0802FEB50">3.1 <span class="Heading">Sesquilinear forms</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7A489A5D79DA9E5C">3.1-1 <span class="Heading">Examples</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X864CAF8881067D8A">3.2 <span class="Heading">Quadratic forms</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7A489A5D79DA9E5C">3.2-1 <span class="Heading">Examples</span></a>
</span>
</div></div>
</div>

<h3>3 <span class="Heading">Background Theory on Forms</span></h3>

<p>In this chapter we give a very brief overview of the theory of sesquilinear and quadratic forms. The reader can find more in the texts: Cameron <a href="chapBib.html#biBCameron">[Cam00]</a>, Taylor <a href="chapBib.html#biBTaylor">[Tay92]</a>, Aschbacher <a href="chapBib.html#biBAschbacher">[Asc00]</a>, or Kleidman and Liebeck <a href="chapBib.html#biBKleidmanLiebeck">[KL90]</a>.</p>

<p><a id="X874CD5E0802FEB50" name="X874CD5E0802FEB50"></a></p>

<h4>3.1 <span class="Heading">Sesquilinear forms</span></h4>

<p>A <em>sesquilinear form</em> on an <span class="SimpleMath">n</span>-dimensional vector space <span class="SimpleMath">V</span> over a field <span class="SimpleMath">F</span>, is a map <span class="SimpleMath">f</span> from <span class="SimpleMath">V× V</span> to <span class="SimpleMath">F</span> which is linear in the first coordinate, but semilinear in the second coordinate; that is, there is a field automorphism <span class="SimpleMath">α</span> (the <em>companion automorphism</em> of <span class="SimpleMath">f</span>) such that</p>

<p class="pcenter">f(v,λw)=λ<sup>α</sup>f(v,w),</p>

<p>for all <span class="SimpleMath">v,w ∈ V</span> and <span class="SimpleMath">λ ∈ F</span>. If <span class="SimpleMath">α</span> is the identity, then <span class="SimpleMath">f</span> is <em>bilinear</em>.</p>

<p>A bilinear form is <em>reflexive</em> if <span class="SimpleMath">f(v,w)=0 ⇒ f(w,v)=0</span> for all <span class="SimpleMath">v,w ∈ V</span>. A bilinear form is <em>symmetric</em> if <span class="SimpleMath">f(v,w)=f(w,v)</span> for all <span class="SimpleMath">v,w ∈ V</span>. It is clear that a symmetric bilinear form is reflexive. A bilinear form is <em>alternating</em> if <span class="SimpleMath">f(v,v)=0</span> for all <span class="SimpleMath">v ∈ V</span>. Using the linearity to compute <span class="SimpleMath">f(v+w,v+w)</span>, we see that an alternating form is also reflexive. When the characteristic of the field differs from 2, an alternating form <span class="SimpleMath">f</span> can also be characterised as <span class="SimpleMath">f(v,w) = -f(w,v)</span> for all <span class="SimpleMath">v,w ∈ V</span>. It can be proved (see Chapter 7 of <a href="chapBib.html#biBTaylor">[Tay92]</a>) that symmetric and alternating bilinear forms are the only reflexive bilinear forms.</p>

<p>For a given sesquilinear form <span class="SimpleMath">f</span>, the choice of the basis determines uniquely an <span class="SimpleMath">n× n</span> matrix <span class="SimpleMath">M</span> such that f(v, w) = v M w<sup>αT</sup>.</p>

<p>This matrix is also called the <em>Gram matrix</em> of <span class="SimpleMath">f</span>. Given a sesquilinear form <span class="SimpleMath">f</span>, we will denote its Gram matrix by M<sub>f</sub>. In <strong class="pkg">Forms</strong>, sesquilinear forms can be constructed using matrices or polynomials, where we always suppose that the basis of the vector space is the standard basis (i.e., the rows of the identity matrix).</p>

<p>One proves easily that a bilinear form <span class="SimpleMath">f</span> is symmetric if and only if M<sub>f</sub> is a symmetric matrix, i.e., M<sub>f</sub><sup>T</sup>=M<sub>f</sub>, and that a bilinear form <span class="SimpleMath">f</span> is alternating if and only if M<sub>f</sub> is a skew symmetric matrix, i.e., M<sub>f</sub><sup>T</sup>=-M<sub>f</sub>. When the characteristic of the field is two, the condition that <span class="SimpleMath">f(v,v)=0</span> for all <span class="SimpleMath">v ∈ V</span> implies M<sub>f</sub><sup>T</sup>=M<sub>f</sub> <strong class="button">and</strong> (M<sub>ii</sub>)=0 for all <span class="SimpleMath">i</span> (and where the matrix M<sub>f</sub> = (M<sub>ij</sub>)). Since any skew symmetric odd dimensional matrix is singular, it follows that an alternating form of an odd dimensional vector space is degenerate.</p>

<p>A sesquilinear form <span class="SimpleMath">f</span> is <em>hermitian</em> (n.b., <em>conjugate-symmetric</em> in <a href="chapBib.html#biBAtlas">[CCN+85]</a>) if f(v,w)=f(w,v)<sup>α</sup> holds for all vectors <span class="SimpleMath">v,w</span>, with <span class="SimpleMath">α</span> an involutory field automorphism only dependent on <span class="SimpleMath">f</span>. Again, it can be easily proved that a sesquilinear form <span class="SimpleMath">f</span> is hermitian if and only if M<sub>f</sub><sup>T</sup>=M<sub>f</sub><sup>α</sup> (i.e., a hermitian matix). It is proved (see Chapter 7 of <a href="chapBib.html#biBTaylor">[Tay92]</a>) that hermitian forms are the only reflexive sesquilinear forms that are not bilinear. Hence, in general, all reflexive sesquilinear forms are known, they are either hermitian or bilinear, and in the latter case, they are either symmetric or alternating (again, see Chapter 7 of <a href="chapBib.html#biBTaylor">[Tay92]</a>).</p>

<p>In <strong class="pkg">Forms</strong>, only the construction of <strong class="button">reflexive</strong> sesquilinear forms is allowed. An error message will be displayed if any attempt to construct a non-reflexive sesquilinear form is made. As a consequence, the Gram Matrix of a sesquilinear form is always a symmetric, a skew symmetric or a hermitian matrix. From now on, the notion of a ``sesquilinear form'' will always refer to a ``reflexive sesquilinear form''.</p>

<p>Given a sesquilinear form <span class="SimpleMath">f</span>, two vectors <span class="SimpleMath">v</span> and <span class="SimpleMath">w</span> are <em>orthogonal</em> with respect to <span class="SimpleMath">f</span> if <span class="SimpleMath">f(v,w) = 0</span>. Note that the reflexivity makes orthogonality between two vectors a symmetric relation. A vector <span class="SimpleMath">v</span> is called <em>isotropic</em> if <span class="SimpleMath">f(v,v)=0</span>. The <em>radical</em> of <span class="SimpleMath">f</span> (n.b., <em>kernel</em> in <a href="chapBib.html#biBAtlas">[CCN+85]</a>) is the subspace consisting of vectors which are orthogonal to every vector. That is,</p>

<p><center>Rad(f) = {v ∈ V | f(v,w) = 0 for all w ∈ V},</center> and we say that <span class="SimpleMath">f</span> is <em>non-degenerate</em> if its radical is trivial (and <em>degenerate</em> otherwise).</p>

<p>Given a subspace <span class="SimpleMath">W</span>, we denote the set of vectors of <span class="SimpleMath">V</span> orthogonal with all vectors of <span class="SimpleMath">W</span> by W<sup>⊥</sup>. We call a subspace <span class="SimpleMath">W</span> <em>totally isotropic</em> with respect to <span class="SimpleMath">f</span> if <span class="SimpleMath">W</span> is contained in W<sup>⊥</sup>, i.e.</p>

<p><center>f(v,w) = 0 for all v,w ∈ W.</center></p>

<p>Suppose that <span class="SimpleMath">f</span> is a non-degenerate sesquilinear form. The <em>Witt index</em> of <span class="SimpleMath">f</span> is the maximum dimension of a totally isotropic subspace with respect to <span class="SimpleMath">f</span>.</p>

<p>Let <span class="SimpleMath">f</span> be a sesquilinear form on <span class="SimpleMath">V(n,q)</span>, with radical <span class="SimpleMath">R</span>, a <span class="SimpleMath">k</span>-dimensional subspace of <span class="SimpleMath">V(n,q)</span>, <span class="SimpleMath">0 ≤ k ≤ n</span>. Then <span class="SimpleMath">f</span> induces a non-degenerate form <span class="SimpleMath">g</span> on <span class="SimpleMath">V/R</span>. When <span class="SimpleMath">dim(R)=0</span>, then <span class="SimpleMath">g=f</span> and <span class="SimpleMath">f</span> is non-degenerate. Notice that all totally isotropic subspaces of maximal dimension of a degenerate form <span class="SimpleMath">f</span> contain the radical of <span class="SimpleMath">f</span>. In <strong class="pkg">Forms</strong>, the notion Witt index will <strong class="button">always refer to the induced non-degenerate form</strong> <span class="SimpleMath">g</span>. Hence, given a degenerate form <span class="SimpleMath">f</span>, computing its Witt index will return the Witt index of the induced form <span class="SimpleMath">g</span>. <strong class="button">This also holds for the notions elliptic, parabolic and hyperbolic for a bilinear form, which are notions defined using the Witt index, see below</strong>.</p>

<p>We end this section with a short description of the conventions used in <strong class="pkg">Forms</strong> for the notions orthogonal, symplectic, pseudo, hyperbolic, elliptic and parabolic. We call a form <span class="SimpleMath">f</span> <em>symplectic</em> if and only if <span class="SimpleMath">f</span> is alternating. When the characteristic of the field is odd, we call a form <span class="SimpleMath">f</span> <em>orthogonal</em> if and only <span class="SimpleMath">f</span> is symmetric, and when the characteristic of the field is even, we call a form <span class="SimpleMath">f</span> <em>pseudo</em> if and only if <span class="SimpleMath">f</span> is symmetric but not alternating. This terminology is related to the theory of polar spaces, and in the case of orthogonal forms, we adopt the terms <em>hyperbolic</em>, <em>elliptic</em> and <em>parabolic</em> for the three different isometry types of orthogonal forms. From the point of view of matrix groups, these three types correspond as follows. Recall that, as explained above, the Witt index refers to the Witt index of the <strong class="button">induced non-degenerate form</strong> <span class="SimpleMath">g</span> when <span class="SimpleMath">f</span> is degenerate.</p>

<div class="pcenter"><table class="GAPDocTable">
<caption class="GAPDocTable"><b>Table: </b>Posibilites for an orthogonal form <span class="SimpleMath">f</span> on a vector space <span class="SimpleMath">V</span></caption>
<tr>
<td class="tdleft">Hyperbolic</td>
<td class="tdleft">Orthogonal of + type</td>
<td class="tdleft">V/Rad(f) has even dimension, <span class="SimpleMath">g</span> has maximal Witt index</td>
</tr>
<tr>
<td class="tdleft">Elliptic</td>
<td class="tdleft">Orthogonal of - type</td>
<td class="tdleft">V/Rad(f) has even dimension, <span class="SimpleMath">g</span> has non-maximal Witt index</td>
</tr>
<tr>
<td class="tdleft">Parabolic</td>
<td class="tdleft">Orthogonal of o type</td>
<td class="tdleft">V/Rad(f) has odd dimension</td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p><a id="X7A489A5D79DA9E5C" name="X7A489A5D79DA9E5C"></a></p>

<h5>3.1-1 <span class="Heading">Examples</span></h5>

<p>The examples we present in this section do not demonstrate the entire suite of operations entailed in <strong class="pkg">Forms</strong>. They are intended to allow the user to become familiar with particular aspects of this package. All the functionality for sesquilinear forms will be listed in detail in the next chapter.</p>

<p>We try to construct a bilinear form...</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[1,0,0],[0,1,4],[1,2,1]]*Z(5)^0;</span>
[ [ Z(5)^0, 0*Z(5), 0*Z(5) ], [ 0*Z(5), Z(5)^0, Z(5)^2 ], 
  [ Z(5)^0, Z(5), Z(5)^0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := BilinearFormByMatrix(mat,GF(5));</span>
Error, Invalid Gram matrix
 called from
BilinearFormByMatrixOp( MutableCopyMat( m ), f 
 ) at ./pkg/forms/lib/forms.gi:164 called from
&lt;function "unknown"&gt;( &lt;arguments&gt; )
 called from read-eval loop at line 8 of *stdin*
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
<span class="GAPbrkprompt">brk&gt;</span> <span class="GAPinput">quit; </span>
</pre></div>

<p>It is clear that the matrix used is not defining a reflexive bilinear form, which causes the system to generate the error message.</p>

<p>We construct now a reflexive bilinear form. We investigate also the radical of the form.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,-1]]*Z(9)^0;</span>
[ [ Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3) ], [ 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3) ], 
  [ 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3) ], [ 0*Z(3), 0*Z(3), 0*Z(3), Z(3) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := BilinearFormByMatrix(mat,GF(9));</span>
&lt; bilinear form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(form);</span>
Bilinear form
Gram Matrix:
 1 . . .
 . 1 . .
 . . 1 .
 . . . 2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsReflexiveForm(form);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSymmetricForm(form);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAlternatingForm(form);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r := RadicalOfForm(form);</span>
&lt;vector space over GF(3^2), with 0 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dimension(r);</span>
0 
</pre></div>

<p>Degenerate forms are allowed. As an example we construct an alternating bilinear form on an odd dimensional vector space.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0,0,-2],[0,0,1],[2,-1,0]]*Z(7)^0;</span>
[ [ 0*Z(7), 0*Z(7), Z(7)^5 ], [ 0*Z(7), 0*Z(7), Z(7)^0 ], 
  [ Z(7)^2, Z(7)^3, 0*Z(7) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := BilinearFormByMatrix(mat,GF(7));</span>
&lt; bilinear form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(form);</span>
Bilinear form
Gram Matrix:
 . . 5
 . . 1
 2 6 .
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSymmetricForm(form);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAlternatingForm(form);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r := RadicalOfForm(form);</span>
&lt;vector space over GF(7), with 1 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dimension(r);</span>
1 
</pre></div>

<p>When the characteristic of the field equals two, alternating forms are also symmetric. We construct an example.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0,1,0,0,0,0],[1,0,0,0,0,0],[0,0,0,0,0,1],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [0,0,0,0,1,0],[0,0,0,1,0,0],[0,0,1,0,0,0]]*Z(16)^0;</span>
[ [ 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2) ], 
  [ Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2) ], 
  [ 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0 ], 
  [ 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ], 
  [ 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2) ], 
  [ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := BilinearFormByMatrix(mat,GF(16));</span>
&lt; bilinear form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(form);</span>
Bilinear form
Gram Matrix:
 . 1 . . . .
 1 . . . . .
 . . . . . 1
 . . . . 1 .
 . . . 1 . .
 . . 1 . . .
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSymmetricForm(form);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAlternatingForm(form);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDegenerateForm(form);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">WittIndex(form);</span>
3 
</pre></div>

<p>To define a hermitian form, we need a matrix and the companion automorphism. Since this automorphism has order 2, it exists and is unique if the ground field has square order. In the next example, the chosen matrix is somewhat special. Together with the companion automorphism, it determines a hermitian sesquilinear form. Without the companion automorphism, it determines an alternating bilinear form.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0*Z(5),0*Z(5),0*Z(25),Z(25)^3],[0*Z(5),0*Z(5),Z(25)^3,0*Z(25)],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [0*Z(5),-Z(25)^3,0*Z(5),0*Z(5)],[-Z(25)^3,0*Z(5),0*Z(25),0*Z(25)]];</span>
[ [ 0*Z(5), 0*Z(5), 0*Z(5), Z(5^2)^3 ], [ 0*Z(5), 0*Z(5), Z(5^2)^3, 0*Z(5) ], 
  [ 0*Z(5), Z(5^2)^15, 0*Z(5), 0*Z(5) ], 
  [ Z(5^2)^15, 0*Z(5), 0*Z(5), 0*Z(5) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := HermitianFormByMatrix(mat,GF(25));</span>
&lt; hermitian form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(form);</span>
Hermitian form
Gram Matrix:
z = Z(25)
    .    .    .  z^3
    .    .  z^3    .
    . z^15    .    .
 z^15    .    .    .
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">WittIndex(form);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form2 := BilinearFormByMatrix(mat,GF(25));</span>
&lt; bilinear form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(form2);</span>
Bilinear form
Gram Matrix:
z = Z(25)
    .    .    .  z^3
    .    .  z^3    .
    . z^15    .    .
 z^15    .    .    .
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAlternatingForm(form2);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(IsometricCanonicalForm(form));</span>
Hermitian form
Gram Matrix:
 1 . . .
 . 1 . .
 . . 1 .
 . . . 1
Witt Index: 2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(IsometricCanonicalForm(form2));</span>
Bilinear form
Gram Matrix:
 . 1 . .
 4 . . .
 . . . 1
 . . 4 .
Witt Index: 2
</pre></div>

<p>We continue the previous example by exploring a little bit the sesquilinear form <var class="Arg">form</var>, and hence demonstrate some of the functionality of the <strong class="pkg">Forms</strong> package. Eventually, we find a 2-dimensional totally isotropic subspace, which lets us conclude that the Witt index of <span class="SimpleMath">form</span> is at least 2, which is confirmed afterwards by calling the appropriate function.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V := GF(25)^4;</span>
( GF(5^2)^4 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := [Z(5)^0,Z(5^2)^11,Z(5)^3,Z(5^2)^13 ];</span>
[ Z(5)^0, Z(5^2)^11, Z(5)^3, Z(5^2)^13 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[u,u]^form;</span>
0*Z(5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v := [Z(5)^0,Z(5^2)^5,Z(5^2),Z(5^2)^13 ];</span>
[ Z(5)^0, Z(5^2)^5, Z(5^2), Z(5^2)^13 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[v,v]^form;                                     </span>
0*Z(5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[u,v]^form;</span>
Z(5^2)^7
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">([v,u]^form)^5;</span>
Z(5^2)^7
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w := [Z(5^2)^21,Z(5^2)^19,Z(5^2)^4,Z(5)^3 ];</span>
[ Z(5^2)^21, Z(5^2)^19, Z(5^2)^4, Z(5)^3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[w,w]^form;</span>
Z(5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v := [Z(5)^0,Z(5^2)^10,Z(5^2)^15,Z(5^2)^3 ];</span>
[ Z(5)^0, Z(5^2)^10, Z(5^2)^15, Z(5^2)^3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := [Z(5)^3,Z(5^2)^9,Z(5^2)^4,Z(5^2)^16 ];</span>
[ Z(5)^3, Z(5^2)^9, Z(5^2)^4, Z(5^2)^16 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w := [Z(5)^2,Z(5^2)^9,Z(5^2)^23,Z(5^2)^11 ];</span>
[ Z(5)^2, Z(5^2)^9, Z(5^2)^23, Z(5^2)^11 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[u,v]^form;</span>
0*Z(5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[u,w]^form;</span>
0*Z(5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[v,w]^form;</span>
0*Z(5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s := Subspace(V,[v,u,w]);</span>
&lt;vector space over GF(5^2), with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dimension(s);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">WittIndex(form);</span>
2
</pre></div>

<p><a id="X864CAF8881067D8A" name="X864CAF8881067D8A"></a></p>

<h4>3.2 <span class="Heading">Quadratic forms</span></h4>

<p>A <em>quadratic form</em> on an <span class="SimpleMath">n</span>-dimensional vector space <span class="SimpleMath">V</span> over a field <span class="SimpleMath">F</span>, is a map <span class="SimpleMath">Q</span> from <span class="SimpleMath">V</span> to <span class="SimpleMath">F</span> satisfying the following two conditions:</p>

<p class="pcenter">Q(λ v) = λ<sup>2</sup> Q(v), for all λ in F, for all v in V,</p>

<p>and, the map <span class="SimpleMath">f</span> defined from <span class="SimpleMath">V× V</span> to <span class="SimpleMath">F</span> as follows,</p>

<p class="pcenter">f(v,w) := Q(v+w) - Q(v) - Q(w),</p>

<p>is a bilinear form on <span class="SimpleMath">V</span>. From this definition it follows that <span class="SimpleMath">f(v,v) = Q(2v) - 2Q(v) = 2Q(v)</span>.</p>

<p>The associated bilinear form <span class="SimpleMath">f</span> (which is called the <em>polar form</em> of <span class="SimpleMath">Q</span> in <a href="chapBib.html#biBAtlas">[CCN+85]</a>) is clearly reflexive. When the characteristic of the field is odd, it is clear that <span class="SimpleMath">f</span> is a symmetric bilinear form. The equation <span class="SimpleMath">f(v,v) = 2Q(v)</span> allows us to reconstruct the quadratic form from the bilinear form, and hence there is a one-to-one correspondence between quadratic forms and symmetric bilinear forms. When the characteristic of the field equals 2, the bilinear form <span class="SimpleMath">f</span> is alternating (from the fact that <span class="SimpleMath">f(v,v) = 2Q(v) = 0</span>). Note, however, that different quadratic forms can determine the same alternating form.</p>

<p>As in the case of sesquilinear forms, we will associate a matrix to a quadratic form. Chosing a basis of the vector space <span class="SimpleMath">V</span>, it is clear that an <span class="SimpleMath">n × n</span> matrix determines the quadratic form completely. In <strong class="pkg">Forms</strong>, the <em>Gram matrix</em> of a quadratic form is always an upper triangle matrix <span class="SimpleMath">M</span>, such that</p>

<p><center>Q(v)=vMv<sup>T</sup>,</center> where the basis of <span class="SimpleMath">V</span> is the standard basis. Although the Gram matrix stored with the quadratic form is always an upper triangle matrix, the user is allowed to use any matrix to define the quadratic form, since any matrix <span class="SimpleMath">M</span> defines a quadratic form Q(v):=vMv<sup>T</sup>. During the construction, an appopriate upper triangle matrix is computed and stored as the Gram matrix. So the Gram matrix of the associated bilinear form is M+M<sup>T</sup>.</p>

<p>The associated bilinear form could be used to define the notions ``isotropic'', ``totally isotropic'' and ``non-degenerate'', however, under these restrictions the geometry of quadratic forms in even characteristic is lost. In most of the literature, these notions refer indeed to the associated bilinear form, and the notion of ``singularity'' is added to regain the geometrical structure.</p>

<p>In <strong class="pkg">Forms</strong>, we use the above described approach. This means that a vector is isotropic if and only if it is isotropic with respect to the associated bilinear form. A subspace is totally isotropic if and only if it is totally isotropic with respect to the associated bilinear form, and we call the quadratic form degenerate if and only if the associated bilinear form is degenerate.</p>

<p>A vector <span class="SimpleMath">v</span> is called <em>singular</em> with relation to the quadratic form <span class="SimpleMath">Q</span> if and only if <span class="SimpleMath">Q(v)=0</span>. two vectors <span class="SimpleMath">v</span> and <span class="SimpleMath">w</span> are <em>orthogonal</em> with respect to <span class="SimpleMath">Q</span> if and only if they are orthogonal with respect to the associated bilinear form <span class="SimpleMath">f</span>. The <em>radical</em> of the quadratic form <span class="SimpleMath">Q</span>, is the intersection of the set of all singular vectors with relation to <span class="SimpleMath">Q</span> and the radical of the associated bilinear form <span class="SimpleMath">f</span>, i.e.</p>

<p><center>Rad(Q) = {v ∈ V | Q(v) = 0 and v ∈ Rad(f)}.</center> We call a quadratic form <span class="SimpleMath">Q</span> <em>non-singular</em> if and only if the radical contains only the zero vector, and <em>singular</em> otherwise.</p>

<p>A subspace <span class="SimpleMath">W</span> of the vector space is called <em>totally singular</em> if and only if all vectors of <span class="SimpleMath">W</span> are singular, i.e., <span class="SimpleMath">Q</span> vanishes totally on <span class="SimpleMath">W</span>. Necessarily, a totally singular subspace is also totally isotropic with relation to the associated bilinear form <span class="SimpleMath">f</span>, but the converse is only true when the characteristic of the field is odd.</p>

<p>Suppose now that <span class="SimpleMath">Q</span> is a non-singular quadratic form. The <em>Witt index</em> of <span class="SimpleMath">Q</span> is the maximum dimension of a totally singular subspace with respect to <span class="SimpleMath">Q</span>.</p>

<p>Let <span class="SimpleMath">Q</span> be a quadratic form on <span class="SimpleMath">V(n,q)</span>, with radical <span class="SimpleMath">R</span>, a <span class="SimpleMath">k</span>-dimensional subspace of <span class="SimpleMath">V(n,q)</span>, <span class="SimpleMath">0 ≤ k ≤ n</span>. Then <span class="SimpleMath">Q</span> induces a non-singular form <span class="SimpleMath">Q'</span> on <span class="SimpleMath">V/R</span>. When <span class="SimpleMath">dim(R)=0</span>, then <span class="SimpleMath">Q=Q'</span> and <span class="SimpleMath">Q</span> is non-singular. Notice that all totally singular subspaces of maximal dimension of a singular form <span class="SimpleMath">Q</span> contain the radical of <span class="SimpleMath">Q</span>. In <strong class="pkg">Forms</strong>, the notion Witt index will <strong class="button">always refer to the induced non-singular form</strong> <span class="SimpleMath">Q'</span>. Hence, given a singular form <span class="SimpleMath">Q</span>, computing its Witt index will return the Witt index of the induced form <span class="SimpleMath">Q'</span>. <strong class="button">This also holds for the notions elliptic, parabolic and hyperbolic for a quadratic form, which are notions defined using the Witt index, see below</strong>.</p>

<p>The terminology<em>hyperbolic</em>, <em>elliptic</em> and <em>parabolic</em> is also used for quadratic forms, and is defined analogously as for the bilinear forms using the Witt index. Also in the case of quadratic forms, this terminology is related to the theory of polar spaces. Recall that, as explained above, the Witt index refers to the Witt index of the <strong class="button">induced non-singular form</strong> <span class="SimpleMath">Q</span> when <span class="SimpleMath">Q'</span> is singular.</p>

<div class="pcenter"><table class="GAPDocTable">
<caption class="GAPDocTable"><b>Table: </b>Posibilites for a quadratic form <span class="SimpleMath">Q</span> on a vector space <span class="SimpleMath">V</span></caption>
<tr>
<td class="tdleft">Hyperbolic</td>
<td class="tdleft">Orthogonal of + type</td>
<td class="tdleft">V/Rad(Q) has even dimension, <span class="SimpleMath">Q'</span> has maximal Witt index</td>
</tr>
<tr>
<td class="tdleft">Elliptic</td>
<td class="tdleft">Orthogonal of - type</td>
<td class="tdleft">V/Rad(Q) has even dimension, <span class="SimpleMath">Q'</span> has non-maximal Witt index</td>
</tr>
<tr>
<td class="tdleft">Parabolic</td>
<td class="tdleft">Orthogonal of o type</td>
<td class="tdleft">V/Rad(Q) has odd dimension</td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p>From the above definitions, it follows that, when the characteristic of the field differs from 2, a quadratic form <span class="SimpleMath">Q</span> is non-singular if and only if its associated bilinear form <span class="SimpleMath">f</span> is non-degenerate. When the characteristic of the field is 2, one can easily construct non-singular quadratic forms, with a degenerate associated bilinear form. We will give an example of this situation in the next section.</p>

<p><a id="X7A489A5D79DA9E5C" name="X7A489A5D79DA9E5C"></a></p>

<h5>3.2-1 <span class="Heading">Examples</span></h5>

<p>We construct some quadratic forms to demonstrate some funcionality of <strong class="pkg">Forms</strong>. As in the previous example section, they are intended to allow the user to gain some familiarity. All the functionality for quadratic forms will be listed in detail in the next chapter.</p>

<p>The user can construct quadratic forms using any matrix (provided it has the right dimension). The Gram matrix is always stored as an upper triangle matrix, as explained above.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V := GF(4)^3;                           </span>
( GF(2^2)^3 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[Z(2^2)^2,Z(2^2),Z(2^2)^2],[Z(2^2)^2,Z(2)^0,Z(2)^0],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [0*Z(2),Z(2)^0,0*Z(2)]];</span>
[ [ Z(2^2)^2, Z(2^2), Z(2^2)^2 ], [ Z(2^2)^2, Z(2)^0, Z(2)^0 ], 
  [ 0*Z(2), Z(2)^0, 0*Z(2) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">qform := QuadraticFormByMatrix(mat, GF(4));</span>
&lt; quadratic form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( qform );</span>
Quadratic form
Gram Matrix:
z = Z(4)
 z^2   1 z^2
   .   1   .
   .   .   .
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolynomialOfForm( qform );</span>
Z(2^2)^2*x_1^2+x_1*x_2+Z(2^2)^2*x_1*x_3+x_2^2 
</pre></div>

<p>In the previous example, we saw how we used a polynomial to display a quadratic form. Conversely, <strong class="pkg">Forms</strong> allows the user to construct (quadratic) forms using a polynomial.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r := PolynomialRing(GF(8),4);</span>
GF(2^3)[x_1,x_2,x_3,x_4]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poly := r.1*r.2+r.3*r.4;</span>
x_1*x_2+x_3*x_4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">qform := QuadraticFormByPolynomial(poly, r);</span>
&lt; quadratic form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(qform);</span>
Quadratic form
Gram Matrix:
 . 1 . .
 . . . .
 . . . 1
 . . . .
Polynomial: x_1*x_2+x_3*x_4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RadicalOfForm(qform);</span>
&lt;vector space over GF(2^3), with 0 generators&gt; 
</pre></div>

<p>We construct now two different quadratic forms with the same associated bilinear form.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[Z(16)^3,1,0,0],[0,Z(16)^5,0,0],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             [0,0,Z(16)^3,1],[0,0,0,Z(16)^12]]*Z(16)^0;</span>
[ [ Z(2^4)^3, Z(2)^0, 0*Z(2), 0*Z(2) ], [ 0*Z(2), Z(2^2), 0*Z(2), 0*Z(2) ], 
  [ 0*Z(2), 0*Z(2), Z(2^4)^3, Z(2)^0 ], [ 0*Z(2), 0*Z(2), 0*Z(2), Z(2^4)^12 ] 
 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">qform := QuadraticFormByMatrix(mat,GF(16));</span>
&lt; quadratic form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( qform );</span>
Quadratic form
Gram Matrix:
z = Z(16)
  z^3    1    .    .
    .  z^5    .    .
    .    .  z^3    1
    .    .    . z^12
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat2 := [[Z(16)^7,1,0,0],[0,0,0,0],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             [0,0,Z(16)^2,1],[0,0,0,Z(16)^9]]*Z(16)^0;</span>
[ [ Z(2^4)^7, Z(2)^0, 0*Z(2), 0*Z(2) ], [ 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2) ], 
  [ 0*Z(2), 0*Z(2), Z(2^4)^2, Z(2)^0 ], [ 0*Z(2), 0*Z(2), 0*Z(2), Z(2^4)^9 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">qform2 := QuadraticFormByMatrix(mat2, GF(16));</span>
&lt; quadratic form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( qform2 );</span>
Quadratic form
Gram Matrix:
z = Z(16)
  z^7    1    .    .
    .    .    .    .
    .    .  z^2    1
    .    .    .  z^9
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">biform := AssociatedBilinearForm( qform2 );</span>
&lt; bilinear form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( biform );</span>
Bilinear form
Gram Matrix:
 . 1 . .
 1 . . .
 . . . 1
 . . 1 . 
</pre></div>

<p>We end with an example of a non-singular quadratic form with a degenerate associated bilinear form.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [ [ Z(2^2), Z(2^2), Z(2^2), Z(2^2), Z(2^2) ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [ 0*Z(2), Z(2^2), Z(2^2)^2, 0*Z(2), Z(2)^0 ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [ 0*Z(2), 0*Z(2), Z(2)^0, Z(2)^0, Z(2)^0 ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [ 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0, Z(2)^0 ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [ 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0 ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">qform := QuadraticFormByMatrix(mat,GF(4));</span>
&lt; quadratic form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSingularForm(qform);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDegenerateForm(qform);</span>
#I  Testing degeneracy of the *associated bilinear form*
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">biform := AssociatedBilinearForm(qform);</span>
&lt; bilinear form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(biform);</span>
Bilinear form
Gram Matrix:
z = Z(4)
   . z^1 z^1 z^1 z^1
 z^1   . z^2   .   1
 z^1 z^2   .   1   1
 z^1   .   1   .   1
 z^1   1   1   1   .
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDegenerateForm(biform);</span>
true 
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
