<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (XMod) - Chapter 2: 2d-groups : crossed modules and cat\(^1\)-groups</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap2"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap2.html">[MathJax off]</a></p>
<p><a id="X7EB8288E8424F39F" name="X7EB8288E8424F39F"></a></p>
<div class="ChapSects"><a href="chap2_mj.html#X7EB8288E8424F39F">2 <span class="Heading">2d-groups : crossed modules and cat<span class="SimpleMath">\(^1\)</span>-groups</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X7BAD9A7F7AFEEC89">2.1 <span class="Heading">Constructions for crossed modules</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7C8175AE7F76B586">2.1-1 XMod</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X83050ED686776933">2.1-2 XModByNormalSubgroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X867B2D53832EF05E">2.1-3 XModByTrivialAction</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X78B14FDA817CCEEF">2.1-4 XModByAutomorphismGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7D0F6FAA7AF69844">2.1-5 XModByCentralExtension</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X84FA2B0A795B6997">2.1-6 XModByPullback</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X824631577864961E">2.1-7 XModByAbelianModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7D9EF8C3856AA95A">2.1-8 DirectProductOp</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X790248A67CB9C33A">2.1-9 Source</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7AF6602C87845F1D">2.1-10 ImageElmXModAction</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7DCC43E47B1764F2">2.1-11 Size</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X7CF622538749FE73">2.2 <span class="Heading">Properties of crossed modules</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7E77E6B881B1CE50">2.2-1 IsXMod</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7884284383284A87">2.2-2 SubXMod</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7D8165F77B23BCF6">2.2-3 KernelCokernelXMod</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X7D435B6279032D4D">2.3 <span class="Heading">Pre-crossed modules</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X8487BE427858C5C9">2.3-1 PreXModByBoundaryAndAction</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X8527F4C07A8F359E">2.3-2 PeifferSubgroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X7AAABC1D7E110988">2.4 <span class="Heading">Cat<span class="SimpleMath">\(^1\)</span>-groups and pre-cat<span class="SimpleMath">\(^1\)</span>-groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7CF4C37F87D27EBA">2.4-1 Cat1Group</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7C4FFC4086531157">2.4-2 Source</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X79944C7B87F767FD">2.4-3 DiagonalCat1Group</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7D30A5207FEB4D42">2.4-4 ReverseCat1Group</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X87544FAD873672E1">2.4-5 Cat1GroupByPeifferQuotient</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X8317816A8361F88C">2.5 <span class="Heading">
Properties of cat<span class="SimpleMath">\(^1\)</span>-groups and pre-cat<span class="SimpleMath">\(^1\)</span>-groups 
</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X78E03FAB84A57D03">2.5-1 IsCat1Group</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X82F10A59867C765D">2.5-2 Cat1GroupOfXMod</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X80D6CB4080417BFA">2.6 <span class="Heading">Enumerating cat<span class="SimpleMath">\(^1\)</span>-groups with a given source</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7A1B967D7B6273F4">2.6-1 AllCat1GroupsWithImageIterator</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7FEB2FCE7D9ADA85">2.6-2 AllCat1GroupsIterator</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7AC53BAA78A7DCCB">2.6-3 CatnGroupNumbers</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X7A6A70BD86DE458D">2.7 <span class="Heading">Selection of a small cat<span class="SimpleMath">\(^1\)</span>-group</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7B8E67D880E380C8">2.7-1 Cat1Select</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X8768CDA180561393">2.7-2 AllCat1DataGroupsBasic</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X8614CDCF8063117F">2.8 <span class="Heading">More functions for crossed modules and cat<span class="SimpleMath">\(^1\)</span>-groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7831DB527CF9DD57">2.8-1 IdGroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X7CFAB044817E5E91">2.9 <span class="Heading">The group groupoid associated to a cat<span class="SimpleMath">\(^1\)</span>-group</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7AF5AF668331321E">2.9-1 GroupGroupoid</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X8578AB6D7C1FC4F3">2.9-2 GroupGroupoidElement</a></span>
</div></div>
</div>

<h3>2 <span class="Heading">2d-groups : crossed modules and cat<span class="SimpleMath">\(^1\)</span>-groups</span></h3>

<p>The term <em>2d-group</em> refers to a set of equivalent categories of which the most common are the categories of <em>crossed modules</em>; <em>cat<span class="SimpleMath">\(^1\)</span>-groups</em>; and <em>group-groupoids</em>, all of which involve a pair of groups.</p>

<p><a id="X7BAD9A7F7AFEEC89" name="X7BAD9A7F7AFEEC89"></a></p>

<h4>2.1 <span class="Heading">Constructions for crossed modules</span></h4>

<p>A crossed module (of groups) <span class="SimpleMath">\(\calX = (\partial : S \to R )\)</span> consists of a group homomorphism <span class="SimpleMath">\(\partial \)</span>, called the <em>boundary</em> of <span class="SimpleMath">\(\calX\)</span>, with <em>source</em> <span class="SimpleMath">\(S\)</span> and <em>range</em> <span class="SimpleMath">\(R\)</span>. The group <span class="SimpleMath">\(R\)</span> acts on itself by conjugation, and on <span class="SimpleMath">\(S\)</span> by an <em>action</em> <span class="SimpleMath">\(\alpha : R \to {\rm Aut}(S)\)</span> such that, for all <span class="SimpleMath">\(s,s_1,s_2 \in S\)</span> and <span class="SimpleMath">\(r \in R\)</span>,</p>

<p class="center">\[
{\bf XMod\ 1}  :   \partial(s^r) 
   = r^{-1} (\partial s) r
   = (\partial s)^r,
\qquad
{\bf XMod\ 2}  :   s_1^{\partial s_2} 
   = s_2^{-1}s_1 s_2
   = {s_1}^{s_2}.
\]</p>

<p>When only the first of these axioms is satisfied, the resulting structure is a <em>pre-crossed module</em> (see section <a href="chap2_mj.html#X7D435B6279032D4D"><span class="RefLink">2.3</span></a>). The kernel of <span class="SimpleMath">\(\partial\)</span> is abelian.</p>

<p>(Much of the literature on crossed modules uses left actions, but we have chosen to use right actions in this package since that is the standard choice for group actions in <strong class="pkg">GAP</strong>.)</p>

<p><a id="X7C8175AE7F76B586" name="X7C8175AE7F76B586"></a></p>

<h5>2.1-1 XMod</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; XMod</code>( <var class="Arg">args</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; XModByBoundaryAndAction</code>( <var class="Arg">bdy</var>, <var class="Arg">act</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The global function <code class="code">XMod</code> calls one of the standard constructions described in the following subsections. In the example the boundary is the identity mapping on <code class="code">c5</code> and the action is trivial.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c5 := Group( (5,6,7,8,9) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( c5, "c5" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id5 := IdentityMapping( c5 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ac5 := AutomorphismGroup( c5 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">act := MappingToOne( c5, ac5 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">XMod( id5, act ) = XModByBoundaryAndAction( id5, act );</span>
true

</pre></div>

<p><a id="X83050ED686776933" name="X83050ED686776933"></a></p>

<h5>2.1-2 XModByNormalSubgroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; XModByNormalSubgroup</code>( <var class="Arg">G</var>, <var class="Arg">N</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>A <em>conjugation crossed module</em> is the inclusion of a normal subgroup <span class="SimpleMath">\(S \unlhd R\)</span>, where <span class="SimpleMath">\(R\)</span> acts on <span class="SimpleMath">\(S\)</span> by conjugation.</p>

<p><a id="X867B2D53832EF05E" name="X867B2D53832EF05E"></a></p>

<h5>2.1-3 XModByTrivialAction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; XModByTrivialAction</code>( <var class="Arg">bdy</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>A <em>trivial action crossed module</em> <span class="SimpleMath">\((\partial : S \to R)\)</span> has <span class="SimpleMath">\(s^r = s\)</span> for all <span class="SimpleMath">\(s \in S, \; r \in R\)</span>, the source is abelian and the image lies in the centre of the range.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q8 := QuaternionGroup( IsPermGroup, 8 );</span>
Group([ (1,5,3,7)(2,8,4,6), (1,2,3,4)(5,6,7,8) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( q8, "q8" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c2 := Centre( q8 );                     </span>
Group([ (1,3)(2,4)(5,7)(6,8) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( c2, "&lt;-1&gt;" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bdy := InclusionMappingGroups( q8, c2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">X8a := XModByTrivialAction( bdy );</span>
[&lt;-1&gt;-&gt;q8]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c4 := Subgroup( q8, [q8.1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( c4, "&lt;i&gt;" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">X8b := XModByNormalSubgroup( q8, c4 );</span>
[&lt;i&gt;-&gt;q8]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(X8b);        </span>
Crossed module [&lt;i&gt;-&gt;q8] :- 
: Source group has generators:
  [ (1,5,3,7)(2,8,4,6) ]
: Range group q8 has generators:
  [ (1,5,3,7)(2,8,4,6), (1,2,3,4)(5,6,7,8) ]
: Boundary homomorphism maps source generators to:
  [ (1,5,3,7)(2,8,4,6) ]
: Action homomorphism maps range generators to automorphisms:
  (1,5,3,7)(2,8,4,6) --&gt; { source gens --&gt; [ (1,5,3,7)(2,8,4,6) ] }
  (1,2,3,4)(5,6,7,8) --&gt; { source gens --&gt; [ (1,7,3,5)(2,6,4,8) ] }
  These 2 automorphisms generate the group of automorphisms.

</pre></div>

<p><a id="X78B14FDA817CCEEF" name="X78B14FDA817CCEEF"></a></p>

<h5>2.1-4 XModByAutomorphismGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; XModByAutomorphismGroup</code>( <var class="Arg">grp</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; XModByInnerAutomorphismGroup</code>( <var class="Arg">grp</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; XModByGroupOfAutomorphisms</code>( <var class="Arg">G</var>, <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>An <em>automorphism crossed module</em> has as range a subgroup <span class="SimpleMath">\(R\)</span> of the automorphism group Aut<span class="SimpleMath">\((S)\)</span> of <span class="SimpleMath">\(S\)</span> which contains the inner automorphism group of <span class="SimpleMath">\(S\)</span>. The boundary maps <span class="SimpleMath">\(s \in S\)</span> to the inner automorphism of <span class="SimpleMath">\(S\)</span> by <span class="SimpleMath">\(s\)</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">X5 := XModByAutomorphismGroup( c5 );</span>
[c5 -&gt; Aut(c5)] 
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( X5 );</span>
Crossed module [c5-&gt;Aut(c5)] :- 
: Source group c5 has generators:
  [ (5,6,7,8,9) ]
: Range group Aut(c5) has generators:
  [ GroupHomomorphismByImages( c5, c5, [ (5,6,7,8,9) ], [ (5,7,9,6,8) ] ) ]
: Boundary homomorphism maps source generators to:
  [ IdentityMapping( c5 ) ]
: Action homomorphism maps range generators to automorphisms:
  GroupHomomorphismByImages( c5, c5, [ (5,6,7,8,9) ], 
[ (5,7,9,6,8) ] ) --&gt; { source gens --&gt; [ (5,7,9,6,8) ] }
  This automorphism generates the group of automorphisms.

</pre></div>

<p><a id="X7D0F6FAA7AF69844" name="X7D0F6FAA7AF69844"></a></p>

<h5>2.1-5 XModByCentralExtension</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; XModByCentralExtension</code>( <var class="Arg">bdy</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>A <em>central extension crossed module</em> has as boundary a surjection <span class="SimpleMath">\(\partial : S \to R\)</span>, with central kernel, where <span class="SimpleMath">\(r \in R\)</span> acts on <span class="SimpleMath">\(S\)</span> by conjugation with <span class="SimpleMath">\(\partial^{-1}r\)</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gen12 := [ (1,2,3,4,5,6), (2,6)(3,5) ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d12 := Group( gen12 );;                  </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gen6 := [ (7,8,9), (8,9) ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s3 := Group( gen6 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pr12 := GroupHomomorphismByImages( d12, s3, gen12, gen6 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Kernel( pr12 ) = Centre( d12 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">X12 := XModByCentralExtension( pr12 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( X12 );                         </span>
Crossed module :- 
: Source group has generators:
  [ (1,2,3,4,5,6), (2,6)(3,5) ]
: Range group has generators:
  [ (7,8,9), (8,9) ]
: Boundary homomorphism maps source generators to:
  [ (7,8,9), (8,9) ]
: Action homomorphism maps range generators to automorphisms:
  (7,8,9) --&gt; { source gens --&gt; [ (1,2,3,4,5,6), (1,3)(4,6) ] }
  (8,9) --&gt; { source gens --&gt; [ (1,6,5,4,3,2), (2,6)(3,5) ] }
  These 2 automorphisms generate the group of automorphisms.

</pre></div>

<p><a id="X84FA2B0A795B6997" name="X84FA2B0A795B6997"></a></p>

<h5>2.1-6 XModByPullback</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; XModByPullback</code>( <var class="Arg">xmod</var>, <var class="Arg">hom</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Let <span class="SimpleMath">\(\calX_0 = (\mu : M \to P)\)</span> be a crossed module. If <span class="SimpleMath">\(\nu : N \to P\)</span> is a group homomorphism with the same range as <span class="SimpleMath">\(\calX_0\)</span>, form the pullback group <span class="SimpleMath">\(L = M \times_P N\)</span>, with projection <span class="SimpleMath">\(\lambda : L \to N\)</span> (as defined in the <strong class="pkg">Utils</strong> package). Then <span class="SimpleMath">\(N\)</span> acts on <span class="SimpleMath">\(L\)</span> by <span class="SimpleMath">\((m,n)^{n'} := (m^{\nu n'},n^{n'})\)</span>, so that <span class="SimpleMath">\(\calX_1 = (\lambda : L \to N)\)</span> is the <em> pullback crossed module</em> determined by <span class="SimpleMath">\(\calX_0\)</span> and <span class="SimpleMath">\(\nu\)</span>. There is also a morphism of crossed modules <span class="SimpleMath">\((\kappa,\nu) : \calX_1 \to \calX_2\)</span>.</p>

<p>The example forms a pullback of the crossed module <code class="code">X12</code> of the previous subsection.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens4 := [ (11,12), (12,13), (13,14) ];; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s4 := Group( gens4 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">theta := GroupHomomorphismByImages( s4, s3, gens4, [(7,8),(8,9),(7,8)] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">X1 := XModByPullback( X12, theta );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription( Source( X1 ) );</span>
"C2 x S4"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">info := PullbackInfo( Source( X1 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">info!.directProduct;</span>
Group([ (1,2,3,4,5,6), (2,6)(3,5), (7,8), (8,9), (9,10) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">info!.projections[1];</span>
[ (7,8)(9,10), (7,9)(8,10), (2,6)(3,5)(8,9), (1,5,3)(2,6,4)(8,10,9), 
  (1,6,5,4,3,2)(8,9,10) ] -&gt; [ (), (), (2,6)(3,5), (1,5,3)(2,6,4), 
  (1,6,5,4,3,2) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">info!.projections[2];</span>
[ (7,8)(9,10), (7,9)(8,10), (2,6)(3,5)(8,9), (1,5,3)(2,6,4)(8,10,9), 
  (1,6,5,4,3,2)(8,9,10) ] -&gt; [ (11,12)(13,14), (11,13)(12,14), (12,13), 
  (12,14,13), (12,13,14) ]

</pre></div>

<p><a id="X824631577864961E" name="X824631577864961E"></a></p>

<h5>2.1-7 XModByAbelianModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; XModByAbelianModule</code>( <var class="Arg">abmod</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>A <em>crossed abelian module</em> has an abelian module as source and the zero map as boundary. See section <a href="chap12_mj.html#X852BD9CA84C2AFF0"><span class="RefLink">12.2</span></a> for an example.</p>

<p><a id="X7D9EF8C3856AA95A" name="X7D9EF8C3856AA95A"></a></p>

<h5>2.1-8 DirectProductOp</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DirectProductOp</code>( <var class="Arg">L</var>, <var class="Arg">X1</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The direct product <span class="SimpleMath">\(\calX_{1} \times \calX_{2}\)</span> of two crossed modules has source <span class="SimpleMath">\(S_1 \times S_2\)</span>, range <span class="SimpleMath">\(R_1 \times R_2\)</span> and boundary <span class="SimpleMath">\(\partial_1 \times \partial_2\)</span>, with <span class="SimpleMath">\(R_1,\ R_2\)</span> acting trivially on <span class="SimpleMath">\(S_2,\ S_1\)</span> respectively.</p>

<p>Since <code class="code">DirectProduct</code> is a global function which only accepts groups, it is necessary to provide an "other method" for the operation <code class="code">DirectProductOp</code>. This operation takes as parameters a list of crossed modules, followed by the first of these: <code class="code">DirectProductOp([X1,X2],X1);</code>. At present only the direct product of two crossed modules is implemented.</p>

<p>The example constructs the product of the two crossed modules formed in subsection <code class="func">XModByTrivialAction</code> (<a href="chap2_mj.html#X867B2D53832EF05E"><span class="RefLink">2.1-3</span></a>).</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DirectProductOp( [X8a,X8b], X8a );</span>
[&lt;-1&gt;x&lt;i&gt;-&gt;q8xq8]

</pre></div>

<p><a id="X790248A67CB9C33A" name="X790248A67CB9C33A"></a></p>

<h5>2.1-9 Source</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Source</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Range</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Boundary</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; XModAction</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The following attributes are used in the construction of a crossed module <code class="code">X0</code>.</p>


<ul>
<li><p><code class="code">Source(X0)</code> and <code class="code">Range(X0)</code> are the source <span class="SimpleMath">\(S\)</span> and range <span class="SimpleMath">\(R\)</span> of <span class="SimpleMath">\(\partial\)</span>, the boundary <code class="code">Boundary(X0)</code>;</p>

</li>
<li><p><code class="code">XModAction(X0)</code> is a homomorphism from <span class="SimpleMath">\(R\)</span> to a group of automorphisms of <code class="code">X0</code>.</p>

</li>
</ul>
<p>(Up until version 2.63 there was an additional attribute <code class="code">AutoGroup</code>, the range of <code class="code">XModAction(X0)</code>.)</p>

<p>The example uses the crossed module <code class="code">X12</code> constructed in subsection <code class="func">XModByCentralExtension</code> (<a href="chap2_mj.html#X7D0F6FAA7AF69844"><span class="RefLink">2.1-5</span></a>).</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Source( X12 );   </span>
Group([ (1,2,3,4,5,6), (2,6)(3,5) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Range( X12 );    </span>
Group([ (7,8,9), (8,9) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Boundary( X12 ); </span>
[ (1,2,3,4,5,6), (2,6)(3,5) ] -&gt; [ (7,8,9), (8,9) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">XModAction( X12 );</span>
[ (7,8,9), (8,9) ] -&gt; 
[ [ (1,2,3,4,5,6), (2,6)(3,5) ] -&gt; [ (1,2,3,4,5,6), (1,3)(4,6) ], 
  [ (1,2,3,4,5,6), (2,6)(3,5) ] -&gt; [ (1,6,5,4,3,2), (2,6)(3,5) ] ]

</pre></div>

<p><a id="X7AF6602C87845F1D" name="X7AF6602C87845F1D"></a></p>

<h5>2.1-10 ImageElmXModAction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ImageElmXModAction</code>( <var class="Arg">X0</var>, <var class="Arg">s</var>, <var class="Arg">r</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>This function returns the element <span class="SimpleMath">\(s^r\)</span> given by <code class="code">XModAction(X0)</code>.</p>

<p><a id="X7DCC43E47B1764F2" name="X7DCC43E47B1764F2"></a></p>

<h5>2.1-11 Size</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Size</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Name</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IdGroup</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExternalSetXMod</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>More familiar attributes are <code class="code">Name</code>, <code class="code">Size</code> and <code class="code">IdGroup</code>. The name is formed by concatenating the names of the source and range (if these exist). <code class="code">Size</code> and <code class="code">IdGroup</code> return two-element lists.</p>

<p>The <code class="func">ExternalSetXMod</code> for a crossed module is the source group considered as a G-set of the range group using the crossed module action.</p>

<p>The <code class="code">Display</code> function is used to print details of 2d-groups.</p>

<p>In the simple example below, <code class="code">X5</code> is the automorphism crossed module constructed in subsection <code class="func">XModByAutomorphismGroup</code> (<a href="chap2_mj.html#X78B14FDA817CCEEF"><span class="RefLink">2.1-4</span></a>). The <code class="code">Print</code> statements at the end of the example list the <strong class="pkg">GAP</strong> representations and attributes of <code class="code">X5</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( X5 );  IdGroup( X5 ); </span>
[ 5, 4 ]
[ [ 5, 1 ], [ 4, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ext := ExternalSetXMod( X5 ); </span>
&lt;xset:[ (), (5,6,7,8,9), (5,7,9,6,8), (5,8,6,9,7), (5,9,8,7,6) ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Orbits( ext );</span>
[ [ () ], [ (5,6,7,8,9), (5,7,9,6,8), (5,9,8,7,6), (5,8,6,9,7) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := GeneratorsOfGroup( Range( X5 ) )[1]^2; </span>
[ (5,6,7,8,9) ] -&gt; [ (5,9,8,7,6) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ImageElmXModAction( X5, (5,7,9,6,8), a );</span>
(5,8,6,9,7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RepresentationsOfObject( X5 );</span>
[ "IsComponentObjectRep", "IsAttributeStoringRep", "IsPreXModObj" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KnownAttributesOfObject( X5);</span>
[ "Name", "Size", "Range", "Source", "IdGroup", "Boundary", "XModAction", 
  "ExternalSetXMod" ]

</pre></div>

<p><a id="X7CF622538749FE73" name="X7CF622538749FE73"></a></p>

<h4>2.2 <span class="Heading">Properties of crossed modules</span></h4>

<p>The underlying category structures for the objects constructed in this chapter follow the sequence <code class="code">Is2DimensionalDomain</code>; <code class="code">Is2DimensionalMagma</code>; <code class="code">Is2DimensionalMagmaWithOne</code>; <code class="code">Is2DimensionalMagmaWithInverses</code>, mirroring the situation for (one-dimensional) groups. From these we construct <code class="code">Is2DimensionalSemigroup</code>, <code class="code">Is2DimensionalMonoid</code> and <code class="code">Is2DimensionalGroup</code>.</p>

<p>There are then a variety of properties associated with crossed modules, starting with <code class="code">IsPreXMod</code> and <code class="code">IsXMod</code>.</p>

<p><a id="X7E77E6B881B1CE50" name="X7E77E6B881B1CE50"></a></p>

<h5>2.2-1 IsXMod</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsXMod</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPreXMod</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPerm2DimensionalGroup</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPc2DimensionalGroup</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFp2DimensionalGroup</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>A structure which has <code class="code">IsPerm2DimensionalGroup</code> is a precrossed module or a pre-cat<span class="SimpleMath">\(^1\)</span>-group (see section <a href="chap2_mj.html#X7AAABC1D7E110988"><span class="RefLink">2.4</span></a>) whose source and range are both permutation groups. The properties <code class="code">IsPc2DimensionalGroup</code>, <code class="code">IsFp2DimensionalGroup</code> are defined similarly. In the example below we see that <code class="code">X5</code> has <code class="code">IsPreXMod</code>, <code class="code">IsXMod</code> and <code class="code">IsPerm2DimensionalGroup</code>. There are also properties corresponding to the various construction methods listed in section <a href="chap2_mj.html#X7BAD9A7F7AFEEC89"><span class="RefLink">2.1</span></a>: <code class="code">IsTrivialAction2DimensionalGroup</code>; <code class="code">IsNormalSubgroup2DimensionalGroup</code>; <code class="code">IsCentralExtension2DimensionalGroup</code>; <code class="code">IsAutomorphismGroup2DimensionalGroup</code>; <code class="code">IsAbelianModule2DimensionalGroup</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KnownPropertiesOfObject( X5 );</span>
[ "IsEmpty", "IsTrivial", "IsNonTrivial", "IsFinite", 
  "CanEasilyCompareElements", "CanEasilySortElements", "IsDuplicateFree", 
  "IsGeneratorsOfSemigroup", "IsPreXModDomain", "IsPreXMod", "IsXMod", 
  "IsAutomorphismGroup2DimensionalGroup" ]

</pre></div>

<p><a id="X7884284383284A87" name="X7884284383284A87"></a></p>

<h5>2.2-2 SubXMod</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SubXMod</code>( <var class="Arg">X0</var>, <var class="Arg">src</var>, <var class="Arg">rng</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TrivialSubXMod</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NormalSubXMods</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>With the standard crossed module constructors listed above as building blocks, sub-crossed modules, normal sub-crossed modules <span class="SimpleMath">\(\calN \lhd \calX\)</span>, and also quotients <span class="SimpleMath">\(\calX/\calN\)</span> may be constructed. A sub-crossed module <span class="SimpleMath">\(\calS = (\delta : N \to M)\)</span> is <em>normal</em> in <span class="SimpleMath">\(\calX = (\partial : S \to R)\)</span> if</p>


<ul>
<li><p><span class="SimpleMath">\(N,M\)</span> are normal subgroups of <span class="SimpleMath">\(S,R\)</span> respectively,</p>

</li>
<li><p><span class="SimpleMath">\(\delta\)</span> is the restriction of <span class="SimpleMath">\(\partial\)</span>,</p>

</li>
<li><p><span class="SimpleMath">\(n^r \in N\)</span> for all <span class="SimpleMath">\(n \in N,~r \in R\)</span>,</p>

</li>
<li><p><span class="SimpleMath">\((s^{-1})^ms \in N\)</span> for all <span class="SimpleMath">\(m \in M,~s \in S\)</span>.</p>

</li>
</ul>
<p>These conditions ensure that <span class="SimpleMath">\(M \ltimes N\)</span> is normal in the semidirect product <span class="SimpleMath">\(R \ltimes S\)</span>. (Note that <span class="SimpleMath">\(\langle s,m \rangle = (s^{-1})^ms\)</span> is a displacement: see <code class="func">Displacement</code> (<a href="chap4_mj.html#X7E20208279038BB8"><span class="RefLink">4.1-3</span></a>).)</p>

<p>A method for <code class="code">IsNormal</code> for precrossed modules is provided. See section <a href="chap4_mj.html#X7E373BF3836B3A9C"><span class="RefLink">4.1</span></a> for factor crossed modules and their natural morphisms.</p>

<p>The five normal subcrossed modules of <code class="code">X4</code> found in the following example are <code class="code">[id,id], [k4,k4], [k4,a4], [a4,a4]</code> and <code class="code">X4</code> itself.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s4 := Group( (1,2), (2,3), (3,4) );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a4 := Subgroup( s4, [ (1,2,3), (2,3,4) ] );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k4 := Subgroup( a4, [ (1,2)(3,4), (1,3)(2,4) ] );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName(s4,"s4");  SetName(a4,"a4");  SetName(k4,"k4"); </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">X4 := XModByNormalSubgroup( s4, a4 );</span>
[a4-&gt;s4]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Y4 := SubXMod( X4, k4, a4 ); </span>
[k4-&gt;a4]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsNormal(X4,Y4);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NX4 := NormalSubXMods( X4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( NX4 ); </span>
5

</pre></div>

<p><a id="X7D8165F77B23BCF6" name="X7D8165F77B23BCF6"></a></p>

<h5>2.2-3 KernelCokernelXMod</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; KernelCokernelXMod</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Let <span class="SimpleMath">\(\calX = (\partial : S \to R)\)</span>. If <span class="SimpleMath">\(K \leqslant S\)</span> is the kernel of <span class="SimpleMath">\(\partial\)</span>, and <span class="SimpleMath">\(J \leqslant R\)</span> is the image of <span class="SimpleMath">\(\partial\)</span>, form <span class="SimpleMath">\(C = R/J\)</span>. Then <span class="SimpleMath">\((\nu\partial|_K : K \to C)\)</span> is a crossed module where <span class="SimpleMath">\(\nu : R \to C, r \mapsto Jr\)</span> is the natural map, and the action of <span class="SimpleMath">\(C\)</span> on <span class="SimpleMath">\(K\)</span> is given by <span class="SimpleMath">\(k^{Jr} = k^r\)</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d8d8 := Group( (1,2,3,4), (1,3), (5,6,7,8), (5,7) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">X88 := XModByAutomorphismGroup( d8d8 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( X88 );</span>
[ 64, 2048 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Y88 := KernelCokernelXMod( X88 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription( Y88 );</span>
[ "C2 x C2", "(D8 x D8) : C2" ] 

</pre></div>

<p><a id="X7D435B6279032D4D" name="X7D435B6279032D4D"></a></p>

<h4>2.3 <span class="Heading">Pre-crossed modules</span></h4>

<p><a id="X8487BE427858C5C9" name="X8487BE427858C5C9"></a></p>

<h5>2.3-1 PreXModByBoundaryAndAction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PreXModByBoundaryAndAction</code>( <var class="Arg">bdy</var>, <var class="Arg">act</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SubPreXMod</code>( <var class="Arg">X0</var>, <var class="Arg">src</var>, <var class="Arg">rng</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>If axiom <span class="SimpleMath">\({\bf XMod\ 2}\)</span> is <em>not</em> satisfied, the corresponding structure is known as a <em>pre-crossed module</em>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b1 := (11,12,13,14,15,16,17,18);;  b2 := (12,18)(13,17)(14,16);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d16 := Group( b1, b2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sk4 := Subgroup( d16, [ b1^4, b2 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( d16, "d16" );  SetName( sk4, "sk4" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bdy16 := GroupHomomorphismByImages( d16, sk4, [b1,b2], [b1^4,b2] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">aut1 := GroupHomomorphismByImages( d16, d16, [b1,b2], [b1^5,b2] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">aut2 := GroupHomomorphismByImages( d16, d16, [b1,b2], [b1,b2^4*b2] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">aut16 := Group( [ aut1, aut2 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">act16 := GroupHomomorphismByImages( sk4, aut16, [b1^4,b2], [aut1,aut2] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P16 := PreXModByBoundaryAndAction( bdy16, act16 );</span>
[d16-&gt;sk4]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsXMod(P16);</span>
false

</pre></div>

<p><a id="X8527F4C07A8F359E" name="X8527F4C07A8F359E"></a></p>

<h5>2.3-2 PeifferSubgroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PeifferSubgroup</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; XModByPeifferQuotient</code>( <var class="Arg">prexmod</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The <em>Peiffer subgroup</em> <span class="SimpleMath">\(P\)</span> of a pre-crossed module <span class="SimpleMath">\(\calX\)</span> is the subgroup of <span class="SimpleMath">\({\rm ker}(\partial)\)</span> generated by <em>Peiffer commutators</em></p>

<p class="center">\[
\lfloor s_1,s_2 \rfloor ~=~ 
(s_1^{-1})^{\partial s_2}~s_2^{-1}~s_1~s_2 ~=~ 
\langle \partial s_2, s_1 \rangle\ [s_1,s_2]~.
\]</p>

<p>Then <span class="SimpleMath">\(\calP = (0 : P \to \{1_R\})\)</span> is a normal sub-pre-crossed module of <span class="SimpleMath">\(\calX\)</span> and <span class="SimpleMath">\(\calX/\calP = (\partial : S/P \to R)\)</span> is a crossed module.</p>

<p>In the following example the Peiffer subgroup is cyclic of size <span class="SimpleMath">\(4\)</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P := PeifferSubgroup( P16 );</span>
Group( [ (11,15)(12,16)(13,17)(14,18), (11,17,15,13)(12,18,16,14) ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">X16 := XModByPeifferQuotient( P16 );</span>
Peiffer([d16-&gt;sk4])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( X16 );</span>
Crossed module Peiffer([d16-&gt;sk4]) :-
: Source group has generators:
  [ f1, f2 ]
: Range group has generators:
  [ (11,15)(12,16)(13,17)(14,18), (12,18)(13,17)(14,16) ]
: Boundary homomorphism maps source generators to:
  [ (12,18)(13,17)(14,16), (11,15)(12,16)(13,17)(14,18) ]
  The automorphism group is trivial
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso16 := IsomorphismPermGroup( Source( X16 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S16 := Image( iso16 );</span>
Group([ (1,2), (3,4) ])   

</pre></div>

<p><a id="X7AAABC1D7E110988" name="X7AAABC1D7E110988"></a></p>

<h4>2.4 <span class="Heading">Cat<span class="SimpleMath">\(^1\)</span>-groups and pre-cat<span class="SimpleMath">\(^1\)</span>-groups</span></h4>

<p>In <a href="chapBib_mj.html#biBL1">[Lod82]</a>, Loday reformulated the notion of a crossed module as a cat<span class="SimpleMath">\(^1\)</span>-group, namely a group <span class="SimpleMath">\(G\)</span> with a pair of endomorphisms <span class="SimpleMath">\(t,h : G \to G\)</span> having a common image <span class="SimpleMath">\(R\)</span> and satisfying certain axioms. We find it computationally convenient to define a cat<span class="SimpleMath">\(^1\)</span>-group <span class="SimpleMath">\(\calC = (e;t,h : G \to R )\)</span> as having source group <span class="SimpleMath">\(G\)</span>, range group <span class="SimpleMath">\(R\)</span>, and three homomorphisms: two surjections <span class="SimpleMath">\(t,h : G \to R\)</span> and an embedding <span class="SimpleMath">\(e : R \to G\)</span> satisfying:</p>

<p class="center">\[
{\bf Cat\ 1}  :  ~t \circ e ~=~ h \circ e = {\rm id}_R,
\qquad
{\bf Cat\ 2}  :  ~[\ker t, \ker h] ~=~ \{ 1_G \}.
\]</p>

<p>It follows that <span class="SimpleMath">\(\;t \circ e \circ h = h,~ h \circ e \circ t = t,~ t \circ e \circ t = t~\)</span> and <span class="SimpleMath">\(~h \circ e \circ h = h\)</span>. (See section <a href="chap2_mj.html#X8317816A8361F88C"><span class="RefLink">2.5</span></a> for the case when <span class="SimpleMath">\(t,h\)</span> are endomorphisms.)</p>

<p><a id="X7CF4C37F87D27EBA" name="X7CF4C37F87D27EBA"></a></p>

<h5>2.4-1 Cat1Group</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Cat1Group</code>( <var class="Arg">args</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PreCat1Group</code>( <var class="Arg">args</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PreCat1GroupByTailHeadEmbedding</code>( <var class="Arg">t</var>, <var class="Arg">h</var>, <var class="Arg">e</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PreCat1GroupByEndomorphisms</code>( <var class="Arg">t</var>, <var class="Arg">h</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The global functions <code class="code">Cat1Group</code> and <code class="code">PreCat1Group</code> can be called in various ways.</p>


<ul>
<li><p>as <code class="code">Cat1Group(t,h,e);</code> when <span class="SimpleMath">\(t,h,e\)</span> are three homomorphisms, which is equivalent to <code class="code">PreCat1GroupByTailHeadEmbedding(t,h,e);</code></p>

</li>
<li><p>as <code class="code">Cat1Group(t,h);</code> when <span class="SimpleMath">\(t,h\)</span> are two endomorphisms, which is equivalent to <code class="code">PreCat1GroupByEndomorphisms(t,h);</code></p>

</li>
<li><p>as <code class="code">Cat1Group(t);</code> when <span class="SimpleMath">\(t=h\)</span> is an endomorphism, which is equivalent to <code class="code">PreCat1GroupByEndomorphisms(t,t);</code></p>

</li>
<li><p>as <code class="code">Cat1Group(t,e);</code> when <span class="SimpleMath">\(t=h\)</span> and <span class="SimpleMath">\(e\)</span> are homomorphisms, which is equivalent to <code class="code">PreCat1GroupByTailHeadEmbedding(t,t,e);</code></p>

</li>
<li><p>as <code class="code">Cat1Group(i,j,k);</code> when <span class="SimpleMath">\(i,j,k\)</span> are integers, which is equivalent to <code class="code">Cat1Select(i,j,k);</code> as described in section <a href="chap2_mj.html#X7A6A70BD86DE458D"><span class="RefLink">2.7</span></a>.</p>

</li>
</ul>

<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g18gens := [ (1,2,3), (4,5,6), (2,3)(5,6) ];;     </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s3agens := [ (7,8,9), (8,9) ];;                </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g18 := Group( g18gens );;  SetName( g18, "g18" ); </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s3a := Group( s3agens );;  SetName( s3a, "s3a" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t1 := GroupHomomorphismByImages(g18,s3a,g18gens,[(7,8,9),(),(8,9)]);     </span>
[ (1,2,3), (4,5,6), (2,3)(5,6) ] -&gt; [ (7,8,9), (), (8,9) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h1 := GroupHomomorphismByImages(g18,s3a,g18gens,[(7,8,9),(7,8,9),(8,9)]);</span>
[ (1,2,3), (4,5,6), (2,3)(5,6) ] -&gt; [ (7,8,9), (7,8,9), (8,9) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e1 := GroupHomomorphismByImages(s3a,g18,s3agens,[(1,2,3),(2,3)(5,6)]);   </span>
[ (7,8,9), (8,9) ] -&gt; [ (1,2,3), (2,3)(5,6) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C18 := Cat1Group( t1, h1, e1 );</span>
[g18=&gt;s3a]

</pre></div>

<p><a id="X7C4FFC4086531157" name="X7C4FFC4086531157"></a></p>

<h5>2.4-2 Source</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Source</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Range</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TailMap</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeadMap</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RangeEmbedding</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; KernelEmbedding</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Boundary</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Name</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Size</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>These are the attributes of a cat<span class="SimpleMath">\(^1\)</span>-group <span class="SimpleMath">\(\calC\)</span> in this implementation.</p>

<p>The maps <span class="SimpleMath">\(t,h\)</span> are often referred to as the <em>source</em> and <em>target</em>, but we choose to call them the <em>tail</em> and <em>head</em> of <span class="SimpleMath">\(\calC\)</span>, because <em>source</em> is the <strong class="pkg">GAP</strong> term for the domain of a function. The <code class="code">RangeEmbedding</code> is the embedding of <code class="code">R</code> in <code class="code">G</code>, the <code class="code">KernelEmbedding</code> is the inclusion of the kernel of <code class="code">t</code> in <code class="code">G</code>, and the <code class="code">Boundary</code> is the restriction of <code class="code">h</code> to the kernel of <code class="code">t</code>. It is frequently the case that <span class="SimpleMath">\(t=h\)</span>, but not in the example <code class="code">C18</code> above.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Source( C18 );</span>
g18
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Range( C18 );</span>
s3a
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TailMap( C18 );</span>
[ (1,2,3), (4,5,6), (2,3)(5,6) ] -&gt; [ (7,8,9), (), (8,9) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HeadMap( C18 );</span>
[ (1,2,3), (4,5,6), (2,3)(5,6) ] -&gt; [ (7,8,9), (7,8,9), (8,9) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RangeEmbedding( C18 );</span>
[ (7,8,9), (8,9) ] -&gt; [ (1,2,3), (2,3)(5,6) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Kernel( C18 );</span>
Group([ (4,5,6) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KernelEmbedding( C18 );</span>
[ (4,5,6) ] -&gt; [ (4,5,6) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Name( C18 );</span>
"[g18=&gt;s3a]"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( C18 );</span>
[ 18, 6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription( C18 );</span>
[ "(C3 x C3) : C2", "S3" ]

</pre></div>

<p><a id="X79944C7B87F767FD" name="X79944C7B87F767FD"></a></p>

<h5>2.4-3 DiagonalCat1Group</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DiagonalCat1Group</code>( <var class="Arg">gen1</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p><strong class="button">[Needs revising!]</strong></p>

<p>The next three subsections contain some more constructors for cat<span class="SimpleMath">\(^1\)</span>-groups. The following listing shows an example of a permutation cat<span class="SimpleMath">\(^1\)</span>-group of size <span class="SimpleMath">\([576,24]\)</span> with source group <span class="SimpleMath">\(S_4 \times S_4\)</span>, range group a third <span class="SimpleMath">\(S_4\)</span>, and <span class="SimpleMath">\(t \neq h\)</span>. A similar example may be reproduced using the command <code class="code">C := DiagonalCat1Group([(1,2,3,4),(3,4)]);</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G4 := Group( (1,2,3,4), (3,4), (5,6,7,8), (7,8) );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R4 := Group( (9,10,11,12), (11,12) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( G4, "s4s4" );  SetName( R4, "s4d" ); </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G4gens := GeneratorsOfGroup( G4 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R4gens := GeneratorsOfGroup( R4 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t := GroupHomomorphismByImages( G4, R4, G4gens, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Concatenation( R4gens, [ (), () ] ) );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h := GroupHomomorphismByImages( G4, R4, G4gens,  </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Concatenation( [ (), () ], R4gens ) );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e := GroupHomomorphismByImages( R4, G4, R4gens, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           [ (1,2,3,4)(5,6,7,8), (3,4)(7,8) ] );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C4 := PreCat1GroupByTailHeadEmbedding( t, h, e );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(C4);</span>
Cat1-group [s4s4=&gt;s4d] :- 
: Source group s4s4 has generators:
  [ (1,2,3,4), (3,4), (5,6,7,8), (7,8) ]
: Range group s4d has generators:
  [ ( 9,10,11,12), (11,12) ]
: tail homomorphism maps source generators to:
  [ ( 9,10,11,12), (11,12), (), () ]
: head homomorphism maps source generators to:
  [ (), (), ( 9,10,11,12), (11,12) ]
: range embedding maps range generators to:
  [ (1,2,3,4)(5,6,7,8), (3,4)(7,8) ]
: kernel has generators:
  [ (5,6,7,8), (7,8) ]
: boundary homomorphism maps generators of kernel to:
  [ ( 9,10,11,12), (11,12) ]
: kernel embedding maps generators of kernel to:
  [ (5,6,7,8), (7,8) ]

</pre></div>

<p><a id="X7D30A5207FEB4D42" name="X7D30A5207FEB4D42"></a></p>

<h5>2.4-4 ReverseCat1Group</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ReverseCat1Group</code>( <var class="Arg">C0</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The <em>reverse</em> of a cat<span class="SimpleMath">\(^1\)</span>-group <span class="SimpleMath">\(C\)</span> has the same source, range and embedding, but has the tail and head maps interchanged.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R4 := ReverseCat1Group( C4 );</span>
[s4s4=&gt;s4d]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Boundary( R4 );</span>
[ (3,4), (2,3), (1,2,3,4) ] -&gt; [ (11,12), (10,11), (9,10,11,12) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TailMap( R4 ) = HeadMap( C4 ); </span>
true

</pre></div>

<p><a id="X87544FAD873672E1" name="X87544FAD873672E1"></a></p>

<h5>2.4-5 Cat1GroupByPeifferQuotient</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Cat1GroupByPeifferQuotient</code>( <var class="Arg">P</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>If <span class="SimpleMath">\(C = (e;t,h : G \to R)\)</span> is a pre-cat<span class="SimpleMath">\(^1\)</span>-group, its Peiffer subgroup is <span class="SimpleMath">\(P = [\ker t,\ker h]\)</span> and the associated cat<span class="SimpleMath">\(^1\)</span>-group <span class="SimpleMath">\(C_2\)</span> has source <span class="SimpleMath">\(G/P\)</span>. In the example, <span class="SimpleMath">\(t=h : s4 \to c2\)</span> with <span class="SimpleMath">\(\ker t = \ker h = a4\)</span> and <span class="SimpleMath">\(P = [a4,a4]=k4\)</span>, so that <span class="SimpleMath">\(G/P = s4/k4 \cong s3\)</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s4:=Group( (1,2,3), (3,4) );;  SetName( s4, "s4" ); </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h := GroupHomomorphismByImages( s4, s4, [(1,2,3),(3,4)], [(),(3,4)] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c2 := Image( h );;  SetName( c2, "c2" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := PreCat1Group( h, h );</span>
[s4=&gt;c2]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P := PeifferSubgroupPreCat1Group( C );</span>
Group([ (1,3)(2,4), (1,2)(3,4) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C2 := Cat1GroupByPeifferQuotient( C );</span>
[Group( [ f1, f2 ] )=&gt;c2]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription( C2 );</span>
[ "S3", "C2" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">XC := PreXModOfPreCat1Group( C );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription( XC );  </span>
[ "A4", "C2" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">XC2 := XModByPeifferQuotient( XC );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription( XC2 );</span>
[ "C3", "C2" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CXC2 := Cat1GroupOfXMod( XC2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription( CXC2 );</span>
[ "S3", "C2" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphismCat1Groups( C2, CXC2 );</span>
[[..] =&gt; [(..|X..)=&gt;c2]]

</pre></div>

<p><a id="X8317816A8361F88C" name="X8317816A8361F88C"></a></p>

<h4>2.5 <span class="Heading">
Properties of cat<span class="SimpleMath">\(^1\)</span>-groups and pre-cat<span class="SimpleMath">\(^1\)</span>-groups 
</span></h4>

<p>Many of the properties listed in section <a href="chap2_mj.html#X7CF622538749FE73"><span class="RefLink">2.2</span></a> apply to pre-cat<span class="SimpleMath">\(^1\)</span>-groups and to cat<span class="SimpleMath">\(^1\)</span>-groups since these are also 2d-groups. There are also more specific properties.</p>

<p><a id="X78E03FAB84A57D03" name="X78E03FAB84A57D03"></a></p>

<h5>2.5-1 IsCat1Group</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCat1Group</code>( <var class="Arg">C0</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPreXCat1Group</code>( <var class="Arg">C0</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsIdentityCat1Group</code>( <var class="Arg">C0</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPreCat1GroupByEndomorphisms</code>( <var class="Arg">C0</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EndomorphismPreCat1Group</code>( <var class="Arg">C0</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><code class="code">IsIdentityCat1Group(C0)</code> is true when the head and tail maps of <code class="code">C0</code> are identity mappings. <code class="code">IsPreCat1GroupByEndomorphisms(C0)</code> is true when the range of <code class="code">C0</code> is a subgroup of the source. When this is not the case, replacing <span class="SimpleMath">\(t,h,e\)</span> by <span class="SimpleMath">\(t*e,h*e\)</span> and the inclusion mapping of the image of <span class="SimpleMath">\(e\)</span> gives an isomorphic cat<span class="SimpleMath">\(^1\)</span>-group for which <code class="code">IsPreCat1GroupByEndomorphisms</code> is true.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G2 := SmallGroup( 288, 956 );  SetName( G2, "G2" );</span>
&lt;pc group of size 288 with 7 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d12 := DihedralGroup( 12 );  SetName( d12, "d12" );</span>
&lt;pc group of size 12 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a1 := d12.1;;  a2 := d12.2;;  a3 := d12.3;;  a0 := One( d12 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gensG2 := GeneratorsOfGroup( G2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t2 := GroupHomomorphismByImages( G2, d12, gensG2,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          [ a0, a1*a3, a2*a3, a0, a0, a3, a0 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h2 := GroupHomomorphismByImages( G2, d12, gensG2,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          [ a1*a2*a3, a0, a0, a2*a3, a0, a0, a3^2 ] );;                   </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e2 := GroupHomomorphismByImages( d12, G2, [a1,a2,a3],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [ G2.1*G2.2*G2.4*G2.6^2, G2.3*G2.4*G2.6^2*G2.7, G2.6*G2.7^2 ] );</span>
[ f1, f2, f3 ] -&gt; [ f1*f2*f4*f6^2, f3*f4*f6^2*f7, f6*f7^2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C2 := PreCat1GroupByTailHeadEmbedding( t2, h2, e2 );</span>
[G2=&gt;d12]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCat1Group( C2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KnownPropertiesOfObject( C2 );</span>
[ "CanEasilyCompareElements", "CanEasilySortElements", "IsDuplicateFree", 
  "IsGeneratorsOfSemigroup", "IsPreCat1Domain", "IsPerm2DimensionalGroup", 
  "IsPreCat1Group", "IsCat1Group", "IsPreCat1GroupByEndomorphisms" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPreCat1GroupByEndomorphisms( C2 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EC4 := EndomorphismPreCat1Group( C4 );</span>
[s4s4=&gt;Group( [ (1,2,3,4)(5,6,7,8), (3,4)(7,8), (), () ] )]

</pre></div>

<p><a id="X82F10A59867C765D" name="X82F10A59867C765D"></a></p>

<h5>2.5-2 Cat1GroupOfXMod</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Cat1GroupOfXMod</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; XModOfCat1Group</code>( <var class="Arg">C0</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PreCat1GroupOfPreXMod</code>( <var class="Arg">P0</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PreXModOfPreCat1Group</code>( <var class="Arg">P0</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The category of crossed modules is equivalent to the category of cat<span class="SimpleMath">\(^1\)</span>-groups, and the functors between these two categories may be described as follows. Starting with the crossed module <span class="SimpleMath">\(\calX = (\partial : S \to R)\)</span> the group <span class="SimpleMath">\(G\)</span> is defined as the semidirect product <span class="SimpleMath">\(G = R \ltimes S\)</span> using the action from <span class="SimpleMath">\(\calX\)</span>, with multiplication rule</p>

<p class="center">\[
(r_1,s_1)(r_2,s_2) ~=~ (r_1r_2,{s_1}^{r_2}s_2).
\]</p>

<p>The structural morphisms are given by</p>

<p class="center">\[
t(r,s) = r, \quad h(r,s) = r (\partial s), \quad er = (r,1).
\]</p>

<p>On the other hand, starting with a cat<span class="SimpleMath">\(^1\)</span>-group <span class="SimpleMath">\( \calC = (e;t,h : G \to R)\)</span>, we define <span class="SimpleMath">\( S = \ker t\)</span>, the range <span class="SimpleMath">\(R\)</span> is unchanged, and <span class="SimpleMath">\( \partial = h\!\mid_S \)</span>. The action of <span class="SimpleMath">\(R\)</span> on <span class="SimpleMath">\(S\)</span> is conjugation in <span class="SimpleMath">\(G\)</span> via the embedding of <span class="SimpleMath">\(R\)</span> in <span class="SimpleMath">\(G\)</span>.</p>

<p>As from version 2.74, the attribute <code class="code">PreCat1GroupOfPreXMod</code> of a pre-crossed modute <span class="SimpleMath">\(X = (\partial : S \to R)\)</span> returns a record with fields</p>


<ul>
<li><p><code class="code">.precat1</code>, the pre-cat1-group <span class="SimpleMath">\(C = (e;t,h: G \to R)\)</span> of <span class="SimpleMath">\(X\)</span>, where <span class="SimpleMath">\(G = R \ltimes S\)</span>;</p>

</li>
<li><p><code class="code">.iscat1</code>, true if <span class="SimpleMath">\(C\)</span> is a cat1-group;</p>

</li>
<li><p><code class="code">.xmodSourceEmbedding</code>, the image <span class="SimpleMath">\(S'\)</span> of <span class="SimpleMath">\(S\)</span> in <span class="SimpleMath">\(G\)</span>;</p>

</li>
<li><p><code class="code">.xmodSourceEmbeddingIsomorphism</code>, the isomorphism <span class="SimpleMath">\(S \to S'\)</span>;</p>

</li>
<li><p><code class="code">.xmodRangeEmbedding</code>, the image <span class="SimpleMath">\(R'\)</span> of <span class="SimpleMath">\(R\)</span> in <span class="SimpleMath">\(G\)</span>;</p>

</li>
<li><p><code class="code">.xmodRangeEmbeddingIsomorphism</code>, the isomorphism <span class="SimpleMath">\(R \to R'\)</span>;</p>

</li>
</ul>

<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">X2 := XModOfCat1Group( C2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( X2 );</span>

Crossed module X([G2=&gt;d12]) :- 
: Source group has generators:
  [ f1, f4, f5, f7 ]
: Range group d12 has generators:
  [ f1, f2, f3 ]
: Boundary homomorphism maps source generators to:
  [ f1*f2*f3, f2*f3, &lt;identity&gt; of ..., f3^2 ]
: Action homomorphism maps range generators to automorphisms:
  f1 --&gt; { source gens --&gt; [ f1*f5, f4*f5, f5, f7^2 ] }
  f2 --&gt; { source gens --&gt; [ f1*f5*f7^2, f4, f5, f7 ] }
  f3 --&gt; { source gens --&gt; [ f1*f7, f4, f5, f7 ] }
  These 3 automorphisms generate the group of automorphisms.
: associated cat1-group is [G2=&gt;d12]

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription(X2);</span>
[ "D24", "D12" ]


</pre></div>

<p><a id="X80D6CB4080417BFA" name="X80D6CB4080417BFA"></a></p>

<h4>2.6 <span class="Heading">Enumerating cat<span class="SimpleMath">\(^1\)</span>-groups with a given source</span></h4>

<p>As the size of a group <span class="SimpleMath">\(G\)</span> increases, the number of cat<span class="SimpleMath">\(^1\)</span>-groups with source <span class="SimpleMath">\(G\)</span> increases rapidly. However, one is usually only interested in the isomorphism classes of cat<span class="SimpleMath">\(^1\)</span>-groups with source <span class="SimpleMath">\(G\)</span>. An iterator <code class="code">AllCat1GroupsIterator</code> is provided, which runs through the various cat<span class="SimpleMath">\(^1\)</span>-groups. This iterator finds, for each subgroup <span class="SimpleMath">\(R\)</span> of <span class="SimpleMath">\(G\)</span>, the cat<span class="SimpleMath">\(^1\)</span>-groups with range <span class="SimpleMath">\(R\)</span>. It does this by running through the <code class="code">AllSubgroupsIterator(G)</code> provided by the <strong class="pkg">Utils</strong> package, and then using the iterator <code class="code">AllCat1GroupsWithImageIterator(G,R)</code>.</p>

<p><a id="X7A1B967D7B6273F4" name="X7A1B967D7B6273F4"></a></p>

<h5>2.6-1 AllCat1GroupsWithImageIterator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AllCat1GroupsWithImageIterator</code>( <var class="Arg">G</var>, <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AllCat1GroupsWithImageNumber</code>( <var class="Arg">G</var>, <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AllCat1GroupsWithImageUpToIsomorphism</code>( <var class="Arg">G</var>, <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AllCat1GroupsWithImage</code>( <var class="Arg">G</var>, <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The iterator <code class="code">AllCat1GroupsWithImageIterator(G,R)</code> iterates through all the cat<span class="SimpleMath">\(^1\)</span>-groups with source <code class="code">G</code> and range <span class="SimpleMath">\(R\)</span>. The attribute <code class="code">AllCat1GroupsWithImageNumber(G)</code> runs through this iterator to count the number <span class="SimpleMath">\(n_R\)</span> of these cat<span class="SimpleMath">\(^1\)</span>-groups. The operation <code class="code">AllCat1GroupsWithImage(G)</code> returns a list containing these <span class="SimpleMath">\(n_R\)</span> cat<span class="SimpleMath">\(^1\)</span>-groups. Since these lists can get very long, this operation should only be used for simple cases. The operation <code class="code">AllCat1GroupsWithImageUpToIsomorphism(G)</code> returns representatives of the isomorphism classes of these cat<span class="SimpleMath">\(^1\)</span>-groups.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d12 := DihedralGroup( IsPermGroup, 12 );  SetName( d12, "d12" );</span>
Group([ (1,2,3,4,5,6), (2,6)(3,5) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c2 := Subgroup( d12, [ (1,6)(2,5)(3,4) ] );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AllCat1GroupsWithImageNumber( d12, c2 );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L12 := AllCat1GroupsWithImage( d12, c2 );</span>
[ [d12=&gt;Group( [ (), (1,6)(2,5)(3,4) ] )] ]

</pre></div>

<p><a id="X7FEB2FCE7D9ADA85" name="X7FEB2FCE7D9ADA85"></a></p>

<h5>2.6-2 AllCat1GroupsIterator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AllCat1GroupsIterator</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AllCat1GroupsNumber</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AllCat1GroupsUpToIsomorphism</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AllCat1Groups</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The iterator <code class="code">AllCat1GroupsIterator(G)</code> iterates through all the cat<span class="SimpleMath">\(^1\)</span>-groups with source <code class="code">G</code>. The attribute <code class="code">AllCat1GroupsNumber(G)</code> runs this iterator to count the number <span class="SimpleMath">\(n\)</span> of these cat<span class="SimpleMath">\(^1\)</span>-groups. The operation <code class="code">AllCat1Groups(G)</code> returns a list containing these <span class="SimpleMath">\(n\)</span> cat<span class="SimpleMath">\(^1\)</span>-groups. Since these lists can get very long, this operation should only be used for simple cases. The operation <code class="code">AllCat1GroupsUpToIsomorphism(G)</code> returns representatives of the isomorphism classes of these subgroups.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iter := AllCat1GroupsIterator( d12 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AllCat1GroupsNumber( d12 );</span>
12
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso12 := AllCat1GroupsUpToIsomorphism( d12 );</span>
[ [d12=&gt;Group( [ (), (2,6)(3,5) ] )], 
  [d12=&gt;Group( [ (1,4)(2,5)(3,6), (2,6)(3,5) ] )], 
  [d12=&gt;Group( [ (1,5,3)(2,6,4), (2,6)(3,5) ] )], 
  [d12=&gt;Group( [ (1,2,3,4,5,6), (2,6)(3,5) ] )] ]

</pre></div>

<p><a id="X7AC53BAA78A7DCCB" name="X7AC53BAA78A7DCCB"></a></p>

<h5>2.6-3 CatnGroupNumbers</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CatnGroupNumbers</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CatnGroupLists</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InitCatnGroupRecords</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The attribute <code class="code">CatnGroupNumbers</code> for a group <span class="SimpleMath">\(G\)</span> is a mutable record which stores numbers of cat<span class="SimpleMath">\(^1\)</span>-groups, cat<span class="SimpleMath">\(^2\)</span>-groups, etc. as they are calculated. The field <code class="code">CatnGroupNumbers(G).idem</code> is the number of idempotent endomorphisms of <span class="SimpleMath">\(G\)</span>. Similarly, <code class="code">CatnGroupNumbers(G).cat1</code> is the number of cat<span class="SimpleMath">\(^1\)</span>-groups on <span class="SimpleMath">\(G\)</span>, while <code class="code">CatnGroupNumbers(G).iso1</code> is the number of isomorphism classes of these cat<span class="SimpleMath">\(^1\)</span>-groups. The attribute <code class="code">CatnGroupLists</code> is used for storing results of cat<span class="SimpleMath">\(^2\)</span>-group calculations.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CatnGroupNumbers( d12 );</span>
rec( cat1 := 12, idem := 21, iso1 := 4 )

</pre></div>

<p><a id="X7A6A70BD86DE458D" name="X7A6A70BD86DE458D"></a></p>

<h4>2.7 <span class="Heading">Selection of a small cat<span class="SimpleMath">\(^1\)</span>-group</span></h4>

<p>The <code class="code">Cat1Group</code> function may also be used to select a cat<span class="SimpleMath">\(^1\)</span>-group from a data file. All cat<span class="SimpleMath">\(^1\)</span>-structures on groups of size up to <span class="SimpleMath">\(70\)</span> (ordered according to the <strong class="pkg">GAP</strong> 4 numbering of small groups) are stored in a list in file <code class="file">cat1data.g</code>. Global variables <code class="code">CAT1_LIST_MAX_SIZE := 70</code> and <code class="code">CAT1_LIST_CLASS_SIZES</code> are also stored. The data is read into the list <code class="code">CAT1_LIST</code> only when this function is called.</p>

<p><a id="X7B8E67D880E380C8" name="X7B8E67D880E380C8"></a></p>

<h5>2.7-1 Cat1Select</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Cat1Select</code>( <var class="Arg">size</var>, <var class="Arg">gpnum</var>, <var class="Arg">num</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The function <code class="code">Cat1Select</code> may be used in three ways. <code class="code">Cat1Select( size )</code> returns the names of the groups with this size, while <code class="code">Cat1Select( size, gpnum )</code> prints a list of cat<span class="SimpleMath">\(^1\)</span>-structures for this chosen group. <code class="code">Cat1Select( size, gpnum, num )</code> returns the chosen cat<span class="SimpleMath">\(^1\)</span>-group.</p>

<p>The example below is the first case in which <span class="SimpleMath">\(t \neq h\)</span> and the associated conjugation crossed module is given by the normal subgroup <code class="code">c3</code> of <code class="code">s3</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## check the number of groups of size 18</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L18 := Cat1Select( 18 ); </span>
Usage:  Cat1Select( size, gpnum, num );
[ "D18", "C18", "C3 x S3", "(C3 x C3) : C2", "C6 x C3" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## check the number of cat1-structures on the fourth of these</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Cat1Select( 18, 4 );</span>
Usage:  Cat1Select( size, gpnum, num );
There are 4 cat1-structures for the group (C3 x C3) : C2.
Using small generating set [ f1, f2, f2*f3 ] for source of homs.
[ [range gens], [tail genimages], [head genimages] ] :-
(1)  [ [ f1 ], [ f1, &lt;identity&gt; of ..., &lt;identity&gt; of ... ], 
  [ f1, &lt;identity&gt; of ..., &lt;identity&gt; of ... ] ]
(2)  [ [ f1, f3 ], [ f1, &lt;identity&gt; of ..., f3 ], 
  [ f1, &lt;identity&gt; of ..., f3 ] ]
(3)  [ [ f1, f3 ], [ f1, &lt;identity&gt; of ..., f3 ], 
  [ f1, f3^2, &lt;identity&gt; of ... ] ]
(4)  [ [ f1, f2, f2*f3 ],  tail = head = identity mapping ]
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## select the third of these cat1-structures </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C18 := Cat1Select( 18, 4, 3 );</span>
[(C3 x C3) : C2=&gt;Group( [ f1, &lt;identity&gt; of ..., f3 ] )]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## convert from a pc-cat1-group to a permutation cat1-group</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso18 := IsomorphismPermObject( C18 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PC18 := Image( iso18 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( PC18 );</span>
Cat1-group :- 
: Source group has generators:
  [ (2,3)(5,6), (4,5,6), (1,2,3) ]
: Range group has generators:
  [ (2,3), (), (1,2,3) ]
: tail homomorphism maps source generators to:
  [ (2,3), (), (1,2,3) ]
: head homomorphism maps source generators to:
  [ (2,3), (1,3,2), (1,2,3) ]
: range embedding maps range generators to:
  [ (2,3)(5,6), (), (1,2,3) ]
: kernel has generators:
  [ (4,5,6) ]
: boundary homomorphism maps generators of kernel to:
  [ (1,3,2) ]
: kernel embedding maps generators of kernel to:
  [ (4,5,6) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">convert the result to the associated permutation crossed module </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">X18 := XModOfCat1Group( PC18 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( X18 ); </span>
Crossed module:- 
: Source group has generators:
  [ (4,5,6) ]
: Range group has generators:
  [ (2,3), (), (1,2,3) ]
: Boundary homomorphism maps source generators to:
  [ (1,3,2) ]
: Action homomorphism maps range generators to automorphisms:
  (2,3) --&gt; { source gens --&gt; [ (4,6,5) ] }
  () --&gt; { source gens --&gt; [ (4,5,6) ] }
  (1,2,3) --&gt; { source gens --&gt; [ (4,5,6) ] }
  These 3 automorphisms generate the group of automorphisms.
: associated cat1-group is [..=&gt;..]

</pre></div>

<p><a id="X8768CDA180561393" name="X8768CDA180561393"></a></p>

<h5>2.7-2 AllCat1DataGroupsBasic</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AllCat1DataGroupsBasic</code>( <var class="Arg">gp</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>For a group <span class="SimpleMath">\(G\)</span> of size greater than <span class="SimpleMath">\(70\)</span> which is reasonably straightforward this function may be used to construct a list of all cat<span class="SimpleMath">\(^1\)</span>-group structures on <span class="SimpleMath">\(G\)</span>. The operation also attempts to write output to a file in the folder <code class="file">xmod/lib</code>. (Other operations in the file <code class="file">cat1data.gi</code> have been used to deal with the more complicated groups of size up to <span class="SimpleMath">\(70\)</span>, but these are not described here.)</p>

<p>Van Luyen Le has a more efficient algorithm, extending the data up to groups of size 171, which is expected to appear in a future release of <strong class="pkg">HAP</strong>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gp := SmallGroup( 102, 2 ); </span>
&lt;pc group of size 102 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription( gp ); </span>
"C3 x D34"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">all := AllCat1DataGroupsBasic( gp );</span>
#I Edit last line of .../xmod/lib/nn.kk.out to end with ] ] ] ] ]
[ [Group( [ f1, f2, f3 ] )=&gt;Group( [ f1, &lt;identity&gt; of ..., &lt;identity&gt; of ... 
     ] )], [Group( [ f1, f2, f3 ] )=&gt;Group( [ f1, f2, &lt;identity&gt; of ... ] )], 
  [Group( [ f1, f2, f3 ] )=&gt;Group( [ f1, &lt;identity&gt; of ..., f3 ] )], 
  [Group( [ f1, f2, f3 ] )=&gt;Group( [ f1, f2, f3 ] )] ]

</pre></div>

<p><a id="X8614CDCF8063117F" name="X8614CDCF8063117F"></a></p>

<h4>2.8 <span class="Heading">More functions for crossed modules and cat<span class="SimpleMath">\(^1\)</span>-groups</span></h4>

<p>Chapter <a href="chap4_mj.html#X802AFE8E7EDB435E"><span class="RefLink">4</span></a> contains functions for quotient crossed modules; centre of a crossed module; commutator and derived subcrossed modules; etc.</p>

<p>Here we mention two functions for groups which have been extended to the two-dimensional case.</p>

<p><a id="X7831DB527CF9DD57" name="X7831DB527CF9DD57"></a></p>

<h5>2.8-1 IdGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IdGroup</code>( <var class="Arg">2DimensionalGroup</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StructureDescription</code>( <var class="Arg">2DimensionalGroup</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>These functions return two-element lists formed by applying the function to the source and range of the 2d-group.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdGroup( X2 );</span>
[ [ 24, 6 ], [ 12, 4 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription( C2 );</span>
[ "(S3 x D24) : C2", "D12" ]

</pre></div>

<p><a id="X7CFAB044817E5E91" name="X7CFAB044817E5E91"></a></p>

<h4>2.9 <span class="Heading">The group groupoid associated to a cat<span class="SimpleMath">\(^1\)</span>-group</span></h4>

<p>A <em>group groupoid</em> is an algebraic object which is both a groupoid and a group. The category of group groupoids is equivalent to the categories of precrossed modules and precat<span class="SimpleMath">\(^1\)</span>-groups. Starting with a (pre)cat<span class="SimpleMath">\(^1\)</span>-group <span class="SimpleMath">\(\calC = (e;t,h : G \to R)\)</span>, we form the groupoid <span class="SimpleMath">\(\calG\)</span> having the elements of <span class="SimpleMath">\(R\)</span> as objects and the elements of <span class="SimpleMath">\(G\)</span> as arrows. The arrow <span class="SimpleMath">\(g\)</span> has tail <span class="SimpleMath">\(tg\)</span> and head <span class="SimpleMath">\(hg\)</span>. <span class="SimpleMath">\(\calG\)</span> has one connected component for each coset of <span class="SimpleMath">\(tG\)</span> in <span class="SimpleMath">\(R\)</span>.</p>

<p>The groupoid (partial) multiplication <span class="SimpleMath">\(*\)</span> on these arrows is defined by:</p>

<p class="center">\[
(g_1 : r_1 \to r_2) * (g_2 : r_2 \to r_3) ~=~ (g_1(er_2^{-1})g_2 : r_1 \to r_3). 
\]</p>

<p><a id="X7AF5AF668331321E" name="X7AF5AF668331321E"></a></p>

<h5>2.9-1 GroupGroupoid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GroupGroupoid</code>( <var class="Arg">precat1</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The operation <code class="code">GroupGroupoid</code> implements this construction. In the example we start with a crossed module <span class="SimpleMath">\((C_3^2 \to S_3)\)</span>, form the associated cat<span class="SimpleMath">\(^1\)</span>-group <span class="SimpleMath">\((S_3 \ltimes C_3^2 \Rightarrow S_3)\)</span>, and then form the group groupoid <code class="code">gpd33</code>. Since the image of the boundary of the crossed module is <span class="SimpleMath">\(C_3\)</span>, with index <span class="SimpleMath">\(2\)</span> in the range, the groupoid has two connected components, and the root objects are <span class="SimpleMath">\(\{(),(12,13)\}\)</span>. The size of the vertex groups is <span class="SimpleMath">\(|\ker t \cap \ker h| = 3\)</span>, and the generators at the root objects are <span class="SimpleMath">\(() \to ( 4, 5, 6)( 7, 9, 8) \to ()\)</span> and <span class="SimpleMath">\((12,13) \to ( 2, 3)( 4, 6)( 7, 8) \to (12,13)\)</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s3 := Group( (11,12), (12,13) );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c3c3 := Group( [ (14,15,16), (17,18,19) ] );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bdy := GroupHomomorphismByImages( c3c3, s3, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [(14,15,16),(17,18,19)], [(11,12,13),(11,12,13)] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := GroupHomomorphismByImages( c3c3, c3c3, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [(14,15,16),(17,18,19)], [(14,16,15),(17,19,18)] );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">aut := Group( [a] );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">act := GroupHomomorphismByImages( s3, aut, [(11,12),(12,13)], [a,a] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">X33 := XModByBoundaryAndAction( bdy, act );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C33 := Cat1GroupOfXMod( X33 ).precat1;; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G33 := Source( C33 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gpd33 := GroupGroupoid( C33 ); </span>
groupoid with 2 pieces:
1:  single piece groupoid with rays: &lt; Group( [ ()&gt;-( 4, 5, 6)( 7, 9, 8)-&gt;() 
 ] ), [ (), (11,12,13), (11,13,12) ], [ ()&gt;-()-&gt;(), ()&gt;-(7,8,9)-&gt;(11,12,13), 
  ()&gt;-(7,9,8)-&gt;(11,13,12) ] &gt;
2:  single piece groupoid with rays: &lt; Group( 
[ (12,13)&gt;-( 2, 3)( 4, 6)( 7, 8)-&gt;(12,13) ] ), [ (12,13), (11,12), (11,13) ], 
[ (12,13)&gt;-(2,3)(5,6)(8,9)-&gt;(12,13), (12,13)&gt;-(2,3)(5,6)(7,9)-&gt;(11,13), 
  (12,13)&gt;-(2,3)(5,6)(7,8)-&gt;(11,12) ] &gt;

</pre></div>

<p><a id="X8578AB6D7C1FC4F3" name="X8578AB6D7C1FC4F3"></a></p>

<h5>2.9-2 GroupGroupoidElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GroupGroupoidElement</code>( <var class="Arg">precat1</var>, <var class="Arg">root</var>, <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Since we need to define a second multiplication on the elements of <span class="SimpleMath">\(G\)</span>, we have to convert <span class="SimpleMath">\(g \in G\)</span> into a new type of object, <code class="code">GroupGroupoidElementType</code>, a record <span class="SimpleMath">\(e\)</span> with fields:</p>


<ul>
<li><p><code class="code">e!.precat1</code>, the precat<span class="SimpleMath">\(^1\)</span>-group from which <span class="SimpleMath">\(\calG\)</span> was formed;</p>

</li>
<li><p><code class="code">e!.root</code>, the root object of the component containing <span class="SimpleMath">\(e\)</span>;</p>

</li>
<li><p><code class="code">e!.element</code>, the element <span class="SimpleMath">\(g \in G\)</span>;</p>

</li>
<li><p><code class="code">e!.tail</code>, the tail object of the element <span class="SimpleMath">\(e\)</span>;</p>

</li>
<li><p><code class="code">e!.head</code>, the head object of the element <span class="SimpleMath">\(e\)</span>;</p>

</li>
<li><p><code class="code">e!.tailid</code>, the identity element at the tail object;</p>

</li>
<li><p><code class="code">e!.headid</code>, the identity element at the head object;</p>

</li>
</ul>
<p>In the example we pick a particular pair of elements <span class="SimpleMath">\(g_1,g_2 \in G\)</span>, construct group groupoid elements <span class="SimpleMath">\(e_1,e_2\)</span> from them, and show that <span class="SimpleMath">\(g_1*g_2\)</span> and <span class="SimpleMath">\(e_1*e_2\)</span> give very different results. (Warning: at present iterators for object groups and homsets do not work.)</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">piece2 := Pieces( gpd33 )[2];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obs2 := piece2!.objects; </span>
[ (12,13), (11,12), (11,13) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RaysOfGroupoid( piece2 );</span>
[ (12,13)&gt;-(2,3)(5,6)(8,9)-&gt;(12,13), (12,13)&gt;-(2,3)(5,6)(7,9)-&gt;(11,13), 
  (12,13)&gt;-(2,3)(5,6)(7,8)-&gt;(11,12) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g1 := (1,2)(5,6)(7,9);; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g2 := (2,3)(4,5)(7,8);;                         </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g1 * g2;</span>
(1,3,2)(4,5,6)(7,9,8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e1 := GroupGroupoidElement( C33, (12,13), g1 ); </span>
(11,12)&gt;-(1,2)(5,6)(7,9)-&gt;(12,13)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e2 := GroupGroupoidElement( C33, (12,13), g2 );</span>
(12,13)&gt;-(2,3)(4,5)(7,8)-&gt;(11,13)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e1*e2;</span>
(11,12)&gt;-(1,2)(4,5)(8,9)-&gt;(11,13)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e2^-1;</span>
(11,13)&gt;-(1,3)(4,6)(7,9)-&gt;(12,13)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obgp := ObjectGroup( gpd33, (11,12) );</span>
&lt;group with 1 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsOfGroup( obgp )[1];</span>
(11,13)&gt;-( 1, 3)( 4, 6)( 7, 8)-&gt;(11,13)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Homset( gpd33, (11,12), (11,13) );</span>
&lt;homset (11,12) -&gt; (11,13) with head group Group( 
[ (11,12)&gt;-( 1, 2)( 4, 6)( 7, 8)-&gt;(11,12) ] )&gt;

</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
