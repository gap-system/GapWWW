<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (XMod) - Chapter 4: Isoclinism of groups and crossed modules</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap4"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap3.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap5.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap4_mj.html">[MathJax on]</a></p>
<p><a id="X802AFE8E7EDB435E" name="X802AFE8E7EDB435E"></a></p>
<div class="ChapSects"><a href="chap4.html#X802AFE8E7EDB435E">4 <span class="Heading">Isoclinism of groups and crossed modules</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4.html#X7E373BF3836B3A9C">4.1 <span class="Heading">More operations for crossed modules</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X873ED97185D9176E">4.1-1 FactorPreXMod</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X8591E25680C5C575">4.1-2 IntersectionSubXMods</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7E20208279038BB8">4.1-3 Displacement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X86ACB83E7D70C625">4.1-4 CommutatorSubXMod</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X86E0804B780A7FD6">4.1-5 DerivedSubXMod</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X85640DD17F5A2949">4.1-6 FixedPointSubgroupXMod</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7B57446086BA1BF0">4.1-7 CentreXMod</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X814D9E1E78EEE665">4.1-8 CentralQuotient</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7F4222757B0E08B6">4.1-9 IsAbelian2DimensionalGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X87C524C08588AAC0">4.1-10 LowerCentralSeriesOfXMod</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X81EE2188863E6E85">4.1-11 AllXMods</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7C67623F797A0301">4.1-12 IsomorphismXMods</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4.html#X7B0D511A82FD945E">4.2 <span class="Heading">Isoclinism for groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7B0D511A82FD945E">4.2-1 Isoclinism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7C72991985B58DB8">4.2-2 IsStemDomain</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X82DD52587F81C95C">4.2-3 IsoclinicRank</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4.html#X81338C977972AD83">4.3 <span class="Heading">Isoclinism for crossed modules</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X81338C977972AD83">4.3-1 Isoclinism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7E86DCB083CA5915">4.3-2 IsStemDomain</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X820C412679910975">4.3-3 IsoclinicRank</a></span>
</div></div>
</div>

<h3>4 <span class="Heading">Isoclinism of groups and crossed modules</span></h3>

<p>This chapter describes some functions written by Alper Odabaş and Enver Uslu, and reported in their paper <a href="chapBib.html#biBIOU1">[IOU16]</a>. Section <a href="chap4.html#X7E373BF3836B3A9C"><span class="RefLink">4.1</span></a> contains some additional basic functions for crossed modules, constructing quotients, centres, centralizers and normalizers. In Sections <a href="chap4.html#X7B0D511A82FD945E"><span class="RefLink">4.2</span></a> and <a href="chap4.html#X81338C977972AD83"><span class="RefLink">4.3</span></a> there are functions dealing specifically with isoclinism for groups and for crossed modules. Since these functions represent a recent addition to the package (as of November 2015), the function names are liable to change in future versions. The notion of isoclinism has been crucial to the enumeration of groups of prime power order, see for example James, Newman and O'Brien, <a href="chapBib.html#biBJNO">[JNO90]</a>.</p>

<p><a id="X7E373BF3836B3A9C" name="X7E373BF3836B3A9C"></a></p>

<h4>4.1 <span class="Heading">More operations for crossed modules</span></h4>

<p><a id="X873ED97185D9176E" name="X873ED97185D9176E"></a></p>

<h5>4.1-1 FactorPreXMod</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FactorPreXMod</code>( <var class="Arg">X1</var>, <var class="Arg">X2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalMorphismByNormalSubPreXMod</code>( <var class="Arg">X1</var>, <var class="Arg">X2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>When <span class="SimpleMath">calX_2 = (∂_2 : S_2 -&gt; R_2)</span> is a normal sub-precrossed module of <span class="SimpleMath">calX_1 = (∂_1 : S_1 -&gt; R_1)</span>, then the quotient precrossed module is <span class="SimpleMath">(∂ : S_2/S_1 -&gt; R_2/R_1)</span> with the induced boundary and action maps. Quotienting a precrossed module by it's Peiffer subgroup is a special case of this construction. (Permutation representations vary between different versions of <strong class="pkg">GAP</strong>.)</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d24 := DihedralGroup( IsPermGroup, 24 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( d24, "d24" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Y24 := XModByAutomorphismGroup( d24 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( Y24 );</span>
[ 24, 48 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">X24 := Image( IsomorphismPerm2DimensionalGroup( Y24 ) );</span>
[d24-&gt;Group([ (2,4), (1,2,3,4), (6,7), (5,6,7) ])]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nsx := NormalSubXMods( X24 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( nsx );</span>
40
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ids := List( nsx, n -&gt; IdGroup(n) );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pos1 := Position( ids, [ [4,1], [8,3] ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Xn1 := nsx[pos1]; </span>
[Group( [ f2*f4^2, f3*f4 ] )-&gt;Group( [ f3, f4, f5 ] )]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nat1 := NaturalMorphismByNormalSubPreXMod( X24, Xn1 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Qn1 := FactorPreXMod( X24, Xn1 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ Size( Xn1 ), Size( Qn1 ) ];</span>
[ [ 4, 8 ], [ 6, 6 ] ]

</pre></div>

<p><a id="X8591E25680C5C575" name="X8591E25680C5C575"></a></p>

<h5>4.1-2 IntersectionSubXMods</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IntersectionSubXMods</code>( <var class="Arg">X0</var>, <var class="Arg">X1</var>, <var class="Arg">X2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>When <code class="code">X1,X2</code> are subcrossed modules of <code class="code">X0</code>, then the source and range of their intersection are the intersections of the sources and ranges of <code class="code">X1</code> and <code class="code">X2</code> respectively.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pos2 := Position( ids, [ [24,6], [12,4] ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Xn2 := nsx[pos2];; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdGroup( Xn2 );         </span>
[ [ 24, 6 ], [ 12, 4 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pos3 := Position( ids, [ [12,2], [24,5] ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Xn3 := nsx[pos3];; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdGroup( Xn3 );</span>
[ [ 12, 2 ], [ 24, 5 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Xn23 := IntersectionSubXMods( X24, Xn2, Xn3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdGroup( Xn23 );</span>
[ [ 12, 2 ], [ 6, 2 ] ]

</pre></div>

<p><a id="X7E20208279038BB8" name="X7E20208279038BB8"></a></p>

<h5>4.1-3 Displacement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Displacement</code>( <var class="Arg">alpha</var>, <var class="Arg">r</var>, <var class="Arg">s</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DisplacementGroup</code>( <var class="Arg">X0</var>, <var class="Arg">Q</var>, <var class="Arg">T</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DisplacementSubgroup</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Commutators may be written <span class="SimpleMath">[r,q] = r^-1q^-1rq = (q^-1)^rq = r^-1r^q</span>, and satisfy identities</p>

<p class="pcenter"> 
[r,q]^p = [r^p,q^p], \qquad 
[pr,q] = [p,q]^r[r,q], \qquad 
[r,pq] = [r,q][r,p]^q, \qquad 
[r,q]^{-1} = [q,r]. 
</p>

<p>In a similar way, when a group <span class="SimpleMath">R</span> acts on a group <span class="SimpleMath">S</span>, the <em>displacement</em> of <span class="SimpleMath">s ∈ S</span> by <span class="SimpleMath">r ∈ R</span> is defined to be <span class="SimpleMath">⟨ r,s ⟩ := (s^-1)^rs ∈ S</span>. When <span class="SimpleMath">calX = (∂ : S -&gt; R)</span> is a pre-crossed module, the first crossed module axiom requires <span class="SimpleMath">∂⟨ r,s ⟩ = [r,∂ s]</span>. When <span class="SimpleMath">α</span> is the action of <span class="SimpleMath">calX</span>, the <code class="func">Displacement</code> function may be used to calculate <span class="SimpleMath">⟨ r,s ⟩</span>. Displacements satisfy the following identities, where <span class="SimpleMath">s,t ∈ S,~ p,q,r ∈ R</span>:</p>

<p class="pcenter">
\langle r,s \rangle^p = \langle r^p,s^p \rangle, \qquad 
\langle qr,s \rangle = \langle q,s \rangle^r \langle r,s \rangle, \qquad 
\langle r,st \rangle = \langle r,t \rangle \langle r,s \rangle^t, \qquad 
\langle r,s \rangle^{-1} = \langle r^{-1},s^r \rangle. 
</p>

<p>The operation <code class="func">DisplacementGroup</code> applied to <code class="code">X0,Q,T</code> is the subgroup of <code class="code">S</code> consisting of all the displacements <span class="SimpleMath">⟨ r,s ⟩, r ∈ Q leqslant R, s ∈ T leqslant S</span>. The <code class="func">DisplacementSubgroup</code> of <span class="SimpleMath">calX</span> is the subgroup <span class="SimpleMath">Disp(calX)</span> of <span class="SimpleMath">S</span> given by <code class="code">DisplacementGroup(X0,R,S)</code>. The identities imply <span class="SimpleMath">⟨ r,s ⟩^t = ⟨ r,st^r^-1} ⟩ ⟨ r^-1,t ⟩</span>, so <span class="SimpleMath">Disp(calX)</span> is normal in <span class="SimpleMath">S</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pos4 := Position( ids, [ [6,2], [24,14] ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Xn4 := nsx[pos4];; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bn4 := Boundary( Xn4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Sn4 := Source(Xn4);; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Rn4 := Range(Xn4);; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">genRn4 := GeneratorsOfGroup( Rn4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := List( genRn4, g -&gt; ( Order(g) = 2 ) and </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                not ( IsNormal( Rn4, Subgroup( Rn4, [g] ) ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pos := Position( L, true );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s := Sn4.1;  r := genRn4[pos]; </span>
(1,3,5,7,9,11)(2,4,6,8,10,12)
(6,7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">act := XModAction( Xn4 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d := Displacement( act, r, s );</span>
(1,5,9)(2,6,10)(3,7,11)(4,8,12)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Image( bn4, d ) = Comm( r, Image( bn4, s ) );  </span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Qn4 := Subgroup( Rn4, [ (6,7), (1,3), (2,4) ] );;   </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Tn4 := Subgroup( Sn4, [ (1,3,5,7,9,11)(2,4,6,8,10,12) ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DisplacementGroup( Xn4, Qn4, Tn4 );                        </span>
Group([ (1,5,9)(2,6,10)(3,7,11)(4,8,12) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DisplacementSubgroup( Xn4 );</span>
Group([ (1,5,9)(2,6,10)(3,7,11)(4,8,12) ])

</pre></div>

<p><a id="X86ACB83E7D70C625" name="X86ACB83E7D70C625"></a></p>

<h5>4.1-4 CommutatorSubXMod</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CommutatorSubXMod</code>( <var class="Arg">X</var>, <var class="Arg">X1</var>, <var class="Arg">X2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CrossActionSubgroup</code>( <var class="Arg">X</var>, <var class="Arg">X1</var>, <var class="Arg">X2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>When <span class="SimpleMath">calX_1 = (N -&gt; Q), calX_2 = (M -&gt; P)</span> are two normal subcrossed modules of <span class="SimpleMath">calX = (∂ : S -&gt; R)</span>, the displacements <span class="SimpleMath">⟨ p,n ⟩</span> and <span class="SimpleMath">⟨ q,m ⟩</span> all map by <span class="SimpleMath">∂</span> into <span class="SimpleMath">[Q,P]</span>. These displacements form a normal subgroup of <span class="SimpleMath">S</span>, called the <code class="code">CrossActionSubgroup</code>. The <code class="code">CommutatorSubXMod</code> <span class="SimpleMath">[calX_1,calX_2]</span> has this subgroup as source and <span class="SimpleMath">[P,Q]</span> as range, and is normal in <span class="SimpleMath">calX</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CAn23 := CrossActionSubgroup( X24, Xn2, Xn3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdGroup( CAn23 );</span>
[ 12, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Cn23 := CommutatorSubXMod( X24, Xn2, Xn3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdGroup( Cn23 );</span>
[ [ 12, 2 ], [ 6, 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Xn23 = Cn23;</span>
true

</pre></div>

<p><a id="X86E0804B780A7FD6" name="X86E0804B780A7FD6"></a></p>

<h5>4.1-5 DerivedSubXMod</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DerivedSubXMod</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The <code class="code">DerivedSubXMod</code> of <span class="SimpleMath">calX</span> is the normal subcrossed module <span class="SimpleMath">[calX,calX] = (∂' : Disp(calX) -&gt; [R,R])</span> where <span class="SimpleMath">∂'</span> is the restriction of <span class="SimpleMath">∂</span> (see page 66 of Norrie's thesis <a href="chapBib.html#biBN2">[Nor87]</a>).</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DXn4 := DerivedSubXMod( Xn4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdGroup( DXn4 );</span>
[ [ 3, 1 ], [ 3, 1 ] ]

</pre></div>

<p><a id="X85640DD17F5A2949" name="X85640DD17F5A2949"></a></p>

<h5>4.1-6 FixedPointSubgroupXMod</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FixedPointSubgroupXMod</code>( <var class="Arg">X0</var>, <var class="Arg">T</var>, <var class="Arg">Q</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StabilizerSubgroupXMod</code>( <var class="Arg">X0</var>, <var class="Arg">T</var>, <var class="Arg">Q</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The <code class="code">FixedPointSubgroupXMod(X,T,Q)</code> for <span class="SimpleMath">calX=(∂ : S -&gt; R)</span> is the subgroup <span class="SimpleMath">Fix(calX,T,Q)</span> of elements <span class="SimpleMath">t ∈ T leqslant S</span> individually fixed under the action of <span class="SimpleMath">Q leqslant R</span>.</p>

<p>The <code class="code">StabilizerSubgroupXMod(X,T,Q)</code> for <span class="SimpleMath">calX</span> is the subgroup <span class="SimpleMath">Stab(calX,T,Q)</span> of <span class="SimpleMath">Q leqslant R</span> whose elements act trivially on the whole of <span class="SimpleMath">T leqslant S</span> (see page 19 of Norrie's thesis <a href="chapBib.html#biBN2">[Nor87]</a>).</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fix := FixedPointSubgroupXMod( Xn4, Sn4, Rn4 );</span>
Group([ (1,7)(2,8)(3,9)(4,10)(5,11)(6,12) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">stab := StabilizerSubgroupXMod( Xn4, Sn4, Rn4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdGroup( stab );</span>
[ 12, 5 ]

</pre></div>

<p><a id="X7B57446086BA1BF0" name="X7B57446086BA1BF0"></a></p>

<h5>4.1-7 CentreXMod</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CentreXMod</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Centralizer</code>( <var class="Arg">X</var>, <var class="Arg">Y</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Normalizer</code>( <var class="Arg">X</var>, <var class="Arg">Y</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The <em>centre</em> <span class="SimpleMath">Z(calX)</span> of <span class="SimpleMath">calX = (∂ : S -&gt; R)</span> has as source the fixed point subgroup <span class="SimpleMath">Fix(calX,S,R)</span>. The range is the intersection of the centre <span class="SimpleMath">Z(R)</span> with the stabilizer subgroup.</p>

<p>When <span class="SimpleMath">calY = (T -&gt; Q)</span> is a subcrossed module of <span class="SimpleMath">calX = (∂ : S -&gt; R)</span>, the <em>centralizer</em> <span class="SimpleMath">C_calX(calY)</span> of <span class="SimpleMath">calY</span> has as source the fixed point subgroup <span class="SimpleMath">Fix(calX,S,Q)</span>. The range is the intersection of the centralizer <span class="SimpleMath">C_R(Q)</span> with <span class="SimpleMath">Stab(calX,T,R)</span>.</p>

<p>The <em>normalizer</em> <span class="SimpleMath">N_calX(calY)</span> of <span class="SimpleMath">calY</span> has as source the subgroup of <span class="SimpleMath">S</span> consisting of the displacements <span class="SimpleMath">⟨ s,q ⟩</span> which lie in <span class="SimpleMath">S</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZXn4 := CentreXMod( Xn4 );      </span>
[Group( [ f3*f4 ] )-&gt;Group( [ f3, f5 ] )]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdGroup( ZXn4 );</span>
[ [ 2, 1 ], [ 4, 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CDXn4 := Centralizer( Xn4, DXn4 );</span>
[Group( [ f3*f4 ] )-&gt;Group( [ f2 ] )]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdGroup( CDXn4 );    </span>
[ [ 2, 1 ], [ 3, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NDXn4 := Normalizer( Xn4, DXn4 ); </span>
[Group( &lt;identity&gt; of ... )-&gt;Group( [ f5, f2*f3 ] )]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdGroup( NDXn4 );</span>
[ [ 1, 1 ], [ 12, 5 ] ]

</pre></div>

<p><a id="X814D9E1E78EEE665" name="X814D9E1E78EEE665"></a></p>

<h5>4.1-8 CentralQuotient</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CentralQuotient</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The <code class="code">CentralQuotient</code> of a group <span class="SimpleMath">G</span> is the crossed module <span class="SimpleMath">(G -&gt; G/Z(G))</span> with the natural homomorphism as the boundary map. This is a special case of <code class="func">XModByCentralExtension</code> (<a href="chap2.html#X7D0F6FAA7AF69844"><span class="RefLink">2.1-5</span></a>).</p>

<p>Similarly, the central quotient of a crossed module <span class="SimpleMath">calX</span> is the crossed square <span class="SimpleMath">(calX ⇒ calX/Z(calX))</span> (see section <a href="chap8.html#X820A7D30847BC828"><span class="RefLink">8.2</span></a>).</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q24 := CentralQuotient( d24);  IdGroup( Q24 );                     </span>
[d24-&gt;d24/Z(d24)]
[ [ 24, 6 ], [ 12, 4 ] ]

</pre></div>

<p><a id="X7F4222757B0E08B6" name="X7F4222757B0E08B6"></a></p>

<h5>4.1-9 IsAbelian2DimensionalGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsAbelian2DimensionalGroup</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsAspherical2DimensionalGroup</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSimplyConnected2DimensionalGroup</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFaithful2DimensionalGroup</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>A crossed module is <em>abelian</em> if it equal to its centre. This is the case when the range group is abelian and the action is trivial.</p>

<p>A crossed module is <em>aspherical</em> if the boundary has trivial kernel.</p>

<p>A crossed module is <em>simply connected</em> if the boundary has trivial cokernel.</p>

<p>A crossed module is <em>faithful</em> if the action is faithful.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ IsAbelian2DimensionalGroup(Xn4), IsAbelian2DimensionalGroup(X24) ];</span>
[ false, false ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pos7 := Position( ids, [ [3,1], [6,1] ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ IsAspherical2DimensionalGroup(nsx[pos7]), IsAspherical2DimensionalGroup(X24) ];</span>
[ true, false ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ IsSimplyConnected2DimensionalGroup(Xn4), IsSimplyConnected2DimensionalGroup(X24) ];</span>
[ true, true ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ IsFaithful2DimensionalGroup(Xn4), IsFaithful2DimensionalGroup(X24) ];              </span>
[ false, true ] 

</pre></div>

<p><a id="X87C524C08588AAC0" name="X87C524C08588AAC0"></a></p>

<h5>4.1-10 LowerCentralSeriesOfXMod</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LowerCentralSeriesOfXMod</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsNilpotent2DimensionalGroup</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NilpotencyClass2DimensionalGroup</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Let <span class="SimpleMath">calY</span> be a subcrossed module of <span class="SimpleMath">calX</span>. A <em> series of length</em> <span class="SimpleMath">n</span> from <span class="SimpleMath">calX</span> to <span class="SimpleMath">calY</span> has the form</p>

<p class="pcenter">
\calX ~=~ \calX_0 ~\unrhd~ \calX_1 ~\unrhd~ \cdots 
                ~\unrhd~ \calX_i ~\unrhd~ \cdots 
                ~\unrhd~ \calX_n ~=~ \calY 
                \quad (1 \leqslant i \leqslant n). 
</p>

<p>The quotients <span class="SimpleMath">calF_i = calX_i / calX_i-1</span> are the <em>factors</em> of the series.</p>

<p>A factor <span class="SimpleMath">calF_i</span> is <em>central</em> if <span class="SimpleMath">calX_i-1 ⊴ calX</span> and <span class="SimpleMath">calF_i</span> is a subcrossed module of the centre of <span class="SimpleMath">calX / calX_i-1</span>.</p>

<p>A series is <em>central</em> if all its factors are central.</p>

<p><span class="SimpleMath">calX</span> is <em>soluble</em> if it has a series all of whose factors are abelian.</p>

<p><span class="SimpleMath">calX</span> is <em>nilpotent</em> is it has a series all of whose factors are central factors of <span class="SimpleMath">calX</span>.</p>

<p>The <em>lower central series</em> of <span class="SimpleMath">calX</span> is the sequence (see <a href="chapBib.html#biBN2">[Nor87]</a>, p.77):</p>

<p class="pcenter">
\calX ~=~ \Gamma_1(\calX) ~\unrhd~ \Gamma_2(\calX) 
              ~\unrhd~ \cdots 
\qquad \mbox{where} \qquad  
\Gamma_j(\calX) ~=~ [ \Gamma_{j-1}(\calX), \calX].
</p>

<p>If <span class="SimpleMath">calX</span> is nilpotent, then its lower central series is its most rapidly descending central series.</p>

<p>The least integer <span class="SimpleMath">c</span> such that <span class="SimpleMath">Γ_c+1(calX)</span> is the trivial crossed module is the <em>nilpotency class</em> of <span class="SimpleMath">calX</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lcs := LowerCentralSeries( X24 );;      </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( lcs, g -&gt; IdGroup(g) );</span>
[ [ [ 24, 6 ], [ 48, 38 ] ], [ [ 12, 2 ], [ 6, 2 ] ], [ [ 6, 2 ], [ 3, 1 ] ], 
  [ [ 3, 1 ], [ 3, 1 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsNilpotent2DimensionalGroup( X24 );      </span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NilpotencyClassOf2DimensionalGroup( X24 );</span>
0

</pre></div>

<p><a id="X81EE2188863E6E85" name="X81EE2188863E6E85"></a></p>

<h5>4.1-11 AllXMods</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AllXMods</code>( <var class="Arg">args</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>The global function <code class="code">AllXMods</code> may be called in three ways: as <code class="code">AllXMods(S,R)</code> to compute all crossed modules with chosen source and range groups; as <code class="code">AllXMods([n,m])</code> to compute all crossed modules with a given size; or as <code class="code">AllXMods(ord)</code> to compute all crossed modules whose associated cat1-groups have a given size <code class="code">ord</code>.</p>

<p>In the example we see that there are <span class="SimpleMath">4</span> crossed modules <span class="SimpleMath">(C_6 -&gt; S_3)</span>; forming a subset of the <span class="SimpleMath">17</span> crossed modules with size <code class="code">[6,6]</code>; and that these form a subset of the <span class="SimpleMath">205</span> crossed modules whose cat1-group has size <span class="SimpleMath">36</span>. There are <span class="SimpleMath">40</span> precrossed modules with size <code class="code">[6,6]</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">xc6s3 := AllXMods( SmallGroup(6,2), SmallGroup(6,1) );;   </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( xc6s3 );           </span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x66 := AllXMods( [6,6] );;   </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( x66 );</span>
17
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x36 := AllXMods( 36 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( x36 ); </span>
205
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">size36 := List( x36, x -&gt; [ Size(Source(x)), Size(Range(x)) ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Collected( size36 );</span>
[ [ [ 1, 36 ], 14 ], [ [ 2, 18 ], 7 ], [ [ 3, 12 ], 21 ], [ [ 4, 9 ], 14 ], 
  [ [ 6, 6 ], 17 ], [ [ 9, 4 ], 102 ], [ [ 12, 3 ], 8 ], [ [ 18, 2 ], 18 ], 
  [ [ 36, 1 ], 4 ] ]

</pre></div>

<p><a id="X7C67623F797A0301" name="X7C67623F797A0301"></a></p>

<h5>4.1-12 IsomorphismXMods</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismXMods</code>( <var class="Arg">X1</var>, <var class="Arg">X2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AllXModsUpToIsomorphism</code>( <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The function <code class="code">IsomorphismXMods</code> computes an isomorphism <span class="SimpleMath">μ : calX_1 -&gt; calX_2</span>, provided one exists, or else returns <code class="code">fail</code>. In the example below we see that the <span class="SimpleMath">17</span> crossed modules of size <code class="code">[6,6]</code> in <code class="code">x66</code> (see the previous subsection) fall into <span class="SimpleMath">9</span> isomorphism classes.</p>

<p>The function <code class="code">AllXModsUpToIsomorphism</code> takes a list of crossed modules and partitions them into isomorphism classes.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphismXMods( x66[1], x66[2] );</span>
[[Group( [ f1, f2 ] )-&gt;Group( [ f1, f2 ] )] =&gt; [Group( [ f1, f2 ] )-&gt;Group( 
[ f1, f2 ] )]]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso66 := AllXModsUpToIsomorphism( x66 );;  Length( iso66 ); </span>
9 

</pre></div>

<p><a id="X7B0D511A82FD945E" name="X7B0D511A82FD945E"></a></p>

<h4>4.2 <span class="Heading">Isoclinism for groups</span></h4>

<p><a id="X7B0D511A82FD945E" name="X7B0D511A82FD945E"></a></p>

<h5>4.2-1 Isoclinism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Isoclinism</code>( <var class="Arg">G</var>, <var class="Arg">H</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AreIsoclinicDomains</code>( <var class="Arg">G</var>, <var class="Arg">H</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Let <span class="SimpleMath">G,H</span> be groups with central quotients <span class="SimpleMath">Q(G)</span> and <span class="SimpleMath">Q(H)</span> and derived subgroups <span class="SimpleMath">[G,G]</span> and <span class="SimpleMath">[H,H]</span> respectively. Let <span class="SimpleMath">c_G : G/Z(G) × G/Z(G) -&gt; [G,G]</span> and <span class="SimpleMath">c_H : H/Z(H) × H/Z(H) -&gt; [H,H]</span> be the two commutator maps. An <em>isoclinism</em> <span class="SimpleMath">G ∼ H</span> is a pair of isomorphisms <span class="SimpleMath">(η,ξ)</span> where <span class="SimpleMath">η : G/Z(G) -&gt; H/Z(H)</span> and <span class="SimpleMath">ξ : [G,G] -&gt; [H,H]</span> such that <span class="SimpleMath">c_G * ξ = (η × η) * c_H</span>. Isoclinism is an equivalence relation, and all abelian groups are isoclinic to the trivial group.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SmallGroup( 64, 6 );;  StructureDescription( G ); </span>
"(C8 x C4) : C2"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QG := CentralQuotient( G );;  IdGroup( QG );</span>
[ [ 64, 6 ], [ 8, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := SmallGroup( 32, 41 );;  StructureDescription( H );</span>
"C2 x Q16"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QH := CentralQuotient( H );;  IdGroup( QH );</span>
[ [ 32, 41 ], [ 8, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Isoclinism( G, H );</span>
[ [ f1, f2, f3 ] -&gt; [ f1, f2*f3, f3 ], [ f3, f5 ] -&gt; [ f4*f5, f5 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K := SmallGroup( 32, 43 );;  StructureDescription( K );</span>
"(C2 x D8) : C2"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QK := CentralQuotient( K );;  IdGroup( QK );                       </span>
[ [ 32, 43 ], [ 16, 11 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AreIsoclinicDomains( G, K );</span>
false

</pre></div>

<p><a id="X7C72991985B58DB8" name="X7C72991985B58DB8"></a></p>

<h5>4.2-2 IsStemDomain</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsStemDomain</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsoclinicStemDomain</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AllStemGroupIds</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AllStemGroupFamilies</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>A group <span class="SimpleMath">G</span> is a <em>stem group</em> if <span class="SimpleMath">Z(G) ≤ [G,G]</span>. Every group is isoclinic to a stem group, but distinct stem groups may be isoclinic. For example, groups <span class="SimpleMath">D_8, Q_8</span> are two isoclinic stem groups.</p>

<p>The function <code class="code">IsoclinicStemDomain </code> returns a stem group isoclinic to <span class="SimpleMath">G</span>.</p>

<p>The function <code class="code">AllStemGroupIds</code> returns the <code class="code">IdGroup</code> list of the stem groups of a specified size, while <code class="code">AllStemGroupFamilies</code> splits this list into isoclinism classes.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DerivedSubgroup(G);     </span>
Group([ f3, f5 ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsStemDomain( G );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsoclinicStemDomain( G );</span>
&lt;pc group of size 16 with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AllStemGroupIds( 32 );</span>
[ [ 32, 6 ], [ 32, 7 ], [ 32, 8 ], [ 32, 18 ], [ 32, 19 ], [ 32, 20 ], 
  [ 32, 27 ], [ 32, 28 ], [ 32, 29 ], [ 32, 30 ], [ 32, 31 ], [ 32, 32 ], 
  [ 32, 33 ], [ 32, 34 ], [ 32, 35 ], [ 32, 43 ], [ 32, 44 ], [ 32, 49 ], 
  [ 32, 50 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AllStemGroupFamilies( 32 );</span>
[ [ [ 32, 6 ], [ 32, 7 ], [ 32, 8 ] ], [ [ 32, 18 ], [ 32, 19 ], [ 32, 20 ] ],
  [ [ 32, 27 ], [ 32, 28 ], [ 32, 29 ], [ 32, 30 ], [ 32, 31 ], [ 32, 32 ], 
      [ 32, 33 ], [ 32, 34 ], [ 32, 35 ] ], [ [ 32, 43 ], [ 32, 44 ] ], 
  [ [ 32, 49 ], [ 32, 50 ] ] ]

</pre></div>

<p><a id="X82DD52587F81C95C" name="X82DD52587F81C95C"></a></p>

<h5>4.2-3 IsoclinicRank</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsoclinicRank</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsoclinicMiddleLength</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Let <span class="SimpleMath">G</span> be a finite <span class="SimpleMath">p</span>-group. Then <span class="SimpleMath">log_p |[G,G] / (Z(G) ∩ [G,G])|</span> is called the <em>middle length</em> of <span class="SimpleMath">G</span>. Also <span class="SimpleMath">log_p |Z(G) ∩ [G,G]| + log_p |G/Z(G)|</span> is called the <em>rank</em> of <span class="SimpleMath">G</span>. These invariants appear in the tables of isoclinism families of groups of order 128 in <a href="chapBib.html#biBJNO">[JNO90]</a>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsoclinicMiddleLength( G );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsoclinicRank( G );</span>
4

</pre></div>

<p><a id="X81338C977972AD83" name="X81338C977972AD83"></a></p>

<h4>4.3 <span class="Heading">Isoclinism for crossed modules</span></h4>

<p><a id="X81338C977972AD83" name="X81338C977972AD83"></a></p>

<h5>4.3-1 Isoclinism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Isoclinism</code>( <var class="Arg">X0</var>, <var class="Arg">Y0</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AreIsoclinicDomains</code>( <var class="Arg">X0</var>, <var class="Arg">Y0</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Let <span class="SimpleMath">calX,calY</span> be crossed modules with central quotients <span class="SimpleMath">Q(calX)</span> and <span class="SimpleMath">Q(calY)</span>, and derived subcrossed modules <span class="SimpleMath">[calX,calX]</span> and <span class="SimpleMath">[calY,calY]</span> respectively. Let <span class="SimpleMath">c_calX : Q(calX) × Q(calX) -&gt; [calX,calX]</span> and <span class="SimpleMath">c_calY : Q(calY) × Q(calY) -&gt; [calY,calY]</span> be the two commutator maps. An <em>isoclinism</em> <span class="SimpleMath">calX ∼ calY</span> is a pair of bijective morphisms <span class="SimpleMath">(η,ξ)</span> where <span class="SimpleMath">η : Q(calX) -&gt; Q(calY)</span> and <span class="SimpleMath">ξ : [calX,calX] -&gt; [calY,calY]</span> such that <span class="SimpleMath">c_calX * ξ = (η × η) * c_calY</span>. Isoclinism is an equivalence relation, and all abelian crossed modules are isoclinic to the trivial crossed module.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C8 := Cat1Group( 16, 8, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">X8 := XMod(C8);  IdGroup( X8 );</span>
[Group( [ f1*f2*f3, f3, f4 ] )-&gt;Group( [ f2, f2 ] )]
[ [ 8, 1 ], [ 2, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C9 := Cat1Group( 32, 9, 1 );</span>
[(C8 x C2) : C2=&gt;Group( [ f2, f2 ] )]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">X9 := XMod( C9 );  IdGroup( X9 );</span>
[Group( [ f1*f2*f3, f3, f4, f5 ] )-&gt;Group( [ f2, f2 ] )]
[ [ 16, 5 ], [ 2, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AreIsoclinicDomains( X8, X9 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ism89 := Isoclinism( X8, X9 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ism89 );</span>
[ [[Group( [ f1, f2, &lt;identity&gt; of ... ] ) -&gt; Group( [ f2, f2 ] )] =&gt; [Group( 
    [ f1, f2, &lt;identity&gt; of ..., &lt;identity&gt; of ... ] ) -&gt; Group( 
    [ f2, f2 ] )]], 
  [[Group( [ f3 ] ) -&gt; Group( &lt;identity&gt; of ... )] =&gt; [Group( 
    [ f3 ] ) -&gt; Group( &lt;identity&gt; of ... )]] ]

</pre></div>

<p><a id="X7E86DCB083CA5915" name="X7E86DCB083CA5915"></a></p>

<h5>4.3-2 IsStemDomain</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsStemDomain</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsoclinicStemDomain</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>A crossed module <span class="SimpleMath">calX</span> is a <em>stem crossed module</em> if <span class="SimpleMath">Z(calX) ≤ [calX,calX]</span>. Every crossed module is isoclinic to a stem crossed module, but distinct stem crossed modules may be isoclinic.</p>

<p>A method for <code class="code">IsoclinicStemDomain</code> has yet to be implemented.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsStemDomain(X8);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsStemDomain(X9);</span>
false

</pre></div>

<p><a id="X820C412679910975" name="X820C412679910975"></a></p>

<h5>4.3-3 IsoclinicRank</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsoclinicRank</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsoclinicMiddleLength</code>( <var class="Arg">X0</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The formulae in subsection <a href="chap4.html#X82DD52587F81C95C"><span class="RefLink">4.2-3</span></a> are applied to the crossed module.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsoclinicMiddleLength(X8);</span>
[ 1, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsoclinicRank(X8);        </span>
[ 3, 1 ]

</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap3.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap5.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
