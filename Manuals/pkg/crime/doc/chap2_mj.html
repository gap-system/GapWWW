<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (crime) - Chapter 2: Usage</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap2"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chapA_mj.html">A</a>  <a href="chapB_mj.html">B</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapA_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap2.html">[MathJax off]</a></p>
<p><a id="X86A9B6F87E619FFF" name="X86A9B6F87E619FFF"></a></p>
<div class="ChapSects"><a href="chap2_mj.html#X86A9B6F87E619FFF">2 <span class="Heading">Usage</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X85BF21B17BF76907">2.1 <span class="Heading">Cohomology Objects</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X8716E7657F9683B7">2.1-1 CohomologyObject</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X7FEB30657DDEFE44">2.2 <span class="Heading">Minimal Projective Resolutions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X8273999C7B352F22">2.2-1 ProjectiveResolution</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7AF313D387F6BA22">2.2-2 BoundaryMap</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X78C37B2E7D297FC5">2.3 <span class="Heading">Cohomology Generators and Relators</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X81F141187B0EC653">2.3-1 CohomologyGenerators</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X812BE8E983DC20BC">2.3-2 CohomologyRelators</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X87C9251687CD4247">2.4 <span class="Heading">Tests for Completion</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X80B6849C835B7F19">2.5 <span class="Heading">Cohomology Rings</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7B77337486380998">2.5-1 CohomologyRing</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7D8EA4528082A74D">2.5-2 IsHomogeneous</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X826A861E7E7D944E">2.5-3 Degree</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X813A8E4C7D4C9FBD">2.5-4 LocateGeneratorsInCohomologyRing</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X7E21853583D6D86D">2.6 <span class="Heading">What Happens if <code class="keyw">n</code> Isn't
Big Enough?</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X837261007B39795C">2.7 <span class="Heading">Induced Maps</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X8608BD148307390B">2.7-1 InducedHomomorphismOnCohomology</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X80798C0979D4E9DC">2.7-2 SubgroupInclusion</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X7B541EB97BAB36D7">2.8 <span class="Heading">Massey Products</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7E3023CE86641F9E">2.8-1 MasseyProduct</a></span>
</div></div>
</div>

<h3>2 <span class="Heading">Usage</span></h3>

<p>Unless otherwise specified, all the functions described below taking an argument <code class="keyw">n</code> do whatever the manual says they do up to homological degree <code class="keyw">n</code>. These functions are idempotent in the sense that called a second time with the same argument <code class="keyw">n</code>, they do nothing, but called with a bigger <code class="keyw">n</code>, they continue computing from where the previous calculations finished.</p>

<p><a id="X85BF21B17BF76907" name="X85BF21B17BF76907"></a></p>

<h4>2.1 <span class="Heading">Cohomology Objects</span></h4>

<p>The computation of group cohomology involves several calculations, the results of which are reused in later calculations, and are thus collected in an object of type <code class="keyw">CObject</code>, which is created with the following command.</p>

<p><a id="X8716E7657F9683B7" name="X8716E7657F9683B7"></a></p>

<h5>2.1-1 CohomologyObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CohomologyObject</code>( <var class="Arg">G</var>, <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CohomologyObject</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a <code class="keyw">CObject</code>.</p>

<p>This function creates a <code class="keyw">CObject</code> having components the <span class="SimpleMath">\(p\)</span>-group <code class="keyw">G</code> and the <strong class="pkg">MeatAxe</strong> module <code class="keyw">M</code>, which should be a <span class="SimpleMath">\(kG\)</span>-module where <span class="SimpleMath">\(G\)</span> the group <code class="keyw">G</code> and <span class="SimpleMath">\(k\)</span> a field of characteristic <span class="SimpleMath">\(p\)</span>. Note that <strong class="pkg">MeatAxe</strong> modules know what <span class="SimpleMath">\(k\)</span> is, but not what <span class="SimpleMath">\(G\)</span> is, which is why this operation requires the user to specify <span class="SimpleMath">\(G\)</span> but not <span class="SimpleMath">\(k\)</span>.</p>

<p>Fortunately, most users don't need to know anything about <strong class="pkg">MeatAxe</strong> modules, being interested primarily in the case where <span class="SimpleMath">\(k=GF(p)\)</span> and <span class="SimpleMath">\(M=k\)</span> is the trivial <span class="SimpleMath">\(kG\)</span>-module. In this situation, the second invocation creates a cohomology object having components the <span class="SimpleMath">\(p\)</span>-group <span class="SimpleMath">\(G\)</span> and the trivial <strong class="pkg">MeatAxe</strong> <span class="SimpleMath">\(kG\)</span>-module <span class="SimpleMath">\(k=GF(p)\)</span>.</p>

<p>We emphasize that in the first invocation, <span class="SimpleMath">\(k\)</span> can be any field of characteristic <span class="SimpleMath">\(p\)</span> and <code class="keyw">M</code> can be any <strong class="pkg">MeatAxe</strong> module over <span class="SimpleMath">\(kG\)</span>, and that <code class="keyw">ProjectiveResolution</code> works when <code class="keyw">M</code> is an arbitrary <strong class="pkg">MeatAxe</strong> module, but that all the functions dealing with the ring-structure of <span class="SimpleMath">\(H*(G,k)\)</span> require that <code class="keyw">M</code> be the trivial module.</p>

<p>The cohomology object is used to store, in addition to the items mentioned above, the boundary maps, the Betti numbers, the multiplication table, etc.</p>

<p><a id="X7FEB30657DDEFE44" name="X7FEB30657DDEFE44"></a></p>

<h4>2.2 <span class="Heading">Minimal Projective Resolutions</span></h4>

<p>Given a <span class="SimpleMath">\(p\)</span>-group <span class="SimpleMath">\(G\)</span>, a field <span class="SimpleMath">\(k\)</span> of characteristic <span class="SimpleMath">\(p\)</span>, and a <span class="SimpleMath">\(kG\)</span>-module <span class="SimpleMath">\(M\)</span>, the function below computes the beginning of the minimal projective resolution of <span class="SimpleMath">\(M\)</span></p>

<p class="center">\[ P_n -&gt; ... -&gt; P_2 -&gt; P_1 -&gt; P_0 -&gt; M -&gt; 0\]</p>

<p>where <span class="SimpleMath">\(P_i\)</span> is the direct sum <span class="SimpleMath">\((kG)^(b_i)\)</span> for certain numbers <span class="SimpleMath">\(b_i\)</span>, the <em>Betti numbers</em> of the resolution. The minimal <span class="SimpleMath">\(kG\)</span>-projective resolution of <span class="SimpleMath">\(M\)</span> is unique up to chain isomorphism. Because of the minimality of <span class="SimpleMath">\(P\)</span> the groups <span class="SimpleMath">\(Ext^i(M,N)\)</span> are simply <span class="SimpleMath">\(Hom(P_i,N)\)</span>, and if <span class="SimpleMath">\(M\)</span> and <span class="SimpleMath">\(N\)</span> are both the trivial <span class="SimpleMath">\(kG\)</span>-module <span class="SimpleMath">\(k\)</span>, then <span class="SimpleMath">\(H^i(G,k)=Ext^i(k,k)=k^(b_i)\)</span>.</p>

<p><a id="X8273999C7B352F22" name="X8273999C7B352F22"></a></p>

<h5>2.2-1 ProjectiveResolution</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ProjectiveResolution</code>( <var class="Arg">C</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list containing the Betti numbers <span class="SimpleMath">\(b_0, b_1,\ldots, b_n\)</span>.</p>

<p>Given a cohomology object <code class="keyw">C</code> having components <span class="SimpleMath">\(G\)</span> and <span class="SimpleMath">\(M\)</span>, this function computes the first <code class="keyw">n</code><span class="SimpleMath">\(+1\)</span> terms of the minimal projective resolution <span class="SimpleMath">\(P\)</span> of <span class="SimpleMath">\(M\)</span> of the form <span class="SimpleMath">\(P_i=(kG)^(b_i)\)</span> for <span class="SimpleMath">\(i=0,1,...,n\)</span> and returns the numbers <span class="SimpleMath">\(b_i\)</span> as a list.</p>

<p><a id="X7AF313D387F6BA22" name="X7AF313D387F6BA22"></a></p>

<h5>2.2-2 BoundaryMap</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BoundaryMap</code>( <var class="Arg">C</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: the <code class="keyw">n</code>th boundary map.</p>

<p>Given the cohomology object <code class="keyw">C</code>, this function computes a projective resolution to degree <code class="keyw">n</code> if it hasn't been computed already, and returns the <code class="keyw">n</code>th boundary map <span class="SimpleMath">\(P_n \rightarrow P_{n-1}\)</span>.</p>

<p>The map returned is a <span class="SimpleMath">\(b_n x b_{n-1}|G|\)</span> matrix, having in the <span class="SimpleMath">\(i\)</span>th row the image of the element <span class="SimpleMath">\(1_G\)</span> from the <span class="SimpleMath">\(i\)</span>th direct summand of <span class="SimpleMath">\(P_n\)</span>.</p>

<p>See the file <code class="keyw">doc/example.*</code> for an example of the usage and interpretation of the result of this function.</p>

<p><a id="X78C37B2E7D297FC5" name="X78C37B2E7D297FC5"></a></p>

<h4>2.3 <span class="Heading">Cohomology Generators and Relators</span></h4>

<p>See <a href="chapBib_mj.html#biBcarlson">[2]</a> for the details of the calculation of cohomology products using composition of chain maps. See also the file <code class="keyw">doc/explanation.*</code> for an explanation of the implementation.</p>

<p><a id="X81F141187B0EC653" name="X81F141187B0EC653"></a></p>

<h5>2.3-1 CohomologyGenerators</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CohomologyGenerators</code>( <var class="Arg">C</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list containing the degrees of the elements of a set of generators of the cohomology ring.</p>

<p>Given a cohomology object <code class="keyw">C</code> having group component <span class="SimpleMath">\(G\)</span> and module component the trivial <span class="SimpleMath">\(kG\)</span>-module, this function computes a set of generators of <span class="SimpleMath">\(H*(G,k)\)</span> having degree <code class="keyw">n</code> or less, and stores them in <code class="keyw">C</code>. The function returns a list of the degrees of these generators.</p>

<p>The actual cohomology generators are represented by maps <span class="SimpleMath">\(P_i \rightarrow k\)</span> for <span class="SimpleMath">\(0\le i\le n\)</span> and are stored in <code class="keyw">C</code> as matrices. Only their degrees are returned.</p>

<p><a id="X812BE8E983DC20BC" name="X812BE8E983DC20BC"></a></p>

<h5>2.3-2 CohomologyRelators</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CohomologyRelators</code>( <var class="Arg">C</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list of generators and a list of relators.</p>

<p>Given a cohomology object <code class="keyw">C</code> having group component <span class="SimpleMath">\(G\)</span> and module component <span class="SimpleMath">\(k\)</span>, this function computes a set of generators of the ideal of relators in <span class="SimpleMath">\(H*(G,k),\)</span> all having degree <span class="SimpleMath">\(n\)</span> or less.</p>

<p>More specifically, the function returns two lists, the first list containing the variables <code class="keyw">z</code>, <code class="keyw">y</code>, <code class="keyw">x</code>, <span class="SimpleMath">\(\ldots\)</span> corresponding to the generators of <span class="SimpleMath">\(H*(G,k)\)</span> if there are fewer than 12 generators and containing the variables <code class="keyw">x_1</code>, <code class="keyw">x_2</code>, <code class="keyw">x_3</code>, <span class="SimpleMath">\(\ldots\)</span> otherwise. The second list is a list of polynomials in the variables from the first list.</p>

<p>These two lists should be interpreted as follows. A degree <code class="keyw">n</code> approximation of the cohomology ring <span class="SimpleMath">\(H*(G,k)\)</span> is given by the polynomial ring over <span class="SimpleMath">\(k\)</span> in the non-commuting variables from the first list, (having degrees given by the list returned by <code class="keyw">CohomologyGenerators</code> in section <a href="chap2_mj.html#X81F141187B0EC653"><span class="RefLink">2.3-1</span></a> ) and subject to the relators in the second list. See section <a href="chap2_mj.html#X7E21853583D6D86D"><span class="RefLink">2.6</span></a> for more details still.</p>

<p>For example, consider the following commands.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C:=CohomologyObject(DihedralGroup(8));</span>
&lt;object&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CohomologyGenerators(C,10);</span>
[ 1, 1, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CohomologyRelators(C,10);</span>
[ [ z, y, x ], [ z*y+y^2 ] ]
</pre></div>

<p>This tells us that for <span class="SimpleMath">\(G=D_8\)</span> and <span class="SimpleMath">\(k=GF(p)\)</span> the cohomology ring <span class="SimpleMath">\(H*(G,k)\)</span> is the graded-commutative polynomial ring in the variables <span class="SimpleMath">\(z\)</span>, <span class="SimpleMath">\(y\)</span>, <span class="SimpleMath">\(x\)</span> of degrees 1, 1, 2, subject to the relation <span class="SimpleMath">\(zy+y^2\)</span>. But since <span class="SimpleMath">\(H*(G,k)\)</span> is commutative, <span class="SimpleMath">\(k\)</span> being of characteristic 2, we have <span class="SimpleMath">\(H*(G,k)=k[z,y,x]/(zy+y^2)\)</span>. This result can be further improved by taking <span class="SimpleMath">\(z=z+y\)</span>, giving <span class="SimpleMath">\(H*(G,k)=k[z,y,x]/(zy)\)</span>.</p>

<p>Observe that in this case, we knew in advance that there was a set of generators for <span class="SimpleMath">\(H*(G,k)\)</span> all having degree less than 10, and that there was a set of generators of the ideal of relators all having degree less than 10. See see section <a href="chap2_mj.html#X7E21853583D6D86D"><span class="RefLink">2.6</span></a> for details.</p>

<p>While this isn't likely to occur, we point out that if there are 12 or more generators and some of the indeterminates <code class="keyw">x_1</code>, <code class="keyw">x_2</code>, <code class="keyw">x_3</code>, <span class="SimpleMath">\(\ldots\)</span> have already been named, say by a previous call to <code class="keyw">CohomologyRelators</code>, then these variables will retain their old names. If this is confusing, you could restart <strong class="pkg">GAP</strong> and do it again.</p>

<p>Finally, <code class="keyw">CohomologyRelators</code> is <em>not</em> idempotent for efficiency reasons, so sadly, if you don't uncover all the relators the first time, you will have to start all over from the beginning.</p>

<p><a id="X87C9251687CD4247" name="X87C9251687CD4247"></a></p>

<h4>2.4 <span class="Heading">Tests for Completion</span></h4>

<p>A test or series of tests for completion of the calculation will hopefully be implemented soon. See <a href="chapBib_mj.html#biBcarlson">[2]</a> for the details.</p>

<p><a id="X80B6849C835B7F19" name="X80B6849C835B7F19"></a></p>

<h4>2.5 <span class="Heading">Cohomology Rings</span></h4>

<p>Whereas the operations in sections <a href="chap2_mj.html#X81F141187B0EC653"><span class="RefLink">2.3-1</span></a> and <a href="chap2_mj.html#X812BE8E983DC20BC"><span class="RefLink">2.3-2</span></a> calculate a presentation for the cohomology ring, the operation below creates the ring in <strong class="pkg">GAP</strong> as a structure constant algebra.</p>

<p>See <a href="chapBib_mj.html#biBcarlson">[2]</a> for the details of the calculation of cohomology products using composition of chain maps. See also the file <code class="keyw">doc/explanation.*</code> for an explanation of the implementation.</p>

<p><a id="X7B77337486380998" name="X7B77337486380998"></a></p>

<h5>2.5-1 CohomologyRing</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CohomologyRing</code>( <var class="Arg">C</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CohomologyRing</code>( <var class="Arg">G</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: the cohomology ring of <span class="SimpleMath">\(G\)</span>.</p>

<p>Given a cohomology object <code class="keyw">C</code> with group component <span class="SimpleMath">\(G\)</span> and module component the trivial <span class="SimpleMath">\(kG\)</span>-module, this function returns the degree <code class="keyw">n</code> truncation of the cohomology ring <span class="SimpleMath">\(H*(G,k)\)</span>. See <a href="chap2_mj.html#X7E21853583D6D86D"><span class="RefLink">2.6</span></a> for what this means exactly. The object returned is a structure constant algebra.</p>

<p>Users interested only in working with the cohomology ring of a group as a <strong class="pkg">GAP</strong> object, and not in calculating generators, relators, induced maps, etc, can use the second invocation of this function, which returns the cohomology ring of the group <code class="keyw">G</code> immediately, throwing away all intermediate calculations.</p>

<p>Observe that the object returned is a degree <code class="keyw">n</code> truncation of the infinite-dimensional cohomology ring. A consequence of this is that multiplying two elements whose product has degree greater than <code class="keyw">n</code> results in zero, whether or not the product is really zero.</p>

<p>Observe also that calling <code class="keyw">CohomologyRing</code> a second time with a bigger <code class="keyw">n</code> does <em>not</em> extend the previous ring, but rather, recalculates the entire ring from the beginning. Extending the previous ring appears not to be worth the effort for technical reasons, since almost everything would need to be recalculated again anyway.</p>

<p>Recall that <span class="SimpleMath">\(H*(G,k)\)</span> is a graded algebra, the components being the cohomology groups <span class="SimpleMath">\(H^i(G,k)\)</span>. The following functions were intended to be used for cohomology rings, but in principle, they work for any graded structure constant algebra.</p>

<p><a id="X7D8EA4528082A74D" name="X7D8EA4528082A74D"></a></p>

<h5>2.5-2 IsHomogeneous</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsHomogeneous</code>( <var class="Arg">e</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>Given an element <code class="keyw">e</code> of a cohomology ring <span class="SimpleMath">\(H*(G,k)\)</span>, this operation determines whether or not <code class="keyw">e</code> is homogeneous, that is, whether <code class="keyw">e</code> is contained in <span class="SimpleMath">\(H^i(G,k)\)</span> for some <code class="keyw">i</code>.</p>

<p><a id="X826A861E7E7D944E" name="X826A861E7E7D944E"></a></p>

<h5>2.5-3 Degree</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Degree</code>( <var class="Arg">e</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the degree of <code class="keyw">e</code>.</p>

<p>This function returns the degree of the possibly non-homogeneous element <code class="keyw">e</code> of a cohomology ring <span class="SimpleMath">\(H*(G,k)\)</span>. Specifically, if <span class="SimpleMath">\(H*(G,k) = A_0 + A_1 + A_2 + \ldots\)</span> where <span class="SimpleMath">\(A_i = H^i(G,k)\)</span> then this function returns the minimum <span class="SimpleMath">\(n\)</span> such that <code class="keyw">e</code> is in <span class="SimpleMath">\(A_0 + A_1 + \ldots + A_n\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A:=CohomologyRing(DihedralGroup(8),10);</span>
&lt;algebra of dimension 66 over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b:=Basis(A);</span>
CanonicalBasis( &lt;algebra of dimension 66 over GF(2)&gt; )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:=b[2]+b[4];</span>
v.2+v.4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsHomogeneous(x);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Degree(x);</span>
2 
</pre></div>

<p><a id="X813A8E4C7D4C9FBD" name="X813A8E4C7D4C9FBD"></a></p>

<h5>2.5-4 LocateGeneratorsInCohomologyRing</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LocateGeneratorsInCohomologyRing</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a list containing the cohomology generators.</p>

<p>Having already called <code class="keyw">CohomologyRing</code> (see <a href="chap2_mj.html#X7B77337486380998"><span class="RefLink">2.5-1</span></a>), this function returns a list of elements of the cohomology ring which together with the identity element generate the cohomology ring.</p>

<p>This function is a wrapper for <code class="keyw">CohomologyGenerators</code> (see <a href="chap2_mj.html#X81F141187B0EC653"><span class="RefLink">2.3-1</span></a>). It points out which elements of the cohomology ring correspond with the generators found by <code class="keyw">CohomologyGenerators</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C:=CohomologyObject(SmallGroup(8,4));</span>
&lt;object&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A:=CohomologyRing(C,10);</span>
&lt;algebra of dimension 17 over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:=LocateGeneratorsInCohomologyRing(C);</span>
[ v.2, v.3, v.7 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A=Subalgebra(A,Concatenation(L,[One(A)]));</span>
true
</pre></div>

<p><a id="X7E21853583D6D86D" name="X7E21853583D6D86D"></a></p>

<h4>2.6 <span class="Heading">What Happens if <code class="keyw">n</code> Isn't
Big Enough?</span></h4>

<p>Since <span class="SimpleMath">\(P\)</span> is a <em>minimal</em> projective resolution, we have <span class="SimpleMath">\(H^i(G,k) = Hom_{{kG}}(P_i,k)\)</span> where <span class="SimpleMath">\(P_i = \left(kG\right)^{b_i}\)</span> so that <span class="SimpleMath">\(H^i\left(G,k\right)\)</span> has a natural basis consisting of the maps sending the element <span class="SimpleMath">\(1_G\)</span> of the <span class="SimpleMath">\(j\)</span>th direct summand of <span class="SimpleMath">\(P_i\)</span> to <span class="SimpleMath">\(1_k\)</span> and all other direct summands to <span class="SimpleMath">\(0\)</span>, for <span class="SimpleMath">\(j=1,2,\ldots,b_i\)</span>, where <span class="SimpleMath">\(b_i\)</span> is the <span class="SimpleMath">\(kG\)</span>-rank of <span class="SimpleMath">\(P_i\)</span>.</p>

<p>The command <code class="keyw">CohomologyRing(C,n)</code> forms the vector space whose basis is the concatenation of the natural bases of <span class="SimpleMath">\(H^i\left(G,k\right)\)</span> for <span class="SimpleMath">\(i=1,2,\ldots,n\)</span> and computes all products of basis elements <span class="SimpleMath">\(x\)</span> and <span class="SimpleMath">\(y\)</span> for which <span class="SimpleMath">\(\deg x+\deg y \leq n\)</span>. Thinking of <span class="SimpleMath">\(H*(G,k)\)</span> in terms of it's multiplication table, this means that the function computes the upper left-hand corner of the multiplication table. If <span class="SimpleMath">\(\deg x + \deg y &gt; n\)</span>, the product <span class="SimpleMath">\(xy\)</span> is taken to be zero. Therefore, the ring returned by <code class="keyw">CohomologyRing</code> is <span class="SimpleMath">\(H*(G,k)/J\)</span> where <span class="SimpleMath">\(J\)</span> is the ideal of all elements of degree <span class="SimpleMath">\(&gt;n\)</span>.</p>

<p>The ring determined by <code class="keyw">CohomologyGenerators</code> and <code class="keyw">CohomologyRelators</code> is somewhat different. <code class="keyw">CohomologyGenerators</code> proceeds inductively, taking all natural basis elements of <span class="SimpleMath">\(H^1\left(G,k\right)\)</span> as generators, and for <span class="SimpleMath">\(i=2\ldots n\)</span>, taking all natural basis elements of <span class="SimpleMath">\(H^i\left(G,k\right)\)</span> which are <em>not</em> products of lower-degree elements as generators. Therefore, unless you know that there is an <span class="SimpleMath">\(n\)</span> for which there exists a generating set of <span class="SimpleMath">\(H*(G,k)\)</span> consisting of elements of degree <span class="SimpleMath">\(n\)</span> or less, then you are <em>not</em> guaranteed that the elements returned by the <code class="keyw">CohomologyGenerators</code> generate <span class="SimpleMath">\(H*(G,k)\)</span> as a ring. The knowledge of such an <span class="SimpleMath">\(n\)</span> is the subject of section <a href="chap2_mj.html#X87C9251687CD4247"><span class="RefLink">2.4</span></a>.</p>

<p>Similarly, <code class="keyw">CohomologyRelators</code> proceeds inductively until degree <span class="SimpleMath">\(n\)</span>, returning a list of polynomials which generate the ideal of relators of degree <span class="SimpleMath">\(n\)</span> or less. Again, you have to already know how big <span class="SimpleMath">\(n\)</span> should be.</p>

<p>The result of the preceding information is that there is a homomorphism <span class="SimpleMath">\(k\left\langle x_1,x_2,\ldots, x_m \right\rangle/ I \to H*(G,k)\)</span>, where <span class="SimpleMath">\(k\left\langle x_1,x_2,\ldots,x_m \right\rangle\)</span> is the graded polynomial ring over <span class="SimpleMath">\(k\)</span> in the non-commuting variables <span class="SimpleMath">\(x_1,x_2,\ldots,x_m\)</span>, having degrees the numbers in the list returned by <code class="keyw">CohomologyGenerators</code>, and <span class="SimpleMath">\(I\)</span> is the ideal in <span class="SimpleMath">\(k\left\langle x_1,x_2,\ldots, x_m \right\rangle\)</span> generated by the elements returned by <code class="keyw">CohomologyRelators(C,n)</code>.</p>

<p>Therefore, if there is a generator of degree greater than <span class="SimpleMath">\(n\)</span>, then <span class="SimpleMath">\(f\)</span> won't be surjective. Similarly, if there is a relator of degree greater than <span class="SimpleMath">\(n\)</span> which is not a consequence of lower degree relators, then <span class="SimpleMath">\(f\)</span> won't be injective. See section <a href="chap2_mj.html#X87C9251687CD4247"><span class="RefLink">2.4</span></a> for a discussion on how big <span class="SimpleMath">\(n\)</span> needs to be to ensure that <span class="SimpleMath">\(f\)</span> will be an isomorphism.</p>

<p><a id="X837261007B39795C" name="X837261007B39795C"></a></p>

<h4>2.7 <span class="Heading">Induced Maps</span></h4>

<p>Let <span class="SimpleMath">\(f: H \rightarrow G\)</span> be a group homomorphism. Then <span class="SimpleMath">\(f\)</span> induces a homomorphism on cohomology <span class="SimpleMath">\(H\ast(G,k) \rightarrow H\ast(H,k)\)</span> which is returned by the following function.</p>

<p><a id="X8608BD148307390B" name="X8608BD148307390B"></a></p>

<h5>2.7-1 InducedHomomorphismOnCohomology</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InducedHomomorphismOnCohomology</code>( <var class="Arg">C</var>, <var class="Arg">D</var>, <var class="Arg">f</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: the induced homomorphism on cohomology.</p>

<p>This function returns the induced homomorphism <span class="SimpleMath">\(H\ast(G,k) \rightarrow H\ast(H,k)\)</span> where the groups <span class="SimpleMath">\(H\)</span> and <span class="SimpleMath">\(G\)</span> are the components of the cohomology objects <code class="keyw">C</code> and <code class="keyw">D</code> and <span class="SimpleMath">\(f: H \rightarrow G\)</span> is a group homomorphism. If the cohomology rings have not yet been calculated, they will be computed to degree <span class="SimpleMath">\(n\)</span>, and in this case, they can then be accessed by calling <code class="keyw">CohomologyRing</code> (see <a href="chap2_mj.html#X7B77337486380998"><span class="RefLink">2.5-1</span></a>).</p>

<p><a id="X80798C0979D4E9DC" name="X80798C0979D4E9DC"></a></p>

<h5>2.7-2 SubgroupInclusion</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SubgroupInclusion</code>( <var class="Arg">H</var>, <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: the inclusion <span class="SimpleMath">\(H\rightarrow G\)</span></p>

<p>This function returns the group homomorphism <span class="SimpleMath">\(H\rightarrow G\)</span> when <span class="SimpleMath">\(H\)</span> is a subgroup of <span class="SimpleMath">\(G\)</span>. The returned map can be used as the <code class="keyw">f</code> argument of <code class="keyw">InducedHomomorphismOnCohomology</code>, in which case the induced homomorphism is the restriction map <span class="SimpleMath">\(Res: H\ast(G,k) \rightarrow H\ast(H,k)\)</span>.</p>

<p>The following example calculates the homomorphism on cohomology induced by the inclusion of the cyclic group of size 4 into the dihedral group of size 8.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:=DihedralGroup(8);H:=Subgroup(G,[G.2]);</span>
&lt;pc group of size 8 with 3 generators&gt;
Group([ f2 ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C:=CohomologyObject(H);D:=CohomologyObject(G);</span>
&lt;object&gt;
&lt;object&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i:=SubgroupInclusion(H,G);</span>
[ f2 ] -&gt; [ f2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Res:=InducedHomomorphismOnCohomology(C,D,i,10);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A:=CohomologyRing(D,10);</span>
&lt;algebra of dimension 66 over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LocateGeneratorsInCohomologyRing(D);</span>
[ v.2, v.3, v.6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A.1^Res; A.2^Res; A.3^Res; A.6^Res;</span>
v.1
0*v.1
v.2
v.3

</pre></div>

<p><a id="X7B541EB97BAB36D7" name="X7B541EB97BAB36D7"></a></p>

<h4>2.8 <span class="Heading">Massey Products</span></h4>

<p>See <a href="chapBib_mj.html#biBkraines">[3]</a> for the definitions and <a href="chapBib_mj.html#biBborge">[1]</a> for the details of the calculation using the Yoneda cocomplex. See also the file <code class="keyw">doc/explanation.*</code> for an explanation of the implementation.</p>

<p><a id="X7E3023CE86641F9E" name="X7E3023CE86641F9E"></a></p>

<h5>2.8-1 MasseyProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MasseyProduct</code>( <var class="Arg">x1</var>, <var class="Arg">x2</var>, <var class="Arg">...</var>, <var class="Arg">xn</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: the Massey product <span class="SimpleMath">\(\left\langle x1, x2, ... , xn\right\rangle\)</span>.</p>

<p>Given elements <span class="SimpleMath">\(x1, x2, \ldots , xn\)</span> of the ring returned by <code class="keyw">CohomologyRing</code> (see <a href="chap2_mj.html#X80B6849C835B7F19"><span class="RefLink">2.5</span></a>) this function computes the <span class="SimpleMath">\(n\)</span>-fold Massey product <span class="SimpleMath">\(\left\langle x1, x2, \ldots , xn \right\rangle\)</span> provided that the lower-degree Massey products <span class="SimpleMath">\(\left\langle xi, x{{i+1}}, \ldots , xj \right\rangle\)</span> vanish for all <span class="SimpleMath">\(1 \leq i &lt; j \leq n\)</span> and returns <code class="keyw">fail</code> otherwise.</p>

<p>As an example, recall that the cohomology rings of the cyclic groups <span class="SimpleMath">\(C_3\)</span> and <span class="SimpleMath">\(C_9\)</span> of sizes 3 and 9 over <span class="SimpleMath">\(k=GF(3)\)</span> are both given by <span class="SimpleMath">\(k\left\langle z,y \right\rangle/\left(z^2\right)\)</span>, so they are isomorphic as rings. However, the following example shows that <span class="SimpleMath">\(\left\langle z, z, z \right\rangle\)</span> is non-zero in <span class="SimpleMath">\(H*(C_3,k)\)</span> but is zero in <span class="SimpleMath">\(H*(C_9,k)\)</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A:=CohomologyRing(CyclicGroup(3),10);</span>
&lt;algebra of dimension 11 over GF(3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z:=Basis(A)[2];</span>
v.2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MasseyProduct(z,z);</span>
0*v.1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MasseyProduct(z,z,z);</span>
v.3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A:=CohomologyRing(CyclicGroup(9),10);</span>
&lt;algebra of dimension 11 over GF(3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z:=Basis(A)[2];</span>
v.2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MasseyProduct(z,z);</span>
0*v.1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MasseyProduct(z,z,z);</span>
0*v.1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MasseyProduct(z,z,z,z,z,z,z,z,z);</span>
v.3

</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapA_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chapA_mj.html">A</a>  <a href="chapB_mj.html">B</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
