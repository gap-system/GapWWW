<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (FinInG) - Chapter 2: Examples</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap2"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chapA_mj.html">A</a>  <a href="chapB_mj.html">B</a>  <a href="chapC_mj.html">C</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap2.html">[MathJax off]</a></p>
<p><a id="X7A489A5D79DA9E5C" name="X7A489A5D79DA9E5C"></a></p>
<div class="ChapSects"><a href="chap2_mj.html#X7A489A5D79DA9E5C">2 <span class="Heading">Examples</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X81660CB279889CB6">2.1 <span class="Heading">Elementary examples</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X8016E6857D53F2ED">2.1-1 <span class="Heading">subspaces of projective spaces</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7B99511887D41A95">2.1-2 <span class="Heading">Subspaces of classical polar spaces</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X8555398C83677C27">2.1-3 <span class="Heading">Underlying objects</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X8771ACB879E479C6">2.1-4 <span class="Heading">Constructing polar spaces</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X85D3BB2A8274DDCB">2.1-5 <span class="Heading">Some collineation groups</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X825F78F57E309197">2.2 <span class="Heading">Some objects with interesting combinatorial properties</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X815BB30986E84DB1">2.2-1 <span class="Heading">The Tits ovoid</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7E79F18B8170B4B3">2.2-2 <span class="Heading">Lines meeting a hermitian curve</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X85C255FD78C50992">2.2-3 <span class="Heading">The Patterson ovoid</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X80B93785876EF3E0">2.2-4 <span class="Heading">A hyperoval</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X876240A479A5717C">2.3 <span class="Heading">Geometry morphisms</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X79CE092B7E17DF24">2.3-1 <span class="Heading">Isomorphic polar spaces</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X83ADB5AE8624C74C">2.3-2 <span class="Heading">Intertwiners</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7C7438AB86A493FE">2.3-3 <span class="Heading">Klein correspondence</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X869EB94D841AE028">2.3-4 <span class="Heading">Embedding in a subspace</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7FE8E4BF7E700E65">2.3-5 <span class="Heading">Subgeometries</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X838BBDD97FA03FD0">2.3-6 <span class="Heading">Embedding by field reduction</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X855C8E6D819EB975">2.4 <span class="Heading">Some geometrical objects</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X8475841778D3BEEC">2.4-1 <span class="Heading">Spreads of <span class="SimpleMath">\(W(5,3)\)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X81F516D07E8165B9">2.4-2 <span class="Heading">Distance-6 spread of the split Cayley hexagon</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X7F13364A7EEA2AD1">2.5 <span class="Heading">Some particular incidence geometries</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X79623B9E7D5816B3">2.5-1 <span class="Heading">The split Cayley hexagon</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X8528558E87DE72C5">2.5-2 <span class="Heading">An (apartment of) a building of type <span class="SimpleMath">\(E_6\)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7B783473852C7899">2.5-3 <span class="Heading">A rank 4 geometry for <span class="SimpleMath">\(PSL(2,11)\)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X80128FF17BB62C83">2.5-4 <span class="Heading">The Ree-Tits octagon of order <span class="SimpleMath">\([2,4]\)</span> as coset geometry</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X7BA462527B2777BC">2.6 <span class="Heading">Elation generalised quadrangles</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7E3707857A74AB5E">2.6-1 <span class="Heading">The classical q-clan</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X83357ED78789111E">2.6-2 <span class="Heading">Two ways to construct a flock generalised quadrangle from a Kantor-Knuth semifield q-clan</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X87EC44BF7F24486E">2.7 <span class="Heading">Algebraic varieties</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7ABCF9637B60FF37">2.7-1 <span class="Heading">A projective variety</span></a>
</span>
</div></div>
</div>

<h3>2 <span class="Heading">Examples</span></h3>

<p>In this chapter we provide some simple examples of the use of <strong class="pkg">FinInG</strong>.</p>

<p><a id="X81660CB279889CB6" name="X81660CB279889CB6"></a></p>

<h4>2.1 <span class="Heading">Elementary examples</span></h4>

<p><a id="X8016E6857D53F2ED" name="X8016E6857D53F2ED"></a></p>

<h5>2.1-1 <span class="Heading">subspaces of projective spaces</span></h5>

<p>The following example shows how to create some subspaces of a projective space, test their incidence, and determine their span and intersection. Projective spaces are considered as incidence geometries too. Incidence, to be tested with <code class="file">IsIncident</code> or equivalently <code class="file">\*</code>, is symmetrized set-theoretic containment, the latter which can be tested through the operation <code class="file">in</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg := PG(3,8);</span>
ProjectiveSpace(3, 8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vec := [0,1,0,1]*Z(8)^0;</span>
[ 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">point := VectorSpaceToElement(pg,vec);</span>
&lt;a point in ProjectiveSpace(3, 8)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0,0,1,1],[0,1,0,0]]*Z(8)^0;</span>
[ [ 0*Z(2), 0*Z(2), Z(2)^0, Z(2)^0 ], [ 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">line := VectorSpaceToElement(pg,mat);</span>
&lt;a line in ProjectiveSpace(3, 8)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat2 := [[1,0,0,1],[1,0,1,0],[1,1,0,0]]*Z(8)^0;</span>
[ [ Z(2)^0, 0*Z(2), 0*Z(2), Z(2)^0 ], [ Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2) ], 
  [ Z(2)^0, Z(2)^0, 0*Z(2), 0*Z(2) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">plane := VectorSpaceToElement(pg,mat2);</span>
&lt;a plane in ProjectiveSpace(3, 8)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIncident(point,line);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIncident(line,point);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">point * line;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">line * point</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">point in line;</span>
Syntax error: ; expected
point in line;
    ^
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">line in point;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIncident(point,plane);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIncident(line,plane);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">line in plane;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">plane2 := Span(point,line);</span>
&lt;a plane in ProjectiveSpace(3, 8)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Meet(plane,plane2);</span>
&lt;a line in ProjectiveSpace(3, 8)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat3 := [[1,0,0,0],[0,0,0,1]]*Z(8)^0;</span>
[ [ Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2) ], [ 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">line2 := VectorSpaceToElement(pg,mat3);</span>
&lt;a line in ProjectiveSpace(3, 8)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Meet(line,line2);</span>
&lt; empty subspace &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Span(plane,plane2);</span>
ProjectiveSpace(3, 8)

</pre></div>

<p><a id="X7B99511887D41A95" name="X7B99511887D41A95"></a></p>

<h5>2.1-2 <span class="Heading">Subspaces of classical polar spaces</span></h5>

<p><strong class="pkg">FinInG</strong> provides classical polar spaces. Subspaces can be constructed the same way as subspaces of projective spaces. Upon construction, it is checked whether the given vector space does determine a subspace of the polar space. Subspaces of polar spaces are also subspaces of the ambient projective space. Operations like <code class="file">Span</code> and <code class="file">Meet</code> are naturally applicable. However, the span of two subspaces might not be a subspace of the polar space anymore, and if the two subspaces belong to two different polar spaces in the same ambient projective space, it cannot be determined in which polar space the span should be constructed. Therefore the result of <code class="file">Span</code> of two subspaces of a polar space is a subspace of the ambient projective space. It can be checked whether the result belongs to a polar space using <code class="file">in</code>. This illustrates very well a general philosophy: a subspace of a polar space, and more generally, an element of any incidence structure is always aware of its ambient geometry. This example also illustrates how to create an element that belongs to the polar space from the subspace of the ambient projective geometry by using <code class="file">ElementToElement</code>. Finally note the behaviour of <code class="file">=</code> applied on the two subspaces. Clearly, a subspace of a polar space is really also a subspace of the ambient projective space.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := EllipticQuadric(5,7);</span>
Q-(5, 7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vec := [1,0,0,0,0,0]*Z(7)^0;</span>
[ Z(7)^0, 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">point := VectorSpaceToElement(ps,vec);</span>
Error, &lt;v&gt; does not generate an element of &lt;geom&gt; called from
&lt;function "unknown"&gt;( &lt;arguments&gt; )
 called from read-eval loop at line 10 of *stdin*
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
<span class="GAPbrkprompt">brk&gt;</span> <span class="GAPinput">quit;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EquationForPolarSpace(ps);</span>
x_1^2+x_2^2+x_3*x_4+x_5*x_6
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vec := [0,0,1,0,0,0]*Z(7)^0;</span>
[ 0*Z(7), 0*Z(7), Z(7)^0, 0*Z(7), 0*Z(7), 0*Z(7) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">point := VectorSpaceToElement(ps,vec);</span>
&lt;a point in Q-(5, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vec2 := [0,0,0,1,0,0]*Z(7)^0;</span>
[ 0*Z(7), 0*Z(7), 0*Z(7), Z(7)^0, 0*Z(7), 0*Z(7) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">point2 := VectorSpaceToElement(ps,vec2);</span>
&lt;a point in Q-(5, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">line := Span(point,point2);</span>
&lt;a line in ProjectiveSpace(5, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0,0,1,0,0,0],[0,0,0,0,1,0]]*Z(7)^0;</span>
[ [ 0*Z(7), 0*Z(7), Z(7)^0, 0*Z(7), 0*Z(7), 0*Z(7) ], 
  [ 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), Z(7)^0, 0*Z(7) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">line2 := VectorSpaceToElement(ps,mat);</span>
&lt;a line in Q-(5, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">meet := Meet(line,line2);</span>
&lt;a point in ProjectiveSpace(5, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">meet in ps;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">point3 := ElementToElement(ps,meet);</span>
&lt;a point in Q-(5, 7)&gt;

</pre></div>

<p><a id="X8555398C83677C27" name="X8555398C83677C27"></a></p>

<h5>2.1-3 <span class="Heading">Underlying objects</span></h5>

<p>Subspaces of projective spaces and polar spaces (and in general, elements of incidence structures), are determined by a mathematical object, called in <strong class="pkg">FinInG</strong> the <em>underlying object</em>. The operation <code class="file">UnderlyingObject</code> simply returns this underlying object. For elements determined by vectors or sub vector spaces, the underlying objects are a vector or a matrix. To represent these objects and to do very efficient orbit calculations under groups, we use the <strong class="pkg">cvec</strong>. This can be noted when applying <code class="file">UnderlyingObject</code>. The operation <code class="file">Unpack</code> simply converts the cvec objects into GAP vectors and matrices. The example also illustrates how the underlying object of an element of an affine spaces looks like.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg := PG(3,169);</span>
ProjectiveSpace(3, 169)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := Random(Points(pg));</span>
&lt;a point in ProjectiveSpace(3, 169)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingObject(p);</span>
&lt;cvec over GF(13,2) of length 4&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Unpack(last);</span>
[ Z(13)^0, Z(13^2)^49, Z(13^2)^31, Z(13^2)^143 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := Random(Lines(pg));</span>
&lt;a line in ProjectiveSpace(3, 169)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingObject(l);</span>
&lt;cmat 2x4 over GF(13,2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Unpack(last);</span>
[ [ Z(13)^0, 0*Z(13), 0*Z(13), Z(13^2)^96 ], 
  [ 0*Z(13), Z(13)^0, Z(13^2)^113, Z(13^2)^99 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">quadric := EllipticQuadric(5,2);</span>
Q-(5, 2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">line := Random(Lines(quadric));</span>
&lt;a line in Q-(5, 2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingObject(line);</span>
&lt;cmat 2x6 over GF(2,1)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Unpack(last);</span>
[ [ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2), Z(2)^0 ], 
  [ 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0, Z(2)^0, 0*Z(2) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ag := AG(4,3);</span>
AG(4, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">plane := Random(Planes(ag));</span>
&lt;a plane in AG(4, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingObject(plane);</span>
[ &lt;cvec over GF(3,1) of length 4&gt;, &lt;cmat 2x4 over GF(3,1)&gt; ]

</pre></div>

<p><a id="X8771ACB879E479C6" name="X8771ACB879E479C6"></a></p>

<h5>2.1-4 <span class="Heading">Constructing polar spaces</span></h5>

<p><strong class="pkg">FinInG</strong> provides the classical polar spaces as the geometries of which the subspaces are represented by the totally isotropic (resp. totally singular) vector subspaces with relation to a chosen sesquilinear (resp. quadratic form). The user may choose any non-degenerate (resp. non-singular) form to construct the polar space. The usage of the forms makes <strong class="pkg">FinInG</strong> dependent on the package <strong class="pkg">forms</strong>. Shortcuts to polar spaces in <em>standard</em> representation are included. Detailed information can be found in Section <a href="chap7_mj.html#X850CD32686B0656B"><span class="RefLink">7.2</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HermitianPolarSpace(4,9);</span>
H(4, 3^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EquationForPolarSpace(ps);</span>
x_1^4+x_2^4+x_3^4+x_4^4+x_5^4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HyperbolicQuadric(5,7);</span>
Q+(5, 7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EquationForPolarSpace(ps);</span>
x_1*x_2+x_3*x_4+x_5*x_6
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := SymplecticSpace(3,3);</span>
W(3, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EquationForPolarSpace(ps);</span>
x1*y2-x2*y1+x3*y4-x4*y3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := IdentityMat(4,GF(11));</span>
[ [ Z(11)^0, 0*Z(11), 0*Z(11), 0*Z(11) ], 
  [ 0*Z(11), Z(11)^0, 0*Z(11), 0*Z(11) ], 
  [ 0*Z(11), 0*Z(11), Z(11)^0, 0*Z(11) ], 
  [ 0*Z(11), 0*Z(11), 0*Z(11), Z(11)^0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := BilinearFormByMatrix(mat,GF(11));</span>
&lt; bilinear form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := PolarSpace(form);</span>
&lt;polar space in ProjectiveSpace(3,GF(11)): x_1^2+x_2^2+x_3^2+x_4^2=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Rank(ps);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps;</span>
Q+(3, 11): x_1^2+x_2^2+x_3^2+x_4^2=0

</pre></div>

<p><a id="X85D3BB2A8274DDCB" name="X85D3BB2A8274DDCB"></a></p>

<h5>2.1-5 <span class="Heading">Some collineation groups</span></h5>

<p>In principle, the full group of collineations of almost any incidence structure can be computed in <strong class="pkg">FinInG</strong>. Mathematically, this is almost obvious for projective spaces and affine spaces. For classical polar spaces, the particular forms plays a role. The coordinate change capabilities of the package <strong class="pkg">forms</strong>, together with the standard theory (see <a href="chapBib_mj.html#biBKleidmanLiebeck">[KL90]</a>), ensure that the full collineation group of a classical polar space can be relatively easily obtained. The computation of the full collineation group of particular incidence structures, such as generalised polygons, may rely on the computation of the automorphism group of an underlying incidence graph, which is done by using nauty through the package <strong class="pkg">GRAPE</strong>. Note that the elements of a projective collineation group are semilinear maps, they consist of a matrix together with a field automorphism.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg := PG(3,4);</span>
ProjectiveSpace(3, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coll := CollineationGroup(pg);</span>
The FinInG collineation group PGammaL(4,4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens := GeneratorsOfGroup(coll);</span>
[ &lt; a collineation: &lt;cmat 4x4 over GF(2,2)&gt;, F^0&gt;, 
  &lt; a collineation: &lt;cmat 4x4 over GF(2,2)&gt;, F^0&gt;, 
  &lt; a collineation: &lt;cmat 4x4 over GF(2,2)&gt;, F^2&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingMatrix(gens[2]);</span>
&lt;cmat 4x4 over GF(2,2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Unpack(last);</span>
[ [ Z(2)^0, 0*Z(2), 0*Z(2), Z(2)^0 ], [ Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2) ], 
  [ 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2) ], [ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">as := AffineSpace(3,4);</span>
AG(3, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coll := CollineationGroup(as);</span>
AGammaL(3,4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsOfGroup(coll);</span>
[ &lt; a collineation: &lt;cmat 4x4 over GF(2,2)&gt;, F^0&gt;, 
  &lt; a collineation: &lt;cmat 4x4 over GF(2,2)&gt;, F^0&gt;, 
  &lt; a collineation: &lt;cmat 4x4 over GF(2,2)&gt;, F^0&gt;, 
  &lt; a collineation: &lt;cmat 4x4 over GF(2,2)&gt;, F^2&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gp := SplitCayleyHexagon(3);</span>
H(3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coll:= CollineationGroup(gp);</span>
#I  for Split Cayley Hexagon
#I  Computing nice monomorphism...
#I  Found permutation domain...
G_2(3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsOfGroup(coll);</span>
[ &lt; a collineation: &lt;cmat 7x7 over GF(3,1)&gt;, F^0&gt;, 
  &lt; a collineation: &lt;cmat 7x7 over GF(3,1)&gt;, F^0&gt;, 
  &lt; a collineation: &lt;cmat 7x7 over GF(3,1)&gt;, F^0&gt;, 
  &lt; a collineation: &lt;cmat 7x7 over GF(3,1)&gt;, F^0&gt;, 
  &lt; a collineation: &lt;cmat 7x7 over GF(3,1)&gt;, F^0&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">egq := EGQByqClan(LinearqClan(3));</span>
#I  Computed Kantor family. Now computing EGQ...
&lt;EGQ of order [ 9, 3 ] and basepoint 0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coll := CollineationGroup(egq);</span>
#I  Computing incidence graph of generalised polygon...
#I  Using elation of the collineation group...
&lt;permutation group of size 26127360 with 6 generators&gt;

</pre></div>

<p><a id="X825F78F57E309197" name="X825F78F57E309197"></a></p>

<h4>2.2 <span class="Heading">Some objects with interesting combinatorial properties</span></h4>

<p>The examples here are meant to give a flavour of how to explore geometrical objects from different point of views.</p>

<p><a id="X815BB30986E84DB1" name="X815BB30986E84DB1"></a></p>

<h5>2.2-1 <span class="Heading">The Tits ovoid</span></h5>

<p>In this example we consider the Tits ovoid in <span class="SimpleMath">\(PG(3,8)\)</span>. We explicitly check the intersection number of the Tits-ovoid with planes of the projective space, and compute its stabiliser group inside the homography group of <span class="SimpleMath">\(PG(3,8)\)</span>. The use of <code class="file">;;</code> after a command suppresses its output, which is particularly interesting if the output is a long list. The operation <code class="file">Collected</code> is self-explanatory, and a very useful GAP command. The computed stabiliser is the Suzuki group <span class="SimpleMath">\(Sz(8)\)</span>, a finite simple group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := 8;</span>
8
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg := PG(3,q);</span>
ProjectiveSpace(3, 8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := GF(q);</span>
GF(2^3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vecs := Union(List(f,x-&gt;List(f,y-&gt;[One(f),x*y+x^6+y^4,x,y])));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Add(vecs,[0,1,0,0]*Z(q)^0);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ovoid := List(vecs,x-&gt;VectorSpaceToElement(pg,x));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">numbers := List(Planes(pg),x-&gt;Number(ovoid,y-&gt;y in x));</span>
[ 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 1, 1, 9, 
  9, 9, 9, 9, 9, 9, 9, 9, 1, 9, 9, 1, 9, 9, 9, 9, 9, 1, 1, 9, 9, 9, 9, 9, 9, 
  9, 9, 9, 9, 9, 9, 1, 9, 9, 9, 9, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 1, 
  9, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 1, 9, 9, 9, 9, 9, 1, 
  9, 9, 1, 9, 9, 1, 9, 9, 9, 9, 9, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 
  9, 9, 9, 9, 9, 9, 9, 9, 1, 9, 9, 9, 1, 9, 9, 9, 9, 9, 1, 9, 9, 9, 1, 9, 9, 
  1, 9, 9, 9, 9, 9, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 1, 9, 1, 9, 9, 9, 9, 
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 1, 1, 9, 9, 9, 9, 
  9, 9, 9, 9, 9, 9, 1, 9, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 
  9, 9, 9, 9, 1, 9, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 1, 9, 9, 1, 9, 9, 9, 9, 9, 
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 1, 9, 9, 9, 9, 9, 
  9, 1, 9, 9, 1, 9, 9, 1, 9, 9, 9, 9, 9, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 
  9, 9, 1, 9, 9, 9, 9, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 1, 9, 9, 9, 1, 
  9, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 1, 9, 1, 9, 9, 
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 1, 9, 9, 9, 9, 1, 9, 9, 9, 9, 
  9, 9, 9, 9, 9, 9, 9, 9, 1, 9, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 
  9, 9, 9, 9, 9, 1, 9, 9, 1, 9, 9, 9, 9, 9, 1, 9, 9, 9, 1, 9, 9, 9, 9, 9, 9, 
  9, 9, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 1, 9, 9, 9, 
  9, 9, 9, 9, 9, 9, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 1, 9, 9, 9, 9, 9, 9, 9, 9, 
  9, 1, 9, 9, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 1, 
  9, 1, 9, 9, 9, 9, 9, 9, 9, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Collected(numbers);</span>
[ [ 1, 65 ], [ 9, 520 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">group := HomographyGroup(pg);</span>
The FinInG projectivity group PGL(4,8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">stab := FiningSetwiseStabiliser(group,ovoid);</span>
#I  Computing adjusted stabilizer chain...
&lt;projective collineation group with 5 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">time;</span>
55290
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSimple(stab);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order(stab);</span>
29120

</pre></div>

<p><a id="X7E79F18B8170B4B3" name="X7E79F18B8170B4B3"></a></p>

<h5>2.2-2 <span class="Heading">Lines meeting a hermitian curve</span></h5>

<p>Here we see how the lines of a projective plane PG(2,q<sup>2 </sup>) meet a hermitian curve. It is well known that every line meets in either 1 or <span class="SimpleMath">\(q+1\)</span> points. Note that the last comment takes a while to complete.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h:=HermitianPolarSpace(2, 7^2);</span>
H(2, 7^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg := AmbientSpace( h );</span>
ProjectiveSpace(2, 49)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lines := Lines( pg );</span>
&lt;lines of ProjectiveSpace(2, 49)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">curve := AsList( Points( h ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(curve);</span>
344
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Collected( List(lines, t -&gt; Number(curve, c-&gt; c in t)));</span>
[ [ 1, 344 ], [ 8, 2107 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">time;</span>
26412
 
</pre></div>

<p><a id="X85C255FD78C50992" name="X85C255FD78C50992"></a></p>

<h5>2.2-3 <span class="Heading">The Patterson ovoid</span></h5>

<p>In this example, we construct the unique ovoid of the parabolic quadric <span class="SimpleMath">\(Q(6,3)\)</span>, first discovered by Patterson, but for which was given a nice construction by E. E. Shult. We begin with the ``sums of squares'' quadratic form over <span class="SimpleMath">\(GF(3)\)</span> and the associated polar space.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMat(7, GF(3));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := QuadraticFormByMatrix(id, GF(3));</span>
&lt; quadratic form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := PolarSpace( form );</span>
&lt;polar space in ProjectiveSpace(
6,GF(3)): x_1^2+x_2^2+x_3^2+x_4^2+x_5^2+x_6^2+x_7^2=0 &gt;
</pre></div>

<p>The construction of the ovoid (a la Shult):</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">psl32 := PSL(3,2);</span>
Group([ (4,6)(5,7), (1,2,4)(3,6,5) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">reps:=[[1,1,1,0,0,0,0], [-1,1,1,0,0,0,0],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1,-1,1,0,0,0,0], [1,1,-1,0,0,0,0]]*Z(3)^0;</span>
[ [ Z(3)^0, Z(3)^0, Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3) ], 
  [ Z(3), Z(3)^0, Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3) ], 
  [ Z(3)^0, Z(3), Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3) ], 
  [ Z(3)^0, Z(3)^0, Z(3), 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ovoid := Union( List(reps, x-&gt; Orbit(psl32, x, Permuted)) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ovoid := List(ovoid, x -&gt; VectorSpaceToElement(ps, x));;</span>
</pre></div>

<p>We check that this is indeed an ovoid. The observant reader will notice <em>#I Computing collineation group of canonical polar space...</em> which is caused by the command <code class="file">AsList</code> applied to the collection of elements <var class="Arg">planes</var>. The use of <code class="file">AsList</code> invokes the computation of all elements in <var class="Arg">planes</var> as an orbit under the collineation group of the ambient polar space. The reader is invited to redo, in a new GAP session, the same example omitting the <code class="file">AsList</code> command, just defining <code class="file">planes := Planes(ps);;</code>. The result will be te same, but the computation of all elements will now be done using an enumerator, and will be slower.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">planes := AsList(Planes( ps ));;</span>
#I  Computing collineation group of canonical polar space...
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll(planes, p -&gt; Number(ovoid, x -&gt; x * p) = 1);</span>
true
</pre></div>

<p>The stabiliser is interesting since it yields the embedding of <span class="SimpleMath">\(Sp(6,2)\)</span> in <span class="SimpleMath">\(PO(7,3)\)</span>. To efficiently compute the set-wise stabiliser, we refer to the induced permutation representation.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := IsometryGroup( ps );</span>
#I  Computing collineation group of canonical polar space...
&lt;projective collineation group of size 9170703360 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">stabovoid := FiningSetwiseStabiliser(g, ovoid);</span>
#I  Computing adjusted stabilizer chain...
&lt;projective collineation group with 13 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DisplayCompositionSeries(stabovoid);</span>
G (size 1451520)
 | B(3,2) = O(7,2) ~ C(3,2) = S(6,2)
1 (size 1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrbitLengths(stabovoid, ovoid);</span>
[ 28 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsTransitive(stabovoid, ovoid);</span>
true 
</pre></div>

<p><a id="X80B93785876EF3E0" name="X80B93785876EF3E0"></a></p>

<h5>2.2-4 <span class="Heading">A hyperoval</span></h5>

<p>In this example, we consider a hyperoval of the projective plane <span class="SimpleMath">\(PG(2,4)\)</span>, that is, six points no three collinear. We will construct such a hyperoval by some basic explorations into particular properties of the projective plane <span class="SimpleMath">\(PG(2,4)\)</span>. The projective plane is initialised, its points are computed and listed; then a standard frame is constructed, of which we may assume that it is a subset of the hyperoval. Finally, the stabiliser group of the hyperoval is computed, and it is checked that this group is isomorphic with the symmetric group on six elements.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg := ProjectiveSpace(2,4);</span>
ProjectiveSpace(2, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">points := Points(pg);</span>
&lt;points of ProjectiveSpace(2, 4)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pointslist := AsList(points);</span>
[ &lt;a point in ProjectiveSpace(2, 4)&gt;, &lt;a point in ProjectiveSpace(2, 4)&gt;, 
  &lt;a point in ProjectiveSpace(2, 4)&gt;, &lt;a point in ProjectiveSpace(2, 4)&gt;, 
  &lt;a point in ProjectiveSpace(2, 4)&gt;, &lt;a point in ProjectiveSpace(2, 4)&gt;, 
  &lt;a point in ProjectiveSpace(2, 4)&gt;, &lt;a point in ProjectiveSpace(2, 4)&gt;, 
  &lt;a point in ProjectiveSpace(2, 4)&gt;, &lt;a point in ProjectiveSpace(2, 4)&gt;, 
  &lt;a point in ProjectiveSpace(2, 4)&gt;, &lt;a point in ProjectiveSpace(2, 4)&gt;, 
  &lt;a point in ProjectiveSpace(2, 4)&gt;, &lt;a point in ProjectiveSpace(2, 4)&gt;, 
  &lt;a point in ProjectiveSpace(2, 4)&gt;, &lt;a point in ProjectiveSpace(2, 4)&gt;, 
  &lt;a point in ProjectiveSpace(2, 4)&gt;, &lt;a point in ProjectiveSpace(2, 4)&gt;, 
  &lt;a point in ProjectiveSpace(2, 4)&gt;, &lt;a point in ProjectiveSpace(2, 4)&gt;, 
  &lt;a point in ProjectiveSpace(2, 4)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(pointslist[1]);</span>
 . . 1
</pre></div>

<p>Now we may assume that our hyperoval contains the fundamental frame.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">frame := [[1,0,0],[0,1,0],[0,0,1],[1,1,1]]*Z(2)^0;</span>
[ [ Z(2)^0, 0*Z(2), 0*Z(2) ], [ 0*Z(2), Z(2)^0, 0*Z(2) ], 
  [ 0*Z(2), 0*Z(2), Z(2)^0 ], [ Z(2)^0, Z(2)^0, Z(2)^0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">frame := List(frame,x -&gt; VectorSpaceToElement(pg,x));</span>
[ &lt;a point in ProjectiveSpace(2, 4)&gt;, &lt;a point in ProjectiveSpace(2, 4)&gt;, 
  &lt;a point in ProjectiveSpace(2, 4)&gt;, &lt;a point in ProjectiveSpace(2, 4)&gt; ]
</pre></div>

<p>Alternatively, we could use:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">frame := StandardFrame( pg );</span>
[ &lt;a point in ProjectiveSpace(2, 4)&gt;, &lt;a point in ProjectiveSpace(2, 4)&gt;, 
  &lt;a point in ProjectiveSpace(2, 4)&gt;, &lt;a point in ProjectiveSpace(2, 4)&gt; ]
</pre></div>

<p>There are six secant lines to this frame (``four choose two''). So we put together these secant lines from the pairs of points of this frame.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pairs := Combinations(frame,2);</span>
[ [ &lt;a point in ProjectiveSpace(2, 4)&gt;, &lt;a point in ProjectiveSpace(2, 4)&gt; ], 
  [ &lt;a point in ProjectiveSpace(2, 4)&gt;, &lt;a point in ProjectiveSpace(2, 4)&gt; ], 
  [ &lt;a point in ProjectiveSpace(2, 4)&gt;, &lt;a point in ProjectiveSpace(2, 4)&gt; ], 
  [ &lt;a point in ProjectiveSpace(2, 4)&gt;, &lt;a point in ProjectiveSpace(2, 4)&gt; ], 
  [ &lt;a point in ProjectiveSpace(2, 4)&gt;, &lt;a point in ProjectiveSpace(2, 4)&gt; ], 
  [ &lt;a point in ProjectiveSpace(2, 4)&gt;, &lt;a point in ProjectiveSpace(2, 4)&gt; ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">secants := List(pairs,p -&gt; Span(p[1],p[2]));</span>
[ &lt;a line in ProjectiveSpace(2, 4)&gt;, &lt;a line in ProjectiveSpace(2, 4)&gt;, 
  &lt;a line in ProjectiveSpace(2, 4)&gt;, &lt;a line in ProjectiveSpace(2, 4)&gt;, 
  &lt;a line in ProjectiveSpace(2, 4)&gt;, &lt;a line in ProjectiveSpace(2, 4)&gt; ]
</pre></div>

<p>By a counting argument, it is known that the frame of <span class="SimpleMath">\(PG(2,4)\)</span> completes uniquely to a hyperoval.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">leftover := Filtered(pointslist,t-&gt;not ForAny(secants,s-&gt;t in s));</span>
[ &lt;a point in ProjectiveSpace(2, 4)&gt;, &lt;a point in ProjectiveSpace(2, 4)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hyperoval := Union(frame,leftover);</span>
[ &lt;a point in ProjectiveSpace(2, 4)&gt;, &lt;a point in ProjectiveSpace(2, 4)&gt;, 
  &lt;a point in ProjectiveSpace(2, 4)&gt;, &lt;a point in ProjectiveSpace(2, 4)&gt;, 
  &lt;a point in ProjectiveSpace(2, 4)&gt;, &lt;a point in ProjectiveSpace(2, 4)&gt; ]
</pre></div>

<p>This hyperoval has the symmetric group on six symbols as its stabiliser, which can easily be calculated:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := CollineationGroup(pg);</span>
The FinInG collineation group PGammaL(3,4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">stab := Stabilizer(g,Set(hyperoval),OnSets);</span>
&lt;projective collineation group of size 720&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription(stab);</span>
"S6" 
</pre></div>

<p><a id="X876240A479A5717C" name="X876240A479A5717C"></a></p>

<h4>2.3 <span class="Heading">Geometry morphisms</span></h4>

<p>A geometry morphism in <strong class="pkg">FinInG</strong> is a map between (a subset of) the elements of one geometry to (a subset of) the elements of a second geometry, preserving the incidence. Geometry morphisms are not necessarily type preserving. This section is meant to illustrate, in a non exhaustive way the basis philisophy behind geometry morphisms in <strong class="pkg">FinInG</strong>.</p>

<p><a id="X79CE092B7E17DF24" name="X79CE092B7E17DF24"></a></p>

<h5>2.3-1 <span class="Heading">Isomorphic polar spaces</span></h5>

<p>We've seen already that a polar space can be constructed from any non-degenerate sesquilinear or non-singular quadratic form. An isomorphism between polar spaces of the same type, can easily be obtained. This example illustrates <code class="file">IsomorphismPolarSpaces</code>, which is in its basic use self-explanatory, and the use of the obtained map to compute images and pre-images of elements.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat1 := IdentityMat(4,GF(16));</span>
[ [ Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2) ], [ 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2) ], 
  [ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ], [ 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form1 := HermitianFormByMatrix(mat1,GF(16));</span>
&lt; hermitian form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps1 := PolarSpace(form1);</span>
&lt;polar space in ProjectiveSpace(3,GF(2^4)): x_1^5+x_2^5+x_3^5+x_4^5=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat2 := [[0,1,0,0],[1,0,0,0],[0,0,0,1],[0,0,1,0]]*Z(16)^0;</span>
[ [ 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2) ], [ Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2) ], 
  [ 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0 ], [ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form2 := HermitianFormByMatrix(mat2,GF(16));</span>
&lt; hermitian form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps2 := PolarSpace(form2);</span>
&lt;polar space in ProjectiveSpace(
3,GF(2^4)): x_1^4*x_2+x_1*x_2^4+x_3^4*x_4+x_3*x_4^4=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">map := IsomorphismPolarSpaces(ps1,ps2);</span>
#I  No intertwiner computed. One of the polar spaces must have a collineation group computed
&lt;geometry morphism from &lt;Elements of H(3, 
4^2): x_1^5+x_2^5+x_3^5+x_4^5=0&gt; to &lt;Elements of H(3, 
4^2): x_1^4*x_2+x_1*x_2^4+x_3^4*x_4+x_3*x_4^4=0&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := Random(Points(ps1));</span>
&lt;a point in H(3, 4^2): x_1^5+x_2^5+x_3^5+x_4^5=0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p^map;</span>
&lt;a point in H(3, 4^2): x_1^4*x_2+x_1*x_2^4+x_3^4*x_4+x_3*x_4^4=0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := Random(Lines(ps2));</span>
&lt;a line in H(3, 4^2): x_1^4*x_2+x_1*x_2^4+x_3^4*x_4+x_3*x_4^4=0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreImageElm(map,l);</span>
&lt;a line in H(3, 4^2): x_1^5+x_2^5+x_3^5+x_4^5=0&gt;
 
</pre></div>

<p><a id="X83ADB5AE8624C74C" name="X83ADB5AE8624C74C"></a></p>

<h5>2.3-2 <span class="Heading">Intertwiners</span></h5>

<p>We reconsider the previous example. The observant reader might have noticed the message <em>#I No intertwiner computed...</em>. Given a geometry morphism <span class="SimpleMath">\(f\)</span> from <span class="SimpleMath">\(S\)</span> to <span class="SimpleMath">\(S'\)</span>, an intertwiner φ is a map from the automorphism group of <span class="SimpleMath">\(S\)</span> to the automorphism group of <span class="SimpleMath">\(S'\)</span>, such that for every element <span class="SimpleMath">\(p\)</span> of <span class="SimpleMath">\(S\)</span> and every automorphism <span class="SimpleMath">\(g\)</span> of <span class="SimpleMath">\(S\)</span>, we have</p>

<p class="center">\[f(p<sup>g</sup>)=f(p)<sup>φ(g)</sup>.\]</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat1 := IdentityMat(4,GF(16));</span>
[ [ Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2) ], [ 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2) ], 
  [ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ], [ 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form1 := HermitianFormByMatrix(mat1,GF(16));</span>
&lt; hermitian form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps1 := PolarSpace(form1);</span>
&lt;polar space in ProjectiveSpace(3,GF(2^4)): x_1^5+x_2^5+x_3^5+x_4^5=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat2 := [[0,1,0,0],[1,0,0,0],[0,0,0,1],[0,0,1,0]]*Z(16)^0;</span>
[ [ 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2) ], [ Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2) ], 
  [ 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0 ], [ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form2 := HermitianFormByMatrix(mat2,GF(16));</span>
&lt; hermitian form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps2 := PolarSpace(form2);</span>
&lt;polar space in ProjectiveSpace(
3,GF(2^4)): x_1^4*x_2+x_1*x_2^4+x_3^4*x_4+x_3*x_4^4=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CollineationGroup(ps1);</span>
#I  Computing collineation group of canonical polar space...
&lt;projective collineation group of size 4073472000 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">map := IsomorphismPolarSpaces(ps1,ps2);</span>
&lt;geometry morphism from &lt;Elements of H(3, 
4^2): x_1^5+x_2^5+x_3^5+x_4^5=0&gt; to &lt;Elements of H(3, 
4^2): x_1^4*x_2+x_1*x_2^4+x_3^4*x_4+x_3*x_4^4=0&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := Intertwiner(map);</span>
MappingByFunction( &lt;projective collineation group of size 4073472000 with 
3 generators&gt;, &lt;projective collineation group of size 4073472000 with 
3 generators&gt;, function( y ) ... end, function( x ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := Random(CollineationGroup(ps1));</span>
&lt; a collineation: &lt;cmat 4x4 over GF(2,4)&gt;, F^4&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h := g^phi;</span>
&lt; a collineation: &lt;cmat 4x4 over GF(2,4)&gt;, F^4&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h in CollineationGroup(ps2);</span>
#I  Computing collineation group of canonical polar space...
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h := Random(CollineationGroup(ps2));</span>
&lt; a collineation: &lt;cmat 4x4 over GF(2,4)&gt;, F^2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := PreImageElm(phi,h);</span>
&lt; a collineation: &lt;cmat 4x4 over GF(2,4)&gt;, F^2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g in CollineationGroup(ps1);</span>
true
 
</pre></div>

<p><a id="X7C7438AB86A493FE" name="X7C7438AB86A493FE"></a></p>

<h5>2.3-3 <span class="Heading">Klein correspondence</span></h5>

<p>The Klein correspondence is well known. The user may define its own hyperbolic quadric as range for the geometry morphism in <strong class="pkg">FinInG</strong>. Note that more is possible than illustrated in the elementary example, see Section <a href="chap10_mj.html#X79C677CD7B7EC451"><span class="RefLink">10.3</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HyperbolicQuadric(5,5);</span>
Q+(5, 5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">klein := KleinCorrespondence(ps);</span>
&lt;geometry morphism from &lt;lines of ProjectiveSpace(3, 5)&gt; to &lt;points of Q+(5, 
5)&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">line1 := Random(Lines(PG(3,5)));</span>
&lt;a line in ProjectiveSpace(3, 5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">line2 := Random(Lines(PG(3,5)));</span>
&lt;a line in ProjectiveSpace(3, 5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := line1^klein;</span>
&lt;a point in Q+(5, 5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := line2^klein;</span>
&lt;a point in Q+(5, 5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p in ps;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q in ps;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCollinear(ps,p,q);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Meet(line1,line2);</span>
&lt; empty subspace &gt;
 
</pre></div>

<p><a id="X869EB94D841AE028" name="X869EB94D841AE028"></a></p>

<h5>2.3-4 <span class="Heading">Embedding in a subspace</span></h5>

<p>A projective space can be embedded as a subspace in a higher dimensional projective space. A comparable embedding is possible for polar spaces, clearly only when a given subspace intersects the polar space of higher rank in a polar space of the same type as the polar space to be embedded.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg2 := PG(2,5);</span>
ProjectiveSpace(2, 5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg3 := PG(3,5);</span>
ProjectiveSpace(3, 5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hyp := VectorSpaceToElement(pg3,[[1,2,4,0],[0,3,2,0],[1,1,0,1]]*Z(5)^0);</span>
&lt;a plane in ProjectiveSpace(3, 5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">em := NaturalEmbeddingBySubspace( pg2, pg3, hyp );</span>
&lt;geometry morphism from &lt;All elements of ProjectiveSpace(2, 
5)&gt; to &lt;All elements of ProjectiveSpace(3, 5)&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := Random(Lines(pg2));</span>
&lt;a line in ProjectiveSpace(2, 5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l^em;</span>
&lt;a line in ProjectiveSpace(3, 5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := Random(Points(hyp));</span>
&lt;a point in ProjectiveSpace(3, 5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreImageElm(em,p);</span>
&lt;a point in ProjectiveSpace(2, 5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0,0,0,1],[0,0,1,0],[0,-1,0,0],[-1,0,0,0]]*Z(3);</span>
[ [ 0*Z(3), 0*Z(3), 0*Z(3), Z(3) ], [ 0*Z(3), 0*Z(3), Z(3), 0*Z(3) ], 
  [ 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3) ], [ Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := BilinearFormByMatrix(mat,GF(3));</span>
&lt; bilinear form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w3 := PolarSpace(form);</span>
&lt;polar space in ProjectiveSpace(3,GF(3)): -x1*y4-x2*y3+x3*y2+x4*y1=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w5 := SymplecticSpace(5, 3);</span>
W(5, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg := AmbientSpace( w5 );</span>
ProjectiveSpace(5, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">solid := VectorSpaceToElement(pg,[[1,0,0,0,0,0],[0,1,0,0,0,0],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[0,0,1,0,0,0],[0,0,0,1,0,0]]*Z(3)^0);</span>
&lt;a solid in ProjectiveSpace(5, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TypeOfSubspace(w5,solid);</span>
"symplectic"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">em := NaturalEmbeddingBySubspace( w3, w5, solid );</span>
&lt;geometry morphism from &lt;Elements of &lt;polar space in ProjectiveSpace(
3,GF(3)): -x1*y4-x2*y3+x3*y2+x4*y1=0 &gt;&gt; to &lt;Elements of W(5, 3)&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">points := Points( w3 );</span>
&lt;points of W(3, 3): -x1*y4-x2*y3+x3*y2+x4*y1=0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">points2 := ImagesSet(em, AsSet(points));;</span>
#I  Computing collineation group of canonical polar space...
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll(points2, x -&gt; x in solid);</span>
true
 
</pre></div>

<p><a id="X7FE8E4BF7E700E65" name="X7FE8E4BF7E700E65"></a></p>

<h5>2.3-5 <span class="Heading">Subgeometries</span></h5>

<p>A projective space can be embedded as a subgeometry in a projective space of the same dimension but over a field extension. A polar space, determined by a form <span class="SimpleMath">\(f\)</span> can be embedded in a polar space considered over a field extension by interpreting the form <span class="SimpleMath">\(f\)</span> over this field extension. This is an interesting tool to construct geometrical objects in projective and polar spaces.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pgsub := PG(2,7);</span>
ProjectiveSpace(2, 7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg := PG(2,7^2);</span>
ProjectiveSpace(2, 49)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">em := NaturalEmbeddingBySubfield(pgsub,pg);</span>
&lt;geometry morphism from &lt;All elements of ProjectiveSpace(2, 
7)&gt; to &lt;All elements of ProjectiveSpace(2, 49)&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">baer := List(Points(pgsub),x-&gt;x^em);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">numbers := Collected(List(Lines(pg),x-&gt;Number(baer,y-&gt;y in x)));</span>
[ [ 1, 2394 ], [ 8, 57 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0,0,0,1],[0,0,-1,0],[0,1,0,0],[-1,0,0,0]]*Z(5)^0;</span>
[ [ 0*Z(5), 0*Z(5), 0*Z(5), Z(5)^0 ], [ 0*Z(5), 0*Z(5), Z(5)^2, 0*Z(5) ], 
  [ 0*Z(5), Z(5)^0, 0*Z(5), 0*Z(5) ], [ Z(5)^2, 0*Z(5), 0*Z(5), 0*Z(5) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := BilinearFormByMatrix(mat,GF(5));</span>
&lt; bilinear form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">symplecticspace := PolarSpace(form);</span>
&lt;polar space in ProjectiveSpace(3,GF(5)): x1*y4-x2*y3+x3*y2-x4*y1=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hermitianspace := HermitianPolarSpace(3,25);</span>
H(3, 5^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">em := NaturalEmbeddingBySubfield(symplecticspace,hermitianspace);</span>
#I  No intertwiner computed. &lt;geom1&gt; must have a collineation group computed
&lt;geometry morphism from &lt;Elements of &lt;polar space in ProjectiveSpace(
3,GF(5)): x1*y4-x2*y3+x3*y2-x4*y1=0 &gt;&gt; to &lt;Elements of H(3, 5^2)&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := Random(Lines(symplecticspace));</span>
&lt;a line in W(3, 5): x1*y4-x2*y3+x3*y2-x4*y1=0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l^em;</span>
&lt;a line in H(3, 5^2)&gt;

</pre></div>

<p><a id="X838BBDD97FA03FD0" name="X838BBDD97FA03FD0"></a></p>

<h5>2.3-6 <span class="Heading">Embedding by field reduction</span></h5>

<p>Field reduction is a power full tool to embedd low dimensional projective (and polar spaces) over a field <span class="SimpleMath">\(K\)</span> in to high dimensional spaces over a subfield of <span class="SimpleMath">\(K\)</span>. The mathematics behind field reduction is explained in sections <a href="chap10_mj.html#X7BC7FCDC7D9E1A09"><span class="RefLink">10.4-3</span></a> and <a href="chap10_mj.html#X7823BA95797898CE"><span class="RefLink">10.5-3</span></a>. The examples here show the use of these embedings to construct a regular spread of a projective space and a so-called Hermitian spread of a hyperbolic quadric.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg1 := PG(1,3^2);</span>
ProjectiveSpace(1, 9)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg2 := PG(3,3);</span>
ProjectiveSpace(3, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">em := NaturalEmbeddingByFieldReduction(pg1,pg2);</span>
&lt;geometry morphism from &lt;All elements of ProjectiveSpace(1, 
9)&gt; to &lt;All elements of ProjectiveSpace(3, 3)&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spread := List(Points(pg1),x-&gt;x^em);</span>
[ &lt;a line in ProjectiveSpace(3, 3)&gt;, &lt;a line in ProjectiveSpace(3, 3)&gt;, 
  &lt;a line in ProjectiveSpace(3, 3)&gt;, &lt;a line in ProjectiveSpace(3, 3)&gt;, 
  &lt;a line in ProjectiveSpace(3, 3)&gt;, &lt;a line in ProjectiveSpace(3, 3)&gt;, 
  &lt;a line in ProjectiveSpace(3, 3)&gt;, &lt;a line in ProjectiveSpace(3, 3)&gt;, 
  &lt;a line in ProjectiveSpace(3, 3)&gt;, &lt;a line in ProjectiveSpace(3, 3)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Union(List(spread,x-&gt;List(Points(x))))=Set(Points(pg2));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps1 := HermitianPolarSpace(3,3^2);</span>
H(3, 3^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps2 := HyperbolicQuadric(7,3);</span>
Q+(7, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">em := NaturalEmbeddingByFieldReduction(ps1,ps2);</span>
#I  These polar spaces are suitable for field reduction
&lt;geometry morphism from &lt;Elements of H(3, 3^2)&gt; to &lt;Elements of Q+(7, 3)&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spread := List(Points(ps1),x-&gt;x^em);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Union(List(spread,x-&gt;List(Points(x))))=Set(Points(ps2));</span>
true

</pre></div>

<p><a id="X855C8E6D819EB975" name="X855C8E6D819EB975"></a></p>

<h4>2.4 <span class="Heading">Some geometrical objects</span></h4>

<p><a id="X8475841778D3BEEC" name="X8475841778D3BEEC"></a></p>

<h5>2.4-1 <span class="Heading">Spreads of <span class="SimpleMath">\(W(5,3)\)</span></span></h5>

<p>A spread of <span class="SimpleMath">\(W(5,q)\)</span> is a set of q<sup>3</sup>+1 planes which partition the points of <span class="SimpleMath">\(W(5,q)\)</span>. Here we enumerate all spreads of <span class="SimpleMath">\(W(5,3)\)</span> which have a set-wise stabiliser of order a multiple of 13.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w := SymplecticSpace(5, 3);</span>
W(5, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := IsometryGroup(w);</span>
PSp(6,3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">syl := SylowSubgroup(g, 13);</span>
&lt;projective collineation group of size 13&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">planes := Planes( w );</span>
&lt;planes of W(5, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">points := Points( w );</span>
&lt;points of W(5, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbs := Orbits(syl, planes , OnProjSubspaces);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPartialSpread := x -&gt; Number(points, p -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         ForAny(x, i-&gt; p in i)) = Size(x)*13;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">partialspreads := Filtered(orbs, IsPartialSpread);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length(partialspreads);</span>
8
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">13s := Filtered(partialspreads, i -&gt; Size(i) = 13);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length(13s);</span>
6
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">13s[1];</span>
[ &lt;a plane in W(5, 3)&gt;, &lt;a plane in W(5, 3)&gt;, &lt;a plane in W(5, 3)&gt;, 
  &lt;a plane in W(5, 3)&gt;, &lt;a plane in W(5, 3)&gt;, &lt;a plane in W(5, 3)&gt;, 
  &lt;a plane in W(5, 3)&gt;, &lt;a plane in W(5, 3)&gt;, &lt;a plane in W(5, 3)&gt;, 
  &lt;a plane in W(5, 3)&gt;, &lt;a plane in W(5, 3)&gt;, &lt;a plane in W(5, 3)&gt;, 
  &lt;a plane in W(5, 3)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">26s := List(Combinations(13s,2), Union);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">two := Union(Filtered(partialspreads, i -&gt; Size(i) = 1));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">good26s := Filtered(26s, x-&gt;IsPartialSpread(Union(x, two)));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spreads := List(good26s, x-&gt;Union(x, two));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length(spreads);</span>
5
 
</pre></div>

<p><a id="X81F516D07E8165B9" name="X81F516D07E8165B9"></a></p>

<h5>2.4-2 <span class="Heading">Distance-6 spread of the split Cayley hexagon</span></h5>

<p>A distance 6 spread of a split Cayley hexagon is a set of lines mutually at maximal distance in the incidence graph. It is well known that the lines of the hexagon contained in a hyperplane meeting the ambient polar space in an elliptic quadric, yield such a spread. This example also illustrates how an element of a geometry <em>remembers</em> its ambient geometry, and how <code class="file">ElementToElement</code> can be used to embed an element in another geometry, see <a href="chap3_mj.html#X8561C0117FD76C94"><span class="RefLink">3.8-1</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gh := SplitCayleyHexagon(3);</span>
H(3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q6 := AmbientPolarSpace(gh);</span>
Q(6, 3): -x_1*x_5-x_2*x_6-x_3*x_7+x_4^2=0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hyp := First(Hyperplanes(PG(6,3)),x-&gt;TypeOfSubspace(q6,x)="elliptic");</span>
&lt;a proj. 5-space in ProjectiveSpace(6, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q5 := EllipticQuadric(5,3);</span>
Q-(5, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lines := AsList(Lines(q5));</span>
&lt;closed orbit, 280 points&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">em := NaturalEmbeddingBySubspace(q5,q6,hyp);</span>
&lt;geometry morphism from &lt;Elements of Q-(5, 3)&gt; to &lt;Elements of Q(6, 
3): -x_1*x_5-x_2*x_6-x_3*x_7+x_4^2=0&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spread := Filtered(lines,x-&gt;x^em in gh);</span>
[ &lt;a line in Q-(5, 3)&gt;, &lt;a line in Q-(5, 3)&gt;, &lt;a line in Q-(5, 3)&gt;, 
  &lt;a line in Q-(5, 3)&gt;, &lt;a line in Q-(5, 3)&gt;, &lt;a line in Q-(5, 3)&gt;, 
  &lt;a line in Q-(5, 3)&gt;, &lt;a line in Q-(5, 3)&gt;, &lt;a line in Q-(5, 3)&gt;, 
  &lt;a line in Q-(5, 3)&gt;, &lt;a line in Q-(5, 3)&gt;, &lt;a line in Q-(5, 3)&gt;, 
  &lt;a line in Q-(5, 3)&gt;, &lt;a line in Q-(5, 3)&gt;, &lt;a line in Q-(5, 3)&gt;, 
  &lt;a line in Q-(5, 3)&gt;, &lt;a line in Q-(5, 3)&gt;, &lt;a line in Q-(5, 3)&gt;, 
  &lt;a line in Q-(5, 3)&gt;, &lt;a line in Q-(5, 3)&gt;, &lt;a line in Q-(5, 3)&gt;, 
  &lt;a line in Q-(5, 3)&gt;, &lt;a line in Q-(5, 3)&gt;, &lt;a line in Q-(5, 3)&gt;, 
  &lt;a line in Q-(5, 3)&gt;, &lt;a line in Q-(5, 3)&gt;, &lt;a line in Q-(5, 3)&gt;, 
  &lt;a line in Q-(5, 3)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spread := List(spread,x-&gt;ElementToElement(gh,x^em));</span>
[ &lt;a line in H(3)&gt;, &lt;a line in H(3)&gt;, &lt;a line in H(3)&gt;, &lt;a line in H(3)&gt;, 
  &lt;a line in H(3)&gt;, &lt;a line in H(3)&gt;, &lt;a line in H(3)&gt;, &lt;a line in H(3)&gt;, 
  &lt;a line in H(3)&gt;, &lt;a line in H(3)&gt;, &lt;a line in H(3)&gt;, &lt;a line in H(3)&gt;, 
  &lt;a line in H(3)&gt;, &lt;a line in H(3)&gt;, &lt;a line in H(3)&gt;, &lt;a line in H(3)&gt;, 
  &lt;a line in H(3)&gt;, &lt;a line in H(3)&gt;, &lt;a line in H(3)&gt;, &lt;a line in H(3)&gt;, 
  &lt;a line in H(3)&gt;, &lt;a line in H(3)&gt;, &lt;a line in H(3)&gt;, &lt;a line in H(3)&gt;, 
  &lt;a line in H(3)&gt;, &lt;a line in H(3)&gt;, &lt;a line in H(3)&gt;, &lt;a line in H(3)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Collected(Concatenation(List(spread,x-&gt;List(spread,y-&gt;DistanceBetweenElements(x,y)))));</span>
[ [ 0, 28 ], [ 6, 756 ] ]

</pre></div>

<p><a id="X7F13364A7EEA2AD1" name="X7F13364A7EEA2AD1"></a></p>

<h4>2.5 <span class="Heading">Some particular incidence geometries</span></h4>

<p><a id="X79623B9E7D5816B3" name="X79623B9E7D5816B3"></a></p>

<h5>2.5-1 <span class="Heading">The split Cayley hexagon</span></h5>

<p>The split Cayley hexagon is one the well known classical generalised hexagons that are obtained using a triality of the hyperbolic quadric in 7 dimensions. This example shows some basic properties of this geometry.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hexagon := SplitCayleyHexagon(5);</span>
H(5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order(hexagon);</span>
[ 5, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := CollineationGroup( hexagon );</span>
#I  for Split Cayley Hexagon
#I  Computing nice monomorphism...
#I  Found permutation domain...
G_2(5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">incgraph := IncidenceGraph( hexagon );;</span>
#I  Computing incidence graph of generalised polygon...
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Diameter(incgraph);</span>
6
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Girth(incgraph);</span>
12
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">points := Points(hexagon);</span>
&lt;points of H(5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lines := Lines(hexagon);</span>
&lt;lines of H(5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iter := Iterator(points);</span>
&lt;iterator&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := NextIterator(iter);</span>
&lt;a point in H(5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(x);</span>
[.1.....]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingObject(x);</span>
&lt;cvec over GF(5,1) of length 7&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">onx := Lines(x);</span>
&lt;shadow lines in H(5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := Random(onx);</span>
&lt;a line in H(5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">onl := Points(l);</span>
&lt;shadow points in H(5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(onl, t -&gt; DistanceBetweenElements(x,t));</span>
[ 0, 2, 2, 2, 2, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">stabl := FiningStabiliser(g, l);</span>
&lt;projective collineation group of size 1500000 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gl := Action(stabl, onl);</span>
Group([ (1,6,5,4,3), (1,4,3,6), (1,5,4,3,6,2) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription(gl);</span>
"S5"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Transitivity(gl);</span>
3
 
</pre></div>

<p><a id="X8528558E87DE72C5" name="X8528558E87DE72C5"></a></p>

<h5>2.5-2 <span class="Heading">An (apartment of) a building of type <span class="SimpleMath">\(E_6\)</span></span></h5>

<p>This example shows the constructions of an incidence geometry whose automorphism group is an exceptional group of type <span class="SimpleMath">\(E_6\)</span>. The construction is done as a coset geometry. This example also illustrates how to get a diagram of such a coset geometry.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := SimpleLieAlgebra("E",6,Rationals);</span>
&lt;Lie algebra of dimension 78 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rs := RootSystem(L);</span>
&lt;root system of rank 6&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w := WeylGroup(rs);</span>
&lt;matrix group with 6 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens := GeneratorsOfGroup(w);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pabs := List(gens, g -&gt; Group(Difference(gens, [g])));</span>
[ &lt;matrix group with 5 generators&gt;, &lt;matrix group with 5 generators&gt;, 
  &lt;matrix group with 5 generators&gt;, &lt;matrix group with 5 generators&gt;, 
  &lt;matrix group with 5 generators&gt;, &lt;matrix group with 5 generators&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := Group(gens);</span>
&lt;matrix group with 6 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cg := CosetGeometry(g,pabs);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">diag := DiagramOfGeometry( cg );;</span>
#I Using NiceMonomorphism...
#I Using NiceMonomorphism...
#I Using NiceMonomorphism...
#I Using NiceMonomorphism...
#I Using NiceMonomorphism...
#I Using NiceMonomorphism...
#I Using NiceMonomorphism...
#I Using NiceMonomorphism...
#I Using NiceMonomorphism...
#I Using NiceMonomorphism...
#I Using NiceMonomorphism...
#I Using NiceMonomorphism...
#I Using NiceMonomorphism...
#I Using NiceMonomorphism...
#I Using NiceMonomorphism...
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DrawDiagram(diag, "E6");</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">#Exec("open E6.ps");</span>
 
</pre></div>

<p><img src="./graphics/E6.jpg"></img></p>

<p><a id="X7B783473852C7899" name="X7B783473852C7899"></a></p>

<h5>2.5-3 <span class="Heading">A rank 4 geometry for <span class="SimpleMath">\(PSL(2,11)\)</span></span></h5>

<p>Here we look at a particular flag-transitive geometry constructed from four subgroups of <span class="SimpleMath">\(PSL(2,11)\)</span>, and we construct the diagram for this geometry. To view this diagram, you need to either use a postscript viewer or a dotty viewer (such as GraphViz).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := PSL(2,11);</span>
Group([ (3,11,9,7,5)(4,12,10,8,6), (1,2,8)(3,7,9)(4,10,5)(6,12,11) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g1 := Group([ (1,2,3)(4,8,12)(5,10,9)(6,11,7), (1,2)(3,4)(5,12)(6,11)(7,10)(8,9) ]);</span>
Group([ (1,2,3)(4,8,12)(5,10,9)(6,11,7), (1,2)(3,4)(5,12)(6,11)(7,10)(8,9) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g2 := Group([ (1,2,7)(3,9,4)(5,11,10)(6,8,12), (1,2)(3,4)(5,12)(6,11)(7,10)(8,9) ]);</span>
Group([ (1,2,7)(3,9,4)(5,11,10)(6,8,12), (1,2)(3,4)(5,12)(6,11)(7,10)(8,9) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g3 := Group([ (1,2,11)(3,8,7)(4,9,5)(6,10,12), (1,2)(3,12)(4,11)(5,10)(6,9)(7,8) ]);</span>
Group([ (1,2,11)(3,8,7)(4,9,5)(6,10,12), (1,2)(3,12)(4,11)(5,10)(6,9)(7,8) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g4 := Group([ (1,2,11)(3,8,7)(4,9,5)(6,10,12), (1,2)(3,10)(4,9)(5,8)(6,7)(11,12) ]);</span>
Group([ (1,2,11)(3,8,7)(4,9,5)(6,10,12), (1,2)(3,10)(4,9)(5,8)(6,7)(11,12) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cg := CosetGeometry(g, [g1,g2,g3,g4]);</span>
CosetGeometry( Group( [ ( 3,11, 9, 7, 5)( 4,12,10, 8, 6), 
  ( 1, 2, 8)( 3, 7, 9)( 4,10, 5)( 6,12,11) ] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName(cg, "Gamma");</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ParabolicSubgroups(cg);</span>
[ Group([ (1,2,3)(4,8,12)(5,10,9)(6,11,7), (1,2)(3,4)(5,12)(6,11)(7,10)
  (8,9) ]), Group([ (1,2,7)(3,9,4)(5,11,10)(6,8,12), (1,2)(3,4)(5,12)(6,11)
  (7,10)(8,9) ]), Group([ (1,2,11)(3,8,7)(4,9,5)(6,10,12), (1,2)(3,12)(4,11)
  (5,10)(6,9)(7,8) ]), Group([ (1,2,11)(3,8,7)(4,9,5)(6,10,12), (1,2)(3,10)
  (4,9)(5,8)(6,7)(11,12) ]) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BorelSubgroup(cg);</span>
Group(())
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AmbientGroup(cg);</span>
Group([ (3,11,9,7,5)(4,12,10,8,6), (1,2,8)(3,7,9)(4,10,5)(6,12,11) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">type2 := ElementsOfIncidenceStructure( cg, 2 );</span>
&lt;elements of type 2 of Gamma&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsFlagTransitiveGeometry( cg );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DrawDiagram( DiagramOfGeometry(cg), "PSL211");</span>
 
</pre></div>

<p>The output of this example uses <code class="code">dotty</code> which is a sophisticated graph drawing program. We also provide <code class="file">DrawDiagramWithNeato</code> to make a diagram with straight lines, using <code class="code">neato</code>. Here is what the output looks like with the standard <code class="file">DrawDiagram</code> command: <img src="./graphics/PSL211.jpg"></img></p>

<p><a id="X80128FF17BB62C83" name="X80128FF17BB62C83"></a></p>

<h5>2.5-4 <span class="Heading">The Ree-Tits octagon of order <span class="SimpleMath">\([2,4]\)</span> as coset geometry</span></h5>

<p>In this example we construct the Ree-Tits octagon of order <span class="SimpleMath">\([2,4]\)</span> as a coset geometry. From the computation of the so-called rank 2 parameters, it can be observed already that the constructed geometry must be a generalised octagon. Then the points and lines are computed explicitely, and together with the incidence and the available group as a subgroup of the collineation group, a generalised octagon is constructed.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "AtlasRep" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">titsgroup:=AtlasGroup("2F4(2)'");</span>
&lt;permutation group of size 17971200 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g1:=AtlasSubgroup(titsgroup,3);</span>
&lt;permutation group of size 10240 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g2:=AtlasSubgroup(titsgroup,5);</span>
&lt;permutation group of size 6144 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">conj:=ConjugacyClassSubgroups(titsgroup,g1);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># Now look for the conjugate of g1 with maximal intersection</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g1:=First(conj, sg -&gt; Size(Intersection(sg,g2))=2048);</span>
&lt;permutation group of size 10240 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cg:=CosetGeometry(titsgroup,[g1,g2]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Rank2Parameters(cg);</span>
[ [ 8, 8, 8 ], [ 2, 1755 ], [ 4, 2925 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pts := Set(ElementsOfIncidenceStructure(cg,1));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lines := Set(ElementsOfIncidenceStructure(cg,2));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gp := GeneralisedPolygonByElements(pts,lines,\*,titsgroup,OnCosetGeometryElement);</span>
&lt;generalised octagon of order [ 2, 4 ]&gt;

</pre></div>

<p><a id="X7BA462527B2777BC" name="X7BA462527B2777BC"></a></p>

<h4>2.6 <span class="Heading">Elation generalised quadrangles</span></h4>

<p>In this section, we construct a classical elation generalised quadrangle from a q-clan, and we see that the associated BLT-set is a conic.</p>

<p><a id="X7E3707857A74AB5E" name="X7E3707857A74AB5E"></a></p>

<h5>2.6-1 <span class="Heading">The classical q-clan</span></h5>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := GF(3);</span>
GF(3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMat(2, f);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">clan := List( f, t -&gt; t*id );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsqClan( clan, f );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">clan := qClan(clan, f);</span>
&lt;q-clan over GF(3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">egq := EGQByqClan( clan );</span>
#I  Computed Kantor family. Now computing EGQ...
&lt;EGQ of order [ 9, 3 ] and basepoint 0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elations := ElationGroup( egq );</span>
&lt;matrix group of size 243 with 8 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">points := Points( egq );</span>
&lt;points of &lt;EGQ of order [ 9, 3 ] and basepoint 0&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := Random(points);</span>
&lt;a point of class 2 of &lt;EGQ of order [ 9, 3 ] and basepoint 0&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := Random(elations);</span>
[ [ Z(3)^0, 0*Z(3), 0*Z(3), Z(3)^0 ], [ 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0 ], 
  [ 0*Z(3), 0*Z(3), Z(3)^0, Z(3)^0 ], [ 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OnKantorFamily(p,x);</span>
&lt;a point of class 2 of &lt;EGQ of order [ 9, 3 ] and basepoint 0&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbs := Orbits( elations, points, OnKantorFamily);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Collected(List( orbs, Size ));</span>
[ [ 1, 1 ], [ 9, 4 ], [ 243, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">blt := BLTSetByqClan( clan );</span>
[ &lt;a point in Q(4, 3): -x_1*x_5-x_2*x_4+x_3^2=0&gt;, 
  &lt;a point in Q(4, 3): -x_1*x_5-x_2*x_4+x_3^2=0&gt;, 
  &lt;a point in Q(4, 3): -x_1*x_5-x_2*x_4+x_3^2=0&gt;, 
  &lt;a point in Q(4, 3): -x_1*x_5-x_2*x_4+x_3^2=0&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q4q := AmbientGeometry( blt[1] );</span>
Q(4, 3): -x_1*x_5-x_2*x_4+x_3^2=0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">span := Span( blt );</span>
&lt;a plane in ProjectiveSpace(4, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProjectiveDimension( span ); </span>
2
 
</pre></div>

<p><a id="X83357ED78789111E" name="X83357ED78789111E"></a></p>

<h5>2.6-2 <span class="Heading">Two ways to construct a flock generalised quadrangle from a Kantor-Knuth semifield q-clan</span></h5>

<p>We will construct an elation generalised quadrangle directly from the <em>Kantor-Knuth semifield q-clan</em> and also via its corresponding BLT-set. The q-clan in question here are the set of matrices C<sub>t</sub> of the form <table style="color:#000"><tr> <td><table border=0 cellpadding=0 cellspacing=0px style="border-left:1px solid #000; border-right:1px solid #000; color:#000"><tr> <td style ="border-top:1px solid #000; border-bottom:1px solid #000;"> </td><td><table border=0 cellpadding=0 cellspacing=0 style="color:#000;"> </tr> <td align="center" valign="center" width=30>t</td> <td align="center" valign="center" width=30>0</td> </tr> <tr> <td align="center" valign="center" width=30>0</td> <td align="center" valign="center" width=30>-nt<sup>φ</sup></td> </tr> </table></td> <td style ="border-top:1px solid #000; border-bottom:1px solid #000;"> </td></tr></table></td> <td align="center" valign="center"><table border=0 cellpadding=0 cellspacing=0px style="color:#000"> <tr><td> </td></tr> <tr><td> </td></tr> </table></td> </tr></table> where t runs over the elements of <span class="SimpleMath">\(GF(q)\)</span>, <span class="SimpleMath">\(q\)</span> is odd and not prime, <span class="SimpleMath">\(n\)</span> is a fixed nonsquare and φ is a nontrivial automorphism of <span class="SimpleMath">\(GF(q)\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := 9;</span>
9
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := GF(q);</span>
GF(3^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">squares := AsList(Group(Z(q)^2));</span>
[ Z(3)^0, Z(3^2)^6, Z(3), Z(3^2)^2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">n := First(GF(q), x -&gt; not IsZero(x) and not x in squares);</span>
Z(3^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sigma := FrobeniusAutomorphism( f );</span>
FrobeniusAutomorphism( GF(3^2) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">zero := Zero(f);</span>
0*Z(3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">qclan := List(GF(q), t -&gt; [[t, zero], [zero,-n * t^sigma]] );</span>
[ [ [ 0*Z(3), 0*Z(3) ], [ 0*Z(3), 0*Z(3) ] ], 
  [ [ Z(3^2), 0*Z(3) ], [ 0*Z(3), Z(3)^0 ] ], 
  [ [ Z(3^2)^5, 0*Z(3) ], [ 0*Z(3), Z(3) ] ], 
  [ [ Z(3)^0, 0*Z(3) ], [ 0*Z(3), Z(3^2)^5 ] ], 
  [ [ Z(3^2)^2, 0*Z(3) ], [ 0*Z(3), Z(3^2)^3 ] ], 
  [ [ Z(3^2)^3, 0*Z(3) ], [ 0*Z(3), Z(3^2)^6 ] ], 
  [ [ Z(3), 0*Z(3) ], [ 0*Z(3), Z(3^2) ] ], 
  [ [ Z(3^2)^7, 0*Z(3) ], [ 0*Z(3), Z(3^2)^2 ] ], 
  [ [ Z(3^2)^6, 0*Z(3) ], [ 0*Z(3), Z(3^2)^7 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsqClan( qclan, f );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">qclan := qClan(qclan , f);</span>
&lt;q-clan over GF(3^2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">egq1 := EGQByqClan( qclan);  </span>
#I  Computed Kantor family. Now computing EGQ...
&lt;EGQ of order [ 81, 9 ] and basepoint 0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">blt := BLTSetByqClan( qclan );</span>
[ &lt;a point in Q(4, 9): -x_1*x_5-x_2*x_4+Z(3^2)^5*x_3^2=0&gt;, 
  &lt;a point in Q(4, 9): -x_1*x_5-x_2*x_4+Z(3^2)^5*x_3^2=0&gt;, 
  &lt;a point in Q(4, 9): -x_1*x_5-x_2*x_4+Z(3^2)^5*x_3^2=0&gt;, 
  &lt;a point in Q(4, 9): -x_1*x_5-x_2*x_4+Z(3^2)^5*x_3^2=0&gt;, 
  &lt;a point in Q(4, 9): -x_1*x_5-x_2*x_4+Z(3^2)^5*x_3^2=0&gt;, 
  &lt;a point in Q(4, 9): -x_1*x_5-x_2*x_4+Z(3^2)^5*x_3^2=0&gt;, 
  &lt;a point in Q(4, 9): -x_1*x_5-x_2*x_4+Z(3^2)^5*x_3^2=0&gt;, 
  &lt;a point in Q(4, 9): -x_1*x_5-x_2*x_4+Z(3^2)^5*x_3^2=0&gt;, 
  &lt;a point in Q(4, 9): -x_1*x_5-x_2*x_4+Z(3^2)^5*x_3^2=0&gt;, 
  &lt;a point in Q(4, 9): -x_1*x_5-x_2*x_4+Z(3^2)^5*x_3^2=0&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">egq2 := EGQByBLTSet( blt );</span>
#I  Now embedding dual BLT-set into W(5,q)...
#I  Computing elation group...
&lt;EGQ of order [ 81, 9 ] and basepoint in W(5, 9 ) &gt;
 
</pre></div>

<p><a id="X87EC44BF7F24486E" name="X87EC44BF7F24486E"></a></p>

<h4>2.7 <span class="Heading">Algebraic varieties</span></h4>

<p><a id="X7ABCF9637B60FF37" name="X7ABCF9637B60FF37"></a></p>

<h5>2.7-1 <span class="Heading">A projective variety</span></h5>

<p>In this example we demonstrate the construction of projective varieties.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg1 := PG(1, 7);</span>
ProjectiveSpace(1, 7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg3 := PG(3, 7);</span>
ProjectiveSpace(3, 7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">points := Points(pg1);</span>
&lt;points of ProjectiveSpace(1, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coords := List(points, Coordinates);</span>
[ [ Z(7)^0, 0*Z(7) ], [ Z(7)^0, Z(7)^0 ], [ Z(7)^0, Z(7) ], 
  [ Z(7)^0, Z(7)^2 ], [ Z(7)^0, Z(7)^3 ], [ Z(7)^0, Z(7)^4 ], 
  [ Z(7)^0, Z(7)^5 ], [ 0*Z(7), Z(7)^0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">curve := List(coords, t -&gt; VectorSpaceToElement(pg3, [ t[1]^3, t[1]^2 * t[2], t[1] * t[2]^2, t[2]^3  ] ));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pgl := ProjectivityGroup( pg3 );</span>
The FinInG projectivity group PGL(4,7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">stabcurve := FiningSetwiseStabiliser( pgl, curve );</span>
#I  Computing adjusted stabilizer chain...
&lt;projective collineation group with 6 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription( stabcurve );</span>
"PSL(3,2) : C2"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Span( curve );</span>
ProjectiveSpace(3, 7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg3lines := Lines( pg3 );</span>
&lt;lines of ProjectiveSpace(3, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbits := FiningOrbits(stabcurve, pg3lines);</span>
2%..3%..9%..15%..16%..21%..22%..28%..34%..40%..46%..52%..64%..75%..81%..84%..88%..94%..95%..99%..100%..[ &lt;closed orbit, 8 points&gt;, &lt;closed orbit, 56 points&gt;, 
  &lt;closed orbit, 28 points&gt;, &lt;closed orbit, 168 points&gt;, 
  &lt;closed orbit, 168 points&gt;, &lt;closed orbit, 28 points&gt;, 
  &lt;closed orbit, 168 points&gt;, &lt;closed orbit, 28 points&gt;, 
  &lt;closed orbit, 168 points&gt;, &lt;closed orbit, 168 points&gt;, 
  &lt;closed orbit, 168 points&gt;, &lt;closed orbit, 168 points&gt;, 
  &lt;closed orbit, 168 points&gt;, &lt;closed orbit, 336 points&gt;, 
  &lt;closed orbit, 336 points&gt;, &lt;closed orbit, 168 points&gt;, 
  &lt;closed orbit, 84 points&gt;, &lt;closed orbit, 112 points&gt;, 
  &lt;closed orbit, 168 points&gt;, &lt;closed orbit, 21 points&gt;, 
  &lt;closed orbit, 112 points&gt;, &lt;closed orbit, 21 points&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(orbits, Size);</span>
[ 8, 56, 28, 168, 168, 28, 168, 28, 168, 168, 168, 168, 168, 336, 336, 168, 
  84, 112, 168, 21, 112, 21 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg3points := Points( pg3 );</span>
&lt;points of ProjectiveSpace(3, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbits := FiningOrbits(stabcurve, pg3points);</span>
2%..16%..30%..72%..100%..[ &lt;closed orbit, 8 points&gt;, &lt;closed orbit, 56 points&gt;, 
  &lt;closed orbit, 56 points&gt;, &lt;closed orbit, 168 points&gt;, 
  &lt;closed orbit, 112 points&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(orbits, Size);</span>
[ 8, 56, 56, 168, 112 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">reps := List(orbits, Representative);</span>
[ &lt;a point in ProjectiveSpace(3, 7)&gt;, &lt;a point in ProjectiveSpace(3, 7)&gt;, 
  &lt;a point in ProjectiveSpace(3, 7)&gt;, &lt;a point in ProjectiveSpace(3, 7)&gt;, 
  &lt;a point in ProjectiveSpace(3, 7)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := reps[2];</span>
&lt;a point in ProjectiveSpace(3, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">proj := NaturalProjectionBySubspace(pg3, x);</span>
&lt;geometry morphism from &lt;All elements of ProjectiveSpace(3, 
7)&gt; to &lt;All elements of ProjectiveSpace(2, 7)&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">curveminusx := Difference(curve, [x]);</span>
[ &lt;a point in ProjectiveSpace(3, 7)&gt;, &lt;a point in ProjectiveSpace(3, 7)&gt;, 
  &lt;a point in ProjectiveSpace(3, 7)&gt;, &lt;a point in ProjectiveSpace(3, 7)&gt;, 
  &lt;a point in ProjectiveSpace(3, 7)&gt;, &lt;a point in ProjectiveSpace(3, 7)&gt;, 
  &lt;a point in ProjectiveSpace(3, 7)&gt;, &lt;a point in ProjectiveSpace(3, 7)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cuspidal := ImagesSet(proj, List(curveminusx, t -&gt; Span(x, t)));</span>
[ &lt;a point in ProjectiveSpace(2, 7)&gt;, &lt;a point in ProjectiveSpace(2, 7)&gt;, 
  &lt;a point in ProjectiveSpace(2, 7)&gt;, &lt;a point in ProjectiveSpace(2, 7)&gt;, 
  &lt;a point in ProjectiveSpace(2, 7)&gt;, &lt;a point in ProjectiveSpace(2, 7)&gt;, 
  &lt;a point in ProjectiveSpace(2, 7)&gt;, &lt;a point in ProjectiveSpace(2, 7)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coords := List(cuspidal, Coordinates);</span>
[ [ Z(7)^0, 0*Z(7), 0*Z(7) ], [ 0*Z(7), 0*Z(7), Z(7)^0 ], 
  [ Z(7)^0, Z(7)^0, Z(7)^0 ], [ Z(7)^0, Z(7)^2, Z(7)^0 ], 
  [ Z(7)^0, Z(7)^4, Z(7)^0 ], [ Z(7)^0, Z(7)^0, Z(7)^3 ], 
  [ Z(7)^0, Z(7)^2, Z(7)^3 ], [ Z(7)^0, Z(7)^4, Z(7)^3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r := PolynomialRing(GF(7), 3);</span>
GF(7)[x_1,x_2,x_3]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">indets := IndeterminatesOfPolynomialRing(r);</span>
[ x_1, x_2, x_3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">shapes := Filtered(Tuples([0,1,2,3], 3), t -&gt; Sum(t) = 3);</span>
[ [ 0, 0, 3 ], [ 0, 1, 2 ], [ 0, 2, 1 ], [ 0, 3, 0 ], [ 1, 0, 2 ], 
  [ 1, 1, 1 ], [ 1, 2, 0 ], [ 2, 0, 1 ], [ 2, 1, 0 ], [ 3, 0, 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := List(coords, t -&gt; List(shapes, u -&gt; Product([1,2,3], i -&gt; t[i]^u[i])));</span>
[ [ 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), 
      Z(7)^0 ], 
  [ Z(7)^0, 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), 
      0*Z(7) ], 
  [ Z(7)^0, Z(7)^0, Z(7)^0, Z(7)^0, Z(7)^0, Z(7)^0, Z(7)^0, Z(7)^0, Z(7)^0, 
      Z(7)^0 ], 
  [ Z(7)^0, Z(7)^2, Z(7)^4, Z(7)^0, Z(7)^0, Z(7)^2, Z(7)^4, Z(7)^0, Z(7)^2, 
      Z(7)^0 ], 
  [ Z(7)^0, Z(7)^4, Z(7)^2, Z(7)^0, Z(7)^0, Z(7)^4, Z(7)^2, Z(7)^0, Z(7)^4, 
      Z(7)^0 ], 
  [ Z(7)^3, Z(7)^0, Z(7)^3, Z(7)^0, Z(7)^0, Z(7)^3, Z(7)^0, Z(7)^3, Z(7)^0, 
      Z(7)^0 ], 
  [ Z(7)^3, Z(7)^2, Z(7), Z(7)^0, Z(7)^0, Z(7)^5, Z(7)^4, Z(7)^3, Z(7)^2, 
      Z(7)^0 ], 
  [ Z(7)^3, Z(7)^4, Z(7)^5, Z(7)^0, Z(7)^0, Z(7), Z(7)^2, Z(7)^3, Z(7)^4, 
      Z(7)^0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat2 := ShallowCopy(mat);</span>
[ [ 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), 
      Z(7)^0 ], 
  [ Z(7)^0, 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), 
      0*Z(7) ], 
  [ Z(7)^0, Z(7)^0, Z(7)^0, Z(7)^0, Z(7)^0, Z(7)^0, Z(7)^0, Z(7)^0, Z(7)^0, 
      Z(7)^0 ], 
  [ Z(7)^0, Z(7)^2, Z(7)^4, Z(7)^0, Z(7)^0, Z(7)^2, Z(7)^4, Z(7)^0, Z(7)^2, 
      Z(7)^0 ], 
  [ Z(7)^0, Z(7)^4, Z(7)^2, Z(7)^0, Z(7)^0, Z(7)^4, Z(7)^2, Z(7)^0, Z(7)^4, 
      Z(7)^0 ], 
  [ Z(7)^3, Z(7)^0, Z(7)^3, Z(7)^0, Z(7)^0, Z(7)^3, Z(7)^0, Z(7)^3, Z(7)^0, 
      Z(7)^0 ], 
  [ Z(7)^3, Z(7)^2, Z(7), Z(7)^0, Z(7)^0, Z(7)^5, Z(7)^4, Z(7)^3, Z(7)^2, 
      Z(7)^0 ], 
  [ Z(7)^3, Z(7)^4, Z(7)^5, Z(7)^0, Z(7)^0, Z(7), Z(7)^2, Z(7)^3, Z(7)^4, 
      Z(7)^0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sol := NullspaceMat(TransposedMat(mat2))[1];</span>
[ 0*Z(7), 0*Z(7), 0*Z(7), Z(7)^3, Z(7)^0, 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7),
   0*Z(7) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">terms := List(shapes, u -&gt; Product([1,2,3], i -&gt; indets[i]^u[i]));</span>
[ x_3^3, x_2*x_3^2, x_2^2*x_3, x_2^3, x_1*x_3^2, x_1*x_2*x_3, x_1*x_2^2, 
  x_1^2*x_3, x_1^2*x_2, x_1^3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poly := terms * sol;</span>
x_1*x_3^2-x_2^3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg2 := AmbientGeometry(Range(proj));</span>
ProjectiveSpace(2, 7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">variety := ProjectiveVariety(pg2, [poly]);</span>
Projective Variety in ProjectiveSpace(2, 7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">points := Points(variety);</span>
&lt;points of Projective Variety in ProjectiveSpace(2, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(points);</span>
8
 
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chapA_mj.html">A</a>  <a href="chapB_mj.html">B</a>  <a href="chapC_mj.html">C</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
