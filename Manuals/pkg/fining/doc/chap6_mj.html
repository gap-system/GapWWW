<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (FinInG) - Chapter 6: Polarities of Projective Spaces</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap6"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chapA_mj.html">A</a>  <a href="chapB_mj.html">B</a>  <a href="chapC_mj.html">C</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap5_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap7_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap6.html">[MathJax off]</a></p>
<p><a id="X87BA55CB86B110EC" name="X87BA55CB86B110EC"></a></p>
<div class="ChapSects"><a href="chap6_mj.html#X87BA55CB86B110EC">6 <span class="Heading">Polarities of Projective Spaces</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6_mj.html#X86D948C3875A5005">6.1 <span class="Heading">Creating polarities of projective spaces</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7EBD8C07802562B7">6.1-1 PolarityOfProjectiveSpace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7EBD8C07802562B7">6.1-2 PolarityOfProjectiveSpace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7EBD8C07802562B7">6.1-3 PolarityOfProjectiveSpace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7EBD8C07802562B7">6.1-4 PolarityOfProjectiveSpace</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6_mj.html#X81CC3CBE7879FD7B">6.2 <span class="Heading">Operations, attributes and properties for polarities of projective spaces</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X793BE1A27BF349F3">6.2-1 SesquilinearForm</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7BCBA564829D9E89">6.2-2 BaseField</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X847AFB4C81A90B3F">6.2-3 GramMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7C55F56E7E34768B">6.2-4 CompanionAutomorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7C15F40A85F167F4">6.2-5 IsHermitianPolarityOfProjectiveSpace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X855077387D144CDE">6.2-6 IsSymplecticPolarityOfProjectiveSpace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X87FFEEAE7FC2EE41">6.2-7 IsOrthogonalPolarityOfProjectiveSpace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X8372FCBC8313572F">6.2-8 IsPseudoPolarityOfProjectiveSpace</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6_mj.html#X83F8149B7D23301E">6.3 <span class="Heading">Polarities, absolute points, totally isotropic elements and finite classical polar
spaces</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X81C291357E5B2408">6.3-1 GeometryOfAbsolutePoints</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X8686AB4D798970BC">6.3-2 AbsolutePoints</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X863BC8E57C98A471">6.3-3 PolarSpace</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6_mj.html#X7ADFEAC07CE25530">6.4 <span class="Heading">Commuting polarities</span></a>
</span>
</div>
</div>

<h3>6 <span class="Heading">Polarities of Projective Spaces</span></h3>

<p>A <em>polarity</em> of a incidence structure is an incidence reversing, bijective, and involutory map on the elements of the incidence structure. It is well known that every polarity of a projective space is just an involutory correlation of the projective space. The construction of correlations of a projective space is described in Chapter <a href="chap5_mj.html#X816FCFB683915E8A"><span class="RefLink">5</span></a>. In this chapter we describe methods and operations dealing with the construction and use of polarities of projective spaces in <strong class="pkg">FinInG</strong>.</p>

<p><a id="X86D948C3875A5005" name="X86D948C3875A5005"></a></p>

<h4>6.1 <span class="Heading">Creating polarities of projective spaces</span></h4>

<p>Since polarities of a projective space necessarily have an involutory field automorphism as companion automorphism and the standard duality of the projective space as the companion projective space isomorphism, a polarity of a projective space is determined completely by a suitable matrix <span class="SimpleMath">\(A\)</span>. Every polarity of a projective space <span class="SimpleMath">\(\mathrm{PG}(n,q)\)</span> is listed in the following table, including the conditions on the matrix <span class="SimpleMath">\(A\)</span>.</p>

<div class="pcenter"><table class="GAPDocTable">
<caption class="GAPDocTable"><b>Table: </b>polarities of a projective space</caption>
<tr>
<td class="tdleft"></td>
<td class="tdleft"><span class="SimpleMath">\(q\)</span> odd</td>
<td class="tdleft"><span class="SimpleMath">\(q\)</span> even</td>
</tr>
<tr>
<td class="tdleft">hermitian</td>
<td class="tdleft"><span class="SimpleMath">\(A^{\theta}=A^T\)</span></td>
<td class="tdleft"><span class="SimpleMath">\(A^{\theta}=A^T\)</span></td>
</tr>
<tr>
<td class="tdleft">symplectic</td>
<td class="tdleft"><span class="SimpleMath">\(A^T=-A\)</span></td>
<td class="tdleft"><span class="SimpleMath">\(A^T=A\)</span>, all <span class="SimpleMath">\(a_{ii}=0\)</span></td>
</tr>
<tr>
<td class="tdleft">orthogonal</td>
<td class="tdleft"><span class="SimpleMath">\(A^T=A\)</span></td>
<td class="tdleft"></td>
</tr>
<tr>
<td class="tdleft">pseudo</td>
<td class="tdleft"></td>
<td class="tdleft"><span class="SimpleMath">\(A^T=A\)</span>, not all <span class="SimpleMath">\(a_{ii}=0\)</span></td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p>A hermitian polarity of the projective space <span class="SimpleMath">\(\mathrm{PG}(n,q)\)</span> exists if and only if the field <span class="SimpleMath">\(\mathrm{GF}(q)\)</span> admits an involutory field automorphism.</p>

<p>It is well known that there is a correspondence between polarities of projective spaces and non-degenerate sesquilinear forms on the underlying vector space. Consider a sesquilinear form <span class="SimpleMath">\(f\)</span> on the vector space <span class="SimpleMath">\(V(n+1,q)\)</span>. Then <span class="SimpleMath">\(f\)</span> induces a map on the elements of <span class="SimpleMath">\(\mathrm{PG}(n,q)\)</span> as follows: every element with underlying subspace <span class="SimpleMath">\(\alpha\)</span> is mapped to the element with underlying subspace <span class="SimpleMath">\(\alpha^\perp\)</span>, i.e. the subspace of <span class="SimpleMath">\(V(n+1,q)\)</span> orthogonal to <span class="SimpleMath">\(\alpha\)</span> with respect to the form <span class="SimpleMath">\(f\)</span>. It is clear that this induced map is a polarity of <span class="SimpleMath">\(\mathrm{PG}(n,q)\)</span>. Also the converse is true, with any polarity of <span class="SimpleMath">\(\mathrm{PG}(n,q)\)</span> corresponds a sesquilinear form on <span class="SimpleMath">\(V(n+1,q)\)</span>. The above classification of polarities of <span class="SimpleMath">\(\mathrm{PG}(n,q)\)</span> follows from the classification of sesquilinear forms on <span class="SimpleMath">\(V(n+1,q)\)</span>. For more information, we refer to <a href="chapBib_mj.html#biBHirschfeldThas">[HT91]</a> and <a href="chapBib_mj.html#biBKleidmanLiebeck">[KL90]</a>. We mention that the implementation of the action of correlations on projective points (see <a href="chap5_mj.html#X7EBA895D7A501CE0"><span class="RefLink">5.8</span></a>) guarantees that a sesquilinear form with matrix <span class="SimpleMath">\(M\)</span> and field automorphism <span class="SimpleMath">\(\theta\)</span> corresponds to a polarity with matrix <span class="SimpleMath">\(M\)</span> and field automorphism <span class="SimpleMath">\(\theta\)</span> and vice versa.</p>

<p>In <strong class="pkg">FinInG</strong>, polarities of projective spaces are always objects in the category <code class="code">IsPolarityOfProjectiveSpace</code>, which is a subcategory of the category <code class="code">IsProjGrpElWithFrobWithPSIsom</code>.</p>

<p><a id="X7EBD8C07802562B7" name="X7EBD8C07802562B7"></a></p>

<h5>6.1-1 PolarityOfProjectiveSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolarityOfProjectiveSpace</code>( <var class="Arg">mat</var>, <var class="Arg">f</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a polarity of a projective space</p>

<p>The underlying correlation of the projective space is constructed using matrix <var class="Arg">mat</var>, field <var class="Arg">f</var>, the identity mapping as field automorphism and the standard duality of the projective space. It is checked whether the matrix <var class="Arg">mat</var> satisfies the necessary conditions to induce a polarity.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0,1,0],[1,0,0],[0,0,1]]*Z(169)^0;</span>
[ [ 0*Z(13), Z(13)^0, 0*Z(13) ], [ Z(13)^0, 0*Z(13), 0*Z(13) ], 
  [ 0*Z(13), 0*Z(13), Z(13)^0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := PolarityOfProjectiveSpace(mat,GF(169));</span>
&lt;polarity of PG(2, GF(13^2)) &gt;
 
</pre></div>

<p><a id="X7EBD8C07802562B7" name="X7EBD8C07802562B7"></a></p>

<h5>6.1-2 PolarityOfProjectiveSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolarityOfProjectiveSpace</code>( <var class="Arg">mat</var>, <var class="Arg">frob</var>, <var class="Arg">f</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HermitianPolarityOfProjectiveSpace</code>( <var class="Arg">mat</var>, <var class="Arg">f</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a polarity of a projective space</p>

<p>The underlying correlation of the projective space is constructed using matrix <var class="Arg">mat</var>, field automorphism <var class="Arg">frob</var>, <var class="Arg">f</var> and the standard duality of the projective space. It is checked whether the <var class="Arg">mat</var> satisfies the necessary conditions to induce a polarity, and whether <var class="Arg">frob</var> is a non-trivial involutory field automorphism. The second operation only needs the arguments <var class="Arg">mat</var> and <var class="Arg">f</var> to construct a hermitian polarity of a projective space, provided the field <var class="Arg">f</var> allows an involutory field automorphism and <var class="Arg">mat</var> satisfies the necessary conditions. The latter is checked by constructing the underlying hermitian form.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[Z(11)^0,0*Z(11),0*Z(11)],[0*Z(11),0*Z(11),Z(11)],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [0*Z(11),Z(11),0*Z(11)]];</span>
[ [ Z(11)^0, 0*Z(11), 0*Z(11) ], [ 0*Z(11), 0*Z(11), Z(11) ], 
  [ 0*Z(11), Z(11), 0*Z(11) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">frob := FrobeniusAutomorphism(GF(121));</span>
FrobeniusAutomorphism( GF(11^2) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := PolarityOfProjectiveSpace(mat,frob,GF(121));</span>
&lt;polarity of PG(2, GF(11^2)) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">psi := HermitianPolarityOfProjectiveSpace(mat,GF(121));</span>
&lt;polarity of PG(2, GF(11^2)) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi = psi;</span>
true
 
</pre></div>

<p><a id="X7EBD8C07802562B7" name="X7EBD8C07802562B7"></a></p>

<h5>6.1-3 PolarityOfProjectiveSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolarityOfProjectiveSpace</code>( <var class="Arg">form</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a polarity of a projective space</p>

<p>The polarity of the projective space is constructed using a non-degenerate sesquilinear form <var class="Arg">form</var>. It is checked whether the given form is non-degenerate.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0,1,0,0],[1,0,0,0],[0,0,0,1],[0,0,1,0]]*Z(16)^0;</span>
[ [ 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2) ], [ Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2) ], 
  [ 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0 ], [ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := BilinearFormByMatrix(mat,GF(16));</span>
&lt; bilinear form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := PolarityOfProjectiveSpace(form);</span>
&lt;polarity of PG(3, GF(2^4)) &gt;
 
</pre></div>

<p><a id="X7EBD8C07802562B7" name="X7EBD8C07802562B7"></a></p>

<h5>6.1-4 PolarityOfProjectiveSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolarityOfProjectiveSpace</code>( <var class="Arg">ps</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a polarity of a projective space</p>

<p>The polarity of the projective space is constructed using the non-degenerate sesquilinear form that defines the polar space <var class="Arg">ps</var>. When <var class="Arg">ps</var> is a parabolic quadric in even characteristic, no polarity of the ambient projective space can be associated to <var class="Arg">ps</var>, and an error message is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HermitianPolarSpace(4,64);</span>
H(4, 8^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := PolarityOfProjectiveSpace(ps);</span>
&lt;polarity of PG(4, GF(2^6)) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := ParabolicQuadric(6,8);</span>
Q(6, 8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolarityOfProjectiveSpace(ps);</span>
Error, no polarity of the ambient projective space can be associated to &lt;ps&gt; called from
&lt;function "unknown"&gt;( &lt;arguments&gt; )
 called from read-eval loop at line 11 of *stdin*
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
<span class="GAPbrkprompt">brk&gt;</span> <span class="GAPinput">quit;</span>
 
</pre></div>

<p><a id="X81CC3CBE7879FD7B" name="X81CC3CBE7879FD7B"></a></p>

<h4>6.2 <span class="Heading">Operations, attributes and properties for polarities of projective spaces</span></h4>

<p><a id="X793BE1A27BF349F3" name="X793BE1A27BF349F3"></a></p>

<h5>6.2-1 SesquilinearForm</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SesquilinearForm</code>( <var class="Arg">phi</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: a sesquilinear form</p>

<p>The sesquilinear form corresponding to the given polarity <var class="Arg">phi</var> is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0,-2,0,1],[2,0,3,0],[0,-3,0,1],[-1,0,-1,0]]*Z(19)^0;</span>
[ [ 0*Z(19), Z(19)^10, 0*Z(19), Z(19)^0 ], 
  [ Z(19), 0*Z(19), Z(19)^13, 0*Z(19) ], 
  [ 0*Z(19), Z(19)^4, 0*Z(19), Z(19)^0 ], 
  [ Z(19)^9, 0*Z(19), Z(19)^9, 0*Z(19) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := PolarityOfProjectiveSpace(mat,GF(19));</span>
&lt;polarity of PG(3, GF(19)) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := SesquilinearForm(phi);</span>
&lt; non-degenerate bilinear form &gt;
 
</pre></div>

<p><a id="X7BCBA564829D9E89" name="X7BCBA564829D9E89"></a></p>

<h5>6.2-2 BaseField</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BaseField</code>( <var class="Arg">phi</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: a field</p>

<p>The base field over which the polarity <var class="Arg">phi</var> was constructed.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[1,0,0],[0,0,2],[0,2,0]]*Z(5)^0;</span>
[ [ Z(5)^0, 0*Z(5), 0*Z(5) ], [ 0*Z(5), 0*Z(5), Z(5) ], 
  [ 0*Z(5), Z(5), 0*Z(5) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := PolarityOfProjectiveSpace(mat,GF(25));</span>
&lt;polarity of PG(2, GF(5^2)) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BaseField(phi);</span>
GF(5^2)
 
</pre></div>

<p><a id="X847AFB4C81A90B3F" name="X847AFB4C81A90B3F"></a></p>

<h5>6.2-3 GramMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GramMatrix</code>( <var class="Arg">phi</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: a matrix</p>

<p>The Gram matrix of the polarity <var class="Arg">phi</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[1,0,0],[0,0,3],[0,3,0]]*Z(11)^0;</span>
[ [ Z(11)^0, 0*Z(11), 0*Z(11) ], [ 0*Z(11), 0*Z(11), Z(11)^8 ], 
  [ 0*Z(11), Z(11)^8, 0*Z(11) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := PolarityOfProjectiveSpace(mat,GF(11));</span>
&lt;polarity of PG(2, GF(11)) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GramMatrix(phi);</span>
&lt;immutable cmat 3x3 over GF(11,1)&gt;
 
</pre></div>

<p><a id="X7C55F56E7E34768B" name="X7C55F56E7E34768B"></a></p>

<h5>6.2-4 CompanionAutomorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CompanionAutomorphism</code>( <var class="Arg">phi</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: a field automorphism</p>

<p>The involutory field automorphism accompanying the polarity <var class="Arg">phi</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0,2,0,0],[2,0,0,0],[0,0,0,5],[0,0,5,0]]*Z(7)^0;</span>
[ [ 0*Z(7), Z(7)^2, 0*Z(7), 0*Z(7) ], [ Z(7)^2, 0*Z(7), 0*Z(7), 0*Z(7) ], 
  [ 0*Z(7), 0*Z(7), 0*Z(7), Z(7)^5 ], [ 0*Z(7), 0*Z(7), Z(7)^5, 0*Z(7) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := HermitianPolarityOfProjectiveSpace(mat,GF(49));</span>
&lt;polarity of PG(3, GF(7^2)) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CompanionAutomorphism(phi);</span>
FrobeniusAutomorphism( GF(7^2) )
 
</pre></div>

<p><a id="X7C15F40A85F167F4" name="X7C15F40A85F167F4"></a></p>

<h5>6.2-5 IsHermitianPolarityOfProjectiveSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsHermitianPolarityOfProjectiveSpace</code>( <var class="Arg">phi</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>Returns: true or false</p>

<p>The polarity <var class="Arg">phi</var> is a hermitian polarity of a projective space if and only if the underlying matrix is hermitian.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0,2,7,1],[2,0,3,0],[7,3,0,1],[1,0,1,0]]*Z(19)^0;</span>
[ [ 0*Z(19), Z(19), Z(19)^6, Z(19)^0 ], [ Z(19), 0*Z(19), Z(19)^13, 0*Z(19) ],
  [ Z(19)^6, Z(19)^13, 0*Z(19), Z(19)^0 ], 
  [ Z(19)^0, 0*Z(19), Z(19)^0, 0*Z(19) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">frob := FrobeniusAutomorphism(GF(19^4));</span>
FrobeniusAutomorphism( GF(19^4) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := PolarityOfProjectiveSpace(mat,frob^2,GF(19^4));</span>
&lt;polarity of PG(3, GF(19^4)) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsHermitianPolarityOfProjectiveSpace(phi);</span>
true
 
</pre></div>

<p><a id="X855077387D144CDE" name="X855077387D144CDE"></a></p>

<h5>6.2-6 IsSymplecticPolarityOfProjectiveSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSymplecticPolarityOfProjectiveSpace</code>( <var class="Arg">phi</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>Returns: true or false</p>

<p>The polarity <var class="Arg">phi</var> is a symplectic polarity of a projective space if and only if the underlying matrix is symplectic.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0,0,1,0],[0,0,0,1],[1,0,0,0],[0,1,0,0]]*Z(8)^0;</span>
[ [ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ], [ 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0 ], 
  [ Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2) ], [ 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := PolarityOfProjectiveSpace(mat,GF(8));</span>
&lt;polarity of PG(3, GF(2^3)) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSymplecticPolarityOfProjectiveSpace(phi);</span>
true
 
</pre></div>

<p><a id="X87FFEEAE7FC2EE41" name="X87FFEEAE7FC2EE41"></a></p>

<h5>6.2-7 IsOrthogonalPolarityOfProjectiveSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsOrthogonalPolarityOfProjectiveSpace</code>( <var class="Arg">phi</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>Returns: true or false</p>

<p>The polarity <var class="Arg">phi</var> is an orthogonal polarity of a projective space if and only if the underlying matrix is symmetric and the characteristic of the field is odd.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[1,0,2,0],[0,2,0,1],[2,0,0,0],[0,1,0,0]]*Z(9)^0;</span>
[ [ Z(3)^0, 0*Z(3), Z(3), 0*Z(3) ], [ 0*Z(3), Z(3), 0*Z(3), Z(3)^0 ], 
  [ Z(3), 0*Z(3), 0*Z(3), 0*Z(3) ], [ 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := PolarityOfProjectiveSpace(mat,GF(9));</span>
&lt;polarity of PG(3, GF(3^2)) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOrthogonalPolarityOfProjectiveSpace(phi);</span>
true
 
</pre></div>

<p><a id="X8372FCBC8313572F" name="X8372FCBC8313572F"></a></p>

<h5>6.2-8 IsPseudoPolarityOfProjectiveSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPseudoPolarityOfProjectiveSpace</code>( <var class="Arg">phi</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>Returns: true or false</p>

<p>The polarity <var class="Arg">phi</var> is a pseudo-polarity of a projective space if and only if the underlying matrix is symmetric, not all elements on the main diagonal are zero and the characteristic of the field is even.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[1,0,1,0],[0,1,0,1],[1,0,0,0],[0,1,0,0]]*Z(16)^0;</span>
[ [ Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2) ], [ 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ], 
  [ Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2) ], [ 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := PolarityOfProjectiveSpace(mat,GF(16));</span>
&lt;polarity of PG(3, GF(2^4)) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPseudoPolarityOfProjectiveSpace(phi);</span>
true
 
</pre></div>

<p><a id="X83F8149B7D23301E" name="X83F8149B7D23301E"></a></p>

<h4>6.3 <span class="Heading">Polarities, absolute points, totally isotropic elements and finite classical polar
spaces</span></h4>

<p>We already mentioned the equivalence between polarities of <span class="SimpleMath">\(\mathrm{PG}(n,q)\)</span> and sesquilinear forms on <span class="SimpleMath">\(V(n+1,q)\)</span>, hence there is a relation between polarities of <span class="SimpleMath">\(\mathrm{PG}(n,q)\)</span> and polar spaces induced by sesquilinear forms. The following concepts express these relations geometrically.</p>

<p>Suppose that <span class="SimpleMath">\(\phi\)</span> is a polarity of <span class="SimpleMath">\(\mathrm{PG}(n,q)\)</span> and that <span class="SimpleMath">\(\alpha\)</span> is an element of <span class="SimpleMath">\(\mathrm{PG}(n,q)\)</span>. We call <span class="SimpleMath">\(\alpha\)</span> a <em>totally isotropic element</em> or an <em>absolute element</em> if and only if <span class="SimpleMath">\(\alpha\)</span> is incident with <span class="SimpleMath">\(\alpha^\phi\)</span>. An absolute element that is a point is also called an <em>absolute point</em> or an <em>isotropic point</em>. It is clear that an element of <span class="SimpleMath">\(\mathrm{PG}(n,q)\)</span> is absolute if and only if the underlying vector space is totally isotropic with respect to the sesquilinear form equivalent to <span class="SimpleMath">\(\phi\)</span>. Hence the absolute elements induce a <em>finite classical polar space</em>, the same that is induced by the equivalent sesquilinear form. When <span class="SimpleMath">\(\phi\)</span> is a pseudo-polarity, the set of absolute elements are the elements of a hyperplane of <span class="SimpleMath">\(\mathrm{PG}(n,q)\)</span>.</p>

<p>We restrict our introduction to finite classical polar spaces in this section to the following examples. Many aspects of these geometries are extensively described in Chapter <a href="chap7_mj.html#X7F96B1327C022A28"><span class="RefLink">7</span></a>.</p>

<p><a id="X81C291357E5B2408" name="X81C291357E5B2408"></a></p>

<h5>6.3-1 GeometryOfAbsolutePoints</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GeometryOfAbsolutePoints</code>( <var class="Arg">f</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a polar space or a hyperplane</p>

<p>When <var class="Arg">f</var> is not a pseudo-polarity, this operation returns the polar space induced by <var class="Arg">f</var>. When <var class="Arg">f</var> is a pseudo-polarity, this operation returns the hyperplane containing all absolute elements.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := IdentityMat(4,GF(16));</span>
[ [ Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2) ], [ 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2) ], 
  [ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ], [ 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := HermitianPolarityOfProjectiveSpace(mat,GF(16));</span>
&lt;polarity of PG(3, GF(2^4)) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">geom := GeometryOfAbsolutePoints(phi);</span>
&lt;polar space in ProjectiveSpace(3,GF(2^4)): x_1^5+x_2^5+x_3^5+x_4^5=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[1,0,0,0],[0,0,1,1],[0,1,1,0],[0,1,0,0]]*Z(32)^0;</span>
[ [ Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2) ], [ 0*Z(2), 0*Z(2), Z(2)^0, Z(2)^0 ], 
  [ 0*Z(2), Z(2)^0, Z(2)^0, 0*Z(2) ], [ 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := PolarityOfProjectiveSpace(mat,GF(32));</span>
&lt;polarity of PG(3, GF(2^5)) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">geom := GeometryOfAbsolutePoints(phi);</span>
&lt;a plane in ProjectiveSpace(3, 32)&gt;
 
</pre></div>

<p><a id="X8686AB4D798970BC" name="X8686AB4D798970BC"></a></p>

<h5>6.3-2 AbsolutePoints</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AbsolutePoints</code>( <var class="Arg">f</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a set of points</p>

<p>This operation returns all points that are absolute with respect to <var class="Arg">f</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := IdentityMat(4,GF(3));</span>
[ [ Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3) ], [ 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3) ], 
  [ 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3) ], [ 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := PolarityOfProjectiveSpace(mat,GF(3));</span>
&lt;polarity of PG(3, GF(3)) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">points := AbsolutePoints(phi);</span>
&lt;points of Q+(3, 3): x_1^2+x_2^2+x_3^2+x_4^2=0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(points);</span>
[ &lt;a point in Q+(3, 3): x_1^2+x_2^2+x_3^2+x_4^2=0&gt;, 
  &lt;a point in Q+(3, 3): x_1^2+x_2^2+x_3^2+x_4^2=0&gt;, 
  &lt;a point in Q+(3, 3): x_1^2+x_2^2+x_3^2+x_4^2=0&gt;, 
  &lt;a point in Q+(3, 3): x_1^2+x_2^2+x_3^2+x_4^2=0&gt;, 
  &lt;a point in Q+(3, 3): x_1^2+x_2^2+x_3^2+x_4^2=0&gt;, 
  &lt;a point in Q+(3, 3): x_1^2+x_2^2+x_3^2+x_4^2=0&gt;, 
  &lt;a point in Q+(3, 3): x_1^2+x_2^2+x_3^2+x_4^2=0&gt;, 
  &lt;a point in Q+(3, 3): x_1^2+x_2^2+x_3^2+x_4^2=0&gt;, 
  &lt;a point in Q+(3, 3): x_1^2+x_2^2+x_3^2+x_4^2=0&gt;, 
  &lt;a point in Q+(3, 3): x_1^2+x_2^2+x_3^2+x_4^2=0&gt;, 
  &lt;a point in Q+(3, 3): x_1^2+x_2^2+x_3^2+x_4^2=0&gt;, 
  &lt;a point in Q+(3, 3): x_1^2+x_2^2+x_3^2+x_4^2=0&gt;, 
  &lt;a point in Q+(3, 3): x_1^2+x_2^2+x_3^2+x_4^2=0&gt;, 
  &lt;a point in Q+(3, 3): x_1^2+x_2^2+x_3^2+x_4^2=0&gt;, 
  &lt;a point in Q+(3, 3): x_1^2+x_2^2+x_3^2+x_4^2=0&gt;, 
  &lt;a point in Q+(3, 3): x_1^2+x_2^2+x_3^2+x_4^2=0&gt; ]
 
</pre></div>

<p><a id="X863BC8E57C98A471" name="X863BC8E57C98A471"></a></p>

<h5>6.3-3 PolarSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolarSpace</code>( <var class="Arg">f</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a polar space</p>

<p>When <var class="Arg">f</var> is not a pseudo-polarity, this operation returns the polar space induced by <var class="Arg">f</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[1,0,0,0],[0,0,1,1],[0,1,1,0],[0,1,0,0]]*Z(32)^0;</span>
[ [ Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2) ], [ 0*Z(2), 0*Z(2), Z(2)^0, Z(2)^0 ], 
  [ 0*Z(2), Z(2)^0, Z(2)^0, 0*Z(2) ], [ 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := PolarityOfProjectiveSpace(mat,GF(32));</span>
&lt;polarity of PG(3, GF(2^5)) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := PolarSpace(phi);</span>
Error, &lt;polarity&gt; is pseudo and does not induce a polar space called from
&lt;function "unknown"&gt;( &lt;arguments&gt; )
 called from read-eval loop at line 10 of *stdin*
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
<span class="GAPbrkprompt">brk&gt;</span> <span class="GAPinput">quit;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := IdentityMat(5,GF(7));</span>
[ [ Z(7)^0, 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7) ], 
  [ 0*Z(7), Z(7)^0, 0*Z(7), 0*Z(7), 0*Z(7) ], 
  [ 0*Z(7), 0*Z(7), Z(7)^0, 0*Z(7), 0*Z(7) ], 
  [ 0*Z(7), 0*Z(7), 0*Z(7), Z(7)^0, 0*Z(7) ], 
  [ 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), Z(7)^0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := PolarityOfProjectiveSpace(mat,GF(7));</span>
&lt;polarity of PG(4, GF(7)) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := PolarSpace(phi);</span>
&lt;polar space in ProjectiveSpace(4,GF(7)): x_1^2+x_2^2+x_3^2+x_4^2+x_5^2=0 &gt;
 
</pre></div>

<p><a id="X7ADFEAC07CE25530" name="X7ADFEAC07CE25530"></a></p>

<h4>6.4 <span class="Heading">Commuting polarities</span></h4>

<p><strong class="pkg">FinInG</strong> constructs polarities of projective spaces as correlations. This allows polarities to be multiplied easily, resulting in a collineation. The resulting collineation is constructed in the correlation group but can be mapped onto its unique representative in the collineation group. We provide an example with two commuting polarities.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0,1,0,0],[1,0,0,0],[0,0,0,1],[0,0,1,0]]*Z(5)^0;</span>
[ [ 0*Z(5), Z(5)^0, 0*Z(5), 0*Z(5) ], [ Z(5)^0, 0*Z(5), 0*Z(5), 0*Z(5) ], 
  [ 0*Z(5), 0*Z(5), 0*Z(5), Z(5)^0 ], [ 0*Z(5), 0*Z(5), Z(5)^0, 0*Z(5) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := HermitianPolarityOfProjectiveSpace(mat,GF(25));</span>
&lt;polarity of PG(3, GF(5^2)) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat2 := IdentityMat(4,GF(5));</span>
[ [ Z(5)^0, 0*Z(5), 0*Z(5), 0*Z(5) ], [ 0*Z(5), Z(5)^0, 0*Z(5), 0*Z(5) ], 
  [ 0*Z(5), 0*Z(5), Z(5)^0, 0*Z(5) ], [ 0*Z(5), 0*Z(5), 0*Z(5), Z(5)^0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">psi := PolarityOfProjectiveSpace(mat2,GF(25));</span>
&lt;polarity of PG(3, GF(5^2)) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi*psi = psi*phi;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := CorrelationCollineationGroup(PG(3,25));</span>
The FinInG correlation-collineation group PGammaL(4,25) : 2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h := CollineationGroup(PG(3,25));</span>
The FinInG collineation group PGammaL(4,25)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom := Embedding(h,g);</span>
MappingByFunction( The FinInG collineation group PGammaL(4,25), The FinInG cor
relation-collineation group PGammaL(4,25) : 2, function( y ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coll := PreImagesRepresentative(hom,phi*psi);</span>
&lt; a collineation: &lt;cmat 4x4 over GF(5,2)&gt;, F^5&gt;
 
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap5_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap7_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chapA_mj.html">A</a>  <a href="chapB_mj.html">B</a>  <a href="chapC_mj.html">C</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
