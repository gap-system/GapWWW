<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (FinInG) - Chapter 7: Finite Classical Polar Spaces</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap7"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chapA.html">A</a>  <a href="chapB.html">B</a>  <a href="chapC.html">C</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap6.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap8.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap7_mj.html">[MathJax on]</a></p>
<p><a id="X7F96B1327C022A28" name="X7F96B1327C022A28"></a></p>
<div class="ChapSects"><a href="chap7.html#X7F96B1327C022A28">7 <span class="Heading">Finite Classical Polar Spaces</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7.html#X7F96B1327C022A28">7.1 <span class="Heading">Finite Classical Polar Spaces</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X83A92A177BE4E0BB">7.1-1 IsClassicalPolarSpace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X863BC8E57C98A471">7.1-2 PolarSpace</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7.html#X850CD32686B0656B">7.2 <span class="Heading">Canonical and standard Polar Spaces</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X850980EF8607BDA7">7.2-1 SymplecticSpace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7A8CF840833D3D8B">7.2-2 HermitianPolarSpace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7CEDD5CC7A6B0E64">7.2-3 ParabolicQuadric</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7CF248A2864BCD8F">7.2-4 HyperbolicQuadric</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X85EEF70480D7149E">7.2-5 EllipticQuadric</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7F6D25D57BC697B5">7.2-6 IsCanonicalPolarSpace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X8240380A7F8B6EC3">7.2-7 CanonicalPolarSpace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7EE25EDF7ADC30D7">7.2-8 StandardPolarSpace</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7.html#X7A04340A7EC9215B">7.3 <span class="Heading">Basic operations for finite classical polar spaces</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7D544D7985A4572D">7.3-1 UnderlyingVectorSpace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X8606750A8586DF8D">7.3-2 AmbientSpace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X84FDF25D797B874B">7.3-3 ProjectiveDimension</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X827146F37E2AA841">7.3-4 Rank</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7BCBA564829D9E89">7.3-5 BaseField</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X8412E6307ACC82C2">7.3-6 IsHyperbolicQuadric</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X85386DAB8056E316">7.3-7 IsEllipticQuadric</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X87ADB8B5790776C7">7.3-8 IsParabolicQuadric</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7.html#X787E0AEA8284B34B">7.4 <span class="Heading">Subspaces of finite classical polar spaces</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X82E9593B8074AECB">7.4-1 VectorSpaceToElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X8461BCEF862B9A7B">7.4-2 EmptySubspace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X84FDF25D797B874B">7.4-3 ProjectiveDimension</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X87657AEF7E2C50F9">7.4-4 ElementsOfIncidenceStructure</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X8606750A8586DF8D">7.4-5 AmbientSpace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X84E3985A8700B302">7.4-6 Coordinates</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7.html#X8472E78A79F44828">7.5 <span class="Heading">Basic operations for polar spaces and subspaces of projective spaces</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7904128479BDFCC9">7.5-1 <span class="Heading">Incidence and containment</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X875BE2957FAF6209">7.5-2 Span</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X8469B54180FE1E4C">7.5-3 Meet</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X8176044E7D2242D9">7.5-4 IsCollinear</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7EBD8C07802562B7">7.5-5 PolarityOfProjectiveSpace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X863F1924805F6C63">7.5-6 TypeOfSubspace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X82C38639870C0DD6">7.5-7 TangentSpace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X8520DC538717C6BE">7.5-8 Pole</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7.html#X7AA14EDF7B0B1569">7.6 <span class="Heading">Shadow of elements</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7FFA08DA85C5251C">7.6-1 ShadowOfElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X81A8365A7FE68447">7.6-2 ElementsIncidentWithElementOfIncidenceStructure</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7.html#X7988AF9978E75E37">7.7 <span class="Heading">Projective Orthogonal/Unitary/Symplectic groups in <strong class="pkg">FinInG</strong></span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X857C261585038CB8">7.7-1 SpecialIsometryGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X87708229834E4C44">7.7-2 IsometryGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X812836E48364AE6D">7.7-3 SimilarityGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X83FF6FA0790D5747">7.7-4 CollineationGroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7.html#X855D48A07E0BBCDB">7.8 <span class="Heading">Enumerating subspaces of polar spaces</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7AB1BA95825BDE71">7.8-1 <span class="Heading">Enumerators for polar spaces</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7EF8910F82B45EC7">7.8-2 Enumerator</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X861463147B738DF1">7.8-3 <span class="Heading">Iterators for polar spaces</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X83ADF8287ED0668E">7.8-4 Iterator</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X8289FCCC8274C89D">7.8-5 AsList</a></span>
</div></div>
</div>

<h3>7 <span class="Heading">Finite Classical Polar Spaces</span></h3>

<p>In this chapter we describe how to use <strong class="pkg">FinInG</strong> to work with finite classical polar spaces.</p>

<p><a id="X7F96B1327C022A28" name="X7F96B1327C022A28"></a></p>

<h4>7.1 <span class="Heading">Finite Classical Polar Spaces</span></h4>

<p>A <em>polar space</em> is a point-line incidence geometry, satisfying the famous one-or-all axiom, i.e. for any point <span class="SimpleMath">P</span>, not incident with a line <span class="SimpleMath">l</span>, <span class="SimpleMath">P</span> is collinear with exactly one point of <span class="SimpleMath">l</span> or with all points of <span class="SimpleMath">l</span>. The axiomatic treatment of polar spaces has its foundations in <a href="chapBib.html#biBVeldkamp">[Vel59]</a>, <a href="chapBib.html#biBTits74">[Tit74]</a>, and <a href="chapBib.html#biBBS1974">[BS74]</a>, the latter in which the one-or-all axiom is described. Polar spaces are axiomatically, point-line geometries, but may contain higher dimensional projective subspaces too. All maximal subspaces have the same projective dimension, and this determines the rank of the polar space.</p>

<p>Well known examples of <em>finite</em> polar spaces are the geometries attached to sesquilinear and quadratic forms of vector spaces over a finite field, these geometries are called the <em>finite classical polar spaces</em>. For a given sesquilinear, respectively quadratic, form <span class="SimpleMath">f</span>, the elements of the associated geometry are the totally isotropic, respectively totally singular, subspaces of the vectors space with relation to the form <span class="SimpleMath">f</span>. The treatment of the forms is done through the package <strong class="pkg">Forms</strong>.</p>

<p>From the axiomatic point of view, a polar space is a point-line geometry, and has rank at least 2. Considering a sesquilinear or quadratic form <span class="SimpleMath">f</span>, of Witt index 1, the associated geometry consists only of projective points, and is then in the axiomatic treatment, not a polar space. However, as is the case for projective spaces, we will consider the rank one geometries associated to forms of Witt index 1 as examples of classical polar spaces. Even the elliptic quadric on the projective line, a <em>geometry</em> associated to an elliptic quadratic form on a two dimensional vector space over a finite field, is considered as a classical polar space, though it has no singular subspaces. The reason for this treatment is that most, if not all, methods for operations applicable on these geometries, rely on the same algebraic methodology. So, in <strong class="pkg">FinInG</strong>, a classical polar space (sometimes abbreviated to polar space), is the geometry associated with a sesquilinear or quadratic form on a finite dimensional vector space over a finite field.</p>

<p><a id="X83A92A177BE4E0BB" name="X83A92A177BE4E0BB"></a></p>

<h5>7.1-1 IsClassicalPolarSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsClassicalPolarSpace</code></td><td class="tdright">( category )</td></tr></table></div>
<p>This category is a subcategory of <code class="code">IsLieGeometry</code>, and contains all the geometries associated to a non-degenerate sesquilinear or quadratic form.</p>

<p>The underlying vector space and matrix group are to our advantage in the treatment of classical polar spaces. We refer the reader to <a href="chapBib.html#biBHirschfeldThas">[HT91]</a> and <a href="chapBib.html#biBCameron">[Cam00b]</a> for the necessary background theory (if it is not otherwise provided), and we follow the approach of <a href="chapBib.html#biBCameron">[Cam00b]</a> to introduce all different flavours.</p>

<p>Consider the projective space PG(n,q) with underlying vector space <span class="SimpleMath">V(n+1,q)</span>. Consider a non-degenerate sesquilinear form <span class="SimpleMath">f</span>. Then <span class="SimpleMath">f</span> is Hermitian, alternating or symmetric. When the characteristic of the field is odd, respectively even, a symmetric bilinear form is called orthogonal, respectively, pseudo. We do not consider the pseudo case, so we suppose that <span class="SimpleMath">f</span> is Hermitian, symplectic or orthogonal. The classical polar space associated with <span class="SimpleMath">f</span> is the incidence geometry whose elements are of the subspaces of PG(n,q) whose underlying vector subspace is totally isotropic with relation to <span class="SimpleMath">f</span>. We call a polar space <em>Hermitian</em>, respectively, <em>symplectic</em>, <em>orthogonal</em>, if the underlying sesquilinear form is Hermitian, respectively, symplectic, orthogonal.</p>

<p>Symmetric bilinear forms have completely different geometric properties in even characteristic than in odd characteristic. On the other hand, polar spaces geometrically comparable to orthogonal polar spaces in odd characteristic, do exist in even characteristic. The algebraic background is now established by quadratic forms on a vector space instead of bilinear forms. Consider a non-singular quadratic form <span class="SimpleMath">q</span> on a vector space <span class="SimpleMath">V(n+1,q)</span>. The classical polar space associated with <span class="SimpleMath">f</span> is the incidence geometry whose elements are the subspaces of PG(n,q) whose underlying vector subspace is totally singular with relation to <span class="SimpleMath">q</span>. The connection with orthogonal polar spaces in odd characteristic is clear, since in odd characteristic, quadratic forms and symmetric bilinear forms are equivalent. Therefore, we call polar spaces with an underlying quadratic form in even characteristic also <em>orthogonal</em> polar spaces.</p>

<p><a id="X863BC8E57C98A471" name="X863BC8E57C98A471"></a></p>

<h5>7.1-2 PolarSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolarSpace</code>( <var class="Arg">form</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolarSpace</code>( <var class="Arg">pol</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a classical polar space</p>

<p><var class="Arg">form</var> must be a sesquilinear or quadratic form created by use of the GAP package <strong class="pkg">Forms</strong>. In the second variant, the argument <var class="Arg">pol</var> must be a polarity of a projective space. An error message will be displayed if <var class="Arg">pol</var> is a pseudo polarity. We refer to Chapter <a href="chap6.html#X87BA55CB86B110EC"><span class="RefLink">6</span></a> for more information on polarities of projective spaces, and more particularly to Section <a href="chap6.html#X83F8149B7D23301E"><span class="RefLink">6.3</span></a> for the connection between polarities and forms.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0,0,0,1],[0,0,-2,0],[0,2,0,0],[-1,0,0,0]]*Z(5)^0;</span>
[ [ 0*Z(5), 0*Z(5), 0*Z(5), Z(5)^0 ], [ 0*Z(5), 0*Z(5), Z(5)^3, 0*Z(5) ], 
  [ 0*Z(5), Z(5), 0*Z(5), 0*Z(5) ], [ Z(5)^2, 0*Z(5), 0*Z(5), 0*Z(5) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := BilinearFormByMatrix(mat,GF(25));</span>
&lt; bilinear form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := PolarSpace(form);</span>
&lt;polar space in ProjectiveSpace(
3,GF(5^2)): x1*y4+Z(5)^3*x2*y3+Z(5)*x3*y2-x4*y1=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r := PolynomialRing(GF(32),4);</span>
GF(2^5)[x_1,x_2,x_3,x_4]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poly := r.3*r.2+r.1*r.4;</span>
x_1*x_4+x_2*x_3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := QuadraticFormByPolynomial(poly,r);</span>
&lt; quadratic form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := PolarSpace(form);</span>
&lt;polar space in ProjectiveSpace(3,GF(2^5)): x_1*x_4+x_2*x_3=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := IdentityMat(5,GF(7));</span>
[ [ Z(7)^0, 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7) ], 
  [ 0*Z(7), Z(7)^0, 0*Z(7), 0*Z(7), 0*Z(7) ], 
  [ 0*Z(7), 0*Z(7), Z(7)^0, 0*Z(7), 0*Z(7) ], 
  [ 0*Z(7), 0*Z(7), 0*Z(7), Z(7)^0, 0*Z(7) ], 
  [ 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), Z(7)^0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := PolarityOfProjectiveSpace(mat,GF(7));</span>
&lt;polarity of PG(4, GF(7)) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := PolarSpace(phi);</span>
&lt;polar space in ProjectiveSpace(4,GF(7)): x_1^2+x_2^2+x_3^2+x_4^2+x_5^2=0 &gt;
 
</pre></div>

<p><strong class="pkg">FinInG</strong> relies on the package <strong class="pkg">Forms</strong> for its facility with sesquilinear and quadratic forms. One can specify a polar space with a user-defined form, and we refer to the documentation for <strong class="pkg">Forms</strong> for information on how one can create and use forms. Here we just display a worked example.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMat(7, GF(3));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := QuadraticFormByMatrix(id, GF(3));</span>
&lt; quadratic form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := PolarSpace( form );</span>
&lt;polar space in ProjectiveSpace(
6,GF(3)): x_1^2+x_2^2+x_3^2+x_4^2+x_5^2+x_6^2+x_7^2=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">psl32 := PSL(3,2);</span>
Group([ (4,6)(5,7), (1,2,4)(3,6,5) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">reps:=[[1,1,1,0,0,0,0], [-1,1,1,0,0,0,0], [1,-1,1,0,0,0,0], [1,1,-1,0,0,0,0]]*Z(3)^0;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ovoid := Union( List(reps, x-&gt; Orbit(psl32, x, Permuted)) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ovoid := List(ovoid, x -&gt; VectorSpaceToElement(ps, x));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">planes := AsList( Planes( ps ) );;</span>
#I  Computing collineation group of canonical polar space...
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll(planes, p -&gt; Number(ovoid, x -&gt; x in p) = 1);</span>
true
 
</pre></div>

<p><a id="X850CD32686B0656B" name="X850CD32686B0656B"></a></p>

<h4>7.2 <span class="Heading">Canonical and standard Polar Spaces</span></h4>

<p>To introduce the classification of polar spaces, we use the classification of the underlying forms in similarity classes. We follow mostly the approach and terminology of <a href="chapBib.html#biBKleidmanLiebeck">[KL90]</a>, as we did in the manual of the package <strong class="pkg">Forms</strong>.</p>

<p>Consider a vector space <span class="SimpleMath">V=V(n+1,q)</span> and a sesquilinear form <span class="SimpleMath">f</span> on <span class="SimpleMath">V</span>. The pair <span class="SimpleMath">(V,f)</span> is called a formed space. Consider now two formed spaces <span class="SimpleMath">(V,f)</span> and <span class="SimpleMath">(V,f')</span>, where <span class="SimpleMath">f</span> and <span class="SimpleMath">f'</span> are two sesquilinear forms on <span class="SimpleMath">V</span>. A non-singular linear map φ from <span class="SimpleMath">V</span> to itself induces a <em>similarity</em> of the formed space <span class="SimpleMath">(V,f)</span> to the formed space <span class="SimpleMath">(V,f')</span> if and only if</p>

<p class="pcenter">f(v,w) = λ (f'(φ(v),φ(w))),</p>

<p>for all vectors <span class="SimpleMath">v,w</span> and some non-zero λ in <span class="SimpleMath">GF(q)</span>. Up to similarity, there is only one class of non-degenerate Hermitian forms, and one class of non-degenerate symplectic forms on a given vector space <span class="SimpleMath">V</span>. For symmetric bilinear forms in odd characteristic, the number of similarity classes depends on the dimension of <span class="SimpleMath">V</span>. In odd dimension, there is only one similarity class, and non-degenerate forms in this class are called parabolic (bilinear) forms. In even dimension, there are two similarity classes, and non-degenerate forms are either elliptic (bilinear) forms or hyperbolic (bilinear) forms.</p>

<p>Consider now a vector space <span class="SimpleMath">V</span> and a quadratic form <span class="SimpleMath">q</span> on <span class="SimpleMath">V</span>. The pair <span class="SimpleMath">(V,q)</span> is called a formed space. Consider now two formed spaces <span class="SimpleMath">(V,q)</span> and <span class="SimpleMath">(V,q')</span>, where <span class="SimpleMath">q</span> and <span class="SimpleMath">q'</span> are two quadratic forms on <span class="SimpleMath">V</span>. A non-degenerate linear map φ from <span class="SimpleMath">V</span> to itself induces a <em>similarity</em> of the formed space <span class="SimpleMath">(V,q)</span> to the formed space <span class="SimpleMath">(V,q')</span> if and only if</p>

<p class="pcenter">q(v) = λ (q'(φ(v))),</p>

<p>for all vectors <span class="SimpleMath">v</span> and some non-zero λ in <span class="SimpleMath">GF(q)</span>. For quadratic forms in even characteristic, the number of similarity classes depends on the dimension of <span class="SimpleMath">V</span>. In odd dimension, there is only one similarity class, and non-degenerate forms in this class are called parabolic (bilinear) forms. In even dimension, there are two similarity classes, and non-degenerate forms are either elliptic (bilinear) forms or hyperbolic (bilinear) forms.</p>

<p>If φ induces a similarity of a formed vector space such that <span class="SimpleMath">λ = 1</span>, then the similarity is called an <em>isometry</em> of the formed vector space. In almost all cases, each similarity class contains exactly one isometry class. Only the orthogonal sesquilinear forms (in odd characteristic) have two isometry classes. Consequently, if an isometry exists between formed vector spaces, they are called <em>isometric</em>. Projectively, a formed vector space becomes a classical polar space embedded in a projective space. Obviously, forms in the same similarity class determine exactly the same classical polar space. Conversely, it is well known that a classical polar space determines a form up to a constant factor, i.e. it determines a similarity class of forms. In <strong class="pkg">FinInG</strong>, the word <em>canonical</em> is used in the mathematical sense, i.e. a classical polar space is <em>canonical</em> if its determining form belongs to a fixed similarity class. A classical polar space is called <em>standard</em> if its determining form is the fixed representative of the canonical similarity class. Hence a <em>standard</em> classical polar space is always a <em>canonical</em> classical polar space, a canonical polar space is determined by a standard form up to a constant factor. In the following table, we summerise the above information on polar spaces, together with the standard forms that are chosen in <strong class="pkg">FinInG</strong>. Note that Tr refers to the absolute trace map from GF(q) to GF(p).</p>

<div class="pcenter"><table class="GAPDocTable">
<caption class="GAPDocTable"><b>Table: </b>finite classical polar spaces</caption>
<tr>
<td class="tdleft">polar space</td>
<td class="tdleft">standard form</td>
<td class="tdleft">characteristic <span class="SimpleMath">p</span></td>
<td class="tdleft">projective dimension</td>
</tr>
<tr>
<td class="tdleft">hermitian polar space</td>
<td class="tdleft">X<sub>0</sub><sup>q+1</sup> + X<sub>1</sub><sup>q+1</sup> ... + X<sub>n</sub><sup>q+1</sup></td>
<td class="tdleft">odd or even</td>
<td class="tdleft">odd or even</td>
</tr>
<tr>
<td class="tdleft">symplectic space</td>
<td class="tdleft">X<sub>0</sub> Y<sub>1</sub> - X<sub>1</sub>Y<sub>0</sub> + ... + X<sub>n-1</sub>Y<sub>n</sub> - X<sub>n</sub>Y<sub>n-1</sub></td>
<td class="tdleft">odd or even</td>
<td class="tdleft">odd</td>
</tr>
<tr>
<td class="tdleft">hyperbolic quadric</td>
<td class="tdleft">X<sub>0</sub> X<sub>1</sub> + ... + X<sub>n-1</sub>X<sub>n</sub></td>
<td class="tdleft">p ≡ 3 mod 4 or p=2</td>
<td class="tdleft">odd</td>
</tr>
<tr>
<td class="tdleft">hyperbolic quadric</td>
<td class="tdleft">2(X<sub>0</sub> X<sub>1</sub> + ... + X<sub>n-1</sub>X<sub>n</sub> )</td>
<td class="tdleft">p ≡ 1 mod 4</td>
<td class="tdleft">odd</td>
</tr>
<tr>
<td class="tdleft">parabolic quadric</td>
<td class="tdleft">X<sub>0</sub><sup>2</sup> + X<sub>1</sub> X<sub>2</sub> + ... + X<sub>n-1</sub>X<sub>n</sub></td>
<td class="tdleft">p ≡ 1,3 mod 8 or <span class="SimpleMath">p=2</span></td>
<td class="tdleft">even</td>
</tr>
<tr>
<td class="tdleft">parabolic quadric</td>
<td class="tdleft">t(X<sub>0</sub><sup>2</sup> + X<sub>1</sub> X<sub>2</sub> + ... + X<sub>n-1</sub>X<sub>n</sub>), <span class="SimpleMath">t</span> a primitive element of <span class="SimpleMath">GF(p)</span></td>
<td class="tdleft">p ≡ 5,7 mod 8</td>
<td class="tdleft">even</td>
</tr>
<tr>
<td class="tdleft">elliptic quadric</td>
<td class="tdleft">X<sub>0</sub><sup>2</sup> + X<sub>1</sub><sup>2</sup> + X<sub>2</sub> X<sub>3</sub> + ... + X<sub>n-1</sub>X<sub>n</sub></td>
<td class="tdleft">p ≡ 3 mod 4</td>
<td class="tdleft">odd</td>
</tr>
<tr>
<td class="tdleft">elliptic quadric</td>
<td class="tdleft">X<sub>0</sub><sup>2</sup> + tX<sub>1</sub><sup>2</sup> + X<sub>2</sub> X<sub>3</sub> + ... + X<sub>n-1</sub>X<sub>n</sub>, <span class="SimpleMath">t</span> a primitive element of GF(p)</td>
<td class="tdleft">p ≡ 1 mod 4</td>
<td class="tdleft">odd</td>
</tr>
<tr>
<td class="tdleft">elliptic quadric</td>
<td class="tdleft">X<sub>0</sub><sup>2</sup> + X<sub>0</sub>X<sub>1</sub> + d X<sub>1</sub><sup>2</sup> + X<sub>2</sub> X<sub>3</sub> + ... + X<sub>n-1</sub>X<sub>n</sub> , Tr(d) = 1</td>
<td class="tdleft">even</td>
<td class="tdleft">odd</td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p>We refer to Appendix <a href="chapB.html#X866C644987E43DF8"><span class="RefLink">B</span></a> for information on the operations that construct gram matrices that are used to obtain the above standard forms.</p>

<p>The <strong class="pkg">FinInG</strong> provides a wealth of flexibility in constructing polar spaces. The user may choose a particular quadratic or sesquilinear form, but may also chose to construct polars spaces that have one of the above mentioned forms as underlying form. Furthermore, <strong class="pkg">FinInG</strong> will detect when necessary if the user-constructed polar space is canonical. This mechanism gives the user complete flexibility while avoiding unnecessary computations when, for example, constructing the collineation group of a user-defined polar space.</p>

<p>The following five operations always return polar spaces induced by one of the above standard forms.</p>

<p><a id="X850980EF8607BDA7" name="X850980EF8607BDA7"></a></p>

<h5>7.2-1 SymplecticSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SymplecticSpace</code>( <var class="Arg">d</var>, <var class="Arg">F</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SymplecticSpace</code>( <var class="Arg">d</var>, <var class="Arg">q</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a symplectic polar space</p>

<p>This function returns the symplectic polar space of dimension <var class="Arg">d</var> over <var class="Arg">F</var> for a field <var class="Arg">F</var> or over GF(<var class="Arg">q</var>) for a prime power <var class="Arg">q</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := SymplecticSpace(3,4);</span>
W(3, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(ps);</span>
W(3, 4)
Symplectic form
Gram Matrix:
 . 1 . .
 1 . . .
 . . . 1
 . . 1 .
Witt Index: 2
 
</pre></div>

<p><a id="X7A8CF840833D3D8B" name="X7A8CF840833D3D8B"></a></p>

<h5>7.2-2 HermitianPolarSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HermitianPolarSpace</code>( <var class="Arg">d</var>, <var class="Arg">F</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HermitianPolarSpace</code>( <var class="Arg">d</var>, <var class="Arg">q</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a Hermitian polar space</p>

<p>This function returns the Hermitian polar space of dimension <var class="Arg">d</var> over <var class="Arg">F</var> for a field <var class="Arg">F</var> or over GF(<var class="Arg">q</var>) for a prime power <var class="Arg">q</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HermitianPolarSpace(2,25);</span>
H(2, 5^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(ps);</span>
H(2, 25)
Hermitian form
Gram Matrix:
 1 . .
 . 1 .
 . . 1
Polynomial: [ [  x_1^6+x_2^6+x_3^6 ] ]
Witt Index: 1
 
</pre></div>

<p><a id="X7CEDD5CC7A6B0E64" name="X7CEDD5CC7A6B0E64"></a></p>

<h5>7.2-3 ParabolicQuadric</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ParabolicQuadric</code>( <var class="Arg">d</var>, <var class="Arg">F</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ParabolicQuadric</code>( <var class="Arg">d</var>, <var class="Arg">q</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a parabolic quadric</p>

<p><var class="Arg">d</var> must be an even positive integer. This function returns the parabolic quadric of dimension <var class="Arg">d</var> over <var class="Arg">F</var> for a field <var class="Arg">F</var> or over GF(<var class="Arg">q</var>) for a prime power <var class="Arg">q</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := ParabolicQuadric(2,9);</span>
Q(2, 9)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(ps);</span>
Q(2, 9)
Parabolic bilinear form
Gram Matrix:
 1 . .
 . . 2
 . 2 .
Polynomial: [ [  x_1^2+x_2*x_3 ] ]
Witt Index: 1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := ParabolicQuadric(4,16);</span>
Q(4, 16)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(ps);</span>
Q(4, 16)
Parabolic quadratic form
Gram Matrix:
 1 . . . .
 . . 1 . .
 . . . . .
 . . . . 1
 . . . . .
Polynomial: [ [  x_1^2+x_2*x_3+x_4*x_5 ] ]
Witt Index: 2
Bilinear form
Gram Matrix:
 . . . . .
 . . 1 . .
 . 1 . . .
 . . . . 1
 . . . 1 .
 
</pre></div>

<p><a id="X7CF248A2864BCD8F" name="X7CF248A2864BCD8F"></a></p>

<h5>7.2-4 HyperbolicQuadric</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HyperbolicQuadric</code>( <var class="Arg">d</var>, <var class="Arg">F</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HyperbolicQuadric</code>( <var class="Arg">d</var>, <var class="Arg">q</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a hyperbolic quadric</p>

<p><var class="Arg">d</var> must be an odd positive integer. This function returns the hyperbolic quadric of dimension <var class="Arg">d</var> over <var class="Arg">F</var> for a field <var class="Arg">F</var> or over GF(<var class="Arg">q</var>) for a prime power <var class="Arg">q</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HyperbolicQuadric(5,3);</span>
Q+(5, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(ps);</span>
Q+(5, 3)
Hyperbolic bilinear form
Gram Matrix:
 . 2 . . . .
 2 . . . . .
 . . . 2 . .
 . . 2 . . .
 . . . . . 2
 . . . . 2 .
Polynomial: [ [  x_1*x_2+x_3*x_4+x_5*x_6 ] ]
Witt Index: 3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HyperbolicQuadric(3,4);</span>
Q+(3, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(ps);</span>
Q+(3, 4)
Hyperbolic quadratic form
Gram Matrix:
 . 1 . .
 . . . .
 . . . 1
 . . . .
Polynomial: [ [  x_1*x_2+x_3*x_4 ] ]
Witt Index: 2
Bilinear form
Gram Matrix:
 . 1 . .
 1 . . .
 . . . 1
 . . 1 .
 
</pre></div>

<p><a id="X85EEF70480D7149E" name="X85EEF70480D7149E"></a></p>

<h5>7.2-5 EllipticQuadric</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EllipticQuadric</code>( <var class="Arg">d</var>, <var class="Arg">F</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EllipticQuadric</code>( <var class="Arg">d</var>, <var class="Arg">q</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: an elliptic quadric</p>

<p><var class="Arg">d</var> must be an odd positive integer. This function returns the elliptic quadric of dimension <var class="Arg">d</var> over <var class="Arg">F</var> for a field <var class="Arg">F</var> or over GF(<var class="Arg">q</var>) for a prime power <var class="Arg">q</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := EllipticQuadric(3,27);</span>
Q-(3, 27)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(ps);</span>
Q-(3, 27)
Elliptic bilinear form
Gram Matrix:
 1 . . .
 . 1 . .
 . . . 2
 . . 2 .
Polynomial: [ [  x_1^2+x_2^2+x_3*x_4 ] ]
Witt Index: 1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := EllipticQuadric(5,8);</span>
Q-(5, 8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(ps);</span>
Q-(5, 8)
Elliptic quadratic form
Gram Matrix:
 1 1 . . . .
 . 1 . . . .
 . . . 1 . .
 . . . . . .
 . . . . . 1
 . . . . . .
Polynomial: [ [  x_1^2+x_1*x_2+x_2^2+x_3*x_4+x_5*x_6 ] ]
Witt Index: 2
Bilinear form
Gram Matrix:
 . 1 . . . .
 1 . . . . .
 . . . 1 . .
 . . 1 . . .
 . . . . . 1
 . . . . 1 .
 
</pre></div>

<p>The following operations are applicable on any classical polar space in <strong class="pkg">FinInG</strong>.</p>

<p><a id="X7F6D25D57BC697B5" name="X7F6D25D57BC697B5"></a></p>

<h5>7.2-6 IsCanonicalPolarSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCanonicalPolarSpace</code>( <var class="Arg">ps</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: true or false</p>

<p>This attribute returns true when a polar space with a particular underlying form is canonical. The execution of this attribute on a general user constructed polar space needs to check the type of <var class="Arg">ps</var>. The obtained extra information is stored automatically as attribute for <var class="Arg">ps</var>, as can be noted by the different printing of <var class="Arg">ps</var> before and after execution.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0,1,0,0],[0,0,0,0],[0,0,0,1],[0,0,0,0]]*Z(5)^0;</span>
[ [ 0*Z(5), Z(5)^0, 0*Z(5), 0*Z(5) ], [ 0*Z(5), 0*Z(5), 0*Z(5), 0*Z(5) ], 
  [ 0*Z(5), 0*Z(5), 0*Z(5), Z(5)^0 ], [ 0*Z(5), 0*Z(5), 0*Z(5), 0*Z(5) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := QuadraticFormByMatrix(mat,GF(5));</span>
&lt; quadratic form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := PolarSpace(form);</span>
&lt;polar space in ProjectiveSpace(3,GF(5)): x_1*x_2+x_3*x_4=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCanonicalPolarSpace(ps);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps;</span>
Q+(3, 5): x_1*x_2+x_3*x_4=0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[1,0,0],[0,0,1],[0,1,0]]*Z(3)^0;</span>
[ [ Z(3)^0, 0*Z(3), 0*Z(3) ], [ 0*Z(3), 0*Z(3), Z(3)^0 ], 
  [ 0*Z(3), Z(3)^0, 0*Z(3) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := QuadraticFormByMatrix(mat,GF(3));</span>
&lt; quadratic form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := PolarSpace(form);</span>
&lt;polar space in ProjectiveSpace(2,GF(3)): x_1^2-x_2*x_3=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCanonicalPolarSpace(ps);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps;</span>
Q(2, 3): x_1^2-x_2*x_3=0
 
</pre></div>

<p><a id="X8240380A7F8B6EC3" name="X8240380A7F8B6EC3"></a></p>

<h5>7.2-7 CanonicalPolarSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CanonicalPolarSpace</code>( <var class="Arg">form</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CanonicalPolarSpace</code>( <var class="Arg">P</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a classical polar space</p>

<p>the canonical polar space isometric to the given polar space <var class="Arg">P</var> or the classical polar space with underlying form <var class="Arg">form</var>.</p>

<p><a id="X7EE25EDF7ADC30D7" name="X7EE25EDF7ADC30D7"></a></p>

<h5>7.2-8 StandardPolarSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StandardPolarSpace</code>( <var class="Arg">form</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StandardPolarSpace</code>( <var class="Arg">P</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a classical polar space</p>

<p>the polar space induced by a standard form and similar to the given polar space <var class="Arg">P</var> or the classical polar space with underlying form <var class="Arg">form</var>.</p>

<p><a id="X7A04340A7EC9215B" name="X7A04340A7EC9215B"></a></p>

<h4>7.3 <span class="Heading">Basic operations for finite classical polar spaces</span></h4>

<p><a id="X7D544D7985A4572D" name="X7D544D7985A4572D"></a></p>

<h5>7.3-1 UnderlyingVectorSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingVectorSpace</code>( <var class="Arg">ps</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a vector space</p>

<p>The polar space <var class="Arg">ps</var> is the geometry associated with a sesquilinear or quadratic form <span class="SimpleMath">f</span>. The vector space on which <span class="SimpleMath">f</span> is acting is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := EllipticQuadric(5,4);</span>
Q-(5, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vs := UnderlyingVectorSpace(ps);</span>
( GF(2^2)^6 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := SymplecticSpace(3,81);</span>
W(3, 81)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vs := UnderlyingVectorSpace(ps);</span>
( GF(3^4)^4 )
 
</pre></div>

<p><a id="X8606750A8586DF8D" name="X8606750A8586DF8D"></a></p>

<h5>7.3-2 AmbientSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AmbientSpace</code>( <var class="Arg">ps</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: the ambient projective space</p>

<p>When <var class="Arg">ps</var> is a polar space, this operation returns the ambient projective space, i.e. the underlying projective space of the sequilinear or quadratic form that defines <var class="Arg">ps</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := EllipticQuadric(5,4);</span>
Q-(5, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AmbientSpace(ps);</span>
ProjectiveSpace(5, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := SymplecticSpace(3,81);</span>
W(3, 81)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AmbientSpace(ps);</span>
ProjectiveSpace(3, 81)
 
</pre></div>

<p><a id="X84FDF25D797B874B" name="X84FDF25D797B874B"></a></p>

<h5>7.3-3 ProjectiveDimension</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ProjectiveDimension</code>( <var class="Arg">ps</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Dimension</code>( <var class="Arg">ps</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: the dimension of the ambient projective space of <var class="Arg">ps</var></p>

<p>When <var class="Arg">ps</var> is a polar space, an ambient projective space <span class="SimpleMath">P</span> is uniquely defined and can be asked using <code class="file">AmbientSpace</code>. This operation and its synomym <code class="file">Dimension</code> returns the dimension of <span class="SimpleMath">P</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := EllipticQuadric(5,4);</span>
Q-(5, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProjectiveDimension(ps);</span>
5
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := SymplecticSpace(3,81);</span>
W(3, 81)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProjectiveDimension(ps);</span>
3
 
</pre></div>

<p><a id="X827146F37E2AA841" name="X827146F37E2AA841"></a></p>

<h5>7.3-4 Rank</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Rank</code>( <var class="Arg">ps</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: the rank of <var class="Arg">ps</var></p>

<p>When <var class="Arg">ps</var> is a polar space, its rank, i.e. the number of different types, equals the Witt index of the defining sesquilinear or quadratic form.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := EllipticQuadric(5,4);</span>
Q-(5, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Rank(ps);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HyperbolicQuadric(5,4);</span>
Q+(5, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Rank(ps);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := SymplecticSpace(7,81);</span>
W(7, 81)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Rank(ps);</span>
4
 
</pre></div>

<p><a id="X7BCBA564829D9E89" name="X7BCBA564829D9E89"></a></p>

<h5>7.3-5 BaseField</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BaseField</code>( <var class="Arg">ps</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: the base field of the polar space <var class="Arg">ps</var></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HyperbolicQuadric(5,7);</span>
Q+(5, 7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BaseField(ps);</span>
GF(7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HermitianPolarSpace(2,256);</span>
H(2, 16^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BaseField(ps);</span>
GF(2^8)
 
</pre></div>

<p><a id="X8412E6307ACC82C2" name="X8412E6307ACC82C2"></a></p>

<h5>7.3-6 IsHyperbolicQuadric</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsHyperbolicQuadric</code>( <var class="Arg">ps</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>Returns: true or false</p>

<p>returns true if and only if <var class="Arg">ps</var> is a hyperbolic quadric.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := IdentityMat(6,GF(5));</span>
&lt; mutable compressed matrix 6x6 over GF(5) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := BilinearFormByMatrix(mat,GF(5));</span>
&lt; bilinear form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := PolarSpace(form);</span>
&lt;polar space in ProjectiveSpace(
5,GF(5)): x_1^2+x_2^2+x_3^2+x_4^2+x_5^2+x_6^2=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsHyperbolicQuadric(ps);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := IdentityMat(6,GF(7));</span>
&lt; mutable compressed matrix 6x6 over GF(7) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := BilinearFormByMatrix(mat,GF(7));</span>
&lt; bilinear form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := PolarSpace(form);</span>
&lt;polar space in ProjectiveSpace(
5,GF(7)): x_1^2+x_2^2+x_3^2+x_4^2+x_5^2+x_6^2=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsHyperbolicQuadric(ps);</span>
false
 
</pre></div>

<p><a id="X85386DAB8056E316" name="X85386DAB8056E316"></a></p>

<h5>7.3-7 IsEllipticQuadric</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsEllipticQuadric</code>( <var class="Arg">ps</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>Returns: true or false</p>

<p>returns true if and only if <var class="Arg">ps</var> is an elliptic quadric.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := IdentityMat(6,GF(5));</span>
&lt; mutable compressed matrix 6x6 over GF(5) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := BilinearFormByMatrix(mat,GF(5));</span>
&lt; bilinear form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := PolarSpace(form);</span>
&lt;polar space in ProjectiveSpace(
5,GF(5)): x_1^2+x_2^2+x_3^2+x_4^2+x_5^2+x_6^2=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEllipticQuadric(ps);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := IdentityMat(6,GF(7));</span>
&lt; mutable compressed matrix 6x6 over GF(7) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := BilinearFormByMatrix(mat,GF(7));</span>
&lt; bilinear form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := PolarSpace(form);</span>
&lt;polar space in ProjectiveSpace(
5,GF(7)): x_1^2+x_2^2+x_3^2+x_4^2+x_5^2+x_6^2=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEllipticQuadric(ps);</span>
true
 
</pre></div>

<p><a id="X87ADB8B5790776C7" name="X87ADB8B5790776C7"></a></p>

<h5>7.3-8 IsParabolicQuadric</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsParabolicQuadric</code>( <var class="Arg">ps</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>Returns: true or false</p>

<p>returns true if and only if <var class="Arg">ps</var> is a parabolic quadric.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := IdentityMat(5,GF(9));</span>
[ [ Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3) ], 
  [ 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3) ], 
  [ 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3) ], 
  [ 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3) ], 
  [ 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := BilinearFormByMatrix(mat,GF(9));</span>
&lt; bilinear form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := PolarSpace(form);</span>
&lt;polar space in ProjectiveSpace(4,GF(3^2)): x_1^2+x_2^2+x_3^2+x_4^2+x_5^2=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsParabolicQuadric(ps);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[1,0,0,0,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,0,0,1],[0,0,0,0,0]]*Z(2)^0;</span>
[ [ Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2) ], 
  [ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2) ], 
  [ 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2) ], 
  [ 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0 ], 
  [ 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := QuadraticFormByMatrix(mat,GF(8));</span>
&lt; quadratic form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := PolarSpace(form);</span>
&lt;polar space in ProjectiveSpace(4,GF(2^3)): x_1^2+x_2*x_3+x_4*x_5=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsParabolicQuadric(ps);</span>
true
 
</pre></div>

<p><a id="X787E0AEA8284B34B" name="X787E0AEA8284B34B"></a></p>

<h4>7.4 <span class="Heading">Subspaces of finite classical polar spaces</span></h4>

<p>The elements of a finite classical polar space <span class="SimpleMath">P</span> are the subspaces of the ambient projective space that are totally isotropic with relation to the sesquilinear or quadratic form that defines <span class="SimpleMath">P</span>. Constructing subspaces of finite classical polar spaces is done as in the projective space case, except that additional checks are implemented in the methods to check that the subspace of the vector space is totally isotropic. The empty subspace, also called the trivial subspace, which has dimension -1, corresponds with the zero dimensional vector space of the underlying vector space of the ambient projective space of <span class="SimpleMath">P</span>, and is of course totally isotropic. As such, is is considered as a subspace of a finite classical polar space in the mathematical sense, but not as an element of the incidence geometry, and hence do in <strong class="pkg">FinInG</strong> not belong to the category <code class="code">IsSubspaceOfClassicalPolarSpace</code>.</p>

<p><a id="X82E9593B8074AECB" name="X82E9593B8074AECB"></a></p>

<h5>7.4-1 VectorSpaceToElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VectorSpaceToElement</code>( <var class="Arg">ps</var>, <var class="Arg">v</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: an element of the polar space <var class="Arg">geo</var></p>

<p>Let <var class="Arg">ps</var> be a polar space, and <var class="Arg">v</var> is either a row vector (for points) or an <span class="SimpleMath">m</span>x<span class="SimpleMath">n</span> matrix (for an <span class="SimpleMath">(m-1)</span>-subspace of a polar space with an <span class="SimpleMath">(n-1)</span>-dimensional ambient projective space. In the case that <var class="Arg">v</var> is a matrix, the rows represent basis vectors for the subspace. An exceptional case is when <var class="Arg">v</var> is a zero-vector, whereby the trivial subspace is returned. It is checked that the subspace defined by <span class="SimpleMath">v</span> is totally isotropic with relation to the form defining <var class="Arg">ps</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := SymplecticSpace(3,4);</span>
W(3, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v := [1,0,1,0]*Z(4)^0;</span>
[ Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := VectorSpaceToElement(ps,v);</span>
&lt;a point in W(3, 4)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[1,1,0,1],[0,0,1,0]]*Z(4)^0;</span>
[ [ Z(2)^0, Z(2)^0, 0*Z(2), Z(2)^0 ], [ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">line := VectorSpaceToElement(ps,mat);</span>
Error, &lt;x&gt; does not generate an element of &lt;geom&gt; called from
&lt;function "unknown"&gt;( &lt;arguments&gt; )
 called from read-eval loop at line 12 of *stdin*
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
<span class="GAPbrkprompt">brk&gt;</span> <span class="GAPinput">quit;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[1,1,0,0],[0,0,1,0]]*Z(4)^0;</span>
[ [ Z(2)^0, Z(2)^0, 0*Z(2), 0*Z(2) ], [ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">line := VectorSpaceToElement(ps,mat);</span>
&lt;a line in W(3, 4)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := VectorSpaceToElement(ps,[0,0,0,0]*Z(4)^0);</span>
&lt; empty subspace &gt;
 
</pre></div>

<p><a id="X8461BCEF862B9A7B" name="X8461BCEF862B9A7B"></a></p>

<h5>7.4-2 EmptySubspace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EmptySubspace</code>( <var class="Arg">ps</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: the trivial subspace in the projective <var class="Arg">ps</var></p>

<p>The object returned by this operation is contained in every projective subspace of the projective space <var class="Arg">ps</var>, but is not an element of <var class="Arg">ps</var>. Hence, testing incidence results in an error message.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HermitianPolarSpace(10,49);</span>
H(10, 7^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e := EmptySubspace(ps);</span>
&lt; empty subspace &gt;
 
</pre></div>

<p><a id="X84FDF25D797B874B" name="X84FDF25D797B874B"></a></p>

<h5>7.4-3 ProjectiveDimension</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ProjectiveDimension</code>( <var class="Arg">sub</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Dimension</code>( <var class="Arg">sub</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: the projective dimension of a subspace of a polar space. The operation <code class="file">ProjectiveDimension</code> is also applicable on the EmptySubspace</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := EllipticQuadric(7,8);</span>
Q-(7, 8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0]]*Z(8)^0;</span>
[ [ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2) ], 
  [ 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">line := VectorSpaceToElement(ps,mat);</span>
&lt;a line in Q-(7, 8)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProjectiveDimension(line);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dimension(line);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e := EmptySubspace(ps);</span>
&lt; empty subspace &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProjectiveDimension(e);</span>
-1
 
</pre></div>

<p><a id="X87657AEF7E2C50F9" name="X87657AEF7E2C50F9"></a></p>

<h5>7.4-4 ElementsOfIncidenceStructure</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementsOfIncidenceStructure</code>( <var class="Arg">ps</var>, <var class="Arg">j</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: the collection of elements of the projective space <var class="Arg">ps</var> of type <var class="Arg">j</var></p>

<p>For the projective space <var class="Arg">ps</var> of dimension <span class="SimpleMath">d</span> and the type <var class="Arg">j</var>, <span class="SimpleMath">1 ≤ j ≤ d</span> this operation returns the collection of <span class="SimpleMath">j-1</span> dimensional subspaces.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HermitianPolarSpace(8,13^2);</span>
H(8, 13^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">planes := ElementsOfIncidenceStructure(ps,3);</span>
&lt;planes of H(8, 13^2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">solids := ElementsOfIncidenceStructure(ps,4);</span>
&lt;solids of H(8, 13^2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ElementsOfIncidenceStructure(ps,5);</span>
Error, &lt;geo&gt; has no elements of type &lt;j&gt; called from
&lt;function "unknown"&gt;( &lt;arguments&gt; )
 called from read-eval loop at line 11 of *stdin*
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
<span class="GAPbrkprompt">brk&gt;</span> <span class="GAPinput">quit;</span>
 
</pre></div>

<p><a id="X8606750A8586DF8D" name="X8606750A8586DF8D"></a></p>

<h5>7.4-5 AmbientSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AmbientSpace</code>( <var class="Arg">el</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: returns the ambient space of an element <var class="Arg">el</var> of a polar space</p>

<p>This operation is also applicable on the trivial subspace. For a Lie geometry, the ambient space of an element is defined as the ambient space of the Lie geometry, i.e. a projective space.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HermitianPolarSpace(3,7^2);</span>
H(3, 7^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">line := VectorSpaceToElement(ps,[[Z(7)^0,0*Z(7),Z(7^2)^34,Z(7^2)^44],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[0*Z(7),Z(7)^0,Z(7^2)^2,Z(7^2)^4]]);</span>
&lt;a line in H(3, 7^2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AmbientSpace(line);</span>
ProjectiveSpace(3, 49)
 
</pre></div>

<p><a id="X84E3985A8700B302" name="X84E3985A8700B302"></a></p>

<h5>7.4-6 Coordinates</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Coordinates</code>( <var class="Arg">p</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: the homogeneous coordinates of the point <var class="Arg">p</var></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := ParabolicQuadric(6,5);</span>
Q(6, 5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := VectorSpaceToElement(ps,[0,1,0,0,0,0,0]*Z(5)^0);</span>
&lt;a point in Q(6, 5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Coordinates(p);</span>
[ 0*Z(5), Z(5)^0, 0*Z(5), 0*Z(5), 0*Z(5), 0*Z(5), 0*Z(5) ]
 
</pre></div>

<p><a id="X8472E78A79F44828" name="X8472E78A79F44828"></a></p>

<h4>7.5 <span class="Heading">Basic operations for polar spaces and subspaces of projective spaces</span></h4>

<p><a id="X7904128479BDFCC9" name="X7904128479BDFCC9"></a></p>

<h5>7.5-1 <span class="Heading">Incidence and containment</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsIncident</code>( <var class="Arg">el1</var>, <var class="Arg">el2</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; \*</code>( <var class="Arg">el1</var>, <var class="Arg">el2</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; \in</code>( <var class="Arg">el1</var>, <var class="Arg">el2</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: true or false</p>

<p>Recall that for projective spaces, incidence is symmetrized containment, where the empty subspace and the whole projective space are excluded as arguments for this operation, since they are not considered as elements of the geometry, but both the empty subspace and the whole projective space are allowed as arguments for <code class="file">\in</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HyperbolicQuadric(7,7);</span>
Q+(7, 7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := VectorSpaceToElement(ps,[1,0,1,0,0,0,0,0]*Z(7)^0);</span>
&lt;a point in Q+(7, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := VectorSpaceToElement(ps,[[1,0,1,0,0,0,0,0],[0,-1,0,1,0,0,0,0]]*Z(7)^0);</span>
&lt;a line in Q+(7, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p * l;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l * p;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIncident(p,l);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p in l;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l in p;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e := EmptySubspace(ps);</span>
&lt; empty subspace &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e * l;</span>
Error, no method found! For debugging hints type ?Recovery from NoMethodFound
Error, no 1st choice method found for `*' on 2 arguments called from
&lt;function "HANDLE_METHOD_NOT_FOUND"&gt;( &lt;arguments&gt; )
 called from read-eval loop at line 17 of *stdin*
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
<span class="GAPbrkprompt">brk&gt;</span> <span class="GAPinput">quit;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e in l;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l in ps;</span>
true
 
</pre></div>

<p><a id="X875BE2957FAF6209" name="X875BE2957FAF6209"></a></p>

<h5>7.5-2 Span</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Span</code>( <var class="Arg">u</var>, <var class="Arg">v</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: an element</p>

<p><var class="Arg">u</var> and <var class="Arg">v</var> are elements of a projective or polar space. This function returns the join of the two elements, that is, the span of the two subspaces.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HyperbolicQuadric(5,2);</span>
Q+(5, 2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := Random(Planes(ps));</span>
&lt;a plane in Q+(5, 2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := Random(Planes(ps));</span>
&lt;a plane in Q+(5, 2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s := Span(p,q);</span>
&lt;a proj. 4-space in ProjectiveSpace(5, 2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s = Span([p,q]);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t := Span(EmptySubspace(ps),p);</span>
&lt;a plane in Q+(5, 2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t = p;</span>
true
 
</pre></div>

<p><a id="X8469B54180FE1E4C" name="X8469B54180FE1E4C"></a></p>

<h5>7.5-3 Meet</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Meet</code>( <var class="Arg">u</var>, <var class="Arg">v</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: an element</p>

<p><var class="Arg">u</var> and <var class="Arg">v</var> are elements of a projective or polar space. This function returns the meet of the two elements. If two elements do not meet, then Meet returns <code class="code">EmptySubspace</code>, which in <strong class="pkg">FinInG</strong>, is an element with projective dimension -1. (Note that the poset of subspaces of a polar space is a meet-semilattice, but not closed under taking spans).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HyperbolicQuadric(5,3);</span>
Q+(5, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi := Random( Planes(ps) );</span>
&lt;a plane in Q+(5, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tau := Random( Planes(ps) );</span>
&lt;a plane in Q+(5, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Meet(pi,tau);</span>
&lt;a point in Q+(5, 3)&gt;

</pre></div>

<p>Note: the above example will return different answers depending on the two planes chosen at random.</p>

<p><a id="X8176044E7D2242D9" name="X8176044E7D2242D9"></a></p>

<h5>7.5-4 IsCollinear</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCollinear</code>( <var class="Arg">ps</var>, <var class="Arg">u</var>, <var class="Arg">v</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: Boolean</p>

<p><var class="Arg">u</var> and <var class="Arg">v</var> are points of the ambient space of the polar space <var class="Arg">ps</var>. This function returns True if <var class="Arg">u</var> and <var class="Arg">v</var> are collinear in <var class="Arg">ps</var>. Note that belonging to <var class="Arg">ps</var> is a necessary condition for <var class="Arg">u</var> and <var class="Arg">v</var> to be collinear.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := ParabolicQuadric(4,9);</span>
Q(4, 9)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := VectorSpaceToElement(PG(4,9),[0,1,0,0,0]*Z(9)^0);</span>
&lt;a point in ProjectiveSpace(4, 9)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := VectorSpaceToElement(PG(4,9),[0,0,1,0,0]*Z(9)^0);</span>
&lt;a point in ProjectiveSpace(4, 9)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r := VectorSpaceToElement(PG(4,9),[0,0,0,1,0]*Z(9)^0);</span>
&lt;a point in ProjectiveSpace(4, 9)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p in ps;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q in ps;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r in ps;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCollinear(ps,p,q);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCollinear(ps,p,r);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCollinear(ps,q,r);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := ParabolicQuadric(4,4);</span>
Q(4, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := VectorSpaceToElement(PG(4,4),[1,0,0,0,0]*Z(2)^0);</span>
&lt;a point in ProjectiveSpace(4, 4)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := VectorSpaceToElement(PG(4,4),[0,1,0,0,0]*Z(2)^0);</span>
&lt;a point in ProjectiveSpace(4, 4)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r := VectorSpaceToElement(PG(4,4),[0,0,0,1,0]*Z(2)^0);</span>
&lt;a point in ProjectiveSpace(4, 4)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p in ps;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q in ps;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r in ps;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCollinear(ps,p,q);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCollinear(ps,q,r);</span>
true
 
</pre></div>

<p><a id="X7EBD8C07802562B7" name="X7EBD8C07802562B7"></a></p>

<h5>7.5-5 PolarityOfProjectiveSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolarityOfProjectiveSpace</code>( <var class="Arg">ps</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a polarity of a projective space</p>

<p><var class="Arg">ps</var> must be a polar space. This operation returns, when possible a polarity of the ambient projective space of <var class="Arg">ps</var>. It is well known that except for orthogonal polar spaces in even characteristic, a classical polar space is in fact the geometry of absolute points of a polarity of a projective space, and that no polarity can be associated to parabolic quadrics in even characteristic. Polarities of projective spaces are discussed in more detail in Chapter <a href="chap6.html#X87BA55CB86B110EC"><span class="RefLink">6</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := SymplecticSpace(5,9);</span>
W(5, 9)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := PolarityOfProjectiveSpace(ps);</span>
&lt;polarity of PG(5, GF(3^2)) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := EllipticQuadric(3,4);</span>
Q-(3, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := PolarityOfProjectiveSpace(ps);</span>
&lt;polarity of PG(3, GF(2^2)) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := ParabolicQuadric(4,4);</span>
Q(4, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := PolarityOfProjectiveSpace(ps);</span>
Error, no polarity of the ambient projective space can be associated to &lt;ps&gt; called from
&lt;function "unknown"&gt;( &lt;arguments&gt; )
 called from read-eval loop at line 13 of *stdin*
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
<span class="GAPbrkprompt">brk&gt;</span> <span class="GAPinput">quit;</span>
 
</pre></div>

<p><a id="X863F1924805F6C63" name="X863F1924805F6C63"></a></p>

<h5>7.5-6 TypeOfSubspace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TypeOfSubspace</code>( <var class="Arg">ps</var>, <var class="Arg">v</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a string</p>

<p>This operation is a convenient way to find out the intersection type of a projective subspace with a polar space. The argument <var class="Arg">ps</var> is a nondegenerate polar space, and the argument <var class="Arg">v</var> is a subspace of the ambient projective space. The operation returns a string in accordance with the type of subspace: "degenerate", "symplectic", "hermitian", "elliptic", "hyperbolic" or "parabolic".</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h1 := HermitianPolarSpace(2, 3^2);</span>
H(2, 3^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h2 := HermitianPolarSpace(3, 3^2);</span>
H(3, 3^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg := AmbientSpace( h2 );    </span>
ProjectiveSpace(3, 9)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi := VectorSpaceToElement( pg, [[1,0,0,0],[0,1,0,0],[0,0,1,0]] * Z(9)^0 );</span>
&lt;a plane in ProjectiveSpace(3, 9)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TypeOfSubspace(h2, pi);</span>
"hermitian"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi := VectorSpaceToElement( pg, [[1,0,0,0],[0,1,0,0],[0,0,1,Z(9)]] * Z(9)^0 );</span>
&lt;a plane in ProjectiveSpace(3, 9)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TypeOfSubspace(h2, pi);</span>
"degenerate"
 
</pre></div>

<p><a id="X82C38639870C0DD6" name="X82C38639870C0DD6"></a></p>

<h5>7.5-7 TangentSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TangentSpace</code>( <var class="Arg">el</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TangentSpace</code>( <var class="Arg">ps</var>, <var class="Arg">el</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A subspace of a projective space</p>

<p>Let <var class="Arg">el</var> be an element of a classical polar space. The first version returns the tangent space at <var class="Arg">el</var> to this polar space. Let <var class="Arg">el</var> be a subspace of the ambient space of the polar space <var class="Arg">ps</var>. The second version checks whether <var class="Arg">el</var> belongs to <var class="Arg">ps</var> and returns the tangent space at <var class="Arg">el</var> to <var class="Arg">ps</var>. Some obvious properties are demonstrated in the example.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HermitianPolarSpace(3,4^2);</span>
H(3, 4^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := Random(Points(ps));</span>
&lt;a point in H(3, 4^2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">plane := TangentSpace(p);</span>
&lt;a plane in ProjectiveSpace(3, 16)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TypeOfSubspace(ps,plane);</span>
"degenerate"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := ParabolicQuadric(6,4);</span>
Q(6, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := VectorSpaceToElement(PG(6,4),[0,1,0,0,0,0,0]*Z(4)^0);</span>
&lt;a point in ProjectiveSpace(6, 4)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hyp := TangentSpace(ps,p);</span>
&lt;a proj. 5-space in ProjectiveSpace(6, 4)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NucleusOfParabolicQuadric(ps) in hyp;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := EllipticQuadric(5,2);</span>
Q-(5, 2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">line := Random(Lines(ps));</span>
&lt;a line in Q-(5, 2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TangentSpace(line);</span>
&lt;a solid in ProjectiveSpace(5, 2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HermitianPolarSpace(5,4);</span>
H(5, 2^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">plane := Random(Planes(ps));</span>
&lt;a plane in H(5, 2^2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tan := TangentSpace(plane);</span>
&lt;a plane in ProjectiveSpace(5, 4)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tan in ps;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tan = plane;</span>
true
 
</pre></div>

<p><a id="X8520DC538717C6BE" name="X8520DC538717C6BE"></a></p>

<h5>7.5-8 Pole</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Pole</code>( <var class="Arg">ps</var>, <var class="Arg">el</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A subspace of a projective space</p>

<p>Let <var class="Arg">el</var> be a subspace of the ambient space of the polar space <var class="Arg">ps</var>. This operation returns the pole of <var class="Arg">el</var> with relation to the polar space <var class="Arg">ps</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">conic := ParabolicQuadric(2,13);</span>
Q(2, 13)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := VectorSpaceToElement(PG(2,13),[1,0,0]*Z(13)^0);</span>
&lt;a point in ProjectiveSpace(2, 13)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pole := Pole(conic,p);</span>
&lt;a line in ProjectiveSpace(2, 13)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TypeOfSubspace(conic,pole);</span>
"hyperbolic"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tangent_points := Filtered(Points(pole),x-&gt;x in conic);</span>
[ &lt;a point in ProjectiveSpace(2, 13)&gt;, &lt;a point in ProjectiveSpace(2, 13)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tangent_lines_on_p := List(tangent_points,x-&gt;Span(x,p));</span>
[ &lt;a line in ProjectiveSpace(2, 13)&gt;, &lt;a line in ProjectiveSpace(2, 13)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(tangent_lines_on_p,x-&gt;Number(Points(x),y-&gt;y in conic));</span>
[ 1, 1 ]
 
</pre></div>

<p><a id="X7AA14EDF7B0B1569" name="X7AA14EDF7B0B1569"></a></p>

<h4>7.6 <span class="Heading">Shadow of elements</span></h4>

<p>The functionality in this section is comparable to the shadow functionality for elements of projective spaces, which are described in Section <a href="chap4.html#X7BD8312C85784503"><span class="RefLink">4.3</span></a>. The generic description of shadows of elements of incidence structures can be found in Section <a href="chap3.html#X7AA14EDF7B0B1569"><span class="RefLink">3.4</span></a>.</p>

<p><a id="X7FFA08DA85C5251C" name="X7FFA08DA85C5251C"></a></p>

<h5>7.6-1 ShadowOfElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ShadowOfElement</code>( <var class="Arg">ps</var>, <var class="Arg">el</var>, <var class="Arg">i</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ShadowOfElement</code>( <var class="Arg">ps</var>, <var class="Arg">el</var>, <var class="Arg">str</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: the elements of type <var class="Arg">i</var> incident with <var class="Arg">el</var>. The second variant determines the type <var class="Arg">i</var> from the position of <var class="Arg">str</var> in the list returned by <code class="file">TypesOfElementsOfIncidenceStructurePlural</code></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMat(8,GF(7));</span>
&lt; mutable compressed matrix 8x8 over GF(7) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := BilinearFormByMatrix(id,GF(7));</span>
&lt; bilinear form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := PolarSpace(form);</span>
&lt;polar space in ProjectiveSpace(
7,GF(7)): x_1^2+x_2^2+x_3^2+x_4^2+x_5^2+x_6^2+x_7^2+x_8^2=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Rank(ps);</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps;</span>
Q+(7, 7): x_1^2+x_2^2+x_3^2+x_4^2+x_5^2+x_6^2+x_7^2+x_8^2=0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[1,0,0,0,3,2,0,0],[0,1,0,0,0,0,3,2],[0,0,1,0,5,3,0,0]]*Z(7)^0;</span>
[ [ Z(7)^0, 0*Z(7), 0*Z(7), 0*Z(7), Z(7), Z(7)^2, 0*Z(7), 0*Z(7) ], 
  [ 0*Z(7), Z(7)^0, 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), Z(7), Z(7)^2 ], 
  [ 0*Z(7), 0*Z(7), Z(7)^0, 0*Z(7), Z(7)^5, Z(7), 0*Z(7), 0*Z(7) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">plane := VectorSpaceToElement(ps,mat);</span>
&lt;a plane in Q+(7, 7): x_1^2+x_2^2+x_3^2+x_4^2+x_5^2+x_6^2+x_7^2+x_8^2=0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">time;</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">shadow := ShadowOfElement(ps,plane,4);</span>
&lt;shadow solids in Q+(7, 7): x_1^2+x_2^2+x_3^2+x_4^2+x_5^2+x_6^2+x_7^2+x_8^2=0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(shadow);</span>
[ &lt;a solid in Q+(7, 7): x_1^2+x_2^2+x_3^2+x_4^2+x_5^2+x_6^2+x_7^2+x_8^2=0&gt;, 
  &lt;a solid in Q+(7, 7): x_1^2+x_2^2+x_3^2+x_4^2+x_5^2+x_6^2+x_7^2+x_8^2=0&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">shadow := ShadowOfElement(ps,plane,2);</span>
&lt;shadow lines in Q+(7, 7): x_1^2+x_2^2+x_3^2+x_4^2+x_5^2+x_6^2+x_7^2+x_8^2=0&gt;
 
</pre></div>

<p><a id="X81A8365A7FE68447" name="X81A8365A7FE68447"></a></p>

<h5>7.6-2 ElementsIncidentWithElementOfIncidenceStructure</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementsIncidentWithElementOfIncidenceStructure</code>( <var class="Arg">el</var>, <var class="Arg">i</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: the elements of type <var class="Arg">i</var> incident with <var class="Arg">el</var>, in other words, the type <var class="Arg">i</var> shadow of the element <var class="Arg">el</var></p>

<p>Internally, the function <code class="file">FlagOfIncidenceStructure</code> is used to create a flag from <var class="Arg">list</var>. This function also performs the checking.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HyperbolicQuadric(11,2);</span>
Q+(11, 2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vec := [[Z(2)^0,0*Z(2),0*Z(2),0*Z(2),0*Z(2),Z(2)^0,0*Z(2),Z(2)^0,Z(2)^0,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">0*Z(2),0*Z(2),0*Z(2)],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[0*Z(2),Z(2)^0,0*Z(2),0*Z(2),0*Z(2),Z(2)^0,Z(2)^0,Z(2)^0,Z(2)^0,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">0*Z(2),Z(2)^0,Z(2)^0],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[0*Z(2),0*Z(2),Z(2)^0,0*Z(2),0*Z(2),Z(2)^0,0*Z(2),Z(2)^0,0*Z(2),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">0*Z(2),0*Z(2),Z(2)^0],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[0*Z(2),0*Z(2),0*Z(2),Z(2)^0,0*Z(2),Z(2)^0,0*Z(2),Z(2)^0,0*Z(2),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">0*Z(2),Z(2)^0,0*Z(2)],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[0*Z(2),0*Z(2),0*Z(2),0*Z(2),Z(2)^0,Z(2)^0,0*Z(2),0*Z(2),0*Z(2),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Z(2)^0,Z(2)^0,Z(2)^0]];</span>
[ [ Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, Z(2)^0, 
      0*Z(2), 0*Z(2), 0*Z(2) ], 
  [ 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, 
      0*Z(2), Z(2)^0, Z(2)^0 ], 
  [ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), 
      0*Z(2), 0*Z(2), Z(2)^0 ], 
  [ 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), 
      0*Z(2), Z(2)^0, 0*Z(2) ], 
  [ 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0, Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2), 
      Z(2)^0, Z(2)^0, Z(2)^0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">subspace := VectorSpaceToElement(ps,vec);</span>
&lt;a proj. 4-space in Q+(11, 2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">els := ElementsIncidentWithElementOfIncidenceStructure(subspace,6);</span>
&lt;shadow proj. subspaces of dim. 5 in Q+(11, 2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(els);</span>
[ &lt;a proj. 5-space in Q+(11, 2)&gt;, &lt;a proj. 5-space in Q+(11, 2)&gt; ]

</pre></div>

<p><a id="X7988AF9978E75E37" name="X7988AF9978E75E37"></a></p>

<h4>7.7 <span class="Heading">Projective Orthogonal/Unitary/Symplectic groups in <strong class="pkg">FinInG</strong></span></h4>

<p>The classical groups (apart from the general lines group), are the matrix groups that <em>respect</em>, in a certain way, a sesquilinear or quadratic form. We formally recall the definitions used in <strong class="pkg">FinInG</strong>. These definitions are exactly the same as in <strong class="pkg">Forms</strong>.</p>

<p>Let <span class="SimpleMath">(V,f)</span> and <span class="SimpleMath">(W,g)</span> be two formed vector spaces over the same field <span class="SimpleMath">F</span>, where both <span class="SimpleMath">f</span> and <span class="SimpleMath">g</span> are sesquilinear forms. Suppose that φ is a linear map from <span class="SimpleMath">V</span> to <span class="SimpleMath">W</span>. The map φ is an <em>isometry</em> from the formed space <span class="SimpleMath">(V,f)</span> to the formed space <span class="SimpleMath">(W,g)</span> if for all <span class="SimpleMath">v,w</span> in <span class="SimpleMath">V</span> we have</p>

<p class="pcenter">f(v,w) = f'(φ(v),φ(w)).</p>

<p>The map φ is a <em>similarity</em> from the formed space <span class="SimpleMath">(V,f)</span> to the formed space <span class="SimpleMath">(W,g)</span> if for all <span class="SimpleMath">v,w</span> in <span class="SimpleMath">V</span> we have</p>

<p class="pcenter">f(v,w) = λ (f'(φ(v),φ(w)))</p>

<p>for some non-zero λ in <span class="SimpleMath">F</span>. Finally, the map φ is a <em>semi-similarity</em> from the formed space <span class="SimpleMath">(V,f)</span> to the formed space <span class="SimpleMath">(W,g)</span> if for all <span class="SimpleMath">v,w</span> in <span class="SimpleMath">V</span> we have</p>

<p class="pcenter">f(v,w) = λ f'(φ(v),φ(w))<SUP>α</SUP></p>

<p>for some non-zero λ in <span class="SimpleMath">F</span> and a field automorphism α of <span class="SimpleMath">F</span>.</p>

<p>Let <span class="SimpleMath">(V,f)</span> and <span class="SimpleMath">(W,g)</span> be two formed vector spaces over the same field <span class="SimpleMath">F</span>, where both <span class="SimpleMath">f</span> and <span class="SimpleMath">g</span> are quadratic forms. Suppose that φ is a linear map from <span class="SimpleMath">V</span> to <span class="SimpleMath">W</span>. The map φ is an <em>isometry</em> from the formed space <span class="SimpleMath">(V,f)</span> to the formed space <span class="SimpleMath">(W,g)</span> if for all <span class="SimpleMath">v,w</span> in <span class="SimpleMath">V</span> we have</p>

<p class="pcenter">f(v) = f'(φ(v)).</p>

<p>The map φ is a <em>similarity</em> from the formed space <span class="SimpleMath">(V,f)</span> to a formed space <span class="SimpleMath">(W,g)</span> if for all <span class="SimpleMath">v,w</span> in <span class="SimpleMath">V</span> we have</p>

<p class="pcenter">f(v) = \lambda f'(\phi(v))</p>

<p class="pcenter">f(v) = λ (f'(φ(v)))</p>

<p>for some non-zero λ in <span class="SimpleMath">F</span>. Finally, the map φ is a <em>semi-similarity</em> from the formed space <span class="SimpleMath">(V,f)</span> to the formed space <span class="SimpleMath">(W,g)</span> if for all <span class="SimpleMath">v,w</span> in <span class="SimpleMath">V</span> we have</p>

<p class="pcenter">f(v) = λ f'(φ(v))<SUP>α</SUP></p>

<p>for some non-zero λ in <span class="SimpleMath">F</span> and a field automorphism α of <span class="SimpleMath">F</span>.</p>

<p>Collineations of classical polar spaces are induced by semi-similarities of the underlying formed vector space, and vice versa, analoguously by factoring out scalar matrices. The only exceptions are the two-dimensional unitary groups where the the full semi-similarity group can contain elements of its centre that are not scalars. In <strong class="pkg">FinInG</strong>, the subgroups corresponding with similarities and isometries are also implemented, including a <em>special</em> variant, corresponding with the matrices having determinant one. We use a consistent terminology, where isometries, similarities, respectively, of the polar space, correspond with isometries, similarities, respectively, of the underlying formed vector space. Special isometries of a polar space are induced by isometries of the formed vector space that have a matrix with determinant one. If <span class="SimpleMath">P</span> is a polar space with special isometry group, isometry group, similarity group, collineation group, respectively, <span class="SimpleMath">S</span>, <span class="SimpleMath">I</span>, <span class="SimpleMath">G</span>, Γ, respectively, then clearly S ≤ I ≤ G ≤ Γ. Equalities can occur in certain cases, and will, as we will see in the following overview.</p>

<div class="pcenter"><table class="GAPDocTable">
<caption class="GAPDocTable"><b>Table: </b>projective finite classical groups</caption>
<tr>
<td class="tdleft">(sub)group</td>
<td class="tdleft">symplectic</td>
<td class="tdleft">hyperbolic</td>
<td class="tdleft">elliptic</td>
<td class="tdleft">parabolic</td>
<td class="tdleft">hermitian</td>
</tr>
<tr>
<td class="tdleft">special isometry</td>
<td class="tdleft">PSp(d,q)</td>
<td class="tdleft">PSO(1,d,q)</td>
<td class="tdleft">PSO(-1,d,q)</td>
<td class="tdleft">PSO(0,d,q)</td>
<td class="tdleft">PSU(d,q<sup>2</sup>)</td>
</tr>
<tr>
<td class="tdleft">isometry</td>
<td class="tdleft">PSp(d,q)</td>
<td class="tdleft">PGO(1,d,q)</td>
<td class="tdleft">PGO(-1,d,q)</td>
<td class="tdleft">PGO(0,d,q)</td>
<td class="tdleft">PGU(d,q<sup>2</sup>)</td>
</tr>
<tr>
<td class="tdleft">similarity</td>
<td class="tdleft">PGSp(d,q)</td>
<td class="tdleft">PΔO<sup>+</sup>(d,q)</td>
<td class="tdleft">PΔO<sup>-</sup>(d,q)</td>
<td class="tdleft">PGO(0,d,q)</td>
<td class="tdleft">PGU(d,q<sup>2</sup>)</td>
</tr>
<tr>
<td class="tdleft">collineation</td>
<td class="tdleft">PΓSp(d,q)</td>
<td class="tdleft">PΓO<sup>+</sup>(d,q)</td>
<td class="tdleft">PΓO<sup>-</sup>(d,q)</td>
<td class="tdleft">PΓO(d,q)</td>
<td class="tdleft">PΓU(d,q<sup>2</sup>)</td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p><a id="X857C261585038CB8" name="X857C261585038CB8"></a></p>

<h5>7.7-1 SpecialIsometryGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SpecialIsometryGroup</code>( <var class="Arg">ps</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: the special isometry group of the polar space <var class="Arg">ps</var></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := SymplecticSpace(3,4);</span>
W(3, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SpecialIsometryGroup(ps);</span>
PSp(4,4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HyperbolicQuadric(5,8);</span>
Q+(5, 8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SpecialIsometryGroup(ps);</span>
PSO(1,6,8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := EllipticQuadric(3,27);</span>
Q-(3, 27)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SpecialIsometryGroup(ps);</span>
PSO(-1,4,27)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := ParabolicQuadric(4,8);</span>
Q(4, 8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SpecialIsometryGroup(ps);</span>
PSO(0,5,8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HermitianPolarSpace(4,9);</span>
H(4, 3^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SpecialIsometryGroup(ps);</span>
PSU(5,3^2)
 
</pre></div>

<p><a id="X87708229834E4C44" name="X87708229834E4C44"></a></p>

<h5>7.7-2 IsometryGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsometryGroup</code>( <var class="Arg">ps</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: the isometry group of the polar space <var class="Arg">ps</var></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := SymplecticSpace(3,4);</span>
W(3, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsometryGroup(ps);</span>
PSp(4,4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HyperbolicQuadric(5,8);</span>
Q+(5, 8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsometryGroup(ps);</span>
PGO(1,6,8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := EllipticQuadric(3,27);</span>
Q-(3, 27)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsometryGroup(ps);</span>
PGO(-1,4,27)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := ParabolicQuadric(4,8);</span>
Q(4, 8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsometryGroup(ps);</span>
PGO(0,5,8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HermitianPolarSpace(4,9);</span>
H(4, 3^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsometryGroup(ps);</span>
PGU(5,3^2)
 
</pre></div>

<p><a id="X812836E48364AE6D" name="X812836E48364AE6D"></a></p>

<h5>7.7-3 SimilarityGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimilarityGroup</code>( <var class="Arg">ps</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: the similarity group of the polar space <var class="Arg">ps</var></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := SymplecticSpace(3,4);</span>
W(3, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SimilarityGroup(ps);</span>
PGSp(4,4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HyperbolicQuadric(5,8);</span>
Q+(5, 8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SimilarityGroup(ps);</span>
PDeltaO+(6,8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := EllipticQuadric(3,27);</span>
Q-(3, 27)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SimilarityGroup(ps);</span>
PDeltaO-(4,27)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := ParabolicQuadric(4,8);</span>
Q(4, 8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SimilarityGroup(ps);</span>
PGO(0,5,8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HermitianPolarSpace(4,9);</span>
H(4, 3^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SimilarityGroup(ps);</span>
PGU(5,3^2)
 
</pre></div>

<p><a id="X83FF6FA0790D5747" name="X83FF6FA0790D5747"></a></p>

<h5>7.7-4 CollineationGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CollineationGroup</code>( <var class="Arg">ps</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: the collineation group of the polar space <var class="Arg">ps</var></p>

<p>In most cases, the full projective semisimilarity group is returned. For two-dimensional unitary groups, the centre may contain elements that are not scalars. In this case, we return a central extension of the projective semisimilarity group. If the basefield of <var class="Arg">ps</var> is GF(q<sup>2</sup>), <span class="SimpleMath">q</span> prime, the similarity group is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := SymplecticSpace(3,4);</span>
W(3, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CollineationGroup(ps);</span>
PGammaSp(4,4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HyperbolicQuadric(5,8);</span>
Q+(5, 8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CollineationGroup(ps);</span>
PGammaO+(6,8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := EllipticQuadric(3,27);</span>
Q-(3, 27)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CollineationGroup(ps);</span>
PGammaO-(4,27)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := ParabolicQuadric(4,8);</span>
Q(4, 8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CollineationGroup(ps);</span>
PGammaO(5,8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HermitianPolarSpace(4,9);</span>
H(4, 3^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CollineationGroup(ps);</span>
PGammaU(5,3^2)
 
</pre></div>

<p><a id="X855D48A07E0BBCDB" name="X855D48A07E0BBCDB"></a></p>

<h4>7.8 <span class="Heading">Enumerating subspaces of polar spaces</span></h4>

<p><a id="X7AB1BA95825BDE71" name="X7AB1BA95825BDE71"></a></p>

<h5>7.8-1 <span class="Heading">Enumerators for polar spaces</span></h5>

<p>An enumerator for a collection of subspaces of a given type of a polar space is provided in <strong class="pkg">FinInG</strong>. If <var class="Arg">C</var> is such a collection, then <code class="file">List(C)</code> will use the enumerator to compute a list with all the elements of <var class="Arg">C</var>.</p>

<p><a id="X7EF8910F82B45EC7" name="X7EF8910F82B45EC7"></a></p>

<h5>7.8-2 Enumerator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Enumerator</code>( <var class="Arg">C</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; List</code>( <var class="Arg">C</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: an enumerator for the collection <var class="Arg">C</var> and a list with all elements of <var class="Arg">C</var></p>

<p>The argument <var class="Arg">C</var> is a collection of subspaces of a polar space.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Enumerator(Points(ParabolicQuadric(6,3)));</span>
EnumeratorOfSubspacesOfClassicalPolarSpace( &lt;points of Q(6, 3)&gt; )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Enumerator(Lines(HermitianPolarSpace(4,4)));</span>
EnumeratorOfSubspacesOfClassicalPolarSpace( &lt;lines of H(4, 2^2)&gt; )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">planes := List(Planes(HermitianPolarSpace(5,4)));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">time;</span>
11515
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length(planes);</span>
891
 
</pre></div>

<p><a id="X861463147B738DF1" name="X861463147B738DF1"></a></p>

<h5>7.8-3 <span class="Heading">Iterators for polar spaces</span></h5>

<p>For all polar spaces an iterator is constructed using <code class="file">IteratorList(enum)</code>, where <var class="Arg">enum</var> is an appropriate enumerator.</p>

<p><a id="X83ADF8287ED0668E" name="X83ADF8287ED0668E"></a></p>

<h5>7.8-4 Iterator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Iterator</code>( <var class="Arg">elements</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: an iterator</p>

<p><var class="Arg">C</var> is a collection of subspaces of a polar space.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iter := Iterator(Lines(ParabolicQuadric(4,2)));</span>
&lt;iterator&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextIterator(iter);</span>
&lt;a line in Q(4, 2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextIterator(iter);</span>
&lt;a line in Q(4, 2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextIterator(iter);</span>
&lt;a line in Q(4, 2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextIterator(iter);</span>
&lt;a line in Q(4, 2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextIterator(iter);</span>
&lt;a line in Q(4, 2)&gt;
 
</pre></div>

<p><a id="X8289FCCC8274C89D" name="X8289FCCC8274C89D"></a></p>

<h5>7.8-5 AsList</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsList</code>( <var class="Arg">subspaces</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: an Orb object or list</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HyperbolicQuadric(5,3);</span>
Q+(5, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lines := AsList(Lines(ps));</span>
&lt;closed orbit, 520 points&gt;
 
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap6.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap8.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chapA.html">A</a>  <a href="chapB.html">B</a>  <a href="chapC.html">C</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
