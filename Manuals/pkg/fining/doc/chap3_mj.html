<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (FinInG) - Chapter 3: Incidence Geometry</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap3"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chapA_mj.html">A</a>  <a href="chapB_mj.html">B</a>  <a href="chapC_mj.html">C</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap3.html">[MathJax off]</a></p>
<p><a id="X838ACF8A7F100A2B" name="X838ACF8A7F100A2B"></a></p>
<div class="ChapSects"><a href="chap3_mj.html#X838ACF8A7F100A2B">3 <span class="Heading">Incidence Geometry</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X7FB175337C4F8B76">3.1 <span class="Heading">Incidence structures</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X81F7D8FA82A55561">3.1-1 IsIncidenceStructure</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X78C74BE87E050E84">3.1-2 IsIncidenceGeometry</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7C3258887C8DF5C1">3.1-3 IncidenceStructure</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7B0347E2863C1E8C">3.1-4 <span class="Heading">Main categories in <code class="code">IsIncidenceGeometry</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X87FFB1648575FFF2">3.1-5 <span class="Heading">Examples of categories of incidence geometries</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7E574AB27DA97063">3.1-6 TypesOfElementsOfIncidenceStructure</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X827146F37E2AA841">3.1-7 Rank</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X815BE6D57D623452">3.1-8 IncidenceGraph</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X7BBDB0AE7E29F3FB">3.2 <span class="Heading">Elements of incidence structures</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X827CD3C881DC8364">3.2-1 <span class="Heading">Main categories for individual elements of incidence structures</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X810D4D6D87069697">3.2-2 UnderlyingObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X823B3D0F87FB5403">3.2-3 Type</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7809B7C183FA7213">3.2-4 ObjectToElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7DE974E687A2ABFB">3.2-5 <span class="Heading">Main categories for collections of all the elements of a given type of an incidence structure</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X87657AEF7E2C50F9">3.2-6 ElementsOfIncidenceStructure</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X87657AEF7E2C50F9">3.2-7 ElementsOfIncidenceStructure</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X87E64DA67C3D6661">3.2-8 <span class="Heading">Short names for ElementsOfIncidenceStructure</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X86CF041F7FA486D6">3.2-9 NrElementsOfIncidenceStructure</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X79730D657AB219DB">3.2-10 Random</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7A9ED8327C40B445">3.2-11 IsIncident</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X799DB77886B8ABDB">3.2-12 AmbientGeometry</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X7DACFB6785029BF0">3.3 <span class="Heading">Flags of incidence structures</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7E204A78815C46DD">3.3-1 FlagOfIncidenceStructure</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7A453E0E861F2C94">3.3-2 IsChamberOfIncidenceStructure</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7AEFC2C57F10C3A7">3.3-3 IsEmptyFlag</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X86FFFBC584B97371">3.3-4 ElementsOfFlag</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X827146F37E2AA841">3.3-5 Rank</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X858ADA3B7A684421">3.3-6 Size</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X799DB77886B8ABDB">3.3-7 AmbientGeometry</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X823B3D0F87FB5403">3.3-8 Type</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7A9ED8327C40B445">3.3-9 IsIncident</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X7AA14EDF7B0B1569">3.4 <span class="Heading">Shadow of elements</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7FFA08DA85C5251C">3.4-1 ShadowOfElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X81A8365A7FE68447">3.4-2 ElementsIncidentWithElementOfIncidenceStructure</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7E86E6417871730C">3.4-3 ShadowOfFlag</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X78BE3D727B060301">3.4-4 ResidueOfFlag</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7E29C31D7CB5DB23">3.4-5 <span class="Heading">Short names for ElementsIncidentWithElementOfIncidenceStructure</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X8133F88478BAFCB7">3.5 <span class="Heading">Enumerating elements of an incidence structure</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X83ADF8287ED0668E">3.5-1 Iterator</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7EF8910F82B45EC7">3.5-2 Enumerator</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7EBA57FC7CCF8449">3.5-3 List</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X8289FCCC8274C89D">3.5-4 AsList</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X84D77D437B5F3716">3.6 <span class="Heading">Lie geometries</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7D012B9F86E63702">3.6-1 <span class="Heading">Main categories in <code class="code">IsLieGeometry</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X8606750A8586DF8D">3.6-2 AmbientSpace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7D544D7985A4572D">3.6-3 UnderlyingVectorSpace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X84FDF25D797B874B">3.6-4 ProjectiveDimension</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X85DFF5177CA51AE0">3.6-5 IsEmptySubspace</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X7FBCF60385E8C1D8">3.7 <span class="Heading">Elements of Lie geometries</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X82E9593B8074AECB">3.7-1 VectorSpaceToElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X810D4D6D87069697">3.7-2 UnderlyingObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X87BDB89B7AAFE8AD"><code>3.7-3 \in</code></a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X814C3AC27E49AD5B">3.7-4 <span class="Heading">More short names for <code class="file">ElementsIncidentWithElementOfIncidenceStructure</code></span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X7A9EBF9782671634">3.8 <span class="Heading">Changing the ambient geometry of elements of a Lie geometry</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X8561C0117FD76C94">3.8-1 ElementToElement</a></span>
</div></div>
</div>

<h3>3 <span class="Heading">Incidence Geometry</span></h3>

<p>We follow <a href="chapBib_mj.html#biBBC2013">[BC13]</a> for the definitions of incidence structure and incidence geometry. An <em>incidence structure</em> consists of a set of elements, a symmetric relation on the elements and a type function from the set of elements to an index set (i.e., every element has a ``type''). It satisfies the following axiom: <em>(i) no two elements of the same type are incident.</em> An incidence structure without type function is in fact a multipartite graph where the adjacency is the incidence (so with a loop on each vertex). The term geometry, or incidence geometry, is interpreted broadly in this package. Particularly, an <em>incidence geometry</em> is an incidence structure satisfying the following axiom: <em>(ii) every maximal flag contains an element of each type</em>. In graph terminology, this means that every maximal clique contains an element of each type. Thus, a projective 5-space is an incidence geometry with five types of elements: points, lines, planes, solids, and hyperplanes. A finite classical polar space of rank 3 is an incidence geometry with three types of elements: points, lines, and planes. Depending on the viewpoint, the Grassmann variety of the lines of a projective 4-space, is an incidence structure that is not an incidence geometry.</p>

<p><strong class="pkg">FinInG</strong> concerns itself primarily with the most commonly studied incidence geometries of rank at least 2: projective spaces, polar spaces, and affine spaces. Throughout, no matter the geometry, we have made the convention that an element of type 1 is a ``point'', an element of type 2 is a ``line'', and so forth. The examples we use in this section use projective spaces, which have not yet been introduced to the reader in this manual. For further information on projective spaces, see Chapter <a href="chap4_mj.html#X83BBAA668672A76D"><span class="RefLink">4</span></a>.</p>

<p>In this chapter we describe functionality that is <strong class="button">declared</strong> for incidence structures, which does not imply that operations described here will work for arbitrary user-constructed incidence structures. Its aim is furthermore to allow the user to become familiar with the general philosophy of the package, using examples that are self-explanatory. Not all details of the commands used in the examples will be explained in this chapter, therefore we refer to the relevant chapter for the commands. These can easily be found using the index.</p>

<p><a id="X7FB175337C4F8B76" name="X7FB175337C4F8B76"></a></p>

<h4>3.1 <span class="Heading">Incidence structures</span></h4>

<p>Incidence structures can be more general than incidence geometries, e.g., if they do not satisfy axiom (ii) mentioned above. We allow the construction of such objects. This explains one of the top level categories in <strong class="pkg">FinInG</strong>.</p>

<p><a id="X81F7D8FA82A55561" name="X81F7D8FA82A55561"></a></p>

<h5>3.1-1 IsIncidenceStructure</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsIncidenceStructure</code></td><td class="tdright">( category )</td></tr></table></div>
<p>Top level category for all objects representing an incidence structure.</p>

<p><a id="X78C74BE87E050E84" name="X78C74BE87E050E84"></a></p>

<h5>3.1-2 IsIncidenceGeometry</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsIncidenceGeometry</code></td><td class="tdright">( category )</td></tr></table></div>
<p>Category for all objects representing an incidence geometry. All particular geometries implemented in <strong class="pkg">FinInG</strong> are incidence geometries.</p>

<p><a id="X7C3258887C8DF5C1" name="X7C3258887C8DF5C1"></a></p>

<h5>3.1-3 IncidenceStructure</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IncidenceStructure</code>( <var class="Arg">eles</var>, <var class="Arg">inc_rel</var>, <var class="Arg">type</var>, <var class="Arg">typeset</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: an incidence structure</p>

<p><var class="Arg">eles</var> is a set containing the elements of the incidence structure. <var class="Arg">inc_rel</var> must be a function that determines whether two objects in the set <var class="Arg">eles</var> are incident. <var class="Arg">type</var> is a function mapping any element to its type, which is a unique element in the set <var class="Arg">typeset</var>.</p>

<p>In the following example we define an incidence structure that is not an incidence geometry. The example used is the incidence structure with elements the subspaces contained in the line Grassmannian of PG(4,2). This example is not meant to create this incidence structure in an efficient way, but just to demonstrate the general philosophy.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg := PG(4,2);</span>
ProjectiveSpace(4, 2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg2 := PG(9,2);</span>
ProjectiveSpace(9, 2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">points := List(Lines(pg),x-&gt;VectorSpaceToElement(pg2,GrassmannCoordinates(x)));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">flags := Concatenation(List(Points(pg),x-&gt;List(Planes(x),y-&gt;FlagOfIncidenceStructure(pg,[x,y]))));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prelines := List(flags,flag-&gt;ShadowOfFlag(pg,flag,2));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lines := List(prelines,x-&gt;VectorSpaceToElement(pg2,List(x,y-&gt;GrassmannCoordinates(y))));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">flags2 := Concatenation(List(Points(pg),x-&gt;List(Solids(x),y-&gt;FlagOfIncidenceStructure(pg,[x,y]))));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">preplanes := List(flags2,flag-&gt;ShadowOfFlag(pg,flag,2));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">planes := List(preplanes,x-&gt;VectorSpaceToElement(pg2,List(x,y-&gt;GrassmannCoordinates(y))));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">maximals1 := List(Planes(pg),x-&gt;VectorSpaceToElement(pg2,List(Lines(x),y-&gt;GrassmannCoordinates(y))));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">maximals2 := List(Points(pg),x-&gt;VectorSpaceToElement(pg2,List(Lines(x),y-&gt;GrassmannCoordinates(y))));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elements := Union(points,lines,planes,maximals1,maximals2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length(elements);</span>
1891
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">type := x -&gt; ProjectiveDimension(x)+1;</span>
function( x ) ... end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inc_rel := \*;</span>
&lt;Operation "*"&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inc := IncidenceStructure(elements,inc_rel,type,[1,2,3,4]);</span>
Incidence structure of rank 4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Rank(inc);</span>
4


</pre></div>

<p>Lie Geometries, i.e., geometries with a projective space as ambient space, affine spaces and generalised polygons have their own category, which is a subcategory of <code class="code">IsIncidenceGeometry</code>.</p>

<p><a id="X7B0347E2863C1E8C" name="X7B0347E2863C1E8C"></a></p>

<h5>3.1-4 <span class="Heading">Main categories in <code class="code">IsIncidenceGeometry</code></span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLieGeometry</code></td><td class="tdright">( category )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsAffineSpace</code></td><td class="tdright">( category )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsGeneralisedPolygon</code></td><td class="tdright">( category )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCosetGeometry</code></td><td class="tdright">( category )</td></tr></table></div>
<p>Within each category, several subcategories are declared. Subcategories of <code class="code">IsLieGeometry</code> are discussed in Section <a href="chap3_mj.html#X84D77D437B5F3716"><span class="RefLink">3.6</span></a> and subcategories of <code class="code">IsGeneralisedPolygon</code> are discussed in Chapter <a href="chap12_mj.html#X7E1F10767D2A4D6A"><span class="RefLink">12</span></a></p>

<p><a id="X87FFB1648575FFF2" name="X87FFB1648575FFF2"></a></p>

<h5>3.1-5 <span class="Heading">Examples of categories of incidence geometries</span></h5>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CategoriesOfObject(ProjectiveSpace(5,7));</span>
[ "IsIncidenceStructure", "IsIncidenceGeometry", "IsLieGeometry", 
  "IsProjectiveSpace" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CategoriesOfObject(HermitianPolarSpace(5,9));</span>
[ "IsIncidenceStructure", "IsIncidenceGeometry", "IsLieGeometry", 
  "IsClassicalPolarSpace", "IsAlgebraicVariety", "IsProjectiveVariety", 
  "IsHermitianVariety" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CategoriesOfObject(AffineSpace(3,3));</span>
[ "IsIncidenceStructure", "IsIncidenceGeometry", "IsAffineSpace" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CategoriesOfObject(SymplecticSpace(3,11));</span>
[ "IsIncidenceStructure", "IsIncidenceGeometry", "IsLieGeometry", 
  "IsClassicalPolarSpace", "IsGeneralisedPolygon", "IsGeneralisedQuadrangle", 
  "IsClassicalGQ" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CategoriesOfObject(SplitCayleyHexagon(9));</span>
[ "IsIncidenceStructure", "IsIncidenceGeometry", "IsLieGeometry", 
  "IsGeneralisedPolygon", "IsGeneralisedHexagon", 
  "IsClassicalGeneralisedHexagon" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CategoriesOfObject(ParabolicQuadric(4,16));</span>
[ "IsIncidenceStructure", "IsIncidenceGeometry", "IsLieGeometry", 
  "IsClassicalPolarSpace", "IsGeneralisedPolygon", "IsGeneralisedQuadrangle", 
  "IsClassicalGQ", "IsAlgebraicVariety", "IsProjectiveVariety" ]
 
</pre></div>

<p><a id="X7E574AB27DA97063" name="X7E574AB27DA97063"></a></p>

<h5>3.1-6 TypesOfElementsOfIncidenceStructure</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TypesOfElementsOfIncidenceStructure</code>( <var class="Arg">inc</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TypesOfElementsOfIncidenceStructurePlural</code>( <var class="Arg">inc</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: a list of strings or integers</p>

<p>Both attributes are declared for objects in the category <code class="code">IsIncidenceStructure</code>. Any incidence structure has a set of types, which is usually just the list <span class="SimpleMath">\([1..n]\)</span>. If specific names are given to each type, like points, lines, etc., this attribute returns the names for the particular incidence structure <var class="Arg">inc</var>. The second variant returns the list of plurals of these names. For genericly constructed incidence structures, the names of the Elements are also generic: elements of type 1, elements of type 2, etc.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TypesOfElementsOfIncidenceStructure(ProjectiveSpace(5,4));</span>
[ "point", "line", "plane", "solid", "proj. 4-space" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TypesOfElementsOfIncidenceStructurePlural(AffineSpace(7,4));</span>
[ "points", "lines", "planes", "solids", "affine. subspaces of dim. 4", 
  "affine. subspaces of dim. 5", "affine. subspaces of dim. 6" ]
 
</pre></div>

<p><a id="X827146F37E2AA841" name="X827146F37E2AA841"></a></p>

<h5>3.1-7 Rank</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Rank</code>( <var class="Arg">inc</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RankAttr</code>( <var class="Arg">inc</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: rank of <var class="Arg">inc</var>, an object which must belong to the category <code class="code">IsIncidenceStructure</code></p>

<p>The operation <code class="file">Rank</code> returns the rank of the incidence structure <code class="code">inc</code>. The highest level method for <code class="file">Rank</code>, applicable to objects in <code class="code">IsIncidenceStructure</code> simply refers to the attribute <code class="file">RankAttr</code>. In <strong class="pkg">FinInG</strong>, the rank of an incidence structure is determined upon creation, when also <code class="file">RankAttr</code> is set.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Rank(ProjectiveSpace(5,5));</span>
5
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Rank(AffineSpace(3,5));</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Rank(SymplecticSpace(5,5));</span>
3
 
</pre></div>

<p><a id="X815BE6D57D623452" name="X815BE6D57D623452"></a></p>

<h5>3.1-8 IncidenceGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IncidenceGraph</code>( <var class="Arg">inc</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: a graph</p>

<p>The vertices are the elements of <var class="Arg">inc</var>, adjacency between different vertices is equal to incidence, and there are of course no loops. For generic incidence structures, i.e. constructed through <code class="file">IncidenceStructure</code>, there is no efficient method installed, so this operation can be time consuming.</p>

<p>If <var class="Arg">inc</var> is a generic incidence structure, i.e. created using <code class="file">IncidenceStructure</code>, the vertex names of the graph are integers. It is not by default possible to use the elements of <var class="Arg">inc</var> as vertex names, since it is not known in the generic case whether the elements of different type of <var class="Arg">inc</var> can be ordered. For particular incidence geometries, e.g. projective spaces, etc., the vertex names will be the elements, which will be demonstrated through examples in the appropriate chapters.</p>

<p>In the example we consider the so-called doubling of the smallest generalised quadrangle: the points of the incidence structure are the points and the lines of the GQ, the lines of the incidence structure are all the point-line flags of the GQ. The incidence is the natural one. It is then checked that diameter and girth of the incidence graph are 8 and 16 respectively, which makes that the incidence structure is a generalised octagon.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := SymplecticSpace(3,2);</span>
W(3, 2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pts := List(Points(ps));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lines := List(Lines(ps));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">flags := Union(List(pts,x-&gt;List(Lines(x),y-&gt;FlagOfIncidenceStructure(ps,[x,y]))));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inc := function(x,y)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">if x = y then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return true;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">elif IsFlagOfIncidenceStructure(x) and IsElementOfIncidenceStructure(y) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return IsIncident(x,y);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">elif IsElementOfIncidenceStructure(x) and IsElementOfIncidenceStructure(y) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return false;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">elif IsFlagOfIncidenceStructure(x) and IsFlagOfIncidenceStructure(y) then   </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return false;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">else </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return inc(y,x);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;</span>
function( x, y ) ... end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">type := function(x)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">if IsList(Type(x)) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return 2;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return 1;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;</span>
function( x ) ... end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">els := Union(pts,lines,flags);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">struc := IncidenceStructure(els,inc,type,[1,2]);</span>
Incidence structure of rank 2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := IncidenceGraph(struc);</span>
rec( adjacencies := [ [ 31, 32, 33 ], [ 34, 35, 36 ], [ 37, 38, 39 ], 
      [ 40, 41, 42 ], [ 43, 44, 45 ], [ 46, 47, 48 ], [ 49, 50, 51 ], 
      [ 52, 53, 54 ], [ 55, 56, 57 ], [ 58, 59, 60 ], [ 61, 62, 63 ], 
      [ 64, 65, 66 ], [ 67, 68, 69 ], [ 70, 71, 72 ], [ 73, 74, 75 ], 
      [ 31, 40, 43 ], [ 32, 52, 55 ], [ 33, 64, 67 ], [ 34, 41, 46 ], 
      [ 35, 53, 58 ], [ 36, 65, 70 ], [ 37, 42, 49 ], [ 38, 54, 61 ], 
      [ 39, 66, 73 ], [ 44, 59, 74 ], [ 45, 62, 71 ], [ 47, 56, 75 ], 
      [ 50, 57, 72 ], [ 48, 63, 68 ], [ 51, 60, 69 ], [ 1, 16 ], [ 1, 17 ], 
      [ 1, 18 ], [ 2, 19 ], [ 2, 20 ], [ 2, 21 ], [ 3, 22 ], [ 3, 23 ], 
      [ 3, 24 ], [ 4, 16 ], [ 4, 19 ], [ 4, 22 ], [ 5, 16 ], [ 5, 25 ], 
      [ 5, 26 ], [ 6, 19 ], [ 6, 27 ], [ 6, 29 ], [ 7, 22 ], [ 7, 28 ], 
      [ 7, 30 ], [ 8, 17 ], [ 8, 20 ], [ 8, 23 ], [ 9, 17 ], [ 9, 27 ], 
      [ 9, 28 ], [ 10, 20 ], [ 10, 25 ], [ 10, 30 ], [ 11, 23 ], [ 11, 26 ], 
      [ 11, 29 ], [ 12, 18 ], [ 12, 21 ], [ 12, 24 ], [ 13, 18 ], [ 13, 29 ], 
      [ 13, 30 ], [ 14, 21 ], [ 14, 26 ], [ 14, 28 ], [ 15, 24 ], [ 15, 25 ], 
      [ 15, 27 ] ], group := Group(()), isGraph := true, names := [ 1 .. 75 ],
  order := 75, 
  representatives := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 
      17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 
      35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 
      53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 
      71, 72, 73, 74, 75 ], 
  schreierVector := [ -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, 
      -14, -15, -16, -17, -18, -19, -20, -21, -22, -23, -24, -25, -26, -27, 
      -28, -29, -30, -31, -32, -33, -34, -35, -36, -37, -38, -39, -40, -41, 
      -42, -43, -44, -45, -46, -47, -48, -49, -50, -51, -52, -53, -54, -55, 
      -56, -57, -58, -59, -60, -61, -62, -63, -64, -65, -66, -67, -68, -69, 
      -70, -71, -72, -73, -74, -75 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Diameter(gamma);</span>
8
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Girth(gamma);</span>
16

</pre></div>

<p><a id="X7BBDB0AE7E29F3FB" name="X7BBDB0AE7E29F3FB"></a></p>

<h4>3.2 <span class="Heading">Elements of incidence structures</span></h4>

<p><a id="X827CD3C881DC8364" name="X827CD3C881DC8364"></a></p>

<h5>3.2-1 <span class="Heading">Main categories for individual elements of incidence structures</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsElementOfIncidenceStructure</code></td><td class="tdright">( category )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsElementOfIncidenceGeometry</code></td><td class="tdright">( category )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsElementOfLieGeometry</code></td><td class="tdright">( category )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsElementOfAffineSpace</code></td><td class="tdright">( category )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsElementOfCosetGeometry</code></td><td class="tdright">( category )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSubspaceOfProjectiveSpace</code></td><td class="tdright">( category )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSubspaceOfClassicalPolarSpace</code></td><td class="tdright">( category )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsElementOfGeneralisedPolygon</code></td><td class="tdright">( category )</td></tr></table></div>
<p>In general, elements of an incidence structure belonging to <code class="code">IsIncStr</code>, are in the category <code class="code">IsElementOfIncStr</code>. The inclusion for different categories of geometries is followed for their elements, with an exception for <code class="code">IsSubspaceOfClassicalPolarSpace</code>, which is a subcategory of <code class="code">IsSubspaceOfProjectiveSpace</code>, while <code class="code">IsClassicalPolarSpace</code> is not a subcategory of <code class="code">IsProjectiveSpace</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Random(Lines(SplitCayleyHexagon(3)));</span>
#I  for Split Cayley Hexagon
#I  Computing nice monomorphism...
#I  Found permutation domain...
&lt;a line in H(3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CategoriesOfObject(last);</span>
[ "IsElementOfIncidenceStructure", "IsElementOfIncidenceGeometry", 
  "IsElementOfLieGeometry", "IsSubspaceOfProjectiveSpace", 
  "IsSubspaceOfClassicalPolarSpace", "IsElementOfGeneralisedPolygon" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Random(Solids(AffineSpace(7,17)));</span>
&lt;a solid in AG(7, 17)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CategoriesOfObject(last);</span>
[ "IsElementOfIncidenceStructure", "IsElementOfIncidenceGeometry", 
  "IsSubspaceOfAffineSpace" ]
 
</pre></div>

<p><a id="X810D4D6D87069697" name="X810D4D6D87069697"></a></p>

<h5>3.2-2 UnderlyingObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingObject</code>( <var class="Arg">el</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: an object</p>

<p>An element of an incidence structure has a type and an underlying object. E.g. a line of a projective space is determined by a two dimensional sub vector space, which is determined by a basis. Elements of incidence structure can also be objects representing elements of other incidence structures, as is e.g. the case in the example of <a href="chap3_mj.html#X7C3258887C8DF5C1"><span class="RefLink">3.1-3</span></a>. The examples shows the underlying objects of elements of three totally different incidence geometries.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg := PG(2,2);</span>
ProjectiveSpace(2, 2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := Random(Points(pg));</span>
&lt;a point in ProjectiveSpace(2, 2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingObject(p);</span>
&lt;cvec over GF(2,1) of length 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := Random(Lines(pg));</span>
&lt;a line in ProjectiveSpace(2, 2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingObject(l);</span>
&lt;cmat 2x3 over GF(2,1)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [ [ 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0 ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0 ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0 ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0 ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0 ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0 ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1 ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1 ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0 ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1 ] ];</span>
[ [ 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 ], 
  [ 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 ], 
  [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0 ], 
  [ 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 ], 
  [ 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0 ], 
  [ 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0 ], 
  [ 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 ], 
  [ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0 ], 
  [ 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0 ], 
  [ 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0 ], 
  [ 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 ], 
  [ 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1 ], 
  [ 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1 ], 
  [ 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0 ], 
  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gp := GeneralisedPolygonByIncidenceMatrix(mat);</span>
&lt;generalised quadrangle of order [ 2, 2 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := Random(Points(gp));</span>
&lt;a point in &lt;generalised quadrangle of order [ 2, 2 ]&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingObject(p);</span>
15
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := Random(Lines(gp));</span>
&lt;a line in &lt;generalised quadrangle of order [ 2, 2 ]&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingObject(l);</span>
[ 7, 13, 15 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">egq := EGQByBLTSet(BLTSetByqClan(LinearqClan(3)));</span>
#I  Now embedding dual BLT-set into W(5,q)...
#I  Computing elation group...
&lt;EGQ of order [ 9, 3 ] and basepoint in W(5, 3 ) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := Random(Points(egq));</span>
&lt;a point in &lt;EGQ of order [ 9, 3 ] and basepoint in W(5, 3 ) &gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingObject(p);</span>
&lt;a point in W(5, 3)&gt;

</pre></div>

<p><a id="X823B3D0F87FB5403" name="X823B3D0F87FB5403"></a></p>

<h5>3.2-3 Type</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Type</code>( <var class="Arg">el</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: an integer</p>

<p>An element of an incidence structure has a type and an underlying object. Its type is always a non-negative integer. This operation returns the type of an element.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg := PG(2,2);</span>
ProjectiveSpace(2, 2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := Random(Points(pg));</span>
&lt;a point in ProjectiveSpace(2, 2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Type(p);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := Random(Lines(pg));</span>
&lt;a line in ProjectiveSpace(2, 2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Type(l);</span>
2

</pre></div>

<p><a id="X7809B7C183FA7213" name="X7809B7C183FA7213"></a></p>

<h5>3.2-4 ObjectToElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ObjectToElement</code>( <var class="Arg">inc</var>, <var class="Arg">t</var>, <var class="Arg">obj</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: an element of the incidence structure <var class="Arg">inc</var></p>

<p>If <var class="Arg">obj</var> represents an element of <var class="Arg">inc</var> of type <var class="Arg">t</var>, this operation returns the element. An error (or no method found error) is shown when <var class="Arg">obj</var> does not represent an element of type <var class="Arg">t</var>. Note that <code class="file">ObjectToElement</code> is a generic operation. Versions with a different argument set and even alternative operations exist for some particular geometries to construct particular elements.</p>

<p><a id="X7DE974E687A2ABFB" name="X7DE974E687A2ABFB"></a></p>

<h5>3.2-5 <span class="Heading">Main categories for collections of all the elements of a given type of an incidence structure</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsElementsOfIncidenceStructure</code></td><td class="tdright">( category )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsElementsOfIncidenceGeometry</code></td><td class="tdright">( category )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsElementsOfLieGeometry</code></td><td class="tdright">( category )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsElementsOfAffineSpace</code></td><td class="tdright">( category )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsElementsOfCosetGeometry</code></td><td class="tdright">( category )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSubspacesOfProjectiveSpace</code></td><td class="tdright">( category )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSubspacesOfClassicalPolarSpace</code></td><td class="tdright">( category )</td></tr></table></div>
<p>For a given incidence structure, the collection of elements of a given type can be constructed. constructed here means that an object is returned that represents all the elements of a given type, rather than listing them immediately, to avoid long computation times. Such an abstract object is e.g. used as a range for In general, the collection of elements of a given type of an incidence structure belonging to <code class="code">IsIncStr</code>, is in the category <code class="code">IsElementsOfIncStr</code>. The inclusion for different categories of geometries is followed for their collection of elements of a given type, with an exception for <code class="code">IsSubspacesOfClassicalPolarSpace</code>, which is a subcategory of <code class="code">IsSubspacesOfProjectiveSpace</code>, while <code class="code">IsClassicalPolarSpace</code> is not a subcategory of <code class="code">IsProjectiveSpace</code>.</p>

<p>The object representing the set of elements of a given type can be computed using the general operation <code class="file">ElementsOfIncidenceStructure</code>.</p>

<p><a id="X87657AEF7E2C50F9" name="X87657AEF7E2C50F9"></a></p>

<h5>3.2-6 ElementsOfIncidenceStructure</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementsOfIncidenceStructure</code>( <var class="Arg">inc</var>, <var class="Arg">j</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementsOfIncidenceStructure</code>( <var class="Arg">inc</var>, <var class="Arg">str</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a collection of elements</p>

<p><var class="Arg">inc</var> must be an incidence structure, <var class="Arg">j</var> must be a type of element of <var class="Arg">inc</var>. This function returns all elements of <var class="Arg">inc</var> of type <var class="Arg">j</var>, and an error is displayed if <var class="Arg">inc</var> has no elements of type <var class="Arg">j</var>. Calling the elements (of a given type) of <var class="Arg">inc</var> yields an object in the category <code class="code">IsElementsOfIncidenceStructure</code> (or the appropriate category for projective spaces and classical polar spaces), which does not imply that all elements are computed and stored. In an alternative form of this function <var class="Arg">str</var> can be one of the strings found in the list obtained by calling <code class="file">TypesOfElementsOfIncidenceStructurePlural(inc)</code>. E.g. for projective spaces, ``points", ``lines", ``planes" or ``solids" are the names for elements of type 1,2,3 or 4, respectively, of course if <var class="Arg">inc</var> has elements of the deduced type.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := ProjectiveSpace(3,3);</span>
ProjectiveSpace(3, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := ElementsOfIncidenceStructure(ps,2);</span>
&lt;lines of ProjectiveSpace(3, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := EllipticQuadric(5,9);</span>
Q-(5, 9)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lines := ElementsOfIncidenceStructure(ps,2);</span>
&lt;lines of Q-(5, 9)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">planes := ElementsOfIncidenceStructure(ps,3);</span>
Error, &lt;geo&gt; has no elements of type &lt;j&gt; called from
&lt;function "unknown"&gt;( &lt;arguments&gt; )
 called from read-eval loop at line 12 of *stdin*
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
<span class="GAPbrkprompt">brk&gt;</span> <span class="GAPinput">quit;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">as := AffineSpace(3,9);</span>
AG(3, 9)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lines := ElementsOfIncidenceStructure(as,"lines");</span>
&lt;lines of AG(3, 9)&gt;
 
</pre></div>

<p><a id="X87657AEF7E2C50F9" name="X87657AEF7E2C50F9"></a></p>

<h5>3.2-7 ElementsOfIncidenceStructure</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementsOfIncidenceStructure</code>( <var class="Arg">inc</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a collection of elements</p>

<p><var class="Arg">inc</var> must be an incidence structure, then this operation returns the collection of all elements of <var class="Arg">inc</var>. Such a collection can e.g. be the range of a geometry morphism. Note that this operation has no method for generic incidence structures constructed using <code class="file">Incidence Structure</code>.</p>

<p><a id="X87E64DA67C3D6661" name="X87E64DA67C3D6661"></a></p>

<h5>3.2-8 <span class="Heading">Short names for ElementsOfIncidenceStructure</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Points</code>( <var class="Arg">inc</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Lines</code>( <var class="Arg">inc</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Planes</code>( <var class="Arg">inc</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Solids</code>( <var class="Arg">inc</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: The points, lines, planes, solids, respectively of <var class="Arg">inc</var></p>

<p>For geometries in <code class="code">IsLieGeometry</code>, <code class="code">IsAffineSpace</code>, and <code class="code">IsGeneralisedPolygon</code>, the elements of type 1,2,3,4 respectively are called usually points, lines, planes, solids, respectively. These methods are, for such geometries, are shortcuts to <code class="file">ElementsOfIncidenceStructure(inc,j)</code>, with <var class="Arg">j</var> equal to 1,2,3,4, respectively.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Points(HermitianVariety(2,64));</span>
&lt;points of Hermitian Variety in ProjectiveSpace(2, 64)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lines(EllipticQuadric(5,2));</span>
&lt;lines of Q-(5, 2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Planes(SymplecticSpace(7,3));</span>
&lt;planes of W(7, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lines(TwistedTrialityHexagon(2^3));</span>
&lt;lines of T(8, 2)&gt;
 
</pre></div>

<p><a id="X86CF041F7FA486D6" name="X86CF041F7FA486D6"></a></p>

<h5>3.2-9 NrElementsOfIncidenceStructure</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NrElementsOfIncidenceStructure</code>( <var class="Arg">inc</var>, <var class="Arg">j</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NrElementsOfIncidenceStructure</code>( <var class="Arg">inc</var>, <var class="Arg">str</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a positive integer</p>

<p><var class="Arg">inc</var> must be an incidence structure, <var class="Arg">j</var> must be a type of element of <var class="Arg">inc</var>. This function returns the number of elements of <var class="Arg">inc</var> of type <var class="Arg">j</var>, and an error is displayed if <var class="Arg">inc</var> has no elements of type <var class="Arg">j</var>. In the alternative form of this function <var class="Arg">str</var> can be one of ``points", ``lines", ``planes" or ``solids" and the function returns the number of elements of type 1, 2, 3 or 4 respectively, of course if <var class="Arg">inc</var> has elements of the deduced type. For geometries in the category <code class="code">IsLieGeometry</code>, <code class="code">IsAffineSpace</code>, and <code class="code">IsGeneralisedPolygon</code>, the number of elements of a given type is known upon construction of the geometry. As such, for these geometries, this operation requires no computing time.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps:=ProjectiveSpace(4,3);</span>
ProjectiveSpace(4, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrElementsOfIncidenceStructure(ps, 2);</span>
1210
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrElementsOfIncidenceStructure(ps, "points");</span>
121
 
</pre></div>

<p><a id="X79730D657AB219DB" name="X79730D657AB219DB"></a></p>

<h5>3.2-10 Random</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Random</code>( <var class="Arg">C</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: an element in the collection <var class="Arg">C</var></p>

<p><var class="Arg">C</var> is a collection of elements of an incidence structure, i.e., an object in the category <code class="code">IsElementsOfIncidenceStructure</code>. <code class="file">Random(C)</code> will return a random element in <var class="Arg">C</var> provided there is a method installed. The generic method will compute all elements in <var class="Arg">C</var> and return a random member from the list. For e.g. Lie geometries, more efficient methods are installed.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coll := Hyperplanes(PG(5,7));</span>
&lt;proj. 4-subspaces of ProjectiveSpace(5, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Random(coll);</span>
&lt;a proj. 4-space in ProjectiveSpace(5, 7)&gt;
 
</pre></div>

<p><a id="X7A9ED8327C40B445" name="X7A9ED8327C40B445"></a></p>

<h5>3.2-11 IsIncident</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsIncident</code>( <var class="Arg">u</var>, <var class="Arg">v</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; \*</code>( <var class="Arg">u</var>, <var class="Arg">v</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: true or false</p>

<p><var class="Arg">u</var> and <var class="Arg">v</var> must be elements of an incidence structure. This function returns true if and only if <var class="Arg">u</var> is incident with <var class="Arg">v</var>. Recall that <code class="code">IsIncident</code> is a symmetric relation, while <code class="code">in</code> is not. A method for the operation <code class="file">\*</code> is installed, applicable to objects in <code class="code">IsElementOfIncidenceStructure</code>. It just calls <code class="file">IsIncident</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := Random(Points(PG(5,4)));</span>
&lt;a point in ProjectiveSpace(5, 4)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := Random(Lines(p));</span>
&lt;a line in ProjectiveSpace(5, 4)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIncident(p,l);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIncident(l,p);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p * l;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l * p;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p * p;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l * l;</span>
true
 
</pre></div>

<p><a id="X799DB77886B8ABDB" name="X799DB77886B8ABDB"></a></p>

<h5>3.2-12 AmbientGeometry</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AmbientGeometry</code>( <var class="Arg">v</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: the ambient geometry of the element <var class="Arg">v</var></p>

<p>If <var class="Arg">v</var> is an element of an incidence geometry currently implemented in <strong class="pkg">FinInG</strong>, then this operation returns the ambient geometry of <var class="Arg">v</var>, i.e., in general the geometry in which <var class="Arg">v</var> was created. If an incidence structure is created with elements that are a subset of elements of another incidence structure, the ambient geometry might stay unchanged.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">plane := Random(Planes(HyperbolicQuadric(5,2)));</span>
&lt;a plane in Q+(5, 2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AmbientGeometry(plane);</span>
Q+(5, 2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := Random(Lines(SplitCayleyHexagon(3)));</span>
#I  for Split Cayley Hexagon
#I  Computing nice monomorphism...
#I  Found permutation domain...
&lt;a line in H(3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Print(l);</span>
NewMatrix(IsCMatRep,GF(3,1),7,[[ Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), 
  Z(3)^0, Z(3)^0 ],[ 0*Z(3), Z(3)^0, Z(3), Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3) ],])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AmbientGeometry(l);</span>
H(3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := Random(Points(EGQByBLTSet(BLTSetByqClan(LinearqClan(3)))));</span>
#I  Now embedding dual BLT-set into W(5,q)...
#I  Computing elation group...
&lt;a point in &lt;EGQ of order [ 9, 3 ] and basepoint in W(5, 3 ) &gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Print(p);</span>
NewRowVector(IsCVecRep,GF(3,1),[Z(3)^0,Z(3),Z(3),Z(3),Z(3)^0,0*Z(3),])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AmbientGeometry(p);</span>
&lt;EGQ of order [ 9, 3 ] and basepoint in W(5, 3 ) &gt;
 
</pre></div>

<p><a id="X7DACFB6785029BF0" name="X7DACFB6785029BF0"></a></p>

<h4>3.3 <span class="Heading">Flags of incidence structures</span></h4>

<p>A <em>flag</em> of an incidence structure <span class="SimpleMath">\(S\)</span> is a set <span class="SimpleMath">\(F\)</span> of elements of <span class="SimpleMath">\(S\)</span> that are two by two incident. This implies that all elements in <span class="SimpleMath">\(F\)</span> have a different type. A flag is maximal if it cannot be extended with more elements. <strong class="pkg">FinInG</strong> provides a basic category <code class="code">IsFlagOfIncidenceStructure</code>. For different types of incidence structures, methods to create a flag can be installed. A <em>chamber</em> is a flag of size <span class="SimpleMath">\(n\)</span>, where <span class="SimpleMath">\(n\)</span> is the rank of the incidence structure. Recall that an incidence structure is an incidence geometry if every maximal flag is a chamber.</p>

<p><a id="X7E204A78815C46DD" name="X7E204A78815C46DD"></a></p>

<h5>3.3-1 FlagOfIncidenceStructure</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FlagOfIncidenceStructure</code>( <var class="Arg">inc</var>, <var class="Arg">l</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: the flag consisting of the elements of <var class="Arg">inc</var> in the list <var class="Arg">l</var></p>

<p>It is checked if all elements in <var class="Arg">l</var> are incident and belong to the same incidence structure. An empty list is allowed.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := PG(3,7);</span>
ProjectiveSpace(3, 7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">point := VectorSpaceToElement(ps,[1,2,0,0]*Z(7)^0);</span>
&lt;a point in ProjectiveSpace(3, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">line := VectorSpaceToElement(ps,[[1,0,0,0],[0,1,0,0]]*Z(7)^0);</span>
&lt;a line in ProjectiveSpace(3, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">plane := VectorSpaceToElement(ps,[[1,0,0,0],[0,1,0,0],[0,0,0,1]]*Z(7)^0);</span>
&lt;a plane in ProjectiveSpace(3, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">flag := FlagOfIncidenceStructure(ps,[point,line,plane]);</span>
&lt;a flag of ProjectiveSpace(3, 7)&gt;
 
</pre></div>

<p><a id="X7A453E0E861F2C94" name="X7A453E0E861F2C94"></a></p>

<h5>3.3-2 IsChamberOfIncidenceStructure</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsChamberOfIncidenceStructure</code>( <var class="Arg">flag</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: true if and only if <var class="Arg">flag</var> contains an element of each type</p>

<p>The incidence structure is determined by the elements.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := PG(3,7);</span>
ProjectiveSpace(3, 7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">point := VectorSpaceToElement(ps,[1,2,0,0]*Z(7)^0);</span>
&lt;a point in ProjectiveSpace(3, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">line := VectorSpaceToElement(ps,[[1,0,0,0],[0,1,0,0]]*Z(7)^0);</span>
&lt;a line in ProjectiveSpace(3, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">plane := VectorSpaceToElement(ps,[[1,0,0,0],[0,1,0,0],[0,0,0,1]]*Z(7)^0);</span>
&lt;a plane in ProjectiveSpace(3, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">flag1 := FlagOfIncidenceStructure(ps,[point,plane]);</span>
&lt;a flag of ProjectiveSpace(3, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsChamberOfIncidenceStructure(flag1);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">flag2 := FlagOfIncidenceStructure(ps,[point,line,plane]);</span>
&lt;a flag of ProjectiveSpace(3, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsChamberOfIncidenceStructure(flag2);</span>
true
 
</pre></div>

<p><a id="X7AEFC2C57F10C3A7" name="X7AEFC2C57F10C3A7"></a></p>

<h5>3.3-3 IsEmptyFlag</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsEmptyFlag</code>( <var class="Arg">flag</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: true or false</p>

<p>It is possible to construct the empty flag of an incidence structure. This operation tests whether a given flag is empty.</p>

<p><a id="X86FFFBC584B97371" name="X86FFFBC584B97371"></a></p>

<h5>3.3-4 ElementsOfFlag</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementsOfFlag</code>( <var class="Arg">flag</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a list of elements</p>

<p>This operations simply returns the list of elements that define <var class="Arg">flag</var></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gp := SplitCayleyHexagon(4);</span>
H(4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := Random(Points(gp));</span>
#I  for Split Cayley Hexagon
#I  Computing nice monomorphism...
#I  Found permutation domain...
&lt;a point in H(4)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := Random(Lines(p));</span>
&lt;a line in H(4)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">flag := FlagOfIncidenceStructure(gp,[l,p]);</span>
&lt;a flag of H(4)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ElementsOfFlag(flag);</span>
[ &lt;a point in H(4)&gt;, &lt;a line in H(4)&gt; ]

</pre></div>

<p><a id="X827146F37E2AA841" name="X827146F37E2AA841"></a></p>

<h5>3.3-5 Rank</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Rank</code>( <var class="Arg">flag</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: an integer</p>

<p>This operations returns the number of elements that define <var class="Arg">flag</var></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := ParabolicQuadric(8,3); </span>
Q(8, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := Random(Lines(ps));</span>
&lt;a line in Q(8, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">plane := Random(Planes(l));</span>
&lt;a plane in Q(8, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">solid := Random(Solids(plane));</span>
&lt;a solid in Q(8, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">flag := FlagOfIncidenceStructure(ps,[l,plane,solid]);</span>
&lt;a flag of Q(8, 3) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Rank(flag);</span>
3

</pre></div>

<p><a id="X858ADA3B7A684421" name="X858ADA3B7A684421"></a></p>

<h5>3.3-6 Size</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Size</code>( <var class="Arg">flag</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: an integer</p>

<p>This operations returns the number of elements that define <var class="Arg">flag</var></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := SymplecticSpace(5,7);</span>
W(5, 7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := Random(Points(ps));</span>
&lt;a point in W(5, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">plane := Random(Planes(p));</span>
&lt;a plane in W(5, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">flag := FlagOfIncidenceStructure(ps,[p,p,plane]);</span>
&lt;a flag of W(5, 7) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(flag);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ElementsOfFlag(flag);</span>
[ &lt;a point in W(5, 7)&gt;, &lt;a plane in W(5, 7)&gt; ]

</pre></div>

<p><a id="X799DB77886B8ABDB" name="X799DB77886B8ABDB"></a></p>

<h5>3.3-7 AmbientGeometry</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AmbientGeometry</code>( <var class="Arg">flag</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: an incidence structure</p>

<p>This operations returns the ambient geometry of the <var class="Arg">flag</var></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := SymplecticSpace(5,7);</span>
W(5, 7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := Random(Points(ps));</span>
&lt;a point in W(5, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">plane := Random(Planes(p));</span>
&lt;a plane in W(5, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">flag := FlagOfIncidenceStructure(ps,[p,p,plane]);</span>
&lt;a flag of W(5, 7) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(flag);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ElementsOfFlag(flag);</span>
[ &lt;a point in W(5, 7)&gt;, &lt;a plane in W(5, 7)&gt; ]

</pre></div>

<p><a id="X823B3D0F87FB5403" name="X823B3D0F87FB5403"></a></p>

<h5>3.3-8 Type</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Type</code>( <var class="Arg">flag</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: an list of integers</p>

<p>This operations returns the list of types of the elements defining <var class="Arg">flag</var></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg := PG(8,9);</span>
ProjectiveSpace(8, 9)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := Random(Lines(pg));</span>
&lt;a line in ProjectiveSpace(8, 9)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s := Random(Solids(l));</span>
&lt;a solid in ProjectiveSpace(8, 9)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">flag := FlagOfIncidenceStructure(pg,[l,s]);</span>
&lt;a flag of ProjectiveSpace(8, 9)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Type(flag);</span>
[ 2, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := Random(Points(pg));</span>
&lt;a point in ProjectiveSpace(8, 9)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">flag := FlagOfIncidenceStructure(pg,[p]);</span>
&lt;a flag of ProjectiveSpace(8, 9)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Type(flag);</span>
[ 1 ]

</pre></div>

<p><a id="X7A9ED8327C40B445" name="X7A9ED8327C40B445"></a></p>

<h5>3.3-9 IsIncident</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsIncident</code>( <var class="Arg">el</var>, <var class="Arg">flag</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsIncident</code>( <var class="Arg">flag</var>, <var class="Arg">el</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: true or false</p>

<p>An element is incident with a flag if and only if it is incident with all elements defining the flag.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg := PG(3,5);</span>
ProjectiveSpace(3, 5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := Random(Points(pg));</span>
&lt;a point in ProjectiveSpace(3, 5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := Random(Lines(p));</span>
&lt;a line in ProjectiveSpace(3, 5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">plane := Random(Planes(l));</span>
&lt;a plane in ProjectiveSpace(3, 5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">flag := FlagOfIncidenceStructure(pg,[l,plane]);</span>
&lt;a flag of ProjectiveSpace(3, 5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIncident(flag,l);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIncident(l,flag);</span>
true

</pre></div>

<p><a id="X7AA14EDF7B0B1569" name="X7AA14EDF7B0B1569"></a></p>

<h4>3.4 <span class="Heading">Shadow of elements</span></h4>

<p><a id="X7FFA08DA85C5251C" name="X7FFA08DA85C5251C"></a></p>

<h5>3.4-1 ShadowOfElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ShadowOfElement</code>( <var class="Arg">inc</var>, <var class="Arg">v</var>, <var class="Arg">str</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ShadowOfElement</code>( <var class="Arg">inc</var>, <var class="Arg">v</var>, <var class="Arg">j</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: The collection of elements of type <var class="Arg">str</var> or type <var class="Arg">j</var> incident with <var class="Arg">v</var></p>

<p><var class="Arg">inc</var> is an incidence structure, <var class="Arg">v</var> must be an element of <var class="Arg">inc</var>, <var class="Arg">str</var> must be a string which is <strong class="button">the plural</strong> of the name of one of the types of the elements of <var class="Arg">inc</var>. For the second variant, <var class="Arg">j</var> is an integer representing one of the types of the elements of <var class="Arg">inc</var>. This first variant relies on <code class="file">TypesOfElementsOfIncidenceStructurePlural</code> and on a particular method installed for the second variant for particular incidence structures. The use of the argument <var class="Arg">inc</var> makes it flexible, i.e., if the element <var class="Arg">v</var> can belong to different incidence structures, its shadow can be different, as the second example shows.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := ProjectiveSpace(3,3);</span>
ProjectiveSpace(3, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi := Random(Planes(ps));</span>
&lt;a plane in ProjectiveSpace(3, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lines := ShadowOfElement(ps,pi,"lines");</span>
&lt;shadow lines in ProjectiveSpace(3, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(lines);</span>
13

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := Random(Points(PG(3,3)));</span>
&lt;a point in ProjectiveSpace(3, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lines1 := ShadowOfElement(SymplecticSpace(3,3),p,2);</span>
&lt;shadow lines in W(3, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(lines1);</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lines2 := ShadowOfElement(PG(3,3),p,2); </span>
&lt;shadow lines in ProjectiveSpace(3, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(lines2);</span>
13
 
</pre></div>

<p><a id="X81A8365A7FE68447" name="X81A8365A7FE68447"></a></p>

<h5>3.4-2 ElementsIncidentWithElementOfIncidenceStructure</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementsIncidentWithElementOfIncidenceStructure</code>( <var class="Arg">v</var>, <var class="Arg">j</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: The collection of elements of type <var class="Arg">j</var> incident with <var class="Arg">v</var></p>

<p>This operation is applicable for objects <var class="Arg">v</var> belonging to <code class="code">IsElementOfIncidenceStructure</code>, and is a shortcut to <code class="file">ShadowOfElement(AmbientGeometry(v),v,j)</code>.</p>

<p><a id="X7E86E6417871730C" name="X7E86E6417871730C"></a></p>

<h5>3.4-3 ShadowOfFlag</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ShadowOfFlag</code>( <var class="Arg">inc</var>, <var class="Arg">flag</var>, <var class="Arg">str</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ShadowOfFlag</code>( <var class="Arg">inc</var>, <var class="Arg">list</var>, <var class="Arg">str</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ShadowOfFlag</code>( <var class="Arg">inc</var>, <var class="Arg">flag</var>, <var class="Arg">j</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ShadowOfFlag</code>( <var class="Arg">inc</var>, <var class="Arg">list</var>, <var class="Arg">j</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: The collection of elements of type <var class="Arg">str</var> or type <var class="Arg">j</var> incident with all elements of <var class="Arg">flag</var>, or with all elements of <var class="Arg">list</var></p>

<p>Variants 2 and 4 convert <var class="Arg">list</var> to a flag of <var class="Arg">inc</var>, using <code class="file">FlagOfIcidenceStructure</code>, which performs the necessary checks. Variants 1 and 2 rely on variants 3 and 4 respectively, for which a method must be installed for the particular incidence structure <var class="Arg">inc</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := PG(3,7);</span>
ProjectiveSpace(3, 7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">point := VectorSpaceToElement(ps,[1,2,0,0]*Z(7)^0);</span>
&lt;a point in ProjectiveSpace(3, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">plane := VectorSpaceToElement(ps,[[1,0,0,0],[0,1,0,0],[0,0,0,1]]*Z(7)^0);</span>
&lt;a plane in ProjectiveSpace(3, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">flag := FlagOfIncidenceStructure(ps,[point,plane]);</span>
&lt;a flag of ProjectiveSpace(3, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lines := ShadowOfFlag(ps,flag,"lines");</span>
&lt;shadow lines in ProjectiveSpace(3, 7)&gt;

</pre></div>

<p><a id="X78BE3D727B060301" name="X78BE3D727B060301"></a></p>

<h5>3.4-4 ResidueOfFlag</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ResidueOfFlag</code>( <var class="Arg">flag</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: an incidence structure</p>

<p>Consider the flag <var class="Arg">flag</var>, and its ambient geometry <span class="SimpleMath">\(G\)</span>. All elements of <span class="SimpleMath">\(G\)</span> incident with all elements of <var class="Arg">flag</var>, together with the incidence of <span class="SimpleMath">\(G\)</span>, determine an incidence structure. This incidence structure is returned by this operation. Note that independently of the Category of <span class="SimpleMath">\(G\)</span>, the returned incidence structure is constructed using the operation <code class="file">IncidenceStructure</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg := PG(4,5);</span>
ProjectiveSpace(4, 5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := Random(Points(pg));</span>
&lt;a point in ProjectiveSpace(4, 5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := Random(Lines(p));</span>
&lt;a line in ProjectiveSpace(4, 5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">flag := FlagOfIncidenceStructure(pg,[p,l]);</span>
&lt;a flag of ProjectiveSpace(4, 5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">res := ResidueOfFlag(flag);</span>
Incidence structure of rank 2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := IncidenceGraph(res);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Diameter(gamma);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Girth(gamma);</span>
6

</pre></div>

<p><a id="X7E29C31D7CB5DB23" name="X7E29C31D7CB5DB23"></a></p>

<h5>3.4-5 <span class="Heading">Short names for ElementsIncidentWithElementOfIncidenceStructure</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Points</code>( <var class="Arg">inc</var>, <var class="Arg">v</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Lines</code>( <var class="Arg">inc</var>, <var class="Arg">v</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Planes</code>( <var class="Arg">inc</var>, <var class="Arg">v</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Solids</code>( <var class="Arg">inc</var>, <var class="Arg">v</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Points</code>( <var class="Arg">v</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Lines</code>( <var class="Arg">v</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Planes</code>( <var class="Arg">v</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Solids</code>( <var class="Arg">v</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: The collections of elements of <var class="Arg">inc</var> of respective type 1, 2, 3 and 4, that are incident with <var class="Arg">v</var></p>

<p>If <var class="Arg">inc</var>, or the ambient geometry of <var class="Arg">v</var> is an incidence structure, where the elements of type 1, 2, 3 and 4 are called "points", "lines", "planes", and "solids" respectively, these operations are shortcuts to <code class="file">ShadowOfElement</code>. If this is not the case, a method for these operations is not installed.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">line := Random(Lines(AG(5,4)));</span>
&lt;a line in AG(5, 4)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Points(line);</span>
&lt;shadow points in AG(5, 4)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Planes(line);</span>
&lt;shadow planes in AG(5, 4)&gt;
 
</pre></div>

<p><a id="X8133F88478BAFCB7" name="X8133F88478BAFCB7"></a></p>

<h4>3.5 <span class="Heading">Enumerating elements of an incidence structure</span></h4>

<p>In several situations, it can be usful to compute a complete list of objects statisfying one or more conditions. To list all elements of a given type of an incidence structure, is a typical example. <strong class="pkg">FinInG</strong> provides functionality that is common in GAP for this purpose.</p>

<p>In <strong class="pkg">FinInG</strong>, typically a list of all elements satisfying a property, e.g. all points of a projective space, are represented by a GAP object that is a <em>collection</em>. The word 'collection' is important here. E.g. subspaces of a vector space are not calculated on calling <code class="file">Subspaces</code>, rather primitive information is stored in an <code class="file">IsComponentObjectRep</code>. So for example</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v:=GF(31)^5;</span>
( GF(31)^5 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">subs:=Subspaces(v,1);</span>
Subspaces( ( GF(31)^5 ), 1 )
</pre></div>

<p>For a given collection <var class="Arg">C</var>, one can use the GAP function <code class="file">List</code> to compute all objects in the collection <var class="Arg">C</var>. Such a list can be used to iterate over all objects in the list. However, if one needs only few random objects from <var class="Arg">C</var>, or if one needs to iterate over the list of objects until a certain condition is satisfied, it can be highly inefficient to first compute all these objects. Therefore iterators and enumerators come into the picture.</p>

<p>An iterator is a GAP object that gives a user friendly way to loop over all elements without repetition. Only three operations are applicable on an iterator: <code class="file">NextIterator</code>, <code class="file">IsDoneIterator</code> and <code class="file">ShallowCopy</code>. Clearly, all elements of a collection can be obtained by using an available iterator.</p>

<p><a id="X83ADF8287ED0668E" name="X83ADF8287ED0668E"></a></p>

<h5>3.5-1 Iterator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Iterator</code>( <var class="Arg">C</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: an iterator for the collection <var class="Arg">C</var></p>

<p><var class="Arg">C</var> is a collection of elements of an incidence structure. An iterator is returned. The second example demonstrates how an iterator is used by <code class="file">First</code>. Clearly, not all points of the projective space are computed.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := PG(3,7);</span>
ProjectiveSpace(3, 7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">planes := Planes(ps);</span>
&lt;planes of ProjectiveSpace(3, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iter := Iterator(planes);</span>
&lt;iterator&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextIterator(iter);</span>
&lt;a plane in ProjectiveSpace(3, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDoneIterator(iter);</span>
false

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg := PG(12,81);</span>
ProjectiveSpace(12, 81)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pts := Points(pg);</span>
&lt;points of ProjectiveSpace(12, 81)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(pts);</span>
80763523615333416236653
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := ParabolicQuadric(12,81);</span>
Q(12, 81)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">First(pts,x-&gt;x in ps);</span>
&lt;a point in ProjectiveSpace(12, 81)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">time;</span>
23

</pre></div>

<p>In its simplest form, an enumerator is just a list containing all the elements of the collection. Given any object in the list, it is possible to retrieve its number in the list (which is then just its position). Also, given any number between 1 and the length of the list, it is possible to get the corresponding element. For some collections of elements of particular incidence structures, a more advanced version of enumerators is implemented. Such an advanced version is an object containing the two functions <code class="file">ElementNumber</code> and <code class="file">NumberElement</code>. Such functions are able to compute directly, without listing all elements, the element with a given number, or, conversely, compute directly the number of a given element. Clearly, using an enumerator, it is possible to obtain a list containing all elements of a collection.</p>

<p><a id="X7EF8910F82B45EC7" name="X7EF8910F82B45EC7"></a></p>

<h5>3.5-2 Enumerator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Enumerator</code>( <var class="Arg">C</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: an enumerator for the collection <var class="Arg">C</var></p>

<p><var class="Arg">C</var> is a collection of elements of an incidence structure. An enumerator is returned. The second example demonstrates how an enumerator is used by <code class="file">Random</code>. Clearly, not all points of the polar space are to obtain an random point.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lines := Lines( ParabolicQuadric(6,3) );</span>
&lt;lines of Q(6, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">enum := Enumerator( lines );</span>
EnumeratorOfSubspacesOfClassicalPolarSpace( &lt;lines of Q(6, 3)&gt; )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s := Size(enum);</span>
3640
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">n := Random([1..s]);</span>
3081
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := enum[n];</span>
&lt;a line in Q(6, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Position(enum, l);</span>
3081

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := ParabolicQuadric(16,7^4);</span>
Q(16, 2401)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pts := Points(ps);</span>
&lt;points of Q(16, 2401)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(pts);</span>
508233536514931541724405776067904925314839705888016
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Random(pts);</span>
&lt;a point in Q(16, 2401)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">time;</span>
565

</pre></div>

<p>When an iterator or enumerator is installed for a collection, <code class="file">List</code> can be used to obtain all objects in that collection.</p>

<p><a id="X7EBA57FC7CCF8449" name="X7EBA57FC7CCF8449"></a></p>

<h5>3.5-3 List</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; List</code>( <var class="Arg">C</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: all objects in the collection <var class="Arg">C</var></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg := PG(2,2);</span>
ProjectiveSpace(2, 2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(Points(pg));</span>
[ &lt;a point in ProjectiveSpace(2, 2)&gt;, &lt;a point in ProjectiveSpace(2, 2)&gt;, 
  &lt;a point in ProjectiveSpace(2, 2)&gt;, &lt;a point in ProjectiveSpace(2, 2)&gt;, 
  &lt;a point in ProjectiveSpace(2, 2)&gt;, &lt;a point in ProjectiveSpace(2, 2)&gt;, 
  &lt;a point in ProjectiveSpace(2, 2)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(Lines(pg));</span>
[ &lt;a line in ProjectiveSpace(2, 2)&gt;, &lt;a line in ProjectiveSpace(2, 2)&gt;, 
  &lt;a line in ProjectiveSpace(2, 2)&gt;, &lt;a line in ProjectiveSpace(2, 2)&gt;, 
  &lt;a line in ProjectiveSpace(2, 2)&gt;, &lt;a line in ProjectiveSpace(2, 2)&gt;, 
  &lt;a line in ProjectiveSpace(2, 2)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := ParabolicQuadric(6,2);</span>
Q(6, 2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lines := List(Lines(ps));</span>
[ &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">time;</span>
3661
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(lines);</span>
315

</pre></div>

<p>From the example in <a href="chap3_mj.html#X7EBA57FC7CCF8449"><span class="RefLink">3.5-3</span></a> it can be noted that although the number of lines is only 315, already 3 seconds of computing time are needed. This is typically observed for elements of classicla polar spaces different from points or generators, and is explained by the recursive nature of the implementation of the enumerator. Computing a list of these objects as an orbit under the collineation group is, even taking into account the computation of the nice monomorphism of the collineation group, often much faster. Given a collection <var class="Arg">C</var>, the function <code class="file">AsList</code> performs this computation using the collineation group.</p>

<p><a id="X8289FCCC8274C89D" name="X8289FCCC8274C89D"></a></p>

<h5>3.5-4 AsList</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsList</code>( <var class="Arg">C</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: an ORB object containing all objects in <var class="Arg">C</var></p>

<p>The returned object is an ORB object. All objects can easily be obtained by applying the operation <code class="file">List</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := ParabolicQuadric(6,2);</span>
Q(6, 2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lines := AsList(Lines(ps));</span>
&lt;closed orbit, 315 points&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">time;</span>
58
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(lines);</span>
[ &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, 
  &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt;, &lt;a line in Q(6, 2)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">time;</span>
1

</pre></div>

<p><a id="X84D77D437B5F3716" name="X84D77D437B5F3716"></a></p>

<h4>3.6 <span class="Heading">Lie geometries</span></h4>

<p><a id="X7D012B9F86E63702" name="X7D012B9F86E63702"></a></p>

<h5>3.6-1 <span class="Heading">Main categories in <code class="code">IsLieGeometry</code></span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsProjectiveSpace</code></td><td class="tdright">( category )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsClassicalPolarSpace</code></td><td class="tdright">( category )</td></tr></table></div>
<p>In <strong class="pkg">FinInG</strong>, a <em>Lie geometry</em> <span class="SimpleMath">\(G\)</span> refers to a geometry whose automorphism group is a (subgroup of a) group of Lie type. Generally spoken, one could say that a Lie geometry is an incidence geometry, such that each element of type <span class="SimpleMath">\(i\)</span> is represented by a sub space of dimension <span class="SimpleMath">\(i+1\)</span> of a vector space <span class="SimpleMath">\(V\)</span>. The projective space <span class="SimpleMath">\(P\)</span> associated with <span class="SimpleMath">\(V\)</span> is naturally the <em>ambient space</em> of <span class="SimpleMath">\(G\)</span>. However, as one may also consider subspaces of the given vector space over <em>subfields of the ground field of <span class="SimpleMath">\(V\)</span></em>, one cannot not just say that the set of elements of <span class="SimpleMath">\(G\)</span> of a given type <span class="SimpleMath">\(i\)</span>, is a subset of the set of elements of type <span class="SimpleMath">\(i\)</span> of <span class="SimpleMath">\(P\)</span>. Geometrically, this means that embeddings may be full or not, i.e. when a line of a Lie geometry is embedded into <span class="SimpleMath">\(P\)</span> as a line <span class="SimpleMath">\(l\)</span>, the embedding is full only if all projective points of <span class="SimpleMath">\(l\)</span> have a pre image in <span class="SimpleMath">\(G\)</span>. Embeddings of finite classical polar spaces are full, and indeed the set of elements of type <span class="SimpleMath">\(i\)</span> is a proper subset of the set of elements of type <span class="SimpleMath">\(i\)</span> of <span class="SimpleMath">\(P\)</span>. Subgeometries of projective spaces behave differently, and indeed, a line of a subgeometry can be embedded into <span class="SimpleMath">\(P\)</span>, but will not be identified with a line of <span class="SimpleMath">\(P\)</span>. All geometries in <strong class="pkg">FinInG</strong> that have a projective space as ambient space, belong to a subcategory of <code class="code">IsLieGeometry</code>.</p>

<p>One common fact of Lie geometries is that their elements are represented by subspaces of a vector space. In these geometries, incidence is symmetrized set-theoretic containment. In this section we describe methods that are declared in a generic way for (elements of) Lie geometries. These operations are applicable to Lie geometries and related objects.</p>

<p><a id="X8606750A8586DF8D" name="X8606750A8586DF8D"></a></p>

<h5>3.6-2 AmbientSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AmbientSpace</code>( <var class="Arg">ig</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: the ambient projective space of a Lie geometry <var class="Arg">ig</var></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AmbientSpace(PG(3,4));</span>
ProjectiveSpace(3, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AmbientSpace(ParabolicQuadric(4,4));</span>
ProjectiveSpace(4, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AmbientSpace(SplitCayleyHexagon(3));</span>
ProjectiveSpace(6, 3)
 
</pre></div>

<p><a id="X7D544D7985A4572D" name="X7D544D7985A4572D"></a></p>

<h5>3.6-3 UnderlyingVectorSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingVectorSpace</code>( <var class="Arg">ig</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: the underlying vectorspace of the Lie geometry <var class="Arg">ig</var></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingVectorSpace(PG(5,4));</span>
( GF(2^2)^6 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingVectorSpace(HermitianPolarSpace(4,4));</span>
( GF(2^2)^5 )
 
</pre></div>

<p><a id="X84FDF25D797B874B" name="X84FDF25D797B874B"></a></p>

<h5>3.6-4 ProjectiveDimension</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ProjectiveDimension</code>( <var class="Arg">ig</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: the projective dimension of the ambient projective space of <var class="Arg">ig</var></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProjectiveDimension(PG(7,7));</span>
7
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProjectiveDimension(EllipticQuadric(5,2));</span>
5
 
</pre></div>

<p>Mathematically, it makes sense to implement an object representing the empty subspace, since this is typically obtained as a result of a Meet operation, which computes the intersection of two or more elements. On the other hand, we do not consider the empty subspace as an element of the incidence geometry. Hence, using the empty subspace as an argument of <code class="file">IsIncident</code> (and consequently of <code class="file">\*</code>), will result in a ``no method found'' error.</p>

<p><a id="X85DFF5177CA51AE0" name="X85DFF5177CA51AE0"></a></p>

<h5>3.6-5 IsEmptySubspace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsEmptySubspace</code></td><td class="tdright">( category )</td></tr></table></div>
<p>Category for objects representing the empty subspace of a particular Lie geometry. Empty subspaces of different geometries will be different objects, and have a different ambient geometry.</p>

<p><a id="X7FBCF60385E8C1D8" name="X7FBCF60385E8C1D8"></a></p>

<h4>3.7 <span class="Heading">Elements of Lie geometries</span></h4>

<p>Elements of a Lie geometry are constructed using a list of vectors. The methods installed for the particular Lie geometries check whether the subspace of the vector space represents an element of the Lie geometry.</p>

<p><a id="X82E9593B8074AECB" name="X82E9593B8074AECB"></a></p>

<h5>3.7-1 VectorSpaceToElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VectorSpaceToElement</code>( <var class="Arg">ig</var>, <var class="Arg">v</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VectorSpaceToElement</code>( <var class="Arg">ig</var>, <var class="Arg">l</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: the element of <var class="Arg">ig</var>, represented by the subspace spanned by <var class="Arg">v</var> or <var class="Arg">l</var>, or returns the empty subspace.</p>

<p>The first variant of this operation takes as second argument a vector of the underlying vector space of <var class="Arg">ig</var>. Such a vector possibly represents a point of <var class="Arg">ig</var>. The second variant takes as second argument a list of vectors in the underlying vector space of <var class="Arg">ig</var>. Such a list represents a subspace of the vector space. If the dimension of the subspace generated by <var class="Arg">l</var> is larger than zero and strictly less than the dimension of the vector space, it is checked if the subspace represents an element of <var class="Arg">ig</var>, except when <var class="Arg">ig</var> is a projective space. If <var class="Arg">l</var> is a list of vectors generating the whole vector space, then <var class="Arg">ig</var> is returned if and only if <var class="Arg">ig</var> is a projective space, otherwise an error is produced. An empty list is not allowed as second argument.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v := [1,1,1,0,0,0]*Z(7)^0;</span>
[ Z(7)^0, Z(7)^0, Z(7)^0, 0*Z(7), 0*Z(7), 0*Z(7) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w := [0,0,0,1,1,1]*Z(7)^0;</span>
[ 0*Z(7), 0*Z(7), 0*Z(7), Z(7)^0, Z(7)^0, Z(7)^0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VectorSpaceToElement(PG(5,7),v);</span>
&lt;a point in ProjectiveSpace(5, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VectorSpaceToElement(PG(5,7),[v,w]);</span>
&lt;a line in ProjectiveSpace(5, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VectorSpaceToElement(SymplecticSpace(5,7),v);</span>
&lt;a point in W(5, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VectorSpaceToElement(SymplecticSpace(5,7),[v,w]);</span>
Error, &lt;x&gt; does not generate an element of &lt;geom&gt; called from
&lt;function "unknown"&gt;( &lt;arguments&gt; )
 called from read-eval loop at line 13 of *stdin*
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
<span class="GAPbrkprompt">brk&gt;</span> <span class="GAPinput">quit;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VectorSpaceToElement(HyperbolicQuadric(5,7),v);</span>
Error, &lt;v&gt; does not generate an element of &lt;geom&gt; called from
&lt;function "unknown"&gt;( &lt;arguments&gt; )
 called from read-eval loop at line 13 of *stdin*
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
<span class="GAPbrkprompt">brk&gt;</span> <span class="GAPinput">quit;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VectorSpaceToElement(HyperbolicQuadric(5,7),0*v);</span>
&lt; empty subspace &gt;
 
</pre></div>

<p><a id="X810D4D6D87069697" name="X810D4D6D87069697"></a></p>

<h5>3.7-2 UnderlyingObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingObject</code>( <var class="Arg">v</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a CVEC object, which is the vector or matrix representing the element <var class="Arg">v</var></p>

<p>The argument <var class="Arg">v</var> must be an element, so it is not allowed that <var class="Arg">v</var> is the empty subspace, or just a projective space. Note that <code class="file">Unpack</code> can be used to convert the CVEC object into a usual GAP vector or matrix.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := Random(Lines(PG(4,3)));</span>
&lt;a line in ProjectiveSpace(4, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingObject(l);</span>
&lt;cmat 2x5 over GF(3,1)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Unpack(last);</span>
[ [ Z(3)^0, Z(3), 0*Z(3), 0*Z(3), Z(3) ], 
  [ 0*Z(3), 0*Z(3), Z(3)^0, Z(3)^0, 0*Z(3) ] ]
 
</pre></div>

<p><a id="X87BDB89B7AAFE8AD" name="X87BDB89B7AAFE8AD"></a></p>

<h5><code>3.7-3 \in</code></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; \in</code>( <var class="Arg">u</var>, <var class="Arg">v</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: true if and only if the element <var class="Arg">u</var> is set-theoretically contained in the element <var class="Arg">w</var></p>

<p>Both arguments must be elements of the same Lie geometry. The empty subspace and a Lie geometry are also allowed as arguments. This relation is not symmetric, and the methods for <code class="file">IsIncident</code> use this method to test incidence between elements.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := VectorSpaceToElement(PG(3,3),[1,0,0,0]*Z(3)^0);</span>
&lt;a point in ProjectiveSpace(3, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := VectorSpaceToElement(PG(3,3),[[1,0,0,0],[0,1,0,0]]*Z(3)^0);</span>
&lt;a line in ProjectiveSpace(3, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p in l;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p in p;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l in p;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l in PG(3,3);</span>
true
 
</pre></div>

<p><a id="X814C3AC27E49AD5B" name="X814C3AC27E49AD5B"></a></p>

<h5>3.7-4 <span class="Heading">More short names for <code class="file">ElementsIncidentWithElementOfIncidenceStructure</code></span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Hyperplanes</code>( <var class="Arg">inc</var>, <var class="Arg">v</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Hyperplanes</code>( <var class="Arg">v</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: the elements of type <span class="SimpleMath">\(j-1\)</span> incident with <var class="Arg">v</var>, which is an element of type <span class="SimpleMath">\(j\)</span></p>

<p>This operation is a shortcut to the operation <code class="file">ShadowOfElement</code>, where the geometry is taken from <var class="Arg">v</var>, and where the elements of type one less than the type of <var class="Arg">v</var> are asked. <var class="Arg">v</var> is allowed to be a complete projective space here, yielding the hyperplanes of that space.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg := PG(3,7);</span>
ProjectiveSpace(3, 7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hyp := Random(Hyperplanes(pg));</span>
&lt;a plane in ProjectiveSpace(3, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h1 := Random(Hyperplanes(hyp));</span>
&lt;a line in ProjectiveSpace(3, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h2 := Random(Hyperplanes(h1));</span>
&lt;a point in ProjectiveSpace(3, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := SymplecticSpace(7,3);</span>
W(7, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">solid := Random(Solids(ps));</span>
&lt;a solid in W(7, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">plane := Random(Hyperplanes(solid));</span>
&lt;a plane in W(7, 3)&gt;
 
</pre></div>

<p><a id="X7A9EBF9782671634" name="X7A9EBF9782671634"></a></p>

<h4>3.8 <span class="Heading">Changing the ambient geometry of elements of a Lie geometry</span></h4>

<p>A Lie geometry, i.e., an object in the category <code class="code">IsLieGeometry</code>, is naturally embedded in a projective space. This is of course in a mathematical sense. In <strong class="pkg">FinInG</strong>, certain embeddings are implemented by providing a mapping between geometries. The Lie geometries are in some sense <em>hard wired</em> embedded, just simply because a category containing elements of a Lie geometry, is always a subcategory of <code class="code">IsSubspaceOfProjectiveSpace</code>. As a consequence, operations applicable to objects in the category <code class="code">IsSubspaceOfProjectiveSpace</code> are by default applicable to objects in any subcategory, so to elements of any Lie geometry. When dealing with elements of e.g. different polar spaces in the same projective space, this yields a natural way of working with them, and investigating relations between them, without bothering about all necessary mappings. On the other hand, in some situations, it is impossible to decide in which geometry an element has to be considered. An easy example is the following. Consider two different quadrics in the same projective space. The intersection of two elements, one of each quadric, is clearly an element of the ambient projective space. But also of both quadrics. Without extra input of the user, the system cannot decide in which geometry to construct the intersection. To avoid complicated methods with many arguments, in such situations, the resulting element will be constructed in the common ambient projective space. Only in clear situations, where the ambient geometry of all elements is the same, and equal to the geometry of the resulting element, the resulting element will be constructed in this common geometry. We provide however conversion operations for elements of Lie gometries.</p>

<p><a id="X8561C0117FD76C94" name="X8561C0117FD76C94"></a></p>

<h5>3.8-1 ElementToElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementToElement</code>( <var class="Arg">ps</var>, <var class="Arg">el</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Embed</code>( <var class="Arg">ps</var>, <var class="Arg">el</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: <var class="Arg">el</var> as an element of <var class="Arg">ps</var></p>

<p>Let <var class="Arg">ps</var> be any Lie geometry. This method returns <code class="file">VectorSpaceToElement(ps,ElementToVectorSpace(el))</code>, if the conversion is possible. <code class="file">Embed</code> is declared as a synonym of <code class="file">ElementToElement</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := VectorSpaceToElement(PG(3,7),[0,1,0,0]*Z(7)^0);</span>
&lt;a point in ProjectiveSpace(3, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := ElementToElement(HyperbolicQuadric(3,7),p);</span>
&lt;a point in Q+(3, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r := VectorSpaceToElement(PG(3,7),[1,1,0,0]*Z(7)^0);</span>
&lt;a point in ProjectiveSpace(3, 7)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ElementToElement(HyperbolicQuadric(3,7),r);</span>
Error, &lt;v&gt; does not generate an element of &lt;geom&gt; called from
VectorSpaceToElement( geom, Unpack( v ) ) called from
VectorSpaceToElement( ps, UnderlyingObject( el ) ) called from
&lt;function "unknown"&gt;( &lt;arguments&gt; )
 called from read-eval loop at line 11 of *stdin*
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
<span class="GAPbrkprompt">brk&gt;</span> <span class="GAPinput">quit;</span>
 
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chapA_mj.html">A</a>  <a href="chapB_mj.html">B</a>  <a href="chapC_mj.html">C</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
