<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (FinInG) - Chapter 10: Geometry Morphisms</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap10"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chapA.html">A</a>  <a href="chapB.html">B</a>  <a href="chapC.html">C</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap9.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap11.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap10_mj.html">[MathJax on]</a></p>
<p><a id="X876240A479A5717C" name="X876240A479A5717C"></a></p>
<div class="ChapSects"><a href="chap10.html#X876240A479A5717C">10 <span class="Heading">Geometry Morphisms</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap10.html#X850559BF7886E0D2">10.1 <span class="Heading">Geometry morphisms in FinInG</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap10.html#X7A3BDDBE7BADCF0A">10.1-1 IsGeometryMorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap10.html#X86E0B2117DD536D2">10.1-2 Intertwiner</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap10.html#X7926E5367D0C80B7">10.2 <span class="Heading">Type preserving bijective geometry morphisms</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap10.html#X8774AF5B840E488D">10.2-1 IsomorphismPolarSpaces</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap10.html#X79C677CD7B7EC451">10.3 <span class="Heading">Klein correspondence and derived dualities</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap10.html#X7C8E719883F407BB">10.3-1 PluckerCoordinates</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap10.html#X7CD8E5187C5B7116">10.3-2 KleinCorrespondence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap10.html#X7CD8E5187C5B7116">10.3-3 KleinCorrespondence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap10.html#X7FE537C57F2F6BAA">10.3-4 KleinCorrespondenceExtended</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap10.html#X8472EBA584544B51">10.3-5 NaturalDuality</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap10.html#X7954DA578247B06F">10.3-6 SelfDuality</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap10.html#X86D21DCB7C0029F9">10.4 <span class="Heading">Embeddings of projective spaces</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap10.html#X857976B679B8EC30">10.4-1 NaturalEmbeddingBySubspace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap10.html#X82510EF078F0806E">10.4-2 NaturalEmbeddingBySubField</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap10.html#X7BC7FCDC7D9E1A09">10.4-3 <span class="Heading"> Embedding of projective spaces by field reduction</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap10.html#X7F84986879DD952A">10.4-4 BlownUpSubspaceOfProjectiveSpace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap10.html#X7D2D9AD287532FDB">10.4-5 NaturalEmbeddingByFieldReduction</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap10.html#X7C00DD48787B1EEE">10.5 <span class="Heading">Embeddings of polar spaces</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap10.html#X857976B679B8EC30">10.5-1 NaturalEmbeddingBySubspace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap10.html#X82510EF078F0806E">10.5-2 NaturalEmbeddingBySubField</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap10.html#X7823BA95797898CE">10.5-3 <span class="Heading">Embedding of polar spaces by field reduction</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap10.html#X7D2D9AD287532FDB">10.5-4 NaturalEmbeddingByFieldReduction</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap10.html#X7D2D9AD287532FDB">10.5-5 NaturalEmbeddingByFieldReduction</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap10.html#X81FAC1DE7C4B1972">10.6 <span class="Heading">Projections</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap10.html#X7B9E8AB682EC07C2">10.6-1 NaturalProjectionBySubspace</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap10.html#X7952EE1A80D53825">10.7 <span class="Heading">Projective completion</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap10.html#X7E23CA137AEFD1D2">10.7-1 ProjectiveCompletion</a></span>
</div></div>
</div>

<h3>10 <span class="Heading">Geometry Morphisms</span></h3>

<p>Here we describe what is meant by a <em>geometry morphism</em> in <strong class="pkg">FinInG</strong> and the various operations and tools available to the user. When using groups in <strong class="pkg">GAP</strong>, we often use homomorphisms to pass from one situation to another, even though mathematically it may appear to be unneccessary, there can be ambiguities if the functionality is too flexible. This also applies to finite geometry. Take for example the usual exercise of thinking of a hyperplane in a projective space as another projective space. To conform with similar situations in <strong class="pkg">GAP</strong>, the right thing to do is to embed one projective space into another, rather than having one projective space automatically as a substructure of another. The reason for this is that there are many ways one can do this embedding, even though we may dispense with this choice when we are working mathematically. So to avoid ambiguity, we stipulate that one should construct the embedding explicitly. How this is done will be described this chapter.</p>

<p>Suppose that <span class="SimpleMath">S</span> and <span class="SimpleMath">S'</span> are two incidence geometries. A <em>geometry morphism</em> from <span class="SimpleMath">S</span> to <span class="SimpleMath">S'</span> is defined to be a map from the elements of <span class="SimpleMath">S</span> to the elements of <span class="SimpleMath">S'</span> which preserves incidence and induces a function from the type set of <span class="SimpleMath">S</span> to the type set of <span class="SimpleMath">S'</span>. For instance, a correlation and a collineation are examples of geometry morphisms, but they have been dealt with in more specific ways in <strong class="pkg">FinInG</strong>. We will mainly be concerned with geometry morphisms where the source and range are different. Hence, the natural embedding of a projective space in a larger projective space, the mapping induced by field reduction, and e.g. the Klein correspondence are examples of such geometry morphisms.</p>

<p>As a geometry morphism from <span class="SimpleMath">S</span> to <span class="SimpleMath">S'</span> preserves incidence, it also preserves the symmetry, and hence it induces also a map from the collineation group of <span class="SimpleMath">S</span> into the collineation group of <span class="SimpleMath">S'</span>. Such a map will be called an <em>Intertwiner</em>, and <strong class="pkg">FinInG</strong> can provide these maps for some of the geometry morphisms.</p>

<p>Note that quite some technicalities are needed in the implementation of some geometry morphisms. This chapters deals only with the user interface. Some low level functions for geometry morphisms are described in Appendix <a href="chapC.html#X874D94F47C943D71"><span class="RefLink">C</span></a>.</p>

<p><a id="X850559BF7886E0D2" name="X850559BF7886E0D2"></a></p>

<h4>10.1 <span class="Heading">Geometry morphisms in FinInG</span></h4>

<p><a id="X7A3BDDBE7BADCF0A" name="X7A3BDDBE7BADCF0A"></a></p>

<h5>10.1-1 IsGeometryMorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsGeometryMorphism</code></td><td class="tdright">( family )</td></tr></table></div>
<p>The category <code class="code">IsGeometryMorphism</code> represents a special object in <strong class="pkg">FinInG</strong> which carries attributes and the given element map. The element map is given as a <code class="code">IsGeneralMapping</code>, and so has a source and range.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ShowImpliedFilters(IsGeometryMorphism);</span>
Implies:
   IsGeneralMapping
   IsTotal
   Tester(IsTotal)
   IsSingleValued
   Tester(IsSingleValued)
 
</pre></div>

<p>The usual operations of <code class="code">ImageElm</code>, and <code class="code">PreImageElm</code>, have methods installed for geometry morphisms, as well as the overload operator <code class="code">\^</code>.</p>

<p><a id="X86E0B2117DD536D2" name="X86E0B2117DD536D2"></a></p>

<h5>10.1-2 Intertwiner</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Intertwiner</code>( <var class="Arg">f</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: a group homomorphism</p>

<p>The argument <var class="Arg">f</var> is a geometry morphism. If <var class="Arg">f</var> comes equipped with a natural intertwiner from an automorphism group of the source of <var class="Arg">f</var> to the automorphism group to the image of <var class="Arg">f</var>, then the user may is able to obtain the intertwiner by calling this operation (see the individual geometry morphism constructions). For most geometry morphisms, there is also an accompanying intertwiner for the automorphism groups of the source and range. Given a geometry morphism <span class="SimpleMath">f</span> from <span class="SimpleMath">S</span> to <span class="SimpleMath">S'</span>, an intertwiner φ is a map from the automorphism group of <span class="SimpleMath">S</span> to the automorphism group of <span class="SimpleMath">S'</span>, such that for every element <span class="SimpleMath">p</span> of <span class="SimpleMath">S</span> and every automorphism <span class="SimpleMath">g</span> of <span class="SimpleMath">S</span>, we have</p>

<p class="pcenter">f(p<sup>g</sup>)=f(p)<sup>φ(g)</sup>.</p>

<p>There is no method to compute an intertwiner for a given geometry morphism, the attribute is or is not set during the construction of the geometry morphism, depending whether the Source and Range of the morphism have the appropriate automorphism group known as an attribute. When this condition is not satisfied, the user is expected to call the appropriate automorphism groups, so that they are computed, and to recompute the geometry morphism (which will not cost a lot of computation time then). This will make the attribute <code class="file">Intertwiner</code> available. Here is a simple example of the intertwiner for the isomorphism of two polar spaces (see <code class="func">IsomorphismPolarSpaces</code> (<a href="chap10.html#X8774AF5B840E488D"><span class="RefLink">10.2-1</span></a>)). The source of the homomorphism is dependent on the geometry.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := BilinearFormByMatrix( IdentityMat(3,GF(3)), GF(3) );</span>
&lt; bilinear form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := PolarSpace(form);</span>
&lt;polar space in ProjectiveSpace(2,GF(3)): x_1^2+x_2^2+x_3^2=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pq := ParabolicQuadric(2,3);</span>
standard Q(2, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso := IsomorphismPolarSpaces(ps, pq);</span>
#I  Computing nice monomorphism...
&lt;geometry morphism from &lt;Elements of &lt;polar space in ProjectiveSpace(2,GF(
3)): x_1^2+x_2^2+x_3^2=0 &gt;&gt; to &lt;Elements of standard Q(2, 3)&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KnownAttributesOfObject(iso);</span>
[ "Range", "Source", "Intertwiner" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom := Intertwiner(iso);</span>
MappingByFunction( &lt;projective semilinear group with 
3 generators&gt;, PGammaO(3,3), function( y ) ... end, function( x ) ... end )
 
</pre></div>

<p><a id="X7926E5367D0C80B7" name="X7926E5367D0C80B7"></a></p>

<h4>10.2 <span class="Heading">Type preserving bijective geometry morphisms</span></h4>

<p>An important class of geometry morphisms in <strong class="pkg">FinInG</strong> are the isomorphisms between polar spaces of the same kind that are induced by coordinate transformations.</p>

<p><a id="X8774AF5B840E488D" name="X8774AF5B840E488D"></a></p>

<h5>10.2-1 IsomorphismPolarSpaces</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismPolarSpaces</code>( <var class="Arg">ps1</var>, <var class="Arg">ps2</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismPolarSpaces</code>( <var class="Arg">ps1</var>, <var class="Arg">ps2</var>, <var class="Arg">boolean</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a geometry morphism</p>

<p>The arguments <var class="Arg">ps1</var> and <var class="Arg">ps2</var> are <em>equivalent</em> polar spaces, i.e. up to coordinate transformation, the underlying sesquilinear or quadratic form determines the same polar space, or, <var class="Arg">ps1</var> is a parabolic quadric over a finite field <span class="SimpleMath">f</span> of even charateristic in dimension <span class="SimpleMath">2n</span> and <var class="Arg">ps2</var> is a symplectic space over <span class="SimpleMath">f</span> in dimension <span class="SimpleMath">2n-1</span>, then this operation returns a geometry isomorphism between them. The optional third argument <var class="Arg">boolean</var> can take either <code class="code">true</code> or <code class="code">false</code> as input, and then the operation will or will not compute the intertwiner accordingly. The user may wish that the intertwiner is not computed when working with large polar spaces. The default (when calling the operation with two arguments) is set to <code class="code">true</code>, and in this case, if at least one of <var class="Arg">ps1</var> or <var class="Arg">ps2</var> has a collineation group installed as an attribute, then an intertwining homomorphism is installed as an attribute of the resulting geometry morphism. Hence we also obtain a natural group isomorphism from the collineation group of <var class="Arg">ps1</var> onto the collineation group of <var class="Arg">ps2</var> (see also <code class="func">Intertwiner</code> (<a href="chap10.html#X86E0B2117DD536D2"><span class="RefLink">10.1-2</span></a>)).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat1 := IdentityMat(6,GF(5));</span>
&lt; mutable compressed matrix 6x6 over GF(5) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form1 := BilinearFormByMatrix(mat1,GF(5));</span>
&lt; bilinear form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps1 := PolarSpace(form1);</span>
&lt;polar space in ProjectiveSpace(
5,GF(5)): x_1^2+x_2^2+x_3^2+x_4^2+x_5^2+x_6^2=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat2 := [[0,0,0,0,0,1],[0,0,0,0,1,0],[0,0,0,1,0,0],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0]]*Z(5)^0;</span>
[ [ 0*Z(5), 0*Z(5), 0*Z(5), 0*Z(5), 0*Z(5), Z(5)^0 ], 
  [ 0*Z(5), 0*Z(5), 0*Z(5), 0*Z(5), Z(5)^0, 0*Z(5) ], 
  [ 0*Z(5), 0*Z(5), 0*Z(5), Z(5)^0, 0*Z(5), 0*Z(5) ], 
  [ 0*Z(5), 0*Z(5), 0*Z(5), 0*Z(5), 0*Z(5), 0*Z(5) ], 
  [ 0*Z(5), 0*Z(5), 0*Z(5), 0*Z(5), 0*Z(5), 0*Z(5) ], 
  [ 0*Z(5), 0*Z(5), 0*Z(5), 0*Z(5), 0*Z(5), 0*Z(5) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form2 := QuadraticFormByMatrix(mat2,GF(5));</span>
&lt; quadratic form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps2 := PolarSpace(form2);</span>
&lt;polar space in ProjectiveSpace(5,GF(5)): x_1*x_6+x_2*x_5+x_3*x_4=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso := IsomorphismPolarSpaces(ps1,ps2,true);</span>
#I  No intertwiner computed. One of the polar spaces must have a collineation group computed
&lt;geometry morphism from &lt;Elements of Q+(5, 
5): x_1^2+x_2^2+x_3^2+x_4^2+x_5^2+x_6^2=0&gt; to &lt;Elements of Q+(5, 
5): x_1*x_6+x_2*x_5+x_3*x_4=0&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CollineationGroup(ps1);</span>
#I  Computing collineation group of canonical polar space...
&lt;projective collineation group of size 58032000000 with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CollineationGroup(ps2);</span>
#I  Computing collineation group of canonical polar space...
&lt;projective collineation group of size 58032000000 with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso := IsomorphismPolarSpaces(ps1,ps2,true);</span>
&lt;geometry morphism from &lt;Elements of Q+(5, 
5): x_1^2+x_2^2+x_3^2+x_4^2+x_5^2+x_6^2=0&gt; to &lt;Elements of Q+(5, 
5): x_1*x_6+x_2*x_5+x_3*x_4=0&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom := Intertwiner( iso );</span>
MappingByFunction( &lt;projective collineation group of size 58032000000 with 
4 generators&gt;, &lt;projective collineation group of size 58032000000 with 
4 generators&gt;, function( y ) ... end, function( x ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps1 := ParabolicQuadric(6,8);</span>
Q(6, 8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps2 := SymplecticSpace(5,8);</span>
W(5, 8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">em := IsomorphismPolarSpaces(ps1,ps2);</span>
#I  Have 36171 points.
#I  Have 37381 points in new orbit.
#I  Have 36171 points.
#I  Have 37388 points in new orbit.
&lt;geometry morphism from &lt;Elements of Q(6, 8)&gt; to &lt;Elements of W(5, 8)&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom := Intertwiner(em);</span>
MappingByFunction( PGammaO(7,8), &lt;projective collineation group of size 
27231016821530296320 with 
3 generators&gt;, function( el ) ... end, function( el ) ... end )
 
</pre></div>

<p><a id="X79C677CD7B7EC451" name="X79C677CD7B7EC451"></a></p>

<h4>10.3 <span class="Heading">Klein correspondence and derived dualities</span></h4>

<p>The Klein correspondence is a well known geometry morphism from the lines of PG(3,q) to the points of a hyperbolic quadric in PG(5,q). This morphism and some derived morphisms are provided in <strong class="pkg">FinInG</strong>. The bare essential of the Klein corresondence is the so-called Plücker map.</p>

<p><a id="X7C8E719883F407BB" name="X7C8E719883F407BB"></a></p>

<h5>10.3-1 PluckerCoordinates</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PluckerCoordinates</code>( <var class="Arg">line</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>This operation takes a line of PG(3,q) as argument. It returns the plucker coordinates of the argument as list of finite field elements. The retured list can be used in operations as <code class="file">VectorSpaceToElement</code>, and represents a point of the hyperbolic quadric in PG(5,q) with equation X<sub>0</sub>X<sub>5</sub>+X<sub>1</sub>X<sub>4</sub>+X<sub>2</sub>X<sub>3</sub> = 0</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg := PG(3,169);</span>
ProjectiveSpace(3, 169)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := Random(Lines(pg));</span>
&lt;a line in ProjectiveSpace(3, 169)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vec := PluckerCoordinates(l);</span>
[ Z(13)^0, Z(13^2)^138, Z(13^2)^93, Z(13^2)^53, Z(13^2)^71, Z(13^2)^106 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0,0,0,0,0,1],[0,0,0,0,1,0],[0,0,0,1,0,0],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0]]*Z(13)^0;</span>
[ [ 0*Z(13), 0*Z(13), 0*Z(13), 0*Z(13), 0*Z(13), Z(13)^0 ], 
  [ 0*Z(13), 0*Z(13), 0*Z(13), 0*Z(13), Z(13)^0, 0*Z(13) ], 
  [ 0*Z(13), 0*Z(13), 0*Z(13), Z(13)^0, 0*Z(13), 0*Z(13) ], 
  [ 0*Z(13), 0*Z(13), 0*Z(13), 0*Z(13), 0*Z(13), 0*Z(13) ], 
  [ 0*Z(13), 0*Z(13), 0*Z(13), 0*Z(13), 0*Z(13), 0*Z(13) ], 
  [ 0*Z(13), 0*Z(13), 0*Z(13), 0*Z(13), 0*Z(13), 0*Z(13) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := QuadraticFormByMatrix(mat,GF(169));</span>
&lt; quadratic form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">klein := PolarSpace(form);</span>
&lt;polar space in ProjectiveSpace(5,GF(13^2)): x_1*x_6+x_2*x_5+x_3*x_4=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VectorSpaceToElement(klein,vec);</span>
&lt;a point in Q+(5, 169): x_1*x_6+x_2*x_5+x_3*x_4=0&gt;

</pre></div>

<p><a id="X7CD8E5187C5B7116" name="X7CD8E5187C5B7116"></a></p>

<h5>10.3-2 KleinCorrespondence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; KleinCorrespondence</code>( <var class="Arg">f</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; KleinCorrespondence</code>( <var class="Arg">f</var>, <var class="Arg">boolean</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; KleinCorrespondence</code>( <var class="Arg">q</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; KleinCorrespondence</code>( <var class="Arg">q</var>, <var class="Arg">boolean</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a geometry morphism</p>

<p>The argument <var class="Arg">f</var> is a finite field, the argument <var class="Arg">q</var> is a prime power. The first an the third version use <code class="keyw">true</code> as value for <var class="Arg">boolean</var>. When using <code class="keyw">true</code> as value for the boolean, the intertwiner is computed. This variant of the operation <code class="file">KleinCorrespondence</code> has always as ambient geometry of its range the hyperbolic quadric Q<sup>+</sup>(5,q) with equation X<sub>0</sub>X<sub>5</sub>+X<sub>1</sub>X<sub>4</sub>+X<sub>2</sub>X<sub>3</sub> = 0 The returned geometry morphism has the lines of PG(3,q) as source and the points of Q<sup>+</sup>(5,q) as range.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k := KleinCorrespondence( 9 );</span>
&lt;geometry morphism from &lt;lines of ProjectiveSpace(3, 9)&gt; to &lt;points of Q+(5, 
9): x_1*x_6+x_2*x_5+x_3*x_4=0&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Intertwiner(k);</span>
MappingByFunction( The FinInG collineation group PGammaL(4,9), &lt;projective col
lineation group with 
3 generators&gt;, function( g ) ... end, function( g ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg := ProjectiveSpace(3, 9);</span>
ProjectiveSpace(3, 9)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AmbientGeometry(Range(k));</span>
Q+(5, 9): x_1*x_6+x_2*x_5+x_3*x_4=0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := Random( Lines(pg) );</span>
&lt;a line in ProjectiveSpace(3, 9)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l^k;</span>
&lt;a point in Q+(5, 9): x_1*x_6+x_2*x_5+x_3*x_4=0&gt;

</pre></div>

<p><a id="X7CD8E5187C5B7116" name="X7CD8E5187C5B7116"></a></p>

<h5>10.3-3 KleinCorrespondence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; KleinCorrespondence</code>( <var class="Arg">quadric</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; KleinCorrespondence</code>( <var class="Arg">quadric</var>, <var class="Arg">boolean</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a geometry morphism</p>

<p>The argument <var class="Arg">quadric</var> is a hyperbolic quadric in a 5 dimensional projective space. If <var class="Arg">boolean</var> is <code class="keyw">true</code> or not given, this operation returns the geometry morphism equipped with an intertwiner. The returned geometry morphism has the lines of PG(3,q) as source and the points of Q<sup>+</sup>(5,q) as range.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">quadric := HyperbolicQuadric(5,3);                                         </span>
Q+(5, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k := KleinCorrespondence( quadric );</span>
&lt;geometry morphism from &lt;lines of ProjectiveSpace(3, 3)&gt; to &lt;points of Q+(5, 
3)&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg := ProjectiveSpace(3, 3);</span>
ProjectiveSpace(3, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := Random( Lines(pg) );</span>
&lt;a line in ProjectiveSpace(3, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l^k;</span>
&lt;a point in Q+(5, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMat(6,GF(13));</span>
&lt; mutable compressed matrix 6x6 over GF(13) &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := QuadraticFormByMatrix(id,GF(13));</span>
&lt; quadratic form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">quadric := PolarSpace(form);</span>
&lt;polar space in ProjectiveSpace(
5,GF(13)): x_1^2+x_2^2+x_3^2+x_4^2+x_5^2+x_6^2=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k := KleinCorrespondence( quadric );</span>
&lt;geometry morphism from &lt;lines of ProjectiveSpace(3, 13)&gt; to &lt;points of Q+(5, 
13): x_1^2+x_2^2+x_3^2+x_4^2+x_5^2+x_6^2=0&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg := AmbientGeometry(Source(k));</span>
ProjectiveSpace(3, 13)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := Random(Lines(pg));</span>
&lt;a line in ProjectiveSpace(3, 13)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l^k;</span>
&lt;a point in Q+(5, 13): x_1^2+x_2^2+x_3^2+x_4^2+x_5^2+x_6^2=0&gt;

</pre></div>

<p><a id="X7FE537C57F2F6BAA" name="X7FE537C57F2F6BAA"></a></p>

<h5>10.3-4 KleinCorrespondenceExtended</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; KleinCorrespondenceExtended</code>( <var class="Arg">quadric</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; KleinCorrespondenceExtended</code>( <var class="Arg">quadric</var>, <var class="Arg">boolean</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a geometry morphism</p>

<p>The argument <var class="Arg">quadric</var> is a hyperbolic quadric in a 5 dimensional projective space. If <var class="Arg">boolean</var> is <code class="keyw">true</code> or not given, this operation returns the geometry morphism equipped with an intertwiner. The returned geometry morphism has all the elements of PG(3,q) as source (not just the lines) and the elements of Q<sup>+</sup>(5,q) as range, hence this operation is a kind of extension of <code class="file">KleinCorrespondence</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HyperbolicQuadric(5,7);</span>
Q+(5, 7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">em := KleinCorrespondenceExtended(ps);</span>
&lt;geometry morphism from &lt;All elements of ProjectiveSpace(3, 
7)&gt; to &lt;Elements of Q+(5, 7)&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom := Intertwiner(em);</span>
MappingByFunction( The FinInG collineation group PGL(4,7), &lt;projective colline
ation group with 2 generators&gt;, function( g ) ... end, function( g ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0,0,0,0,0,1],[0,0,0,0,1,0],[0,0,0,1,0,0],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">	[0,0,1,0,0,0],[0,1,0,0,0,0],[1,0,0,0,0,0]]*Z(7)^0;</span>
[ [ 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), Z(7)^0 ], 
  [ 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), Z(7)^0, 0*Z(7) ], 
  [ 0*Z(7), 0*Z(7), 0*Z(7), Z(7)^0, 0*Z(7), 0*Z(7) ], 
  [ 0*Z(7), 0*Z(7), Z(7)^0, 0*Z(7), 0*Z(7), 0*Z(7) ], 
  [ 0*Z(7), Z(7)^0, 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7) ], 
  [ Z(7)^0, 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := Projectivity(mat,GF(7));</span>
&lt; a collineation: &lt;cmat 6x6 over GF(7,1)&gt;, F^0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g in CollineationGroup(ps);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreImageElm(hom,g);</span>
#I  &lt;el&gt; is not inducing a collineation of PG(3,q)
fail

</pre></div>

<p>It is well known that the classical generalised quadrangles W(3,q) and Q(4,q) are dual incidence structures, the same holds for the classical generalised quadrangles Q<sup>+</sup>(5,q) and H(3,q<sup>2</sup>). Essentially, these dual dualities are based on the Klein correspondence, and are implemented through the operation <code class="file">NaturalDuality</code>, this operation will return a geometry morphism with <code class="code">ElementsOfIncidenceStructure(gq1)</code> as source and <code class="code">ElementsOfIncidenceStructure(gq2)</code> as range, in other words, it is a geometry morphism from all the elements of <var class="Arg">gq1</var> onto all the elements of <var class="Arg">gq2</var>, preserving the incidence, and swapping the types.</p>

<p><a id="X8472EBA584544B51" name="X8472EBA584544B51"></a></p>

<h5>10.3-5 NaturalDuality</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalDuality</code>( <var class="Arg">gq1</var>, <var class="Arg">gq2</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalDuality</code>( <var class="Arg">gq1</var>, <var class="Arg">gq2</var>, <var class="Arg">boolean</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalDuality</code>( <var class="Arg">gq</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalDuality</code>( <var class="Arg">gq</var>, <var class="Arg">boolean</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a geometry morphism</p>

<p>The operation allows the construction of the duality between W(3,q) and Q(4,q), respectively Q<sup>+</sup>(5,q), in two directions. It is checked if the arguments are appropriate, i.e. the right type of generalised quadrangle(s). The first version requires two arguments: either the symplectic or parabolic quadrangle, in any order, and defined by any suitable bilinear/quadratic and bilinear form; or the elliptic or hermitian quadrangle (in dimension <span class="SimpleMath">3</span>), in any order, and defined by any suitable bilinear/quadratic and hermitian form. In all cases the generalised quadrangles may be the standard one provided by the package <strong class="pkg">FinInG</strong>.</p>

<p>The third version requires only one argument, either W(3,q), Q(4,q), Q<sup>+</sup>(5,q), or H(3,q<sup>2</sup>), standard or user specified using an appropriate bilinear, quadratic or hermitian form. The range of the returned geometry morphism will be the set of all elements of a suitable generalised quadrangle, in standard form.</p>

<p>The first and third version without a boolean as argument will, if possible return a geometry morphism equipped with an intertwiner. Using the boolean argument <var class="Arg">false</var> will return a geometry morphism that is not equipped with an intertwiner.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w := SymplecticSpace(3,5);</span>
W(3, 5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lines:=AsList(Lines(w));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">duality := NaturalDuality(w);</span>
&lt;geometry morphism from &lt;Elements of W(3, 5)&gt; to &lt;Elements of Q(4, 5)&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l:=lines[1];</span>
&lt;a line in W(3, 5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l^duality;</span>
&lt;a point in Q(4, 5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreImageElm(duality,last);</span>
&lt;a line in W(3, 5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom := Intertwiner(duality);</span>
MappingByFunction( PGammaSp(4,5), &lt;projective collineation group of size 
9360000 with 4 generators&gt;, function( g ) ... end, function( g ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := 5;</span>
5
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q5q := EllipticQuadric(5,q);</span>
Q-(5, 5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0,1,0,0],[1,0,0,0],[0,0,0,Z(q)],[0,0,Z(q),0]]*Z(q)^0;</span>
[ [ 0*Z(5), Z(5)^0, 0*Z(5), 0*Z(5) ], [ Z(5)^0, 0*Z(5), 0*Z(5), 0*Z(5) ], 
  [ 0*Z(5), 0*Z(5), 0*Z(5), Z(5) ], [ 0*Z(5), 0*Z(5), Z(5), 0*Z(5) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hform := HermitianFormByMatrix(mat,GF(q^2));</span>
&lt; hermitian form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">herm := PolarSpace(hform);</span>
&lt;polar space in ProjectiveSpace(
3,GF(5^2)): x1^5*x2+x1*x2^5+Z(5)*x3^5*x4+Z(5)*x3*x4^5=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">duality := NaturalDuality(q5q,herm,true);</span>
&lt;geometry morphism from &lt;Elements of Q-(5, 5)&gt; to &lt;Elements of H(3, 
5^2): x1^5*x2+x1*x2^5+Z(5)*x3^5*x4+Z(5)*x3*x4^5=0&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom := Intertwiner(duality);</span>
MappingByFunction( PDeltaO-(6,5), &lt;projective collineation group of size 
58968000000 with 3 generators&gt;, function( g ) ... end, function( g ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := Random(CollineationGroup(q5q));</span>
&lt; a collineation: &lt;cmat 6x6 over GF(5,1)&gt;, F^0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g^hom;</span>
&lt; a collineation: &lt;cmat 4x4 over GF(5,2)&gt;, F^5&gt;

</pre></div>

<p>The combination of the isomorphism of the GQs W(3,q), Q(4,q) when <span class="SimpleMath">q</span> is even and the duality between the same GQs, yields a duality from each of these GQs itself. The operation <code class="file">SelfDuality</code> implements this combination.</p>

<p><a id="X7954DA578247B06F" name="X7954DA578247B06F"></a></p>

<h5>10.3-6 SelfDuality</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SelfDuality</code>( <var class="Arg">gq</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SelfDuality</code>( <var class="Arg">gq</var>, <var class="Arg">boolean</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a geometry morphism</p>

<p>It is checked wheter the base field of <var class="Arg">gq</var> is a field of charateristic 2 and whether <var class="Arg">gq</var> is a symplectic generalised quadrangle in 3-dimensional projective space or a parabolic quadric in 4-dimensional projective space. The first version will return, when possible, a geometry morphism equipped with an intertwiner. Using the boolean argument <var class="Arg">false</var> will return a geometry morphism that is not equipped with an intertwiner. The example shows the use of the boolean argument.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := 16;</span>
16
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0,1,0,0,0],[0,0,0,0,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,0]]*Z(q)^0;</span>
[ [ 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2) ], 
  [ 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2) ], 
  [ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2) ], 
  [ 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2) ], 
  [ 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form := QuadraticFormByMatrix(mat,GF(q));</span>
&lt; quadratic form &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q4q := PolarSpace(form);</span>
&lt;polar space in ProjectiveSpace(4,GF(2^4)): x_1*x_2+x_3^2+x_4*x_5=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">em := SelfDuality(q4q);</span>
#I  No intertwiner computed. The polar space must have a collineation group computed
&lt;geometry morphism from &lt;Elements of Q(4, 
16): x_1*x_2+x_3^2+x_4*x_5=0&gt; to &lt;Elements of Q(4, 
16): x_1*x_2+x_3^2+x_4*x_5=0&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CollineationGroup(q4q);</span>
#I  Computing collineation group of canonical polar space...
&lt;projective collineation group of size 4380799795200 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">em := SelfDuality(q4q);</span>
&lt;geometry morphism from &lt;Elements of Q(4, 
16): x_1*x_2+x_3^2+x_4*x_5=0&gt; to &lt;Elements of Q(4, 
16): x_1*x_2+x_3^2+x_4*x_5=0&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom := Intertwiner(em);</span>
MappingByFunction( &lt;projective collineation group of size 4380799795200 with 
3 generators&gt;, &lt;projective collineation group of size 4380799795200 with 
3 generators&gt;, function( el ) ... end, function( el ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := 16;</span>
16
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w := SymplecticSpace(3,q);</span>
W(3, 16)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">em := SelfDuality(w);</span>
&lt;geometry morphism from &lt;Elements of W(3, 16)&gt; to &lt;Elements of W(3, 16)&gt;&gt;

</pre></div>

<p><a id="X86D21DCB7C0029F9" name="X86D21DCB7C0029F9"></a></p>

<h4>10.4 <span class="Heading">Embeddings of projective spaces</span></h4>

<p>The most natural of geometry morphisms include, for example, the embedding of a projective space into another via a subspace, the embedding of a projective space over a field into a projective space of the same dimension over an extended field, or the embedding of a projective space over a field into a projective space of higher dimension over a subfield through so-called field reduction.</p>

<p><a id="X857976B679B8EC30" name="X857976B679B8EC30"></a></p>

<h5>10.4-1 NaturalEmbeddingBySubspace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalEmbeddingBySubspace</code>( <var class="Arg">geom1</var>, <var class="Arg">geom2</var>, <var class="Arg">v</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a geometry morphism</p>

<p>The arguments <var class="Arg">geom1</var> and <var class="Arg">geom2</var> are both projective spaces, and <var class="Arg">v</var> is an element of a geom2. This function returns a geometry morphism representing the natural embedding of <var class="Arg">geom1</var> into <var class="Arg">geom2</var> as the subspace <var class="Arg">v</var>. Hence <var class="Arg">geom1</var> and <var class="Arg">v</var> must be equivalent as geometries. An Intertwiner is not implemented for this geometry morphism.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">geom1 := ProjectiveSpace(2, 3);</span>
ProjectiveSpace(2, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">geom2 := ProjectiveSpace(3, 3);</span>
ProjectiveSpace(3, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">planes := Planes(geom2);</span>
&lt;planes of ProjectiveSpace(3, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hyp := Random(planes);</span>
&lt;a plane in ProjectiveSpace(3, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">em := NaturalEmbeddingBySubspace(geom1, geom2, hyp);</span>
&lt;geometry morphism from &lt;All elements of ProjectiveSpace(2, 
3)&gt; to &lt;All elements of ProjectiveSpace(3, 3)&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">points := Points(geom1);</span>
&lt;points of ProjectiveSpace(2, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := Random(points);</span>
&lt;a point in ProjectiveSpace(2, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x^em;</span>
&lt;a point in ProjectiveSpace(3, 3)&gt;

</pre></div>

<p><a id="X82510EF078F0806E" name="X82510EF078F0806E"></a></p>

<h5>10.4-2 NaturalEmbeddingBySubField</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalEmbeddingBySubField</code>( <var class="Arg">geom1</var>, <var class="Arg">geom2</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalEmbeddingBySubField</code>( <var class="Arg">geom1</var>, <var class="Arg">geom2</var>, <var class="Arg">boolean</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a geometry morphism</p>

<p>The arguments <var class="Arg">geom1</var> and <var class="Arg">geom2</var> are projective spaces of the same dimension. This function returns a geometry morphism representing the natural embedding of <var class="Arg">geom1</var> into <var class="Arg">geom2</var> as a subfield geometry. The geometry morphism also comes equipped with an intertwiner (see <code class="func">Intertwiner</code> (<a href="chap10.html#X86E0B2117DD536D2"><span class="RefLink">10.1-2</span></a>)). The optional third argument <var class="Arg">boolean</var> can take either <code class="code">true</code> or <code class="code">false</code> as input, and then our operation will or will not compute the intertwiner accordingly. The default (when calling the operation with two arguments) is set to <code class="code">true</code>. Note that the source of the intertwiner is the projectivity group of <var class="Arg">geom1</var> and its range is a subgroup of the projectivity group of <var class="Arg">geom2</var>. Here is a simple example where the geometry morphism embeds PG(2,3) into PG(2,9) .</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg1 := PG(2,3);</span>
ProjectiveSpace(2, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg2 := PG(2,9);</span>
ProjectiveSpace(2, 9)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">em := NaturalEmbeddingBySubfield(pg1,pg2);</span>
&lt;geometry morphism from &lt;All elements of ProjectiveSpace(2, 
3)&gt; to &lt;All elements of ProjectiveSpace(2, 9)&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">points := AsList(Points( pg1 ));</span>
[ &lt;a point in ProjectiveSpace(2, 3)&gt;, &lt;a point in ProjectiveSpace(2, 3)&gt;, 
  &lt;a point in ProjectiveSpace(2, 3)&gt;, &lt;a point in ProjectiveSpace(2, 3)&gt;, 
  &lt;a point in ProjectiveSpace(2, 3)&gt;, &lt;a point in ProjectiveSpace(2, 3)&gt;, 
  &lt;a point in ProjectiveSpace(2, 3)&gt;, &lt;a point in ProjectiveSpace(2, 3)&gt;, 
  &lt;a point in ProjectiveSpace(2, 3)&gt;, &lt;a point in ProjectiveSpace(2, 3)&gt;, 
  &lt;a point in ProjectiveSpace(2, 3)&gt;, &lt;a point in ProjectiveSpace(2, 3)&gt;, 
  &lt;a point in ProjectiveSpace(2, 3)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">image := ImagesSet(em, points);</span>
[ &lt;a point in ProjectiveSpace(2, 9)&gt;, &lt;a point in ProjectiveSpace(2, 9)&gt;, 
  &lt;a point in ProjectiveSpace(2, 9)&gt;, &lt;a point in ProjectiveSpace(2, 9)&gt;, 
  &lt;a point in ProjectiveSpace(2, 9)&gt;, &lt;a point in ProjectiveSpace(2, 9)&gt;, 
  &lt;a point in ProjectiveSpace(2, 9)&gt;, &lt;a point in ProjectiveSpace(2, 9)&gt;, 
  &lt;a point in ProjectiveSpace(2, 9)&gt;, &lt;a point in ProjectiveSpace(2, 9)&gt;, 
  &lt;a point in ProjectiveSpace(2, 9)&gt;, &lt;a point in ProjectiveSpace(2, 9)&gt;, 
  &lt;a point in ProjectiveSpace(2, 9)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom := Intertwiner(em);</span>
MappingByFunction( The FinInG projectivity group PGL(3,3), &lt;projective colline
ation group of size 5616 with 
2 generators&gt;, function( x ) ... end, function( y ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">group1 := ProjectivityGroup(pg1);</span>
The FinInG projectivity group PGL(3,3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens := GeneratorsOfGroup(group1);</span>
[ &lt; a collineation: &lt;cmat 3x3 over GF(3,1)&gt;, F^0&gt;, 
  &lt; a collineation: &lt;cmat 3x3 over GF(3,1)&gt;, F^0&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">group1_image := Group(List(gens,x-&gt;x^hom));</span>
&lt;projective collineation group with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order(group1_image);</span>
5616
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">group2 := ProjectivityGroup(pg2);</span>
The FinInG projectivity group PGL(3,9)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order(group2);</span>
42456960
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := Random(group2);</span>
&lt; a collineation: &lt;cmat 3x3 over GF(3,2)&gt;, F^0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreImageElm(hom,g);</span>
#I  &lt;el&gt; is not in the range of the intertwiner
fail

</pre></div>

<p><a id="X7BC7FCDC7D9E1A09" name="X7BC7FCDC7D9E1A09"></a></p>

<h5>10.4-3 <span class="Heading"> Embedding of projective spaces by field reduction</span></h5>

<p>We briefly describe the mathematics behind field reduction. For more details we refer to <a href="chapBib.html#biBLaVa">[LVdV13]</a>. Consider the fields GF(q) and GF(q<sup>t</sup>). The field GF(q<sup>t</sup>) is a <span class="SimpleMath">t</span>-dimensional vector space over GF(q). Hence, with respect to a chosen basis <span class="SimpleMath">B</span> for GF(q<sup>t</sup>) as a GF(q)-vectorspace, the bijection between the vectorspaces V(n,q<sup>t</sup>) and <span class="SimpleMath">V(tn,q)</span> can be implemented. Consider the projective space PG(n-1,q<sup>t</sup>). The elements are represented by subspaces of V(n,q<sup>t</sup>). Clearly, a <span class="SimpleMath">k</span> dimensional subspace of V(n,q<sup>t</sup>) is also a <span class="SimpleMath">kn</span>-dimensional subspace of <span class="SimpleMath">V(nt,q)</span>. This induces an embedding from PG(n-1,q<sup>t</sup>) into PG(nt-1,q). The embedding will be determined by the chosen basis of GF(q<sup>t</sup>) as a vector space over GF(q)</p>

<p><a id="X7F84986879DD952A" name="X7F84986879DD952A"></a></p>

<h5>10.4-4 BlownUpSubspaceOfProjectiveSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BlownUpSubspaceOfProjectiveSpace</code>( <var class="Arg">B</var>, <var class="Arg">subspace</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a subspace of a projective space</p>

<p>Let <var class="Arg">B</var> be a basis for the field GF(q<sup>t</sup>) as GF(q) vector space, and let <var class="Arg">subspace</var> be a <span class="SimpleMath">k-1</span>-dimensional subspace of PG(n-1,q<sup>t</sup>) represented by a <span class="SimpleMath">k</span>-dimensional subspace <span class="SimpleMath">S</span> of V(n,q<sup>t</sup>). This operation returns the <span class="SimpleMath">kt-1</span>-dimensional subspace of PG(nt-1,q) represented by blowing up <span class="SimpleMath">S</span> with respect to the base <var class="Arg">B</var>. This operation relies on the <strong class="pkg">GAP</strong> operation <code class="file">BlownUpMat</code>. In the example, the effect of choosing a different basis is shown.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg := PG(3,5^2);</span>
ProjectiveSpace(3, 25)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">basis := Basis(AsVectorSpace(GF(5),GF(5^2)));</span>
CanonicalBasis( GF(5^2) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">line := Random(Lines(pg));</span>
&lt;a line in ProjectiveSpace(3, 25)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">solid1 := BlownUpSubspaceOfProjectiveSpace(basis,line);</span>
&lt;a solid in ProjectiveSpace(7, 5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BasisVectors(basis);</span>
[ Z(5)^0, Z(5^2) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">basis := Basis(AsVectorSpace(GF(5),GF(5^2)),[Z(5),Z(5^2)^8]);</span>
Basis( GF(5^2), [ Z(5), Z(5^2)^8 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">solid2 := BlownUpSubspaceOfProjectiveSpace(basis,line);</span>
&lt;a solid in ProjectiveSpace(7, 5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">solid1 = solid2;</span>
false

</pre></div>

<p><a id="X7D2D9AD287532FDB" name="X7D2D9AD287532FDB"></a></p>

<h5>10.4-5 NaturalEmbeddingByFieldReduction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalEmbeddingByFieldReduction</code>( <var class="Arg">geom1</var>, <var class="Arg">f2</var>, <var class="Arg">B</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalEmbeddingByFieldReduction</code>( <var class="Arg">geom1</var>, <var class="Arg">f2</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalEmbeddingByFieldReduction</code>( <var class="Arg">geom1</var>, <var class="Arg">geom2</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalEmbeddingByFieldReduction</code>( <var class="Arg">geom1</var>, <var class="Arg">geom2</var>, <var class="Arg">B</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a geometry morphism</p>

<p>This operation comes in four flavours. For the first flavour, the argument <var class="Arg">geom1</var> is a projective space over a field GF(q<sup>t</sup>). The argument <var class="Arg">f2</var> is a subfield GF(q) of GF(q<sup>t</sup>). The argument <span class="SimpleMath">B</span> is a basis for GF(q<sup>t</sup>) as a GF(q)-vectorspace. When this argument is not given, a basis for GF(q<sup>t</sup>) over GF(q) is computed using <code class="file">Basis(AsVectorSpace(GF(q),GF(q^t)))</code>. It is checked whether <var class="Arg">f2</var> is a subfield of the basefield of <var class="Arg">geom1</var>. The third and fourth flavour are comparable, where now GF(q) is found as the basefield of <var class="Arg">geom2</var>. In fact the arguments <var class="Arg">geom1</var> and <var class="Arg">geom2</var> are the projective spaces PG(n-1,q<sup>t</sup>) and PG(nt-1,q) respectively. As in the previous flavours, the argument <var class="Arg">B</var> is optional.</p>

<p>An intertwiner is always available for this geometry morphism, and has source the homography group of <var class="Arg">geom1</var> and as range a subgroup of the homography group of <var class="Arg">geom2</var> (or the projective space of the appropriate dimension over <var class="Arg">f2</var>. Notice in the example below the difference of a factor 2 in the orders of the group, which comes of course from restricing the homomorphism to the homography group, which differs a factor 2 from the collineation group of the projective line, that has an extra automorphism of order two, corresponding with the Frobenius automorphism.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg1 := ProjectiveSpace(2,81);</span>
ProjectiveSpace(2, 81)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f2 := GF(9);</span>
GF(3^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">em := NaturalEmbeddingByFieldReduction(pg1,f2);</span>
&lt;geometry morphism from &lt;All elements of ProjectiveSpace(2, 
81)&gt; to &lt;All elements of ProjectiveSpace(5, 9)&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f2 := GF(3);</span>
GF(3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">em := NaturalEmbeddingByFieldReduction(pg1,f2);</span>
&lt;geometry morphism from &lt;All elements of ProjectiveSpace(2, 
81)&gt; to &lt;All elements of ProjectiveSpace(11, 3)&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg2 := ProjectiveSpace(11,3);</span>
ProjectiveSpace(11, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">em := NaturalEmbeddingByFieldReduction(pg1,pg2);</span>
&lt;geometry morphism from &lt;All elements of ProjectiveSpace(2, 
81)&gt; to &lt;All elements of ProjectiveSpace(11, 3)&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg1 := PG(1,9);</span>
ProjectiveSpace(1, 9)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">em := NaturalEmbeddingByFieldReduction(pg1,GF(3));</span>
&lt;geometry morphism from &lt;All elements of ProjectiveSpace(1, 
9)&gt; to &lt;All elements of ProjectiveSpace(3, 3)&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i := Intertwiner(em);</span>
MappingByFunction( The FinInG projectivity group PGL(2,9), &lt;projective colline
ation group of size 720 with 
2 generators&gt;, function( m ) ... end, function( m ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spread := List(Points(pg1),x-&gt;x^em);</span>
[ &lt;a line in ProjectiveSpace(3, 3)&gt;, &lt;a line in ProjectiveSpace(3, 3)&gt;, 
  &lt;a line in ProjectiveSpace(3, 3)&gt;, &lt;a line in ProjectiveSpace(3, 3)&gt;, 
  &lt;a line in ProjectiveSpace(3, 3)&gt;, &lt;a line in ProjectiveSpace(3, 3)&gt;, 
  &lt;a line in ProjectiveSpace(3, 3)&gt;, &lt;a line in ProjectiveSpace(3, 3)&gt;, 
  &lt;a line in ProjectiveSpace(3, 3)&gt;, &lt;a line in ProjectiveSpace(3, 3)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">stab := Stabilizer(CollineationGroup(PG(3,3)),Set(spread),OnSets);</span>
&lt;projective collineation group of size 5760 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom := HomographyGroup(pg1);</span>
The FinInG projectivity group PGL(2,9)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens := GeneratorsOfGroup(hom);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">group := Group(List(gens,x-&gt;x^i));</span>
&lt;projective collineation group with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order(group);</span>
2880
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubgroup(stab,group);</span>
true
 
</pre></div>

<p><a id="X7C00DD48787B1EEE" name="X7C00DD48787B1EEE"></a></p>

<h4>10.5 <span class="Heading">Embeddings of polar spaces</span></h4>

<p><a id="X857976B679B8EC30" name="X857976B679B8EC30"></a></p>

<h5>10.5-1 NaturalEmbeddingBySubspace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalEmbeddingBySubspace</code>( <var class="Arg">geom1</var>, <var class="Arg">geom2</var>, <var class="Arg">v</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a geometry morphism</p>

<p>The arguments <var class="Arg">geom1</var> and <var class="Arg">geom2</var> both polar spaces, and <var class="Arg">v</var> is an element of a projective space. This function returns a geometry morphism representing the natural embedding of <var class="Arg">geom1</var> into the intersection of <var class="Arg">geom2</var> and <var class="Arg">v</var>. Hence the intersection of <var class="Arg">geom2</var> and <var class="Arg">v</var> must induce a polar space of the same type as <var class="Arg">geom1</var> in <var class="Arg">v</var>. This operation performs all necessary checks. An Intertwiner is not implemented for this geometry morphism.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h1 := HermitianPolarSpace(2, 3^2);</span>
H(2, 3^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h2 := HermitianPolarSpace(3, 3^2);</span>
H(3, 3^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg := AmbientSpace( h2 );    </span>
ProjectiveSpace(3, 9)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi := VectorSpaceToElement( pg, [[1,0,0,0],[0,1,0,0],[0,0,1,0]] * Z(9)^0 );</span>
&lt;a plane in ProjectiveSpace(3, 9)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">em := NaturalEmbeddingBySubspace( h1, h2, pi );</span>
&lt;geometry morphism from &lt;Elements of H(2, 3^2)&gt; to &lt;Elements of H(3, 3^2)&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps1 := ParabolicQuadric(4,4);</span>
Q(4, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps2 := ParabolicQuadric(6,4);</span>
Q(6, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg := AmbientSpace( ps2 );    </span>
ProjectiveSpace(6, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi := VectorSpaceToElement( pg, [[1,0,0,0,0,0,0],[0,1,0,0,0,0,0],[0,0,1,0,0,0,0],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[0,0,0,1,0,0,0],[0,0,0,0,1,0,0]] * Z(4)^0 );</span>
&lt;a proj. 4-space in ProjectiveSpace(6, 4)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">em := NaturalEmbeddingBySubspace( ps1, ps2, pi );</span>
&lt;geometry morphism from &lt;Elements of Q(4, 4)&gt; to &lt;Elements of Q(6, 4)&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(Lines(ps1),x-&gt;x^em);</span>
[ &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, &lt;a line in Q(6, 4)&gt;, 
  &lt;a line in Q(6, 4)&gt; ]

</pre></div>

<p><a id="X82510EF078F0806E" name="X82510EF078F0806E"></a></p>

<h5>10.5-2 NaturalEmbeddingBySubField</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalEmbeddingBySubField</code>( <var class="Arg">geom1</var>, <var class="Arg">geom2</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalEmbeddingBySubField</code>( <var class="Arg">geom1</var>, <var class="Arg">geom2</var>, <var class="Arg">boolean</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a geometry morphism</p>

<p>The arguments <var class="Arg">geom1</var> and <var class="Arg">geom2</var> are projective or polar spaces with an underlying vector space of the same dimension and the basefield <span class="SimpleMath">L</span> of <var class="Arg">geom2</var> is an extension of the basefield <span class="SimpleMath">K</span> of <var class="Arg">geom1</var>. The form <span class="SimpleMath">f</span> determining <var class="Arg">geom1</var> also defines a form over <span class="SimpleMath">L</span>, and determines a polar space. By considering the underlying vectorspaces determining the elements of <var class="Arg">geom1</var> over the extension field <span class="SimpleMath">L</span>, there is an obvious embedding of <var class="Arg">geom1</var> in the polar space over the extension field. Considering <span class="SimpleMath">f</span> over a field extension might change its type. The possible embeddings, where the polar spaces may be chosen up to equivalent form, are listed in the table below (see <a href="chapBib.html#biBKleidmanLiebeck">[KL90]</a>):</p>

<div class="pcenter"><table class="GAPDocTable">
<caption class="GAPDocTable"><b>Table: </b>Subfield embeddings of polar spaces</caption>
<tr>
<td class="tdleft">Polar Space 1</td>
<td class="tdleft">Polar Space 2</td>
<td class="tdleft">Conditions</td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">W(2n-1,q)</span></td>
<td class="tdleft">W(2n-1,q<sup>a</sup>)</td>
<td class="tdleft">--</td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">W(2n-1,q)</span></td>
<td class="tdleft">H(2n-1,q<sup>a</sup>)</td>
<td class="tdleft">--</td>
</tr>
<tr>
<td class="tdleft">H(d,q<sup>2</sup>)</td>
<td class="tdleft">H(d,q<sup>2r</sup>)</td>
<td class="tdleft"><span class="SimpleMath">r</span> odd</td>
</tr>
<tr>
<td class="tdleft">O<sup>ε</sup>(d,q)</td>
<td class="tdleft">H(d,q<sup>2</sup>)</td>
<td class="tdleft"><span class="SimpleMath">q</span> odd</td>
</tr>
<tr>
<td class="tdleft">O<sup>ε</sup>(d,q)</td>
<td class="tdleft">O<sup>ε'</sup>(d,q<sup>r</sup>)</td>
<td class="tdleft">ε=(ε')<sup>r</sup></td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p>The geometry morphism also comes equipped with an intertwiner (see <code class="func">Intertwiner</code> (<a href="chap10.html#X86E0B2117DD536D2"><span class="RefLink">10.1-2</span></a>)). The optional third argument <var class="Arg">boolean</var> can take either <code class="code">true</code> or <code class="code">false</code> as input, and then our operation will or will not compute the intertwiner accordingly. When set <code class="code">true</code>, the intertwiner will be computed if <code class="file">HasCollineationGroup(geom1)</code> is true. The user may wish that the intertwiner is not computed when embedding large polar spaces. The default (when calling the operation with two arguments) is set to <code class="code">true</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w := SymplecticSpace(5, 3);</span>
W(5, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h := HermitianPolarSpace(5, 3^2);</span>
H(5, 3^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">em := NaturalEmbeddingBySubfield(w, h);</span>
#I  No intertwiner computed. &lt;geom1&gt; must have a collineation group computed
&lt;geometry morphism from &lt;Elements of W(5, 3)&gt; to &lt;Elements of H(5, 3^2)&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">points := AsList(Points(w));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">image := ImagesSet(em, points);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll(image, x -&gt; x in h);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hq:=HyperbolicQuadric(3,4);</span>
Q+(3, 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">eq:=EllipticQuadric(3,2);</span>
Q-(3, 2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">em:=NaturalEmbeddingBySubfield(eq,hq);</span>
#I  No intertwiner computed. &lt;geom1&gt; must have a collineation group computed
&lt;geometry morphism from &lt;Elements of Q-(3, 2)&gt; to &lt;Elements of Q+(3, 4)&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">eqpts:=ImagesSet(em,AsList(Points(eq)));</span>
[ &lt;a point in Q+(3, 4)&gt;, &lt;a point in Q+(3, 4)&gt;, &lt;a point in Q+(3, 4)&gt;, 
  &lt;a point in Q+(3, 4)&gt;, &lt;a point in Q+(3, 4)&gt; ]
 
</pre></div>

<p><a id="X7823BA95797898CE" name="X7823BA95797898CE"></a></p>

<h5>10.5-3 <span class="Heading">Embedding of polar spaces by field reduction</span></h5>

<p>Field reduction for polar spaces is somewhat more involved than for projective spaces, and we give a brief description. Let <span class="SimpleMath">L</span> be the field GF(q<sup>t</sup>) and let <span class="SimpleMath">K</span> be the field GF(q) Let <span class="SimpleMath">P</span> be a polar space over a field <span class="SimpleMath">L</span>. Let <span class="SimpleMath">f</span> be the form on the <span class="SimpleMath">r</span> dimensional vector space <span class="SimpleMath">V</span> over <span class="SimpleMath">L</span> determining <span class="SimpleMath">P</span>. Consider the trace map</p>

<p><span class="SimpleMath">T: L → K: x ↦</span> x<sup>q<sup>t</sup></sup> + x<sup>q<sup>t-1</sup></sup> + … + x.</p>

<p>Define for any <span class="SimpleMath">α ∈ L</span> the map</p>

<p>T<sub>α</sub>: L: → K: x<span class="SimpleMath">↦</span> T<sub>α</sub> = T(α x).</p>

<p>Consider the <span class="SimpleMath">rt</span> dimensional vector space <span class="SimpleMath">W</span> over <span class="SimpleMath">K</span>. There is a bijective map Φ: <span class="SimpleMath">V → W</span> and T<sub>α</sub> • f • Φ <sup>-1</sup> defines a quadratic or sesquilinear form (depending on <span class="SimpleMath">α</span>, and <span class="SimpleMath">f</span> being quadratic or sesquilinear) acting on <span class="SimpleMath">W</span>, and hence, if not singular or degenerate, inducing a polar space <span class="SimpleMath">S</span> over the finite field <span class="SimpleMath">GF(q)</span>. An element of <span class="SimpleMath">P</span> can be mapped onto an element of <span class="SimpleMath">S</span> by simply blowing up <span class="SimpleMath">P</span> using field reduction for projective spaces. So the resulting polar space <span class="SimpleMath">S</span> is dependent on the original form <span class="SimpleMath">f</span>, the parameter <span class="SimpleMath">α</span> and the blowing up of elements by field reduction, the latter being dependent on the basis of <span class="SimpleMath">L</span> as a <span class="SimpleMath">K</span> vector space. <strong class="pkg">FinInG</strong> provides two approaches. The first approach starts from <span class="SimpleMath">P</span> and the parameters <span class="SimpleMath">K</span>, <span class="SimpleMath">α</span> and a basis for <span class="SimpleMath">L</span> as <span class="SimpleMath">K</span> vector space. Then the resulting form T<sub>α</sub> • f • Φ <sup>-1</sup> is determined, and the associated polar space <span class="SimpleMath">S</span> will be the range of the embedding. Note that the resulting polar space will not necessarily be canonical. The second approach starts from two given polar spaces <span class="SimpleMath">P</span> and <span class="SimpleMath">S</span>. Based on this input, it is determined wheter an embedding based on the above described principle is possible, and the necessary parameters are computed. The resulting embedding is a geometry morhpism from <span class="SimpleMath">P</span> to <span class="SimpleMath">S</span>. Note that the polar spaces used as an argument may be freely chosen and are not required to be in the canonical form.</p>

<p>For more information on the embeddings by field reduction of polar spaces, including conditions on the parameter <span class="SimpleMath">α</span>, we refer to <a href="chapBib.html#biBGill">[Gil08]</a> and <a href="chapBib.html#biBLaVa">[LVdV13]</a>. The possible embeddings are listed in the following table.</p>

<div class="pcenter"><table class="GAPDocTable">
<caption class="GAPDocTable"><b>Table: </b>Field reduction of polar spaces</caption>
<tr>
<td class="tdleft">Polar Space 1</td>
<td class="tdleft">Polar Space 2</td>
<td class="tdleft">Conditions</td>
</tr>
<tr>
<td class="tdleft">W(2n-1,q<sup>t</sup>)</td>
<td class="tdleft"><span class="SimpleMath">W(2nt-1,q)</span></td>
<td class="tdleft">--</td>
</tr>
<tr>
<td class="tdleft">Q<sup>+</sup>(2n-1,q<sup>t</sup>)</td>
<td class="tdleft">Q<sup>+</sup>(2nt-1,q)</td>
<td class="tdleft">--</td>
</tr>
<tr>
<td class="tdleft">Q<sup>-</sup>(2n-1,q<sup>t</sup>)</td>
<td class="tdleft">Q<sup>-</sup>(2nt-1,q)</td>
<td class="tdleft">--</td>
</tr>
<tr>
<td class="tdleft">Q(2n,q<sup>2a+1</sup>)</td>
<td class="tdleft"><span class="SimpleMath">Q((2a+1)(2n+1)-1,q)</span></td>
<td class="tdleft"><span class="SimpleMath">q</span> odd</td>
</tr>
<tr>
<td class="tdleft">Q(2n,q<sup>2a</sup>)</td>
<td class="tdleft">Q<sup>-</sup>(2a(2n+1)-1,q)</td>
<td class="tdleft">q ≡ 1 mod 4</td>
</tr>
<tr>
<td class="tdleft">Q(2n,q<sup>4a+2</sup>)</td>
<td class="tdleft">Q<sup>+</sup>((4a+2)(2n+1)-1,q)</td>
<td class="tdleft">q ≡ 3 mod 4</td>
</tr>
<tr>
<td class="tdleft">Q(2n,q<sup>4a</sup>)</td>
<td class="tdleft">Q<sup>-</sup>(4a(2n+1)-1,q)</td>
<td class="tdleft">q ≡ 3 mod 4</td>
</tr>
<tr>
<td class="tdleft">H(n,q<sup>2a+1</sup>)</td>
<td class="tdleft"><span class="SimpleMath">H((2a+1)(n+1)-1,q)</span></td>
<td class="tdleft"><span class="SimpleMath">q</span> square</td>
</tr>
<tr>
<td class="tdleft">H(n,q<sup>2a</sup>)</td>
<td class="tdleft"><span class="SimpleMath">W(2a(n+1)-1,q)</span></td>
<td class="tdleft"><span class="SimpleMath">q</span> even</td>
</tr>
<tr>
<td class="tdleft">H(2n,q<sup>2a</sup>)</td>
<td class="tdleft">Q<sup>-</sup>(2a(2n+1)-1,q)</td>
<td class="tdleft"><span class="SimpleMath">q</span> odd</td>
</tr>
<tr>
<td class="tdleft">H(2n+1,q<sup>2a</sup>)</td>
<td class="tdleft">Q<sup>+</sup>(2a(2n+2)-1,q)</td>
<td class="tdleft"><span class="SimpleMath">q</span> odd</td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p><a id="X7D2D9AD287532FDB" name="X7D2D9AD287532FDB"></a></p>

<h5>10.5-4 NaturalEmbeddingByFieldReduction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalEmbeddingByFieldReduction</code>( <var class="Arg">ps1</var>, <var class="Arg">f2</var>, <var class="Arg">alpha</var>, <var class="Arg">basis</var>, <var class="Arg">bool</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalEmbeddingByFieldReduction</code>( <var class="Arg">ps1</var>, <var class="Arg">f2</var>, <var class="Arg">alpha</var>, <var class="Arg">basis</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalEmbeddingByFieldReduction</code>( <var class="Arg">ps1</var>, <var class="Arg">f2</var>, <var class="Arg">alpha</var>, <var class="Arg">bool</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalEmbeddingByFieldReduction</code>( <var class="Arg">ps1</var>, <var class="Arg">f2</var>, <var class="Arg">alpha</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalEmbeddingByFieldReduction</code>( <var class="Arg">ps1</var>, <var class="Arg">f2</var>, <var class="Arg">bool</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalEmbeddingByFieldReduction</code>( <var class="Arg">ps1</var>, <var class="Arg">f2</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a geometry morphism</p>

<p><var class="Arg">ps1</var> is a polar space over a field extension <span class="SimpleMath">L</span> of <var class="Arg">f2</var>, <var class="Arg">basis</var> is a basis for <span class="SimpleMath">L</span> over <var class="Arg">f2</var>, <var class="Arg">alpha</var> is a non-zero element of <span class="SimpleMath">L</span>. The version of <code class="file">NaturalEmbeddingByFieldReduction</code> implements the first approach as explained in <a href="chap10.html#X7823BA95797898CE"><span class="RefLink">10.5-3</span></a>. When no argument <var class="Arg">basis</var> is given, a basis for <span class="SimpleMath">L</span> over <var class="Arg">f2</var> is computed using <code class="file">Basis(AsVectorSpace(K,L))</code>. When no argument <var class="Arg">alpha</var> is given, <code class="file">One(f2)</code> is used as value for <var class="Arg">alpha</var>. When <var class="Arg">bool</var> is true or not given, an intertwiner is computed, when <var class="Arg">bool</var> is <var class="Arg">false</var>, no intertwiner is computed. This intertwiner has as its domain the <strong class="button">isometry group</strong> of <var class="Arg">ps1</var>. The user may wish that the intertwiner is not computed when embedding large polar spaces. The default (when calling the operation with two arguments) is set to <code class="code">true</code>. In the first example, we construct a spread of maximal subspaces (solids) in a 7 dimensional symplectic space. We compute a subgroup of its stabilizer group using the intertwiner. In the second example, we construct a linear blocking set of the symplectic generalised quadrangle over GF(9) .</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps1 := SymplecticSpace(1,3^3);</span>
W(1, 27)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">em := NaturalEmbeddingByFieldReduction(ps1,GF(3),true);</span>
&lt;geometry morphism from &lt;Elements of W(1, 
27)&gt; to &lt;Elements of &lt;polar space in ProjectiveSpace(
5,GF(3)): -x1*y6-x2*y5-x3*y4-x3*y6+x4*y3+x5*y2+x6*y1+x6*y3=0 &gt;&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps2 := AmbientGeometry(Range(em));</span>
&lt;polar space in ProjectiveSpace(
5,GF(3)): -x1*y6-x2*y5-x3*y4-x3*y6+x4*y3+x5*y2+x6*y1+x6*y3=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spread := List(Points(ps1),x-&gt;x^em);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i := Intertwiner(em);</span>
MappingByFunction( PSp(2,27), &lt;projective collineation group of size 
9828 with 2 generators&gt;, function( m ) ... end, function( m ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coll := CollineationGroup(ps2);</span>
#I  Computing collineation group of canonical polar space...
&lt;projective collineation group of size 9170703360 with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">stab := Group(ImagesSet(i,GeneratorsOfGroup(IsometryGroup(ps1))));</span>
&lt;projective collineation group with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubgroup(coll,stab);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(Orbit(stab,spread[1]),x-&gt;x in spread);</span>
[ true, true, true, true, true, true, true, true, true, true, true, true, 
  true, true, true, true, true, true, true, true, true, true, true, true, 
  true, true, true, true ]

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps1 := SymplecticSpace(3,9);</span>
W(3, 9)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">em := NaturalEmbeddingByFieldReduction(ps1,GF(3),true);</span>
&lt;geometry morphism from &lt;Elements of W(3, 
9)&gt; to &lt;Elements of &lt;polar space in ProjectiveSpace(
7
 ,GF(3)): -x1*y3+x1*y4+x2*y3+x3*y1-x3*y2-x4*y1-x5*y7+x5*y8+x6*y7+x7*y5-x7*y6-x8
*y5=0 &gt;&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps2 := AmbientGeometry(Range(em));</span>
&lt;polar space in ProjectiveSpace(
7
 ,GF(3)): -x1*y3+x1*y4+x2*y3+x3*y1-x3*y2-x4*y1-x5*y7+x5*y8+x6*y7+x7*y5-x7*y6-x8
*y5=0 &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pg := AmbientSpace(ps2);</span>
ProjectiveSpace(7, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spread := List(Points(ps1),x-&gt;x^em);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">el := Random(ElementsOfIncidenceStructure(pg,5));</span>
&lt;a proj. 4-space in ProjectiveSpace(7, 3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prebs := Filtered(spread,x-&gt;Meet(x,el) &lt;&gt; EmptySubspace(pg));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bs := List(prebs,x-&gt;PreImageElm(em,x));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length(bs);</span>
118
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lines := List(Lines(ps1));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Collected(List(lines,x-&gt;Length(Filtered(bs,y-&gt;y * x))));</span>
[ [ 1, 702 ], [ 4, 117 ], [ 10, 1 ] ]
 
</pre></div>

<p><a id="X7D2D9AD287532FDB" name="X7D2D9AD287532FDB"></a></p>

<h5>10.5-5 NaturalEmbeddingByFieldReduction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalEmbeddingByFieldReduction</code>( <var class="Arg">ps1</var>, <var class="Arg">ps2</var>, <var class="Arg">bool</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalEmbeddingByFieldReduction</code>( <var class="Arg">ps1</var>, <var class="Arg">ps2</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a geometry morphism</p>

<p>If <var class="Arg">ps1</var> and <var class="Arg">ps2</var> are two polar spaces which are suitable for field reduction as listed in the table with possible embeddings in Section <a href="chap10.html#X7823BA95797898CE"><span class="RefLink">10.5-3</span></a>, then this operation returns the corresponding embedding. An intertwiner is computed if the third argument <var class="Arg">bool</var> is true, or if there is no third argument. This intertwiner has as its domain the <strong class="button">isometry group</strong> of <var class="Arg">ps1</var>. The example shows two cases where a spread is computed, including a subgroup of its stabiliser group using the intertwiner.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps1 := SymplecticSpace(1,5^3);</span>
W(1, 125)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps2 := SymplecticSpace(5,5);</span>
W(5, 5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">em := NaturalEmbeddingByFieldReduction(ps1,ps2);</span>
#I  These polar spaces are suitable for field reduction
&lt;geometry morphism from &lt;Elements of W(1, 125)&gt; to &lt;Elements of W(5, 5)&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pts := Points(ps1);</span>
&lt;points of W(1, 125)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spread := List(pts,x-&gt;x^em);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">test := Union(List(spread,x-&gt;List(Points(x))));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Set(test)=Set(AsList(Points(ps2)));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom := Intertwiner(em);</span>
MappingByFunction( PSp(2,125), &lt;projective collineation group of size 
976500 with 2 generators&gt;, function( m ) ... end, function( m ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">group := IsometryGroup(ps1);</span>
PSp(2,125)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order(group);</span>
976500
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens := List(GeneratorsOfGroup(group),x-&gt;x^hom);</span>
[ &lt; a collineation: &lt;cmat 6x6 over GF(5,1)&gt;, F^0&gt;, 
  &lt; a collineation: &lt;cmat 6x6 over GF(5,1)&gt;, F^0&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">group2 := Range(hom);</span>
&lt;projective collineation group of size 976500 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order(group2);</span>
976500
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">biggroup := CollineationGroup(ps2);</span>
PGammaSp(6,5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">stab := FiningSetwiseStabiliser(biggroup,spread);</span>
#I  Computing adjusted stabilizer chain...
&lt;projective collineation group with 7 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">time;</span>
6907
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order(stab);</span>
5859000
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps1 := HermitianPolarSpace(2,7^2);</span>
H(2, 7^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps2 := EllipticQuadric(5,7);</span>
Q-(5, 7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">em := NaturalEmbeddingByFieldReduction(ps1,ps2);</span>
#I  These polar spaces are suitable for field reduction
&lt;geometry morphism from &lt;Elements of H(2, 7^2)&gt; to &lt;Elements of Q-(5, 7)&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pts := Points(ps1);</span>
&lt;points of H(2, 7^2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spread := List(pts,x-&gt;x^em);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">test := Union(List(spread,x-&gt;List(Points(x))));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Set(test)=Set(AsList(Points(ps2)));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom := Intertwiner(em);</span>
MappingByFunction( PGU(3,7^2), &lt;projective collineation group of size 
5663616 with 2 generators&gt;, function( m ) ... end, function( m ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">group := IsometryGroup(ps1);</span>
PGU(3,7^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order(group);</span>
5663616
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens := List(GeneratorsOfGroup(group),x-&gt;x^hom);</span>
[ &lt; a collineation: &lt;cmat 6x6 over GF(7,1)&gt;, F^0&gt;, 
  &lt; a collineation: &lt;cmat 6x6 over GF(7,1)&gt;, F^0&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">group2 := Range(hom);</span>
&lt;projective collineation group of size 5663616 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order(group2);</span>
5663616
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">biggroup := CollineationGroup(ps2);</span>
PDeltaO-(6,7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">stab := FiningSetwiseStabiliser(biggroup,spread);</span>
#I  Computing adjusted stabilizer chain...
&lt;projective collineation group with 10 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">time;</span>
3438
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order(stab);</span>
90617856

</pre></div>

<p><a id="X81FAC1DE7C4B1972" name="X81FAC1DE7C4B1972"></a></p>

<h4>10.6 <span class="Heading">Projections</span></h4>

<p><a id="X7B9E8AB682EC07C2" name="X7B9E8AB682EC07C2"></a></p>

<h5>10.6-1 NaturalProjectionBySubspace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalProjectionBySubspace</code>( <var class="Arg">ps</var>, <var class="Arg">v</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a geometry morphism</p>

<p>The argument <var class="Arg">ps</var> is a projective or polar space, and <var class="Arg">v</var> is a subspace of <var class="Arg">ps</var>. In the case that <var class="Arg">ps</var> is a projective space, the geometry of subspaces containing <var class="Arg">v</var> is a projective space of lower dimension over the same basefield, and this operation returns the corresponding geometry morphism. In the case that <var class="Arg">ps</var> is a polar space, the geometry of elements pf <var class="Arg">ps</var> containing <var class="Arg">v</var> is a polar space of lower rank and of the same type over the same basefield, and this operation returns the corresponding geometry morphism. It is checked whether <var class="Arg">v</var> is a subspace of <var class="Arg">ps</var>, and whether the input of the function and preimage of the returned geometry morphism is valid or not. There is a shorthand for this operation which is basically an overload of the quotient operation. So, for example, <code class="code">ps / v</code> achieves the same thing as <code class="code">AmbientGeometry(Range(NaturalProjectionBySubspace(ps, v)))</code>. An intertwiner is not available for this geometry morphism.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ps := HyperbolicQuadric(5,3);</span>
Q+(5, 3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := Random(Points(ps));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">planes_on_x := AsList( Planes(x) );</span>
[ &lt;a plane in Q+(5, 3)&gt;, &lt;a plane in Q+(5, 3)&gt;, &lt;a plane in Q+(5, 3)&gt;, 
  &lt;a plane in Q+(5, 3)&gt;, &lt;a plane in Q+(5, 3)&gt;, &lt;a plane in Q+(5, 3)&gt;, 
  &lt;a plane in Q+(5, 3)&gt;, &lt;a plane in Q+(5, 3)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">proj := NaturalProjectionBySubspace(ps, x);</span>
&lt;geometry morphism from &lt;Elements of Q+(5, 
3)&gt; to &lt;Elements of &lt;polar space in ProjectiveSpace(
3,GF(3)): x_1*x_2+x_3*x_4=0 &gt;&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">image := ImagesSet(proj, planes_on_x);</span>
[ &lt;a line in Q+(3, 3): x_1*x_2+x_3*x_4=0&gt;, 
  &lt;a line in Q+(3, 3): x_1*x_2+x_3*x_4=0&gt;, 
  &lt;a line in Q+(3, 3): x_1*x_2+x_3*x_4=0&gt;, 
  &lt;a line in Q+(3, 3): x_1*x_2+x_3*x_4=0&gt;, 
  &lt;a line in Q+(3, 3): x_1*x_2+x_3*x_4=0&gt;, 
  &lt;a line in Q+(3, 3): x_1*x_2+x_3*x_4=0&gt;, 
  &lt;a line in Q+(3, 3): x_1*x_2+x_3*x_4=0&gt;, 
  &lt;a line in Q+(3, 3): x_1*x_2+x_3*x_4=0&gt; ]
 
</pre></div>

<p><a id="X7952EE1A80D53825" name="X7952EE1A80D53825"></a></p>

<h4>10.7 <span class="Heading">Projective completion</span></h4>

<p><a id="X7E23CA137AEFD1D2" name="X7E23CA137AEFD1D2"></a></p>

<h5>10.7-1 ProjectiveCompletion</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ProjectiveCompletion</code>( <var class="Arg">as</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: a geometry morphism</p>

<p>The argument <var class="Arg">as</var> is an affine space. This operation returns an embedding of <var class="Arg">as</var> into the projective space <var class="Arg">ps</var> of the same dimension, and over the same field. For example, the point <span class="SimpleMath">(x, y, z)</span> is mapped onto the projective point with homogeneous coordinates <span class="SimpleMath">(1, x, y, z)</span>. An intertwiner is unnecessary, <code class="file">CollineationGroup(as)</code> is a subgroup of <code class="file">CollineationGroup(ps)</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">as := AffineSpace(3,5);</span>
AG(3, 5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">map := ProjectiveCompletion(as);</span>
&lt;geometry morphism from &lt;Elements of AG(3, 
5)&gt; to &lt;All elements of ProjectiveSpace(3, 5)&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := Random( Points(as) );</span>
&lt;a point in AG(3, 5)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p^map;</span>
&lt;a point in ProjectiveSpace(3, 5)&gt;

</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap9.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap11.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chapA.html">A</a>  <a href="chapB.html">B</a>  <a href="chapC.html">C</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
