<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (groupoids) - Chapter 4: Groupoids</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap4"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap3.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap5.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap4_mj.html">[MathJax on]</a></p>
<p><a id="X82F6A1AB798648F4" name="X82F6A1AB798648F4"></a></p>
<div class="ChapSects"><a href="chap4.html#X82F6A1AB798648F4">4 <span class="Heading">Groupoids</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4.html#X7AC321DC7E3C6167">4.1 <span class="Heading">Groupoids: their properties and attributes</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X8406913B7ED86CFE">4.1-1 SinglePieceGroupoid</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X813B084184AAA890">4.1-2 ObjectList</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X8511D3EE845CC930">4.1-3 IsPermGroupoid</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X8681D15C7CA15F87">4.1-4 UnionOfPieces</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X855F318181808814">4.1-5 HomogeneousGroupoid</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X78E8FE0C7F599F5A">4.1-6 DirectProductOp</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4.html#X7F23BE3F85C9BA06">4.2 <span class="Heading">Groupoid elements; stars; costars; homsets</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7D028B3B8385ED07">4.2-1 GroupoidElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X78C3228682279032">4.2-2 IdentityArrow</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X84F59A2687C62763">4.2-3 Order</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7B561BAE7D471C60">4.2-4 ObjectStar</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4.html#X7BDBA72C852C4625">4.3 <span class="Heading">Subgroupoids</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X80780D287EDDB7BB">4.3-1 Subgroupoid</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X873E0914871858E8">4.3-2 SubgroupoidWithRays</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X8600FA7B8051C9AC">4.3-3 SubgroupoidByObjects</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7AEA9BF780CD6957">4.3-4 SubgroupoidByPieces</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7FE8F09A7C8CEC5B">4.3-5 FullTrivialSubgroupoid</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7ACFBE7D855A82A3">4.3-6 DiscreteSubgroupoid</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7A9F29BD7D64DCC1">4.3-7 SinglePieceSubgroupoidByGenerators</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4.html#X831AA9E8780235F2">4.4 <span class="Heading">Left, right and double cosets</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X8412ABD57986B9FC">4.4-1 RightCoset</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4.html#X8653FC9786E3209A">4.5 <span class="Heading">Conjugation</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7D21FB1A7D21FB1A"><code>4.5-1 \^</code></a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X78218F357BFEDE82">4.5-2 ConjugateGroupoid</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4.html#X86DD749283068705">4.6 <span class="Heading">Groupoids formed using isomorphisms</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7B066DE28574A768">4.6-1 GroupoidByIsomorphisms</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4.html#X795DEB3D825B2120">4.7 <span class="Heading">Groupoids whose objects form a monoid</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X805FA9F687C7F2A7">4.7-1 SinglePieceGroupoidWithRays</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7E399664868937C8">4.7-2 RightActionGroupoid</a></span>
</div></div>
</div>

<h3>4 <span class="Heading">Groupoids</span></h3>

<p>A <em>groupoid</em> is a (mathematical) category in which every element is invertible. It consists of a set of <em>pieces</em>, each of which is a connected groupoid. The usual terminology is `connected component', but in <strong class="pkg">GAP</strong> `component' is used for `record component', so we use the term <em>single piece</em>.</p>

<p>The simplest form for a <em>single piece groupoid</em> is the direct product of a group and a complete digraph, and so is determined by a set of <em>objects</em> <code class="code">obs</code> <span class="SimpleMath">= Ω</span> (the least of which is the <em>root object</em>), and a <em>root group</em> <code class="code">grp</code> <span class="SimpleMath">= G</span>. Then the elements of the groupoid are <em>arrows</em> <span class="SimpleMath">g : o_1 -&gt; o_2</span>, stored as triples <code class="code">[g,o1,o2]</code>, where <span class="SimpleMath">g ∈ G</span> and <span class="SimpleMath">o_1,o_2 ∈ Ω</span>. The objects will generally be chosen to be consecutive negative integers, but any suitable ordered set is acceptable, and `consecutive' is not a requirement. The root group will usually be taken to be a permutation group, but pc-groups, fp-groups and matrix groups are also supported.</p>

<p>A <em>group</em> may be considered as a single piece groupoid with one object.</p>

<p>A <em>groupoid</em> is a set of one or more single piece groupoids, its <em>pieces</em>, and is represented as <code class="code">IsGroupoidRep</code>, with attribute <code class="code">PiecesOfGroupoid</code>.</p>

<p>The underlying digraph of a single piece groupoid is a regular, complete digraph on the object set <span class="SimpleMath">Ω</span> with <span class="SimpleMath">|G|</span> arrows from any one object to any other object. It will be convenient to specify a set of <em>rays</em> consisting of <span class="SimpleMath">|Ω|</span> arrows <span class="SimpleMath">r_i : o_1 -&gt; o_i</span>, where <span class="SimpleMath">o_1</span> is the root object and <span class="SimpleMath">r_1</span> is the identity in <span class="SimpleMath">G</span>. In the simplest examples all the <span class="SimpleMath">r_i</span> will be identity elements, but rays are useful when forming subgroupoids (see <code class="func">SubgroupoidWithRays</code> (<a href="chap4.html#X873E0914871858E8"><span class="RefLink">4.3-2</span></a>)).</p>

<p>A groupoid is <em>homogeneous</em> if it has two of more isomorphic pieces, with identical groups. The special case of <em>homogeneous, discrete</em> groupoids, where each piece has a single object, is given its own representation. These are used in the <strong class="pkg">XMod</strong> package as the source of a crossed modules of groupoids.</p>

<p>For the definitions of the standard properties of groupoids we refer to R. Brown's book ``Topology'' <a href="chapBib.html#biBBrTop">[Bro88]</a>, recently revised and reissued as ``Topology and Groupoids'' <a href="chapBib.html#biBBrTopGpd">[Bro06]</a>.</p>

<p><a id="X7AC321DC7E3C6167" name="X7AC321DC7E3C6167"></a></p>

<h4>4.1 <span class="Heading">Groupoids: their properties and attributes</span></h4>

<p><a id="X8406913B7ED86CFE" name="X8406913B7ED86CFE"></a></p>

<h5>4.1-1 SinglePieceGroupoid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SinglePieceGroupoid</code>( <var class="Arg">grp</var>, <var class="Arg">obs</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Groupoid</code>( <var class="Arg">args</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DomainWithSingleObject</code>( <var class="Arg">gp</var>, <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The simplest construction of a groupoid is as the direct product of a group and a complete digraph. Such a groupoid will be called a <em>standard groupoid</em>. Many subgroupoids of such a groupoid do not have this simple form, and will be considered in section <a href="chap4.html#X7BDBA72C852C4625"><span class="RefLink">4.3</span></a>. The global function <code class="code">Groupoid</code> will normally find the appropriate constructor to call, the options being:</p>


<ul>
<li><p>the object group, a set of objects;</p>

</li>
<li><p>a group being converted to a groupoid, a single object;</p>

</li>
<li><p>a list of groupoids which have already been constructed (see <a href="chap4.html#X8681D15C7CA15F87"><span class="RefLink">4.1-4</span></a>).</p>

</li>
</ul>
<p>Methods for <code class="code">ViewObj</code>, <code class="code">PrintObj</code> and <code class="code">Display</code> are provided for groupoids and the other types of object in this package. Users are advised to supply names for all the groups and groupoids they construct.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s4 := Group( (1,2,3,4), (3,4) );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d8 := Subgroup( s4, [ (1,2,3,4), (1,3) ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( s4, "s4" );  SetName( d8, "d8" ); </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gs4 := SinglePieceGroupoid( s4, [-15 .. -11] ); </span>
single piece groupoid: &lt; s4, [ -15 .. -11 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gd8 := Groupoid( d8, [-9,-8,-7] );</span>
single piece groupoid: &lt; d8, [ -9, -8, -7 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c6 := Group( (5,6,7)(8,9) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( c6, "c6" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gc6 := DomainWithSingleObject( c6, -6 );</span>
single piece groupoid: &lt; c6, [ -6 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( Gs4, "Gs4" );  SetName( Gd8, "Gd8" );  SetName( Gc6, "Gc6" );  </span>

</pre></div>

<p><a id="X813B084184AAA890" name="X813B084184AAA890"></a></p>

<h5>4.1-2 ObjectList</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ObjectList</code>( <var class="Arg">gpd</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RootObject</code>( <var class="Arg">gpd</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RootGroup</code>( <var class="Arg">gpd</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ObjectGroup</code>( <var class="Arg">gpd</var>, <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The <code class="code">ObjectList</code> of a groupoid is the sorted list of its objects. The <code class="code">RootObject</code> in a single-piece groupoid is the object with the least label. A <em>loop</em> is an arrow of the form <span class="SimpleMath">g : o -&gt; o</span>, and the loops at a particular object <span class="SimpleMath">o</span> form a group, the <code class="code">ObjectGroup</code> at <span class="SimpleMath">o</span>. The <code class="code">RootGroup</code> is the <code class="code">ObjectGroup</code> at the <code class="code">RootObject</code>.</p>

<p>In the example, the groupoids <code class="code">Gf2c6</code> and <code class="code">Gabc</code> illustrate that the objects need not be integers.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ObjectList( Gs4 );    </span>
[ -15 .. -11 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ RootObject( Gd8 ), RootGroup( Gc6 ), ObjectGroup( Gs4, -11 ) ];</span>
[ -9, c6, s4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f2 := FreeGroup(2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gf2c6 := Groupoid( c6, GeneratorsOfGroup(f2) );</span>
single piece groupoid: &lt; c6, [ f1, f2 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Arrow( Gf2c6, (5,7,6), f2.1, f2.2 );</span>
[(5,7,6) : f1 -&gt; f2]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gabc := Groupoid( d8, [ "a", "b", "c" ] );</span>
single piece groupoid: &lt; d8, [ "a", "b", "c" ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Arrow( Gabc, (2,4), "c", "b" );</span>
[(2,4) : c -&gt; b]

</pre></div>

<p><a id="X8511D3EE845CC930" name="X8511D3EE845CC930"></a></p>

<h5>4.1-3 IsPermGroupoid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPermGroupoid</code>( <var class="Arg">gpd</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPcGroupoid</code>( <var class="Arg">gpd</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFpGroupoid</code>( <var class="Arg">gpd</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsMatrixGroupoid</code>( <var class="Arg">gpd</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFreeGroupoid</code>( <var class="Arg">gpd</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>A groupoid is a permutation groupoid if all its pieces have permutation groups. Most of the examples in this chapter are permutation groupoids, but in principle any type of group known to <strong class="pkg">GAP</strong> may be used.</p>

<p>In the following example <code class="code">Gf2</code> is an fp-groupoid and also a free groupoid, <code class="code">Gq8</code> is a pc-groupoid, and <code class="code">Ggl43</code> is a matrix groupoid. See section <a href="chap5.html#X8003AF117B956D16"><span class="RefLink">5.7</span></a> for matrix representations of groupoids.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f2 := FreeGroup( 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gf2 := Groupoid( f2, -22 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( f2, "f2" );  SetName( Gf2, "Gf2" ); </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q8 := QuaternionGroup( 8 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gq8 := Groupoid( q8, [ -28, -27 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( q8, "q8" );  SetName( Gq8, "Gq8" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gl43 := SpecialLinearGroup( 4, 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ggl43 := SinglePieceGroupoid( gl43, [ -35..-31 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( gl43, "gl43" );  SetName( Ggl43, "Ggl43" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ IsMatrixGroupoid( Ggl43 ), IsFpGroupoid( Gf2 ), IsFreeGroupoid( Gf2 ), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     IsPcGroupoid( Gq8 ), IsPermGroupoid( Gs4 ) ]; </span>
[ true, true, true, true, true ]

</pre></div>

<p><a id="X8681D15C7CA15F87" name="X8681D15C7CA15F87"></a></p>

<h5>4.1-4 UnionOfPieces</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnionOfPieces</code>( <var class="Arg">pieces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Pieces</code>( <var class="Arg">gpd</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Size</code>( <var class="Arg">gpd</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ReplaceOnePieceInUnion</code>( <var class="Arg">U</var>, <var class="Arg">old_piece</var>, <var class="Arg">new_piece</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>When a groupoid consists of two or more pieces, we require their object lists to be disjoint. The operation <code class="code">UnionOfPieces</code> and the attribute <code class="code">Pieces</code>, introduced in section <a href="chap2.html#X7C7007207FD91BB0"><span class="RefLink">2.5</span></a>, are also used for groupoids. The pieces are sorted by the least object in their object lists. The <code class="code">ObjectList</code> is the sorted concatenation of the objects in the pieces.</p>

<p>The <code class="code">Size</code> of a groupoid is the number of its arrows. For a single piece groupoid, this is the product of the size of the group with the square of the number of objects. For a non-connected groupoid, the size is the sum of the sizes of its pieces.</p>

<p>One of the pieces in a groupoid may be replaced by an alternative piece using the operation <code class="code">ReplaceOnePieceInUnion</code>. The <em>old_piece</em> may be either the <em>position</em> of the piece to be replaced, or one of the pieces in <code class="code">U</code>. The objects in the new piece may or may not overlap the objects in the piece being removed -- we just require that the object lists in the new union are disjoint.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U3 := UnionOfPieces( [ Gc6, Gd8, Gs4 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( U3 );</span>
groupoid with 3 pieces:
&lt; objects: [ -15 .. -11 ]
    group: s4 = &lt;[ (1,2,3,4), (3,4) ]&gt; &gt;
&lt; objects: [ -9, -8, -7 ]
    group: d8 = &lt;[ (1,2,3,4), (1,3) ]&gt; &gt;
&lt; objects: [ -6 ]
    group: c6 = &lt;[ (5,6,7)(8,9) ]&gt; &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Pieces( U3 );</span>
[ Gs4, Gd8, Gc6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ObjectList( U3 );</span>
[ -15, -14, -13, -12, -11, -9, -8, -7, -6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U2 := Groupoid( [ Gf2, Gq8 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ Size(Gs4), Size(Gd8), Size(Gc6), Size(U3) ];</span>
[ 600, 72, 6, 678 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ Size(Gf2), Size(Gq8), Size(U2) ];           </span>
[ infinity, 32, infinity ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U5 := UnionOfPieces( [ U3, U2 ] );</span>
groupoid with 5 pieces:
[ Gq8, Gf2, Gs4, Gd8, Gc6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( U5 );</span>
groupoid with 5 pieces:
&lt; objects: [ -28, -27 ]
    group: q8 = &lt;[ x, y, y2 ]&gt; &gt;
&lt; objects: [ -22 ]
    group: f2 = &lt;[ f1, f2 ]&gt; &gt;
&lt; objects: [ -15 .. -11 ]
    group: s4 = &lt;[ (1,2,3,4), (3,4) ]&gt; &gt;
&lt; objects: [ -9, -8, -7 ]
    group: d8 = &lt;[ (1,2,3,4), (1,3) ]&gt; &gt;
&lt; objects: [ -6 ]
    group: c6 = &lt;[ (5,6,7)(8,9) ]&gt; &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V5 := ReplaceOnePieceInUnion( U5, 3, Ggl43 ); </span>
groupoid with 5 pieces:
[ Ggl43, Gq8, Gf2, Gd8, Gc6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ObjectList( V5 );             </span>
[ -35, -34, -33, -32, -31, -28, -27, -22, -9, -8, -7, -6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U5 = V5;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W5 := ReplaceOnePieceInUnion( V5, Gc6, Gs4 ); </span>
groupoid with 5 pieces:
[ Ggl43, Gq8, Gf2, Gs4, Gd8 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ObjectList( W5 );</span>
[ -35, -34, -33, -32, -31, -28, -27, -22, -15, -14, -13, -12, -11, -9, -8, -7 
 ]

</pre></div>

<p><a id="X855F318181808814" name="X855F318181808814"></a></p>

<h5>4.1-5 HomogeneousGroupoid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HomogeneousGroupoid</code>( <var class="Arg">gpd</var>, <var class="Arg">oblist</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HomogeneousDiscreteGroupoid</code>( <var class="Arg">gp</var>, <var class="Arg">obs</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PieceIsomorphisms</code>( <var class="Arg">hgpd</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Special functions are provided for the case where a groupoid has more than one connected component, and when these components are identical except for their object sets. Such groupoids are said to be <em>homogeneous</em>.</p>

<p>The operation <code class="code">HomogeneousGroupoid</code> is used when the components each contain more than one object. The arguments consist of a single piece groupoid <code class="code">gpd</code> and a list of lists of objects <code class="code">oblist</code>, each of whose lists has the same length as the object list <code class="code">obs</code> of <code class="code">gpd</code>. Note that <code class="code">gpd</code> is <em>not</em> included as one of the pieces in the output unless <code class="code">obs</code> is included as one of the lists in <code class="code">oblist</code>.</p>

<p>The operation <code class="code">HomogeneousDiscreteGroupoid</code> is used when the components each have a single object. In this case the first argument is just a group -- the root group for each component. These groupoids are used in the <strong class="pkg">XMod</strong> package as the source of many crossed modules of groupoids.</p>

<p>Both types of groupoid have the property <code class="code">IsHomogeneousDomainWithObjects</code>. In the latter case a separate representation <code class="code">IsHomogeneousDiscreteGroupoidRep</code> is used.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Hd8 := HomogeneousGroupoid( Gd8, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              [ [-20,-19,-18], [-12,-11,-10], [-16,-15,-14] ] );</span>
homogeneous groupoid with 3 pieces:
1:  single piece groupoid: &lt; d8, [ -20, -19, -18 ] &gt;
2:  single piece groupoid: &lt; d8, [ -16, -15, -14 ] &gt;
3:  single piece groupoid: &lt; d8, [ -12, -11, -10 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(Hd8);   ## 8x3x3 + 8x3x3</span>
216
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsHomogeneousDomainWithObjects( Hd8 );               </span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PieceIsomorphisms( Hd8 );</span>
[ groupoid homomorphism : 
    [ [ [(1,2,3,4) : -20 -&gt; -20], [(1,3) : -20 -&gt; -20], [() : -20 -&gt; -19], 
          [() : -20 -&gt; -18] ], 
      [ [(1,2,3,4) : -12 -&gt; -12], [(1,3) : -12 -&gt; -12], [() : -12 -&gt; -11], 
          [() : -12 -&gt; -10] ] ], groupoid homomorphism : 
    [ [ [(1,2,3,4) : -20 -&gt; -20], [(1,3) : -20 -&gt; -20], [() : -20 -&gt; -19], 
          [() : -20 -&gt; -18] ], 
      [ [(1,2,3,4) : -16 -&gt; -16], [(1,3) : -16 -&gt; -16], [() : -16 -&gt; -15], 
          [() : -16 -&gt; -14] ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Hc6 := HomogeneousDiscreteGroupoid( c6, [-7..-4] ); </span>
homogeneous, discrete groupoid: &lt; c6, [ -7 .. -4 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(Hc6);   ## 6x4</span>
24
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RepresentationsOfObject(Gd8);</span>
[ "IsComponentObjectRep", "IsAttributeStoringRep", "IsMWOSinglePieceRep" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RepresentationsOfObject(Hd8);</span>
[ "IsComponentObjectRep", "IsAttributeStoringRep", "IsPiecesRep" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RepresentationsOfObject(Hc6);</span>
[ "IsComponentObjectRep", "IsAttributeStoringRep", 
  "IsHomogeneousDiscreteGroupoidRep" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ktpo := KnownTruePropertiesOfObject(Hc6);; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ans := </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "CanEasilyCompareElements", "CanEasilySortElements", </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  "IsDuplicateFree", "IsAssociative", "IsCommutative", </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  "IsDiscreteDomainWithObjects", "IsHomogeneousDomainWithObjects" ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll( ans, a -&gt; ( a in ktpo ) ); </span>
true

</pre></div>

<p><a id="X78E8FE0C7F599F5A" name="X78E8FE0C7F599F5A"></a></p>

<h5>4.1-6 DirectProductOp</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DirectProductOp</code>( <var class="Arg">list</var>, <var class="Arg">gpd</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Projection</code>( <var class="Arg">gpd</var>, <var class="Arg">pos</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Embedding</code>( <var class="Arg">gpd</var>, <var class="Arg">pos</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The direct product of groupoids <span class="SimpleMath">G,H</span> has as group the direct product of the groups in <span class="SimpleMath">G</span> and <span class="SimpleMath">H</span> and as object list the cartesian product of their object lists.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prod := DirectProductOp( [Gd8,Gc6], Gd8 );</span>
single piece groupoid: &lt; Group( [ (1,2,3,4), (1,3), (5,6,7)(8,9) ] ), 
[ [ -9, -6 ], [ -8, -6 ], [ -7, -6 ] ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Projection( prod, 1 );                    </span>
groupoid homomorphism : 
[ [ [(1,2,3,4) : [ -9, -6 ] -&gt; [ -9, -6 ]], [(1,3) : [ -9, -6 ] -&gt; [ -9, -6 ]]
        , [(5,6,7)(8,9) : [ -9, -6 ] -&gt; [ -9, -6 ]], 
      [() : [ -9, -6 ] -&gt; [ -8, -6 ]], [() : [ -9, -6 ] -&gt; [ -7, -6 ]] ], 
  [ [(1,2,3,4) : -9 -&gt; -9], [(1,3) : -9 -&gt; -9], [() : -9 -&gt; -9], 
      [() : -9 -&gt; -8], [() : -9 -&gt; -7] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Embedding( prod, 2 );                        </span>
groupoid homomorphism : 
[ [ [(5,6,7)(8,9) : -6 -&gt; -6] ], 
  [ [(5,6,7)(8,9) : [ -9, -6 ] -&gt; [ -9, -6 ]] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DirectProductInfo( prod );</span>
rec( embeddings := [ , groupoid homomorphism : 
        [ [ [(5,6,7)(8,9) : -6 -&gt; -6] ], 
          [ [(5,6,7)(8,9) : [ -9, -6 ] -&gt; [ -9, -6 ]] ] ] ], first := Gd8, 
  groupoids := [ Gd8, Gc6 ], groups := [ d8, c6 ], 
  objectlists := [ [ -9, -8, -7 ], [ -6 ] ], 
  projections := [ groupoid homomorphism : 
        [ [ [(1,2,3,4) : [ -9, -6 ] -&gt; [ -9, -6 ]], 
              [(1,3) : [ -9, -6 ] -&gt; [ -9, -6 ]], 
              [(5,6,7)(8,9) : [ -9, -6 ] -&gt; [ -9, -6 ]], 
              [() : [ -9, -6 ] -&gt; [ -8, -6 ]], 
              [() : [ -9, -6 ] -&gt; [ -7, -6 ]] ], 
          [ [(1,2,3,4) : -9 -&gt; -9], [(1,3) : -9 -&gt; -9], [() : -9 -&gt; -9], 
              [() : -9 -&gt; -8], [() : -9 -&gt; -7] ] ] ] )

</pre></div>

<p><a id="X7F23BE3F85C9BA06" name="X7F23BE3F85C9BA06"></a></p>

<h4>4.2 <span class="Heading">Groupoid elements; stars; costars; homsets</span></h4>

<p><a id="X7D028B3B8385ED07" name="X7D028B3B8385ED07"></a></p>

<h5>4.2-1 GroupoidElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GroupoidElement</code>( <var class="Arg">gpd</var>, <var class="Arg">elt</var>, <var class="Arg">tail</var>, <var class="Arg">head</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementOfArrow</code>( <var class="Arg">elt</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TailOfArrow</code>( <var class="Arg">elt</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeadOfArrow</code>( <var class="Arg">elt</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The operation <code class="code">GroupoidElement</code> is a synonym for the operation <code class="code">Arrow</code>, as described in subsection <a href="chap2.html#X86247DFC8242CEBE"><span class="RefLink">2.1-3</span></a>. To recapitulate, an arrow <code class="code">e</code> consists of a group element, <code class="code">ElementOfArrow(e)</code>; the tail (source) object, <code class="code">TailOfArrow(e)</code>; and the head (target) object, <code class="code">HeadOfArrow(e)</code>. Arrows have a <em>partial composition</em>: two arrows may be multiplied when the head of the first coincides with the tail of the second. If an attempt is made to multiply arrows where this condition does not hold, then the value <code class="code">fail</code> is returned.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e1 := GroupoidElement( Gd8, (1,2,3,4), -9, -8 );</span>
[(1,2,3,4) : -9 -&gt; -8]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e2 := Arrow( Gd8, (1,3), -8, -7 );</span>
[(1,3) : -8 -&gt; -7]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Print( [ ElementOfArrow(e1), TailOfArrow(e1), HeadOfArrow(e1) ], "\n" );</span>
[ (1,2,3,4), -9, -8 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e1e2 := e1*e2;</span>
[(1,2)(3,4) : -9 -&gt; -7]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e2*e1;</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e3 := Arrow( Gd8, (2,4), -7, -9 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">loop := e1e2*e3;</span>
[(1,4,3,2) : -9 -&gt; -9]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">loop^2;</span>
[(1,3)(2,4) : -9 -&gt; -9]

</pre></div>

<p><a id="X78C3228682279032" name="X78C3228682279032"></a></p>

<h5>4.2-2 IdentityArrow</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IdentityArrow</code>( <var class="Arg">gpd</var>, <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The identity arrow <span class="SimpleMath">1_o</span> of <span class="SimpleMath">G</span> at object <span class="SimpleMath">o</span> is <span class="SimpleMath">(e:o -&gt; o)</span> where <span class="SimpleMath">e</span> is the identity element in the object group. The <em>inverse arrow</em> <span class="SimpleMath">e^-1</span> of <span class="SimpleMath">e = (c : p -&gt; q)</span> is <span class="SimpleMath">(c^-1 : q -&gt; p)</span>, so that <span class="SimpleMath">e*e^-1=1_p</span> and <span class="SimpleMath">e^-1*e = 1_q</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i8 := IdentityArrow( Gd8, -8 );</span>
[() : -8 -&gt; -8]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ e1*i8, i8*e1, e1^-1]; </span>
[ [(1,2,3,4) : -9 -&gt; -8], fail, [(1,4,3,2) : -8 -&gt; -9] ]

</pre></div>

<p><a id="X84F59A2687C62763" name="X84F59A2687C62763"></a></p>

<h5>4.2-3 Order</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Order</code>( <var class="Arg">arr</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>A groupoid element is a <em>loop</em> when the tail and head coincide. In this case the order of the element is defined to be the order of its group element.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i8; Order(i8);</span>
[() : -8 -&gt; -8]
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">loop; Order(loop);</span>
[(1,4,3,2) : -9 -&gt; -9]
4

</pre></div>

<p><a id="X7B561BAE7D471C60" name="X7B561BAE7D471C60"></a></p>

<h5>4.2-4 ObjectStar</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ObjectStar</code>( <var class="Arg">gpd</var>, <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ObjectCostar</code>( <var class="Arg">gpd</var>, <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Homset</code>( <var class="Arg">gpd</var>, <var class="Arg">tail</var>, <var class="Arg">head</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The <em>star</em> at <code class="code">obj</code> is the set of arrows which have <code class="code">obj</code> as tail, while the <em>costar</em> is the set of arrows which have <code class="code">obj</code> as head. The <em>homset</em> from <code class="code">obj1</code> to <code class="code">obj2</code> is the set of arrows with the specified tail and head, and so is bijective with the elements of the object groups. Thus every star and every costar is a union of homsets. The identity arrow at an object is a left identity for the star and a right identity for the costar at that object.</p>

<p>In order not to create unneccessarily long lists, these operations return objects of type <code class="code">IsHomsetCosetsRep</code> for which an <code class="code">Iterator</code> is provided. (An <code class="code">Enumerator</code> is not yet implemented.)</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">star9 := ObjectStar( Gd8, -9 );</span>
&lt;star at -9 with group d8&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( star9 ); </span>
24
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintSelection( star9, 19, 1 );</span>
19 : [(1,2,3,4) : -9 -&gt; -9]
20 : [(1,2,3,4) : -9 -&gt; -8]
21 : [(1,2,3,4) : -9 -&gt; -7]
22 : [(1,2)(3,4) : -9 -&gt; -9]
23 : [(1,2)(3,4) : -9 -&gt; -8]
24 : [(1,2)(3,4) : -9 -&gt; -7]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">costar6 := ObjectCostar( Gc6, -6 );</span>
&lt;costar at -6 with group c6&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hsetq8 := Homset( Gq8, -28, -27 );</span>
&lt;homset -28 -&gt; -27 with group q8&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Perform( hsetq8, Display );</span>
[&lt;identity&gt; of ... : -28 -&gt; -27]
[y2 : -28 -&gt; -27]
[y : -28 -&gt; -27]
[y*y2 : -28 -&gt; -27]
[x : -28 -&gt; -27]
[x*y2 : -28 -&gt; -27]
[x*y : -28 -&gt; -27]
[x*y*y2 : -28 -&gt; -27]

</pre></div>

<p><a id="X7BDBA72C852C4625" name="X7BDBA72C852C4625"></a></p>

<h4>4.3 <span class="Heading">Subgroupoids</span></h4>

<p><a id="X80780D287EDDB7BB" name="X80780D287EDDB7BB"></a></p>

<h5>4.3-1 Subgroupoid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Subgroupoid</code>( <var class="Arg">args</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSubgroupoid</code>( <var class="Arg">gpd</var>, <var class="Arg">sgpd</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsWideSubgroupoid</code>( <var class="Arg">gpd</var>, <var class="Arg">sgpd</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>A <em>subgroupoid</em> <span class="SimpleMath">S</span> of a groupoid <span class="SimpleMath">G</span> has as objects some subset of the objects of <span class="SimpleMath">G</span>. It is <em>wide</em> in <span class="SimpleMath">G</span> if both groupoids have the same object set. It is <em>full</em> if, for any two objects in <span class="SimpleMath">S</span>, the <code class="code">Homset</code> is the same as that in <span class="SimpleMath">G</span>. The arrows of <span class="SimpleMath">S</span> are a subset of those of <span class="SimpleMath">G</span>, closed under multiplication and with tail and head in the chosen object set.</p>

<p>There are a variety of constructors for a subgroupoid of a standard groupoid, as described in for following sections. The global function <code class="code">Subgroupoid</code> should call the operation appropriate to the parameters provided.</p>

<p><a id="X873E0914871858E8" name="X873E0914871858E8"></a></p>

<h5>4.3-2 SubgroupoidWithRays</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SubgroupoidWithRays</code>( <var class="Arg">gpd</var>, <var class="Arg">sgp</var>, <var class="Arg">rays</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RaysOfGroupoid</code>( <var class="Arg">gpd</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RayArrowsOfGroupoid</code>( <var class="Arg">gpd</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>If groupoid <span class="SimpleMath">G</span> is of type <code class="code">IsDirectProductWithCompleteDigraph</code> with group <span class="SimpleMath">g</span> and <span class="SimpleMath">n</span> objects, then a typical wide subgroupoid <span class="SimpleMath">H</span> of <span class="SimpleMath">G</span> is formed by choosing a subgroup <span class="SimpleMath">h</span> of <span class="SimpleMath">g</span> to be the object group at the root object <span class="SimpleMath">q</span>, and an arrow <span class="SimpleMath">r : q -&gt; p</span> for each of the objects <span class="SimpleMath">p</span>. The chosen loop arrow at <span class="SimpleMath">q</span> must be the identity arrow. These <span class="SimpleMath">n</span> arrows are called the <em>ray arrows</em> of the subgroupoid. The arrows in the homset from <span class="SimpleMath">p</span> to <span class="SimpleMath">p'</span> have the form <span class="SimpleMath">r^-1xr'</span> where <span class="SimpleMath">r,r'</span> are the rays from <span class="SimpleMath">q</span> to <span class="SimpleMath">p,p'</span> respectively, and <span class="SimpleMath">x ∈ h</span>.</p>

<p>The operation <code class="code">RayArrowsOfGroupoid</code> returns a list of arrows, one for each object, while the operation <code class="code">RaysOfGroupoid</code> returns the list of group elements in these arrows.</p>

<p>Note that it is also possible to construct a subgroupoid with rays of a subgroupoid with rays.</p>

<p>In the following example we construct a subgroupoid <code class="code">Ua4</code> of the groupoid <code class="code">Gs4</code>, and then a second subgroupoid <code class="code">Uc3</code>. The initial standard groupoid <code class="code">Gs4</code> is set as the parent for both <code class="code">Ua4</code> and <code class="code">Uc3</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a4 := Subgroup( s4, [ (1,2,3), (2,3,4) ] );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( a4, "a4" ); </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ua4 := SubgroupoidWithRays( Gs4, a4, [(),(1,2),(2,3),(3,4),(1,4)] );      </span>
single piece groupoid with rays: &lt; a4, [ -15 .. -11 ], 
[ (), (1,2), (2,3), (3,4), (1,4) ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubgroupoid( Gs4, Ua4 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWideSubgroupoid( Gs4, Ua4 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RaysOfGroupoid( Ua4 );       </span>
[ (), (1,2), (2,3), (3,4), (1,4) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RayArrowsOfGroupoid( Ua4 );  </span>
[ [() : -15 -&gt; -15], [(1,2) : -15 -&gt; -14], [(2,3) : -15 -&gt; -13], 
  [(3,4) : -15 -&gt; -12], [(1,4) : -15 -&gt; -11] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c3 := Subgroup( a4, [ (1,2,3) ] );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( c3, "c3" ); </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Uc3 := SubgroupoidWithRays( Ua4, c3, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              [ (), (1,2,3,4), (1,3), (2,4), (1,4,3,2) ] );</span>
single piece groupoid with rays: &lt; c3, [ -15 .. -11 ], 
[ (), (1,2,3,4), (1,3), (2,4), (1,4,3,2) ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ObjectGroup( Uc3, -14 );</span>
Group([ (2,3,4) ])


</pre></div>

<p><a id="X8600FA7B8051C9AC" name="X8600FA7B8051C9AC"></a></p>

<h5>4.3-3 SubgroupoidByObjects</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SubgroupoidByObjects</code>( <var class="Arg">gpd</var>, <var class="Arg">obs</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SubgroupoidBySubgroup</code>( <var class="Arg">gpd</var>, <var class="Arg">sgp</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The <code class="code">SubgroupoidByObjects</code> of a groupoid <code class="code">gpd</code> on a subset <code class="code">obs</code> of its objects contains all the arrows of <code class="code">gpd</code> with tail and head in <code class="code">obs</code>.</p>

<p>The <code class="code">SubgroupoidBySubgroup</code> of a connected groupoid <code class="code">gpd</code> determinded by a subgroup <code class="code">sgp</code> of the root group is the wide subgroupoid with root group <code class="code">sgp</code> and containing the rays of <code class="code">gpd</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Va4 := SubgroupoidByObjects( Ua4, [-14,-13,-12] );  </span>
single piece groupoid with rays: &lt; Group( [ (1,3,2), (1,3,4) ] ), 
[ -14, -13, -12 ], [ (), (1,3,2), (1,2)(3,4) ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Vc3 := SubgroupoidBySubgroup( Va4, c3 );</span>
single piece groupoid with rays: &lt; c3, [ -14, -13, -12 ], 
[ (), (1,3,2), (1,2)(3,4) ] &gt;

</pre></div>

<p><a id="X7AEA9BF780CD6957" name="X7AEA9BF780CD6957"></a></p>

<h5>4.3-4 SubgroupoidByPieces</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SubgroupoidByPieces</code>( <var class="Arg">gpd</var>, <var class="Arg">pieces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The most general way to construct a subgroupoid is to use the operation <code class="code">SubgroupoidByPieces</code>. Its two parameters are a groupoid and a list of <em>pieces</em>, each piece being specified either as a list <code class="code">[sgp,obs]</code>, where <code class="code">sgp</code> is a subgroup of the root group in that piece, and <code class="code">obs</code> is a subset of the objects in that piece, or as a list <code class="code">[sgp,obs,rays]</code> when a set of rays is required.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(Gd8);</span>
single piece groupoid: Gd8
  objects: [ -9, -8, -7 ]
    group: d8 = &lt;[ (1,2,3,4), (1,3) ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c4 := Subgroup( d8, [ (1,2,3,4) ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k4 := Subgroup( d8, [ (1,3), (2,4) ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( c4, "c4" );  SetName( k4, "k4" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ud8 := Subgroupoid( Gd8, [ [ k4, [-9] ], [ c4, [-8,-7] ] ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( Ud8, "Ud8" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Ud8 );</span>
groupoid with 2 pieces:
&lt; objects: [ -9 ]
    group: k4 = &lt;[ (1,3), (2,4) ]&gt; &gt;
&lt; objects: [ -8, -7 ]
    group: c4 = &lt;[ (1,2,3,4) ]&gt; &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ Parent( Ud8 ), IsWideSubgroupoid( Gd8, Ud8 ) ]; </span>
[ Gd8, true ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U2;</span>
groupoid with 2 pieces:
[ Gq8, Gf2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">genf2b := List( GeneratorsOfGroup(f2), g -&gt; g^2 );</span>
[ f1^2, f2^2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f2b := Subgroup( f2, genf2b );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SU2 := SubgroupoidByPieces( U2, [ [q8,[-27]], [f2b,[-22]] ] );</span>
groupoid with 2 pieces:
1:  single piece groupoid: &lt; q8, [ -27 ] &gt;
2:  single piece groupoid: &lt; Group( [ f1^2, f2^2 ] ), [ -22 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWideSubgroupoid( U2, SU2 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubgroupoid( Gf2, Groupoid( f2b, [-22] ) );</span>
true

</pre></div>

<p><a id="X7FE8F09A7C8CEC5B" name="X7FE8F09A7C8CEC5B"></a></p>

<h5>4.3-5 FullTrivialSubgroupoid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FullTrivialSubgroupoid</code>( <var class="Arg">gpd</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DiscreteTrivialSubgroupoid</code>( <var class="Arg">gpd</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>A <em>trivial subgroupoid</em> has trivial object groups, but need not be discrete. A single piece trivial groupoid is sometimes called a <em>tree groupoid</em>. (The term <em>identity subgroupoid</em> was used in versions up to 1.14.)</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FullTrivialSubgroupoid( Ud8 );</span>
groupoid with 2 pieces:
1:  single piece groupoid: &lt; id(k4), [ -9 ] &gt;
2:  single piece groupoid: &lt; id(c4), [ -8, -7 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DiscreteTrivialSubgroupoid( Ud8 );</span>
groupoid with 3 pieces:
1:  single piece groupoid: &lt; id(k4), [ -9 ] &gt;
2:  single piece groupoid: &lt; id(c4), [ -8 ] &gt;
3:  single piece groupoid: &lt; id(c4), [ -7 ] &gt;

</pre></div>

<p><a id="X7ACFBE7D855A82A3" name="X7ACFBE7D855A82A3"></a></p>

<h5>4.3-6 DiscreteSubgroupoid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DiscreteSubgroupoid</code>( <var class="Arg">gpd</var>, <var class="Arg">sgps</var>, <var class="Arg">obs</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MaximalDiscreteSubgroupoid</code>( <var class="Arg">gpd</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>A subgroupoid is <em>discrete</em> if it is a union of groups. The <code class="code">MaximalDiscreteSubgroupoid</code> of <code class="code">gpd</code> is the union of all the single-object full subgroupoids of <code class="code">gpd</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U3;</span>
groupoid with 3 pieces:
[ Gs4, Gd8, Gc6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DiscreteSubgroupoid( U3, [ a4, a4, c4, k4 ], [-15,-11,-9,-7] );</span>
groupoid with 4 pieces:
1:  single piece groupoid: &lt; a4, [ -15 ] &gt;
2:  single piece groupoid: &lt; a4, [ -11 ] &gt;
3:  single piece groupoid: &lt; c4, [ -9 ] &gt;
4:  single piece groupoid: &lt; k4, [ -7 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MaximalDiscreteSubgroupoid( Vc3 );</span>
groupoid with 3 pieces:
1:  single piece groupoid: &lt; c3, [ -14 ] &gt;
2:  single piece groupoid: &lt; Group( [ (1,2,3) ] ), [ -13 ] &gt;
3:  single piece groupoid: &lt; Group( [ (1,4,2) ] ), [ -12 ] &gt;

</pre></div>

<p><a id="X7A9F29BD7D64DCC1" name="X7A9F29BD7D64DCC1"></a></p>

<h5>4.3-7 SinglePieceSubgroupoidByGenerators</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SinglePieceSubgroupoidByGenerators</code>( <var class="Arg">parent</var>, <var class="Arg">gens</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>A set of arrows generates a groupoid by taking all possible products and inverses. So far, the only implementation is for the case of loops generating a group at an object <span class="SimpleMath">o</span> together with a set of rays from <span class="SimpleMath">o</span>, where <span class="SimpleMath">o</span> is <em>not</em> the least object. A suitably large supergroupoid, which must be a direct product with a complete digraph, should be provided. This is the case needed for <code class="code">ConjugateGroupoid</code> in section <a href="chap4.html#X78218F357BFEDE82"><span class="RefLink">4.5-2</span></a>. Other cases will be added as time permits.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a1 := Arrow( Ua4, (2,3,4), -15, -15 );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a2 := Arrow( Ua4, (1,2,3,4), -15, -13 );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a3 := Arrow( Ua4, (2,3), -15, -11 );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SinglePieceSubgroupoidByGenerators( Ua4, [a1,a2,a3] );</span>
single piece groupoid with rays: &lt; Group( [ (2,3,4) ] ), [ -15, -13, -11 ], 
[ (), (1,2,3,4), (2,3) ] &gt;

</pre></div>

<p><a id="X831AA9E8780235F2" name="X831AA9E8780235F2"></a></p>

<h4>4.4 <span class="Heading">Left, right and double cosets</span></h4>

<p><a id="X8412ABD57986B9FC" name="X8412ABD57986B9FC"></a></p>

<h5>4.4-1 RightCoset</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RightCoset</code>( <var class="Arg">G</var>, <var class="Arg">U</var>, <var class="Arg">elt</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RightCosetRepresentatives</code>( <var class="Arg">G</var>, <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LeftCoset</code>( <var class="Arg">G</var>, <var class="Arg">U</var>, <var class="Arg">elt</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LeftCosetRepresentatives</code>( <var class="Arg">G</var>, <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LeftCosetRepresentativesFromObject</code>( <var class="Arg">G</var>, <var class="Arg">U</var>, <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>If <code class="code">U</code> is a subgroupoid of <span class="SimpleMath">G</span>, the <em>right cosets</em> <span class="SimpleMath">Ug</span> of <span class="SimpleMath">U</span> in <span class="SimpleMath">G</span> are the equivalence classes for the relation on the arrows of <span class="SimpleMath">G</span> where <span class="SimpleMath">g1</span> is related to <span class="SimpleMath">g2</span> if and only if <span class="SimpleMath">g2 = u*g1</span> for some arrow <span class="SimpleMath">u</span> of <span class="SimpleMath">U</span>. The right coset containing <span class="SimpleMath">g</span> is written <span class="SimpleMath">Ug</span>. These right cosets partition the costars of <span class="SimpleMath">G</span> and, in particular, the costar <span class="SimpleMath">U1_o</span> of <span class="SimpleMath">U</span> at object <span class="SimpleMath">o</span>. So (unlike groups) <span class="SimpleMath">U</span> is itself a coset only when <span class="SimpleMath">G</span> has a single object.</p>

<p>The <em>right coset representatives</em> for <span class="SimpleMath">U</span> in <span class="SimpleMath">G</span> form a list containing one arrow for each coset where, in a particular piece of <span class="SimpleMath">U</span>, the group element chosen is the right coset representative of the group of <span class="SimpleMath">U</span> in the group of <span class="SimpleMath">G</span>.</p>

<p>Similarly, the <em>left cosets</em> <span class="SimpleMath">gU</span> refine the stars of <span class="SimpleMath">G</span> while <em>double cosets</em> are unions of left and right cosets. The operation <code class="code">LeftCosetRepresentativesFromObject( G, U, obj )</code> is used in Chapter <a href="chap6.html#X78063DC8847554B4"><span class="RefLink">6</span></a> , and returns only those representatives which have tail at <code class="code">obj</code>.</p>

<p>As with stars and homsets, these cosets are implemented with representation <code class="code">IsHomsetCosetsRep</code> and provided with an iterator. Note that, when <span class="SimpleMath">U</span> has more than one piece, cosets may have differing lengths.</p>

<p>In the example the representative for the right coset <code class="code">re2</code> is the tenth one in the printed list <code class="code">rcrd8</code>, namely <code class="code">[(2,4):-7-&gt;-7]</code>.</p>

<p>Note that no operation <code class="code">DoubleCoset</code> has yet been implemented.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">re2 := RightCoset( Gd8, Ud8, e2 );</span>
&lt;right coset of single piece groupoid: &lt; c4, 
[ -8, -7 ] &gt; with representative [(1,3) : -8 -&gt; -7]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Perform( re2, Display );</span>
[(1,3) : -8 -&gt; -7]
[(1,3) : -7 -&gt; -7]
[(2,4) : -8 -&gt; -7]
[(2,4) : -7 -&gt; -7]
[(1,4)(2,3) : -8 -&gt; -7]
[(1,4)(2,3) : -7 -&gt; -7]
[(1,2)(3,4) : -8 -&gt; -7]
[(1,2)(3,4) : -7 -&gt; -7]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rcrd8 := RightCosetRepresentatives( Gd8, Ud8 );</span>
[ [() : -9 -&gt; -9], [(1,4,3,2) : -9 -&gt; -9], [() : -9 -&gt; -8], 
  [(1,4,3,2) : -9 -&gt; -8], [() : -9 -&gt; -7], [(1,4,3,2) : -9 -&gt; -7], 
  [() : -8 -&gt; -8], [(2,4) : -8 -&gt; -8], [() : -7 -&gt; -7], [(2,4) : -7 -&gt; -7], 
  [() : -8 -&gt; -9], [(2,4) : -8 -&gt; -9] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lcr7 := LeftCosetRepresentativesFromObject( Gd8, Ud8, -7 );</span>
[ [() : -7 -&gt; -9], [(1,2,3,4) : -7 -&gt; -9], [() : -7 -&gt; -7], 
  [(2,4) : -7 -&gt; -7] ]

</pre></div>

<p><a id="X8653FC9786E3209A" name="X8653FC9786E3209A"></a></p>

<h4>4.5 <span class="Heading">Conjugation</span></h4>

<p><a id="X7D21FB1A7D21FB1A" name="X7D21FB1A7D21FB1A"></a></p>

<h5><code>4.5-1 \^</code></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; \^</code>( <var class="Arg">e1</var>, <var class="Arg">e</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Conjugation by an arrow <span class="SimpleMath">e = (c : p -&gt; q)</span> is the groupoid inner automorphism (see section <a href="chap5.html#X803E01577A2B37D2"><span class="RefLink">5.6</span></a>) defined as follows. There are two cases to consider. In the case <span class="SimpleMath">p ≠ q</span>,</p>


<ul>
<li><p>objects <span class="SimpleMath">p,q</span> are interchanged, and the remaining objects are fixed;</p>

</li>
<li><p>loops at <span class="SimpleMath">p,q</span>: <span class="SimpleMath">(b: p -&gt; p) ↦ (b^c : q -&gt; q)</span> and <span class="SimpleMath">(b: q -&gt; q) ↦ (b^c^-1} : p -&gt; p)</span>;</p>

</li>
<li><p>arrows between <span class="SimpleMath">p</span> and <span class="SimpleMath">q</span>: <span class="SimpleMath">(b : p -&gt; q) ↦ (c^-1bc^-1 : q -&gt; p)</span> and <span class="SimpleMath">(b : q -&gt; p) ↦ (cbc : p -&gt; q)</span>;</p>

</li>
<li><p>costars at <span class="SimpleMath">p,q</span>: <span class="SimpleMath">(b : r -&gt; p) ↦ (bc : r -&gt; q)</span> and <span class="SimpleMath">(b : r -&gt; q) ↦ (bc^-1 : r -&gt; p)</span>;</p>

</li>
<li><p>stars at <span class="SimpleMath">p,q</span>: <span class="SimpleMath">(b : p -&gt; r) ↦ (c^-1b : -&gt; q)</span> and <span class="SimpleMath">(b : q -&gt; r) ↦ (cb : p -&gt; r)</span>;</p>

</li>
<li><p>the remaining arrows are unchanged.</p>

</li>
</ul>
<p>In the case <span class="SimpleMath">p=q</span>,</p>


<ul>
<li><p>all the objects are fixed;</p>

</li>
<li><p>loops at <span class="SimpleMath">p</span> are conjugated by <span class="SimpleMath">c</span>, so <span class="SimpleMath">(b : p -&gt; p) ↦ (b^c : p -&gt; p)</span>;</p>

</li>
<li><p>the rest of the costar and star at <span class="SimpleMath">p</span> are permuted,</p>

<p class="pcenter">
(b : r \to p) \mapsto (bc : r \to p) 
\quad\mbox{and}\quad (b : p \to r) \mapsto (c^{-1}b : p \to r); 
</p>

</li>
<li><p>the remaining arrows are unchanged.</p>

</li>
</ul>
<p>The details of this construction may be found in section 3.2 of <a href="chapBib.html#biBAlWe">[AW10]</a>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := Arrow( Gd8, (1,3), -9, -9 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">y := Arrow( Gd8, (1,2,3,4), -8, -9 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z := Arrow( Gd8, (1,2)(3,4), -9, -7 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w := Arrow( Gd8, (1,2,3,4), -7, -8 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##  conjugation with elements x, y, and z in Gd8: </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x^y;</span>
[(2,4) : -8 -&gt; -8]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x^z;</span>
[(2,4) : -7 -&gt; -7]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">y^x;</span>
[() : -8 -&gt; -9]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">y^z;</span>
[(2,4) : -8 -&gt; -7]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z^x;</span>
[(1,4,3,2) : -9 -&gt; -7]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z^y;</span>
[(2,4) : -8 -&gt; -7]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w^z</span>
[(1,3) : -9 -&gt; -8]

</pre></div>

<p><a id="X78218F357BFEDE82" name="X78218F357BFEDE82"></a></p>

<h5>4.5-2 ConjugateGroupoid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConjugateGroupoid</code>( <var class="Arg">gpd</var>, <var class="Arg">e</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>When <span class="SimpleMath">H</span> is a subgroupoid of a groupoid <span class="SimpleMath">G</span> and <span class="SimpleMath">a</span> is an arrow of <span class="SimpleMath">G</span>, then the conjugate of <span class="SimpleMath">H</span> by <span class="SimpleMath">a</span> is the subgroupoid generated by the conjugates of the generators of <span class="SimpleMath">H</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Kd8 := SubgroupoidWithRays( Gs4, d8, [(),(1,2),(2,3),(3,4),(1,4)] );</span>
single piece groupoid with rays: &lt; d8, [ -15 .. -11 ], 
[ (), (1,2), (2,3), (3,4), (1,4) ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := Arrow( Gs4, (1,2,3), -15, -14 );</span>
[(1,2,3) : -15 -&gt; -14]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugateGroupoid( Kd8, u );                                        </span>
single piece groupoid with rays: &lt; Group( [ (1,3,2,4), (1,2) ] ), 
[ -15, -14, -13, -12, -11 ], [ (), (1,2), (), (2,4,3), (1,4)(2,3) ] &gt;

</pre></div>

<p><a id="X86DD749283068705" name="X86DD749283068705"></a></p>

<h4>4.6 <span class="Heading">Groupoids formed using isomorphisms</span></h4>

<p>Here we describe an alternative way of constructing a connected groupoid. This section has been introduced in version 1.66 of the package, and so should be considered very experimental, and liable to change.</p>

<p>Object groups in a connected groupoid are isomorphic, so we may use a collection of isomorphisms to form a groupoid. Let <span class="SimpleMath">G_1,G_2,...,G_n</span> be isomorphic groups and, for <span class="SimpleMath">2 leqslant i leqslant n</span>, let <span class="SimpleMath">μ_i : G_1 -&gt; G_i</span> be isomorphisms. Then <span class="SimpleMath">μ_ij = μ_i^-1*μ_j</span> is an isomorphism from <span class="SimpleMath">G_i</span> to <span class="SimpleMath">G_j</span>. If we take <span class="SimpleMath">{u_1,...,u_n}</span> to be our set of objects, with <span class="SimpleMath">G_i</span> the object group at <span class="SimpleMath">u_i</span>, we may consider the arrows in the groupoid to have the form <span class="SimpleMath">[[g_i,g_j] : u_i -&gt; u_j]</span> where <span class="SimpleMath">g_i ∈ G_i</span> and <span class="SimpleMath">g_j = μ_ij(g_i) ∈ G_j</span>. The product of <span class="SimpleMath">[[g_i,g_j] : u_i -&gt; u_j]</span> and <span class="SimpleMath">[[g'_j,g_k] : u_j -&gt; u_k]</span> is <span class="SimpleMath">[[μ_ij^-1(g_jg'_j), μ_jk(g_jg'_j)] : u_i -&gt; u_k]</span>.</p>

<p><a id="X7B066DE28574A768" name="X7B066DE28574A768"></a></p>

<h5>4.6-1 GroupoidByIsomorphisms</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GroupoidByIsomorphisms</code>( <var class="Arg">gp</var>, <var class="Arg">obs</var>, <var class="Arg">isos</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsGroupoidByIsomorphisms</code>( <var class="Arg">gpd</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>The operation <code class="code">GroupoidByIsomorphisms</code> takes a group <code class="code">G1</code> as root group; a set of <span class="SimpleMath">n</span> objects; and a set of <span class="SimpleMath">n</span> isomorphisms from the root group, where the first isomorphism should be the identity mapping on <code class="code">G1</code>. The output is a single piece groupoid of type <code class="code">IsGroupoidByIsomorphisms</code>. Its rays have the form <code class="code">[One(G1),One(Gi)]</code> where <code class="code">Gi</code> is the image of the <span class="SimpleMath">i</span>-th isomorphism.</p>

<p>In the example we first take three permutation groups isomorphic to the symmetric group <span class="SimpleMath">S_3</span>. There follows an isomorphic groupoid whose object groups are a permutation group; a pc-group and an fp-group.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s3a := Group( (1,2), (2,3) );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s3b := Group( (4,6,8)(5,7,9), (4,9)(5,8)(6,7) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s3c := Group( (4,6,8)(5,7,9), (5,9)(6,8) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( s3a, "s3a" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ida := IdentityMapping( s3a );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">isoab := IsomorphismGroups( s3a, s3b );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">isoac := IsomorphismGroups( s3a, s3c );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">isos1 := [ ida, isoab, isoac ];; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G1 := GroupoidByIsomorphisms( s3a, [-3,-2,-1], isos1 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens1 := GeneratorsOfGroupoid( G1 );                    </span>
[ [[ (1,2), (1,2) ] : -3 -&gt; -3], [[ (2,3), (2,3) ] : -3 -&gt; -3], 
  [[ (), () ] : -3 -&gt; -2], [[ (), () ] : -3 -&gt; -1] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x1 := ImageElm( isos1[2], (1,2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a1 := Arrow( G1, [ (1,2), x1 ], -3, -2 );</span>
[[ (1,2), (4,5)(6,9)(7,8) ] : -3 -&gt; -2]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a1^-1;</span>
[[ (4,5)(6,9)(7,8), (1,2) ] : -2 -&gt; -3]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">y1 := ImageElm( isos1[2], (2,3) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z1 := ImageElm( isos1[3], (2,3) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b1 := Arrow( G1, [ y1, z1 ], -2, -1 );</span>
[[ (4,9)(5,8)(6,7), (5,9)(6,8) ] : -2 -&gt; -1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c1 := a1*b1;</span>
[[ (1,3,2), (4,8,6)(5,9,7) ] : -3 -&gt; -1]

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">isopc := IsomorphismPcGroup( s3a );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s3p := Image( isopc );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f2 := FreeGroup( 2 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s3f := f2/[ f2.1^3, f2.2^2, (f2.1*f2.2)^2 ];; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">isofp := GroupHomomorphismByImages(s3a,s3f,[(1,2,3),(2,3)],[s3f.1,s3f.2]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">isos2 := [ ida, isopc, isofp ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G2 := GroupoidByIsomorphisms( s3a, [-7,-6,-5], isos2 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens2 := GeneratorsOfGroupoid( G2 );</span>
[ [[ (1,2), (1,2) ] : -7 -&gt; -7], [[ (2,3), (2,3) ] : -7 -&gt; -7], 
  [[ (), &lt;identity&gt; of ... ] : -7 -&gt; -6], [[ (), &lt;identity ...&gt; ] : -7 -&gt; -5] 
 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x2 := ImageElm( isos2[2], (1,2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a2 := Arrow( G2, [ (1,2), x2 ], -7, -6 );</span>
[[ (1,2), f1*f2 ] : -7 -&gt; -6]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a2^-1;</span>
[[ f1*f2, (1,2) ] : -6 -&gt; -7]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">y2 := ImageElm( isos2[2], (2,3) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z2 := ImageElm( isos2[3], (2,3) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b2 := Arrow( G2, [ y2, z2 ], -6, -5 );</span>
[[ f1, f2^-1 ] : -6 -&gt; -5]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c2 := a2*b2; </span>
[[ (1,3,2), f1^2 ] : -7 -&gt; -5]

</pre></div>

<p><a id="X795DEB3D825B2120" name="X795DEB3D825B2120"></a></p>

<h4>4.7 <span class="Heading">Groupoids whose objects form a monoid</span></h4>

<p>Let <span class="SimpleMath">M</span> be a monoid with <span class="SimpleMath">G</span> its maximal subgroup. We may form a groupoid with the elements of <span class="SimpleMath">M</span> as its objects and with arrows <span class="SimpleMath">t -&gt; t*g</span> for all <span class="SimpleMath">t ∈ M</span> and <span class="SimpleMath">g ∈ G</span>.</p>

<p>This construction is used in the <strong class="pkg">XMod</strong> package to construct the group-groupoid which corresponds to a crossed module or cat2-group.</p>

<p><a id="X805FA9F687C7F2A7" name="X805FA9F687C7F2A7"></a></p>

<h5>4.7-1 SinglePieceGroupoidWithRays</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SinglePieceGroupoidWithRays</code>( <var class="Arg">gp</var>, <var class="Arg">obs</var>, <var class="Arg">rays</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>When <span class="SimpleMath">M</span> is a group, <span class="SimpleMath">G=M</span> and the groupoid so constructed is a single piece which represents the regular representation of <span class="SimpleMath">G</span>. The ray from <span class="SimpleMath">1</span> to <span class="SimpleMath">g</span> is just <span class="SimpleMath">g</span> since <span class="SimpleMath">1*g=g</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d8 := Group( (1,2,3,4), (1,3) );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ed8 := Elements( d8 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rd8 := SinglePieceGroupoidWithRays( d8, ed8, ed8 );</span>
single piece groupoid with rays: &lt; Group( [ (1,2,3,4), (1,3) ] ), 
[ (), (2,4), (1,2)(3,4), (1,2,3,4), (1,3), (1,3)(2,4), (1,4,3,2), (1,4)(2,3) 
 ], [ (), (2,4), (1,2)(3,4), (1,2,3,4), (1,3), (1,3)(2,4), (1,4,3,2), 
  (1,4)(2,3) ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Homset( rd8, (2,4), (1,3) ) );</span>
[(1,3)(2,4) : (2,4) -&gt; (1,3)]
[(1,3) : (2,4) -&gt; (1,3)]
[() : (2,4) -&gt; (1,3)]
[(2,4) : (2,4) -&gt; (1,3)]
[(1,4,3,2) : (2,4) -&gt; (1,3)]
[(1,4)(2,3) : (2,4) -&gt; (1,3)]
[(1,2,3,4) : (2,4) -&gt; (1,3)]
[(1,2)(3,4) : (2,4) -&gt; (1,3)]

</pre></div>

<p><a id="X7E399664868937C8" name="X7E399664868937C8"></a></p>

<h5>4.7-2 RightActionGroupoid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RightActionGroupoid</code>( <var class="Arg">mon</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsGroupoidWithMonoidObjects</code>( <var class="Arg">gpd</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>When <span class="SimpleMath">M</span> is a monoid, rather than a group, this construction produces several components. One of these has as objects the elements of the group <span class="SimpleMath">G</span>.</p>

<p>When <span class="SimpleMath">M</span> <em>is</em> a group, this operation gives the same result as <code class="code">SinglePieceGroupoidWithRays</code>.</p>

<p>As a simple example we take a monoid <span class="SimpleMath">M</span> generated by two transformations of degree <span class="SimpleMath">4</span>. The groupoid has <span class="SimpleMath">8</span> components, of which <span class="SimpleMath">3</span> have a single object and group <span class="SimpleMath">C_2</span>, while <span class="SimpleMath">5</span> have two objects and trivial group.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t := Transformation( [1,1,2,3] );;  u := Transformation( [1,2,4,3] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := Monoid( t, u );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rag := RightActionGroupoid( M );</span>
groupoid with 8 pieces:
1:  single piece groupoid with rays: &lt; Group( 
[ IdentityTransformation, Transformation( [ 1, 2, 4, 3 ] ) ] ), 
[ Transformation( [ 1, 1, 1, 1 ] ) ], [ IdentityTransformation ] &gt;
2:  single piece groupoid with rays: &lt; Group( 
[ IdentityTransformation, Transformation( [ 1, 2, 4, 3 ] ) ] ), 
[ Transformation( [ 1, 1, 1, 2 ] ) ], [ IdentityTransformation ] &gt;
3:  single piece groupoid with rays: &lt; Group( [ IdentityTransformation ] ), 
[ Transformation( [ 1, 1, 1, 3 ] ), Transformation( [ 1, 1, 1 ] ) ], 
[ IdentityTransformation, Transformation( [ 1, 2, 4, 3 ] ) ] &gt;
4:  single piece groupoid with rays: &lt; Group( 
[ IdentityTransformation, Transformation( [ 1, 2, 4, 3 ] ) ] ), 
[ Transformation( [ 1, 1, 2, 1 ] ) ], [ IdentityTransformation ] &gt;
5:  single piece groupoid with rays: &lt; Group( [ IdentityTransformation ] ), 
[ Transformation( [ 1, 1, 2, 3 ] ), Transformation( [ 1, 1, 2 ] ) ], 
[ IdentityTransformation, Transformation( [ 1, 2, 4, 3 ] ) ] &gt;
6:  single piece groupoid with rays: &lt; Group( [ IdentityTransformation ] ), 
[ Transformation( [ 1, 1, 3, 1 ] ), Transformation( [ 1, 1, 4, 1 ] ) ], 
[ IdentityTransformation, Transformation( [ 1, 2, 4, 3 ] ) ] &gt;
7:  single piece groupoid with rays: &lt; Group( [ IdentityTransformation ] ), 
[ Transformation( [ 1, 1, 3, 2 ] ), Transformation( [ 1, 1, 4, 2 ] ) ], 
[ IdentityTransformation, Transformation( [ 1, 2, 4, 3 ] ) ] &gt;
8:  single piece groupoid with rays: &lt; Group( [ IdentityTransformation ] ), 
[ IdentityTransformation, Transformation( [ 1, 2, 4, 3 ] ) ], 
[ IdentityTransformation, Transformation( [ 1, 2, 4, 3 ] ) ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsGroupoidWithMonoidObjects( rag );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orag := ObjectList( rag );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hs := Homset( rag, orag[3], orag[4] );;  </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( hs );                  </span>
&lt;homset Transformation( [ 1, 1, 1, 3 ] ) -&gt; Transformation( [ 1, 1, 1 ] )
  with elements:
[Transformation( [ 1, 2, 4, 3 ] ) : Transformation( [ 1, 1, 1, 3 ] ) -&gt; 
Transformation( [ 1, 1, 1 ] )]

</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap3.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap5.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
