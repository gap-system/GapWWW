<!DOCTYPE Book SYSTEM "gapdoc.dtd"> <Book Name="GBNP"> <TitlePage>
<Title>Documentation on the <Package>GBNP</Package> package</Title>
<Version>Version $VERSION</Version> <Author>A.M. Cohen
<Email>A.M.Cohen@tue.nl</Email></Author>
<Author>D.A.H. Gijsbers<Email>D.A.H.Gijsbers@tue.nl</Email></Author> <Date>03
January 2007</Date> <Address>RIACA, Dept. Math. and Comp. Sc., TU/e,<Br/> POB
513, 5600 MB Eindhoven, the Netherlands </Address> <Abstract> We provide
algorithms, written in the <Package>GAP</Package> 4 programming language, for
computing Gröbner bases of noncommutative polynomials, and some variations,
such as a weighted and truncated version and a tracing facility. In addition,
there are algorithms for analyzing the quotient of a noncommutative polynomial algebra by
a 2-sided ideal generated by a set of polynomials whose Gröbner basis has been
determined.  <P/> The notion algorithm is interpreted loosely: in general one
cannot expect a noncommutative Gröbner basis algorithm to terminate, 
as it would imply solvability of
the word problem for finitely presented (semi)groups.  </Abstract>

<Acknowledgements>
<List>
<Item>The package is based on an earlier version by Rosane Ushirobira</Item>
<Item>The theory is mainly taken from literature by Teo Mora <Cite Key="TCS::Mora1994:131"/> and
	Edward L. Green <Cite Key="Green1997"/></Item>
<Item>From 0.8.3 on the package has three additional files
	(<File>fincheck.g</File>, <File>tree.g</File> <File>graphs.g</File>)
	with routines for finding the Hilbert function and testing
	finite-dimensionality when given a Gröbner basis by Chris Krook <Cite
		Key="Krook2003"/>, based on work by Victor Ufnarovski <Cite
		Key="MR91d:16053"/>.</Item>
<Item>From 0.9 on the package is enriched with support for gap-fields and
	additional prefix rules as well as some speed improvements by Jan
	Willem Knopper.
</Item>
</List>
&nbsp; <!-- needed to prevent LaTeX from erroring -->
</Acknowledgements></TitlePage>
<TableOfContents/>
<Body>
<Chapter><Heading>Introduction</Heading>
<Section><Heading>Installation</Heading>	
To install GBNP, first download it from 
<URL>http://www.win.tue.nl/~amc/pub/grobner/GBNP-$VERSION.tar.gz</URL>, then unpack
<F>GBNP-$VERSION.tar.gz</F> in the <C>pkg</C> subdirectory of
your <Package>GAP</Package> installation (or in the <C>pkg</C> subdirectory of
any other <Package>GAP</Package> root directory, for example one added with the
<C>-l</C> argument) with the following command: 
<Code>tar -xvzf GBNP-$VERSION.tar.gz</Code>.
<P/>
GBNP is then loaded with the GAP command
<Listing>
gap> LoadPackage( "GBNP" ); 
</Listing>
<P/>
Those who want to download this documentation can find it at
<URL>http://www.win.tue.nl/~amc/pub/grobner/GBNPdoc-$VERSION.tar.gz</URL>
and extract it with 
<Code>tar -xvzf GBNPdoc-$VERSION.tar.gz</Code>.
It is also included in the package.
</Section>
<Section Label="intro"><Heading>Introduction to the package</Heading>	
If you wish to compute a Gröbner basis, create a list of NPs
(noncommutative polynomials in our format), see <Ref Sect="NP"/>.  This can be
done either directly or by use of the transition functions described in Section
<Ref Sect="TransitionFunctions"/>. But beware: the algorithm for computing Gröbner bases is not guaranteed to terminate.

<P/>
To run the standard algorithm use the functions from Section <Ref
	Sect="grobner"/>. With these functions, you can try and find a Gröbner
basis. But also you can find a basis of monomials for the quotient algebra
<M>Q</M> if the GB is found and the dimension of <M>Q</M> is finite with the
functions in Section <Ref Sect="QA"/>.  For more advanced analysis of <M>Q</M>,
such as a proof of finite or infinite-dimensionality, or for determining its
growth or its partial Hilbert series, use the functions from Section <Ref
	Sect="finiteness"/> <!-- <File>fincheck.g</File> -->.
<P/>
There are two variants of the Gröbner basis algorithm, the truncated 
version in the homogeneous case, which is described in Section <Ref
	Sect="trunc"/>, which adds the functions described in Section <Ref Sect="truncfun"/>
<!-- in <File>trunc.g</File> -->, and the version that
gives an expression of the polynomials in terms of the original generators,
described in <Ref Sect="trace"/>, which adds the functions described in <Ref
	Sect="tracefun"/> <!-- <File>trace.g</File> -->.
<P/>
Read the example files in Chapter <Ref Chap="Examples"/> for inspiration.
The source of the files can be perused for auxiliary
functions, which are often used in the main functions
but not needed by a first time user.
</Section>
<Section><Heading>Other parts of the documentation</Heading>
	The unpublished reports <Cite Key="CohenGijsbers2003"/> and <Cite
		Key="Krook2003"/> can be downloaded from the web at these
	addresses:
	<P/>
	The report <Q>Dimensionality of quotient algebras</Q>, by Chris
	Krook can be downloaded from
	<URL>http://www.win.tue.nl/~amc/pub/grobner/dqa.pdf</URL>.
	<P/>
	The report <Q>Noncommutative Gröbner basis computations</Q>, by Arjeh
	M. Cohen and Dié A.H Gijsbers can be downloaded from
	<URL>http://www.win.tue.nl/~amc/pub/grobner/gbnp.pdf</URL>.
</Section>
</Chapter>
<Chapter><Heading>Description</Heading>
<Section Label="NP"><Heading>Noncommutative Polynomials (NPs)</Heading>
	The main datatype of the GBNP package is a list of noncommutative
	polynomials (NPs). 
	The data type for a noncommutative polynomial is a list of two lists:
<List>
	<Item>the first list is a list <C>m</C> of monomials</Item>
	<Item>the second list is a list <C>c</C> of coefficients of these
		monomials</Item>
</List>
The two lists have the same length. The polynomial represented
by the list <C>[m,c]</C> of the two lists <C>m</C> and <C>c</C> is <M>\sum_i c_i m_i</M>.
<P/>
A monomial is a list of positive integers. They are interpreted as the
indices of the variables.  So, if <M>m = [1,2,3,2,1]</M> and the variables are
<M>x</M>,<M>y</M>,<M>z</M> (in this order), then <M>m</M> stands for the
monomial <M>xyzyx</M>.
By the way, the name of the variables has no meaning. There are various ways to
print these but the default is as <M>a</M>,<M>b</M>,<M>c</M>,<M>\ldots</M> (see
below).
<P/>
The zero polynomial is represented by <C>[[],[]]</C>.
The polynomial 1 is represented by <C>[[[]],[1]]</C>.
<P/>
The algorithms work for the ring
<M>\mathbb F\langle\langle x_1,x_2,\ldots,x_t\rangle\rangle</M> of
noncommutative polynomials in <A>t</A> variables, where <M>\mathbb F</M> is a
field. 
<P/>
In order to facilitate viewing the polynomials, we provide the function
<Ref Func="PrintNP" Style="Text"/>. For instance
<Listing>PrintNP([[[1,2],[2,1]],[3,-1]]);</Listing> yields
<Listing>3ab - ba</Listing> Indeed, we have the names: <C>a</C>, <C>b</C>, <C>c</C>,
<M>\ldots</M>  for <M>x_1</M>, <M>x_2</M>, <M>x_3</M>, <M>\ldots</M>,
except that everything beyond <M>l</M> (the 12-th letter) is called <M>x</M>.
This can be easily changed by calling the function <C>GBNP.ConfigPrint</C>,
which can be found in Section <Ref Sect="printing"/><!-- the file
<File>printing.g</File> -->.
<P/>
The function <Ref Func="PrintNPList" Style="Text"/> is available for printing a list of NPs
(=noncommutative polynomials).
<P/>
In order to facilitate testing whether two data structures represent
the same NP, we use the convention that polynomials are
"clean". This means that they look as if they are output of the
function <Ref Func="CleanNP" Style="Text"/>.  In other words:
<List>
	<Item>each monomial occurs at most once in the list of monomials,</Item>
	<Item>no monomials occur whose coefficients are zero,</Item>
	<Item>the monomials are ordered (total degree first, then
		lexicographically) from big to small.</Item>
</List>
An advantage of the ordering is that the leading monomial of an NP <C>p</C> is
just <C>p[1][1]</C> and that its leading coefficient is <C>p[2][1]</C>.
</Section>
<Section Label="NPM"><Heading>Noncommutative Polynomials for Modules (NPMs)</Heading>
	The format can be adjusted slightly to allow the use of a free module
	over the algebra. The internal format of an element of the
	module is similar to that of a noncommutative polynomial, see
	<Ref Sect="NP"/>. The only change is that each monomial will start with
	a negative number. The absolute value of this number is the index of
	the standard basis vector of the free module.
	<P/>
	For example in a two-dimensional free <M>\mathbb F\langle\langle x_1, x_2,
		\ldots, x_t\rangle\rangle</M>-module <C>[[[-1]],[1]]</C> would
	represent <C>[1,0]</C>. Note that the zero vector is the same as
	in <Ref Sect="NP"/> and the only one without a negative entry:
	<C>[[],[]]</C>.
	<P/>
	Elements of modules will be printed as vectors. 
</Section>
<Section><Heading>Core Functions</Heading>
The core function is <Ref Func="SGrobner" Style="Text"/> (for Strong Gröbner,
as we use the Strong Normal Form most of the time). It takes a list of NPs and,
prepares two lists for a loopy treatment:
<List>
	<Item> first the list itself, called <C>G</C>. Before entering the
		loop, <C>G</C> is cleaned, ordered and its elements are made
		monic, that is, multiplied by a scalar so that the leading
		coefficient becomes one.</Item>
	<Item>second the list of all NormalForms wrt <C>G</C> of S-polynomials
		of elements of <C>G</C>. This list is called <C>todo</C>
		('<C>D</C>' in the report), reminding us that we still need to
		compute the S-polynomials of these NPs (possibly with an
		element of <C>G</C>). If todo is empty then <C>G</C> is a
		Gröbner basis.</Item>
</List>
Then, the function calls the routine <C>GBNP.SGrobnerLoop</C> on the arguments
<A>G</A>, <A>todo</A> which are changed in an attempt to modify <C>G</C> so
that still 
<Enum>
	<Item><C>G</C> generates the same two-sided ideal <M>I</M> as
		before.</Item>
	<Item><C>todo</C> contains all NormalForms wrt <C>G</C> of S-polynomials
		of elements from <C>G</C> that need to reduce to zero for the
		basis to be a Gröbner basis.<!-- XXX does this need rephrasing
		? --></Item> </Enum>
The importance of this feature is that, in case of huge computations,
the user may store <C>G</C> and <C>todo</C> at almost any time and take up the
computation by loading <C>G</C> and <C>todo</C> and using the
<C>GBNP.SGrobnerLoop</C> whenever convenient. The only technical detail to
handle is that the last element of the list <C>G</C> should be copied into the
<C>todo</C> list.<!-- XXX This is not still true, 'almost any time' is the
problem. It should be possible to make a function which restores G and todo at
all time. This is on the todo list -->
<P/>
Now the loop ends when the list <C>todo</C> is empty. As we referred to
in the introduction (<Ref Sect="intro"/>), this may never happen. But if it
does, then the work is essentially done.  After some internal cleaning and a
bit of further rewriting, the computation is over.
<P/>
There is also a <Ref Func="Grobner" Style="Text"/> function. It uses (at some places) the Normal
Form instead of the Strong Normal Form algorithm. In most of our
applications, this usually led to slower performance, so we are not
very keen to use it.
<P/>
In many of our own applications we often have finite-dimensional
quotient algebras: the full polynomial ring modulo the two-sided ideal <M>I</M>
generated by <C>G</C>. In such cases, one would like to know the dimension
(whence the function <Ref Func="DimQA" Style="Text"/>, QA for Quotient Algebra), find a basis
(whence the function <Ref Func="BaseQA" Style="Text"/>), or just the monomials up to a certain
degree that are not divisible by a leading term of <C>G</C> (whence the
function <C>GBNP.NondivMons</C>).  Actually by use of <Ref Func="MulQA"
	Style="Text"/>, you can even multiply elements of the quotient algebra.
In case it is unknown whether the quotient algebra is finite or infinite, one
can use the functions <Ref Func="FinCheck" Style="Text"/>, <Ref
	Func="DetermineGrowth" Style="Text"/> and <Ref
	Func="DetermineGrowthObs" Style="Text"/>. When the quotient algebra is infinite dimensional you may want to determine its partial Hilbert Series. This can be done with the function <Ref Func="HilbertSeries" Style="Text"/>.
</Section>
<Section><Heading>Some words about the implementation</Heading>
Rather than storing all obstructions, the Gröbner basis algorithm computes the
(Strong) Normal Form of obstructions from <C>G</C> and puts them into <C>todo</C>
whenever nonzero. At the beginning of the loop, we take the first element of
the
<C>todo</C> list and prepare it for addition to <C>G</C>.  We are then concerned with
two goals: 
<Enum>
	<Item>to restore the invariant properties,</Item>
	<Item>to clean up G (that is, reduce it to a more succinct, shorter
		set).</Item>
</Enum>
This is mainly done by means of additional S-polynomial and Normal Form
computations.
<P/>
As for data management, we have used the facility to work with
lists in situ, that is, not to copy the list but rather perform all operations
on one and the same list. To this end we use operations like
<C>RemoveElmList</C> and <C>Add</C>, see <Ref BookName="Reference"
	Label="Add"/>. The idea here is to economize on space for large
computations.  We haven't gotten here to the bottom of things, but have
concentrated on the potentially biggest lists: <C>G</C> and <C>todo</C>.
<P/>
For checking whether a monomial can be reduced, an internal tree
structure is used. 
</Section>
<Section><Heading>Dimensionality of a quotient algebra</Heading>
	A number of functions are available to determine whether the quotient
	algebra of the ideal generated by a Gröbner basis is finite dimensional
	or infinite dimensional. A set of leading terms of the Gröbner
	basis needs to be constructed (using <Ref Func="LTermsNP"
		Style="Text"/>). Such a set has the property that no monomial
	in it divides any other monomial in the set. <!-- We call such elements
	(used to be obstructions in Chris's part) term removed because it only
	makes things less clear instead of clearer. -->The function <Ref
		Func="FinCheck" Style="Text"/> determines whether the quotient
	algebra is finite or infinite dimensional. More generally,
the growth of the quotient algebra can be determined by use of
 the function <Ref
		Func="DetermineGrowth" Style="Text"/>, which either states that
	the algebra is finite, or states that the algebra has polynomial
	growth, in which case it gives bounds for the degree of polynomial
	growth, or states that the algebra has exponential growth. Finally,
	with the function <Ref Func="HilbertSeries" Style="Text"/> one can
	compute coefficients of the Hilbert series.
</Section>
<Section Label="trace"><Heading>Tracing variant</Heading>
When computing with small examples, it may be handy to provide the elements of
the Gröbner basis with a way of expressing them as elements in <C>I</C>, that
is, as combinations of elements of the input. This can be done, not only for
elements of <C>G</C>, but for any element, by the functions in the file
<F>trace.g</F>. This file calls the file <F>nparith2.g</F> for arithmetic
keeping track of the expressions of polynomials as combinations of elements
from the original basis.  With respect to a given input basis <C>B</C>, a
polynomial <C>p</C> in the traced version is a record with two fields. One
field, called <C>p.pol</C>, is the usual NP. The other,
called <C>p.trace</C>, is a list of elements indexed by <C>B</C>. Each element
of <C>p.trace</C> is a list whose elements are four-tuples <C>[ml,i,mr,c]</C>
where <C>ml</C> and <C>mr</C> are monomials, <C>i</C> is an index of an element
of <C>B</C> and <C>c</C> is a scalar. The interpretation of this data structure
is that <C>p.pol</C> can be written as the sum over all four-tuples
<C>[ml,i,mr,c]</C> of <M>c*ml*B_i*mr</M>.
Functions to print these expressions in a human understandable way are 
described in Section <Ref Sect="tracefun"/><!-- <F>printing2.g</F> -->.
</Section>

<Section Label="trunc"><Heading>Truncation variant</Heading>
When computing with large and/or infinite examples, it may be handy to
truncate everything above a certain degree. In fact, we encountered
various examples where the polynomials are homogeneous and then it
makes perfect sense to truncate the polynomials, that is, to disregard
everything above a certain degree, as all S-polynomials the lower degree part
of the Gröbner basis can be found without these.
The functions of this variant can be found in Section <Ref Sect="truncfun"/>.
</Section>

<Section><Heading>Prefix and Two-Sided (PTS) variant</Heading>
<!--Gröbner basis record, which is explained in <Ref Sect="GBR"/>.-->

Given an ideal <M>I</M> in a free noncommutative algebra <M>A</M> generated by
a finite set <M>G</M>, and a positive integer <M>s</M>,
we can work with the free right <M>A/I</M> module
<M>(A/I)^s</M>. See <Ref Sect="NPM"/> on how
to represent elements of the free module <M>A^s</M>. 
Given a subset <M>W</M> of <M>A^s</M>, called the prefix relations, let
<M>W'</M> be submodule generated by the image of <M>W</M> in <M>(A/I)^s</M>.
The function <Ref Func="SGrobnerPTS" Style="Text"/> can be used to
determine the quotient module
<M>(A/I)^s/W'</M>.
</Section>

<Section Label="GBR"><Heading>Gröbner basis records</Heading>
	The function <Ref Func="SGrobnerPTS" Style="Text"/> calculates a
	Gröbner basis consisting of some two-sided relations in the algebra and
	some prefix or module relations in the vector space. These are returned
	in a record <C>GBR</C>. The two-sided relations can be found under the
	name <C>GBR.ts</C> and the prefix relations under the name <C>GBR.p</C>.
	Some other information is stored in this record as well.
	<P/>
	Note that the prefix conditions are in NPM format (see <Ref
		Subsect="NPM"/>), but the two-sided relations are not.
</Section>
</Chapter>
<Chapter>
	<Heading>Functions</Heading>
	<Section Label="TransitionFunctions"><Heading>Converting Polynomials
			into different formats</Heading>
		<#Include Label="GP2NP">
		<#Include Label="GP2NPList">
		<#Include Label="NP2GP">
		<#Include Label="NP2GPList">
	</Section>
	<Section Label="printing"><Heading>Printing polynomials in NP format</Heading>
		<#Include Label="GBNP.ConfigPrint">
		<#Include Label="PrintNP">
		<#Include Label="PrintNPList">
	</Section>
	<Section><Heading>Calculating with polynomials in NP format</Heading>
		<#Include Label="AddNP">
		<#Include Label="BimulNP">
		<#Include Label="CleanNP">
		<#Include Label="GtNP">
		<#Include Label="LtNP">
		<#Include Label="LTermsNP"> <!-- here ?? -->
		<#Include Label="MkMonicNP">
		<#Include Label="MulNP">
	</Section>
	<Section Label="grobner"><Heading>Gröbner functions, standard variant</Heading>
		<#Include Label="Grobner"> <!-- remove ?? -->
		<#Include Label="SGrobner">
	</Section>
	<Section Label="QA"><Heading>Finite dimensional quotient
		algebras</Heading>
		<#Include Label="BaseQA">
		<#Include Label="DimQA">
		<#Include Label="MatricesQA">
		<#Include Label="MatricesQAC">
		<#Include Label="MatrixQA">
		<#Include Label="MatrixQAC">
		<#Include Label="MulQA">
		<#Include Label="StrongNormalFormNP">
	</Section>
	<Section Label="finiteness"><Heading>Finiteness and Hilbert Series</Heading>
		<Subsection><Heading>Introduction</Heading>
This section contains some functions designed to obtain information on the 
dimensionality of the quotient algebra related to the Gröbner basis (the 
full polynomial ring modulo the two-sided ideal <A>I</A> generated by the 
Gröbner basis). All functions in this section work in the more general 
setting where we have a monomial ideal with a basis of which no element 
divides any other element. Throughout this section we speak of `obstructions' 
to refer to such elements. Note that this is a different obstruction than the 
one used in the rest of this documentation.<!-- XXX (if probably is better to
rename this kind of obstruction (and change the previous remark) -->
<P/>
The purpose of the functions <Ref Func="FinCheck" Style="Text"/>, <Ref Func="DetermineGrowth" Style="Text"/>, and <Ref Func="DetermineGrowthObs" Style="Text"/>
are all closely related. Their speed decreases in this order, while their 
functionality increases, as illustrated from the following table.
<P/>
<Table Align="l|l|l|l|">
	<Row>
		<Item>&nbsp;</Item>
		<Item><Ref Func="FinCheck" Style="Text"/></Item>
		<Item><Ref Func="DetermineGrowth" Style="Text"/></Item>
		<Item><Ref Func="DetermineGrowthObs" Style="Text"/></Item>
	</Row>
	<HorLine/>
	<Row>
		<Item>finite</Item>
		<Item><C>true</C></Item>
		<Item><C>"finite"</C></Item>
		<Item><C>0</C></Item>
	</Row>
	<Row>
		<Item>infinite (polyn., d)</Item>
		<Item><C>false</C></Item>
		<Item><C>d</C> or <C>[d1,d2]</C><!-- , s.t. <M>d_1\leq d\leq d_2</M>--></Item>
		<Item><C>d</C></Item>
	</Row>
	<Row>
		<Item>infinite (expon.)</Item>
		<Item><C>false</C></Item>
		<Item><C>"exponential growth"</C></Item>
		<Item><C>"exponential growth"</C></Item>
	</Row>
	<Caption>dimensionality functions</Caption>
</Table>
The function <Ref Func="DetermineGrowth" Style="Text"/> only sometimes finds
the exact dimension. If this is the case than that dimension is returned. If
only an interval could be found then the interval <C>[d1,d2]</C>, s.t.
<M>d_1\leq d\leq d_2</M> is returned.
<P/>

With the function <Ref Func="Preprocess" Style="Text"/>, the computations done by these 3 functions 
can be sped up. Note however that by applying preprocessing of the data, the 
set of `obstructions' is changed and corresponds no longer to the same quotient 
algebra (but to a quotient algebra with the same dimension).
		</Subsection>
		<#Include Label="DetermineGrowth">
		<#Include Label="DetermineGrowthObs">
		<#Include Label="FinCheck">
		<!--<#Include Label="GraphOfNormalWords">
		<#Include Label="GraphOfChains">
		<#Include Label="HilbertSeriesG">-->
		<#Include Label="HilbertSeries">
		<#Include Label="Preprocess">
	</Section>
	<Section Label="tracefun"><Heading>Functions of the
			trace-variant</Heading>
		<#Include Label="PrintTraceList">
		<#Include Label="PrintTracePol">
		<#Include Label="PrintNPListTrace">
		<#Include Label="SGrobnerTrace">
		<#Include Label="StrongNormalFormTraceNP">
	</Section>
	<Section Label="truncfun"><Heading>Functions of the truncated variant</Heading>
		<Subsection><Heading>Examples</Heading>
			More about these functions can be found in <Ref
				Sect="Example11"/> and in <Ref
				Sect="Example12"/>.
		</Subsection>
		<#Include Label="SGrobnerTrunc">
		<#Include Label="MakeArgumentList">
	</Section>
	<Section><Heading>Functions with prefix and two-sided rules</Heading>
		<#Include Label="BaseQAPTS">
		<#Include Label="DimQAPTS">
		<#Include Label="MulQAPTS">
		<#Include Label="SGrobnerPTS">
		<#Include Label="StrongNormalFormPTSNP">
	</Section>
</Chapter> 
<Chapter Label="Info"><Heading>Info Level</Heading>
<Section><Heading>Introduction</Heading>
A lot of the functions of this package can produce additional output. Such
output might be useful for long calculations, to see where the calculation is
or to gain more information about the calculation itself. For smaller
calculations this information is usually not necessary. 

<Package>GAP</Package> provides the tools to be able to tune the output of the
functions. All of the functions of this package use the <C>InfoClass</C> <Ref
	InfoClass="InfoGBNP" Style="Text"/>. As usual with gap when
this is left at 0, the functions will hardly give output. It can be set
to 1 or 2 with <C>SetInfoLevel</C> (more about this function can be found at <Ref BookName="Reference" Label="SetInfoLevel"/>). A brief
explanation about each infolevel will be given in the next sections.
</Section>
<Section><Heading>InfoGBNP</Heading>
<ManSection>
	<InfoClass Name="InfoGBNP" Comm="InfoClass for this package"/>
	<Description>
		The <C>InfoClass</C> for this package is used in almost all
		functions. To change this level to 1 (some information) or 2
		(more information, also information from calculation loops) use
		the function <C>SetInfoLevel</C>.
	</Description>
</ManSection>
<Subsection><Heading>What will be printed at level 0</Heading>
	At level 0 only the functions that are invoked to print give output.
	This include functions like <Ref Func="PrintNP" Style="Text"/>, <Ref
		Func="PrintNPList" Style="Text"/>, 
	<Ref Func="PrintTraceList" Style="Text"/> and
	<Ref Func="PrintNPListTrace" Style="Text"/>, but it also includes the
	function <Ref Func="DetermineGrowth" Style="Text"/>, which only prints
	one or two lines and <Ref Func="MakeArgumentList" Style="Text"/> which
	produces information about a truncated Gröbner basis.
</Subsection>
<Subsection><Heading>What will be printed at level 1</Heading>
	The infolevel can be set to 1 with the following command:
<Listing>
SetInfoLevel(InfoGBNP,1);
</Listing>
At level 1 some larger set of functions will produce a bit of output. Most of this
information reports on the phase of the algorithm the calculations
are in or some simple statistics about the input or output.
</Subsection>
<Subsection><Heading>What will be printed at level 2</Heading>
	The infolevel can be set to 2 with the following command.
<Listing>
SetInfoLevel(InfoGBNP,2);
</Listing>
At level 2 the larger functions will produce a lot of output. This mostly is
information from the loops in the calculations. The timing information will be
printed now aswell.
</Subsection>
<Subsection><Heading>What will be printed at level 3</Heading>
	The infolevel can be set to 3 with the following command:
<Listing>
SetInfoLevel(InfoGBNP,3);
</Listing>
At the moment there is nothing more that will be printed at level 3, but it is
possible that this level (and possibly higher levels) will be used for debug
purposes in the future.
</Subsection>
</Section>
<Section><Heading>InfoGBNPTime</Heading>
<ManSection>
	<InfoClass Name="InfoGBNPTime" Comm="InfoClass for timing information"/>
	<Description>
		The <C>InfoClass</C> for timing is used in producing some
		information about the runtime of the algorithm in certain
		possible lengthy calculations.
		<P/>
		To change this level to 1 (Gröbner functions give information)
		or 2 (more information, also information from other functions,
		which might not always take a long time and from inside loops)
		use the function <C>SetInfoLevel</C>. For more information see
		below.
	</Description>
</ManSection>
<Subsection><Heading>What will be printed at level 0</Heading>
	No timing information will be printed at level 0. This can be desired
	for small examples or when producing test output, for use with
	<C>ReadTest</C>.
</Subsection>
<Subsection><Heading>What will be printed at level 1</Heading>
	The infolevel can be set to 1 with the following command:
<Listing>
SetInfoLevel(InfoGBNPTime,1);
</Listing>
	At level one there will be time information printed by the functions
	from different variants producing Gröbner basis: 
	<Ref Func="Grobner" Style="Text"/>,<Ref Func="SGrobner" Style="Text"/>,
	<Ref Func="SGrobnerTrace" Style="Text"/> and <Ref Func="SGrobnerTrunc"
		Style="Text"/>
</Subsection>
<Subsection><Heading>What will be printed at level 2</Heading>
	The infolevel can be set to 2 with the following command:
<Listing>
SetInfoLevel(InfoGBNPTime,2);
</Listing>
	At level two there will also be some information printed from a loop
	from within <Ref Func="SGrobnerTrunc" Style="Text"/> and certain other
	functions will start to produce timing output. At the moment the only
	function that does this is <Ref Func="DimQA" Style="Text"/>, but this
	might be extended.
</Subsection>
<Subsection><Heading>What will be printed at level 3</Heading>
	The infolevel can be set to 3 with the following command:
<Listing>
SetInfoLevel(InfoGBNPTime,3);
</Listing>
	At the moment no extra timing information will be printed at level 3 or
	higher. In the future this may be used for debugging purposes.
</Subsection>
</Section>
</Chapter>
</Body>
<Appendix Label="Examples"><Heading>Examples</Heading>
	<Section Label="Examples_Introduction"><Heading>Introduction</Heading>
		In this Chapter all of the examples can be found with comments.
		The examples without comments can be found in the directory
		<F>gbnp/examples</F>.
		<#Include Label="timing">
<List>
	<Mark>example01.g</Mark><Item>A small commutative example (see <Ref
			Sect="Example01"/>) (General example).</Item>
	<Mark>example02.g</Mark><Item>A 157 dimensional truncated example (see
		also the Examples 11 and 12 in the Sections <Ref
			Sect="Example11"/> and <Ref Sect="Example12"/>)(see
		<Ref Sect="Example02"/>) (truncated example).</Item>
	<Mark>example03.g</Mark><Item>Computing the order of the Weyl group of
		type E6 (see <Ref Sect="Example03"/>) (General example).</Item>
	<Mark>example04.g</Mark><Item>A very simple example in 1 variable (see
		<Ref Sect="Example04"/>) (General example).</Item>
	<Mark>example05.g</Mark><Item>An example in 1 variable (see <Ref
			Sect="Example05"/>) (General example).</Item>
	<Mark>example06.g</Mark><Item>A commutative example from <Cite
			Key="CohenCuypersSterk1999"/>, page 339 (see <Ref
			Sect="Example06"/>) (General example, uses input
		conversion).</Item>
	<Mark>example07.g</Mark><Item>An example with the Birman-Murakami-Wenzl
		algebra for A3 (see <Ref Sect="Example07"/>) (General
		example).</Item>
	<Mark>example08.g</Mark><Item>An example with the Birman-Murakami-Wenzl
		algebra for A2 (see <Ref Sect="Example08"/>) (Example using the
		trace variant).</Item>
	<Mark>example09.g</Mark><Item>A small non-commutative example from
		<Cite Key="TCS::Mora1994:131"/>, page 18 (see <Ref
			Sect="Example09"/>) (General example).</Item>
	<Mark>example10.g</Mark><Item>A commutative example from <Cite
			Key="TCS::Mora1994:131"/>. The field is changed to
		<C>GF(7)</C> (see <Ref Sect="Example10"/>) (general example
		with a different field).</Item>
	<Mark>example11.g</Mark><Item>An example of the truncated variant (see
		<Ref Sect="Example11"/>) (Truncated example).</Item>
	<Mark>example12.g</Mark><Item>Another example of the truncated variant
		corresponding with example 2 (<Ref Sect="Example02"/>) (see
		<Ref Sect="Example12"/>) (Truncated example).</Item>
	<Mark>example13.g</Mark><Item>Example 3 (<Ref Sect="Example03"/>, order
		Weyl group of type E6) extended with a finiteness check (see
		<Ref Sect="Example13"/>) (General example, with finiteness
		check).</Item>
	<Mark>example14.g</Mark><Item>Example 3 (<Ref Sect="Example03"/>, order
		Weyl group of type E6) extended with a finiteness check and
		preprocessing(see <Ref Sect="Example14"/>) (General example,
		with finiteness check and preprocessing).</Item>
	<Mark>example15.g</Mark><Item>A small example with exponential growth
		(see <Ref Sect="Example15"/>) (example with finiteness
		checks).</Item>
	<Mark>example16.g</Mark><Item>Example 6 (<Ref Sect="Example06"/>), with
		growth analysis and Hilbert Series (see <Ref
			Sect="Example16"/>) (example about analyzing growth and
		the Hilbert Series).</Item>
	<Mark>example17.g</Mark><Item>A small example of using a finite field
		(see <Ref Sect="Example17"/>).</Item>
	<Mark>example18.g</Mark><Item>Module example, permutation module of
		dimension 4 of the dihedral group of order 8 (see <Ref
			Sect="Example18"/>).</Item>
	<Mark>example19.g</Mark><Item>Example 18 (<Ref Sect="Example18"/>), with the all ones vector fixed (see <Ref Sect="Example19"/>).</Item>
	<Mark>example20.g</Mark><Item>The dihedral group of example 18 (<Ref
			Sect="Example18"/>), now with module relations with two
		module generators (see <Ref Sect="Example20"/>).</Item>
	<Mark>example21.g</Mark><Item>Module example: the symmetric inverse
		monoid for a set of size four. There is a 4 dimensional
		representation (see <Ref Sect="Example21"/>).</Item>
	<Mark>example22.g</Mark><Item>Module example: Hecke Algebra of type
		A<M>_3</M> over GF(3), obtaining a 4 dimensional representation
		(see <Ref Sect="Example22"/>).</Item>
	<Mark>example23.g</Mark><Item>Example, where the dimension of a
		Generalized Temperley-Lieb Algebra of type A, D, or E is
		calculated (see <Ref Sect="Example23"/>).</Item>
</List>
</Section>
	<#Include Label="Example01">
	<#Include Label="Example02">
	<#Include Label="Example03">
	<#Include Label="Example04">
	<#Include Label="Example05">
	<#Include Label="Example06">
	<#Include Label="Example07">
	<#Include Label="Example08">
	<#Include Label="Example09">
	<#Include Label="Example10">
	<#Include Label="Example11">
	<#Include Label="Example12">
	<#Include Label="Example13">
	<#Include Label="Example14">
	<#Include Label="Example15">
	<#Include Label="Example16">
	<#Include Label="Example17">
	<#Include Label="Example18">
	<#Include Label="Example19">
	<#Include Label="Example20">
	<#Include Label="Example21">
	<#Include Label="Example22">
	<#Include Label="Example23">
</Appendix>
<Appendix>
<Heading>Files</Heading>
<Section><Heading>Files:Introduction</Heading>
	In the header of each file, you will find a list of the functions
	it contains. Above each funtion, there is a documentation. Only the
	global functions are also documented in the <Package>GAPDoc</Package>
	format and included here.
</Section>
<Section>
<Heading>Main files</Heading>
<List>
<Mark><File>grobnerall.g</File></Mark><Item>loads all other files listed
	below</Item>
<Mark><File>grobner.g</File></Mark><Item>Gröbner basis computation and quotient
	algebra multiplication</Item>
<Mark><File>trace.g</File></Mark><Item>Version with tracing of Gröbner basis
	computation</Item>
<Mark><File>trunc.g</File></Mark><Item>Truncated version of Gröbner basis
	computation</Item>
<Mark><File>fincheck.g</File></Mark><Item>quotient algebra analysis</Item>
</List>
<List>
<Mark><File>example??.g</File></Mark><Item>(??=01,...,16,20) files with
	examples, which can be used inspiration or for testing. More about the
	examples can be found in <Ref Sect="Examples_Introduction"/>.</Item>
</List>
</Section>

<Section>
<Heading>Auxiliary files</Heading>
These auxiliary files are usually automatically loaded by the above files.
<List>
<Mark><File>nparith.g</File></Mark><Item>NP (= Noncommutative Polynomial)
	arithmetic</Item>
<Mark><File>nparith2.g</File></Mark><Item>additional NP (= Noncommutative
	Polynomial) arithmetic for the trace version</Item>
<Mark><File>npformat.g</File></Mark><Item>transition from
	<Package>GAP</Package> native polynomial format to our NP format and
	back</Item>
<Mark><File>printing.g</File></Mark><Item>algorithms for printing the
	NPs</Item>
<Mark><File>printing2.g</File></Mark><Item>algorithms for printing the NPs
	expressed as linear combinations of the original basis, for the trace
	version of the program.</Item>
<Mark><File>tree.g</File></Mark><Item>operations on trees</Item>
<Mark><File>graphs.g</File></Mark><Item>operations to create graphs on
	monomials from the algebra setting</Item>
</List>
</Section>
</Appendix>

<Bibliography Databases="gbnp_doc" Style="plainurl"/>
<!-- -->
<TheIndex/>

</Book>
