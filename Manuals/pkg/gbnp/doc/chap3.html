<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (GBNP) - Chapter 3: Functions</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap3"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chapA.html">A</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4.html">[Next Chapter]</a>&nbsp;  </div>

<p><a id="X86FA580F8055B274" name="X86FA580F8055B274"></a></p>
<div class="ChapSects"><a href="chap3.html#X86FA580F8055B274">3 <span class="Heading">Functions</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X81ABB91B79E00229">3.1 <span class="Heading">Converting polynomials
			into different formats</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B0EBCBC7857F1AE">3.1-1 GP2NP</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7CF0ED937DDA5A7E">3.1-2 GP2NPList</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X86C3912F781ABEDC">3.1-3 NP2GP</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X844A23EA7D97150C">3.1-4 NP2GPList</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X78F44B01851B1020">3.2 <span class="Heading">Printing polynomials in NP format</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B63BEA87A8D6162">3.2-1 PrintNP</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7F7510A878045D3A">3.2-2 GBNP.ConfigPrint</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X832103DC79A9E9D0">3.2-3 PrintNPList</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X83DE3F817EA74727">3.3 <span class="Heading">Calculating with polynomials in NP format</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7DB3792385AAA805">3.3-1 NumAlgGensNP</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X865548F07C74AB0A">3.3-2 NumAlgGensNPList</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X782647C57D148379">3.3-3 NumModGensNP</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8119282084CA8076">3.3-4 NumModGensNPList</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X788E1ACA82A833A8">3.3-5 AddNP</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X84FC611A822D808F">3.3-6 BimulNP</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X855F3D4C783000E3">3.3-7 CleanNP</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7D05B60E83FDA567">3.3-8 GtNP</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8075AE7E7A8088FF">3.3-9 LtNP</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X86ECA4F57C720E45">3.3-10 LMonsNP</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X878A8C027DA25196">3.3-11 MkMonicNP</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7ABA720E87EFF040">3.3-12 MulNP</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X81381B2D83D2B9A9">3.4 <span class="Heading">Gröbner functions, standard variant</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7CD9F9C97B2563E2">3.4-1 Grobner</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7FEDA29E78B0CEED">3.4-2 SGrobner</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X80D4D22C7E643C7B">3.4-3 IsGrobnerBasis</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7D17F9027F08CF0B">3.4-4 IsStrongGrobnerBasis</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7E0105ED7FF4210F">3.4-5 IsGrobnerPair</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8752DA1A7CAF77D3">3.4-6 MakeGrobnerPair</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7F387F7780425B9A">3.5 <span class="Heading">Finite-dimensional quotient
		algebras</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7EAA04247B2C6330">3.5-1 BaseQA</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X81A50EEE7B56C723">3.5-2 DimQA</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7DFA841A8425DD94">3.5-3 MatrixQA</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X78E4BF2F7F0D5E74">3.5-4 MatricesQA</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X80C4D0E882B05FDF">3.5-5 MulQA</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8563683E7FA604F8">3.5-6 StrongNormalFormNP</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X79FE4A3983E2329F">3.6 <span class="Heading">Finiteness and Hilbert series</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X83C57C3A7DCF0471">3.6-1 DetermineGrowthQA</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X792E39A98717D779">3.6-2 FinCheckQA</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7CFD47367CF309EB">3.6-3 HilbertSeriesQA</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X863124677B933CEE">3.6-4 PreprocessAnalysisQA</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7BA5CAA07890F7AA">3.7 <span class="Heading">Functions of the
			trace variant</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X813454F6799B1D57">3.7-1 EvalTrace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X83D1560C7F2A04BA">3.7-2 PrintTraceList</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8039BEE77C070FB1">3.7-3 PrintTracePol</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7DD0B56D7BD6CD98">3.7-4 PrintNPListTrace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X78AE6EED83B97595">3.7-5 SGrobnerTrace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8219059A86A54130">3.7-6 StrongNormalFormTraceDiff</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7E4E3AD07B2465F9">3.8 <span class="Heading">Functions of the truncated variant</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7A489A5D79DA9E5C">3.8-1 <span class="Heading">Examples</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7CD043E081BF2302">3.8-2 SGrobnerTrunc</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X83C9E598798D5809">3.8-3 CheckHomogeneousNPs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7E33C064875D95CA">3.8-4 BaseQATrunc</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7C6882DB837A9F5A">3.8-5 DimsQATrunc</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7FBA7F1D79DA883F">3.8-6 FreqsQATrunc</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X8706DD3287E82019">3.9 <span class="Heading">Functions of the module variant</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X860966487ED88A43">3.9-1 SGrobnerModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7E3160E67C504F37">3.9-2 BaseQM</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X813E6A2C8709C9F3">3.9-3 DimQM</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X805FB42A7EEF510F">3.9-4 MulQM</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X87D51A8379C50A80">3.9-5 StrongNormalFormNPM</a></span>
</div></div>
</div>

<h3>3 <span class="Heading">Functions</span></h3>

<p><a id="X81ABB91B79E00229" name="X81ABB91B79E00229"></a></p>

<h4>3.1 <span class="Heading">Converting polynomials
			into different formats</span></h4>

<p><a id="X7B0EBCBC7857F1AE" name="X7B0EBCBC7857F1AE"></a></p>

<h5>3.1-1 GP2NP</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GP2NP</code>( <var class="Arg">gp</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: If <var class="Arg">gp</var> is an element of a free algebra, then the polynomial in NP format (see Section <a href="chap2.html#X7FDF3E5E7F33D3A2"><span class="RefLink">2.1</span></a>) corresponding to <var class="Arg">gp</var>; if <var class="Arg">gp</var> is an element of a free module, then the vector in NPM format (see Section <a href="chap2.html#X7B27E2D1784538DE"><span class="RefLink">2.2</span></a>) corresponding to <var class="Arg">gp</var>.</p>

<p>This function will convert an element of a free algebra to a polynomial in NP format and an element of a free right module to a vector in NPM format.</p>

<p><em>Example:</em> Let <code class="code">A</code> be the free associative algebra with one over the rationals on the generators <code class="code">a</code> and <code class="code">b</code>. Let <code class="code">e</code> be the one of the algebra.</p>


<div class="example"><pre>
gap&gt; A:=FreeAssociativeAlgebraWithOne(Rationals,"a","b");;
gap&gt; a:=A.a;;
gap&gt; b:=A.b;;
gap&gt; e:=One(A);;
gap&gt; z:=Zero(A);;
</pre></div>

<p>Now let <code class="code">gp</code> be the polynomial <span class="SimpleMath">ba-ab-e</span>.</p>


<div class="example"><pre>
gap&gt; gp:=b*a-a*b-e;
(-1)*&lt;identity ...&gt;+(-1)*a*b+(1)*b*a
</pre></div>

<p>The polynomial in NP format, corresponding to <code class="code">gp</code> can now be obtained with GP2NP:</p>


<div class="example"><pre>
gap&gt; GP2NP(gp);
[ [ [ 2, 1 ], [ 1, 2 ], [  ] ], [ 1, -1, -1 ] ]
</pre></div>

<p>Let <code class="code">D</code> be the free associative algebra over <code class="code">A</code> of rank 2.</p>


<div class="example"><pre>
gap&gt; D := A^2;;
</pre></div>

<p>Take the following list <code class="code">R</code> of two elements of <code class="code">D</code>.</p>


<div class="example"><pre>
gap&gt; R := [ [b-e, z], [e+a*(e+a+b), -e-a*(e+a+b)] ];;
</pre></div>

<p>Convert the list <code class="code">R</code> to a list of vectors in NPM format.</p>


<div class="example"><pre>
gap&gt; List(R,GP2NP);
[ [ [ [ -1, 2 ], [ -1 ] ], [ 1, -1 ] ], 
  [ [ [ -1, 1, 2 ], [ -1, 1, 1 ], [ -2, 1, 2 ], [ -2, 1, 1 ], [ -1, 1 ], 
          [ -2, 1 ], [ -1 ], [ -2 ] ], [ 1, 1, -1, -1, 1, -1, 1, -1 ] ] ]
</pre></div>

<p><a id="X7CF0ED937DDA5A7E" name="X7CF0ED937DDA5A7E"></a></p>

<h5>3.1-2 GP2NPList</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GP2NPList</code>( <var class="Arg">Lgp</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The list of polynomials in NP or NPM format corresponding to elements of a free algebra or module occurring in the list <var class="Arg">Lgp</var>.</p>

<p>This function has the same effect as <code class="code">List(Lgp,GBNP)</code>.</p>

<p><em>Example:</em> Let <code class="code">A</code> be the free associative algebra with one over the rationals on the generators <code class="code">a</code> and <code class="code">b</code>. Let <code class="code">e</code> be the one of the algebra.</p>


<div class="example"><pre>
gap&gt; A:=FreeAssociativeAlgebraWithOne(Rationals,"a","b");;
gap&gt; a:=A.a;;
gap&gt; b:=A.b;;
gap&gt; e:=One(A);;
</pre></div>

<p>Let <code class="code">Lgp</code> be the list of polynomials <span class="SimpleMath">[a^2-e,b^2-e,ba-ab-e]</span>.</p>


<div class="example"><pre>
gap&gt; Lgp:=[a^2-e,b^2-e,b*a-a*b-e];
[ (-1)*&lt;identity ...&gt;+(1)*a^2, (-1)*&lt;identity ...&gt;+(1)*b^2, 
  (-1)*&lt;identity ...&gt;+(-1)*a*b+(1)*b*a ]
</pre></div>

<p>The polynomial in NP format corresponding to <code class="code">gp</code> can be obtained with GP2NP:</p>


<div class="example"><pre>
gap&gt; GP2NPList(Lgp);
[ [ [ [ 1, 1 ], [  ] ], [ 1, -1 ] ], [ [ [ 2, 2 ], [  ] ], [ 1, -1 ] ], 
  [ [ [ 2, 1 ], [ 1, 2 ], [  ] ], [ 1, -1, -1 ] ] ]
</pre></div>

<p>The same result is obtained by a simple application of the standard List function in GAP:</p>


<div class="example"><pre>
gap&gt; List(Lgp,GP2NP) = GP2NPList(Lgp);
true
</pre></div>

<p><a id="X86C3912F781ABEDC" name="X86C3912F781ABEDC"></a></p>

<h5>3.1-3 NP2GP</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NP2GP</code>( <var class="Arg">np</var>, <var class="Arg">A</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The GAP format of the polynomial <var class="Arg">np</var> in NP format.</p>

<p>This function will convert a polynomial in NP format to a GAP polynomial in the free associative algebra <var class="Arg">A</var> and a vector in NPM format to a GAP vector in the free module <var class="Arg">A</var>. In case of the NP format, the number of variables should not exceed the rank of the free algebra <var class="Arg">A</var>. In case of the NPM format, the absolute of the negative numbers should not exceed the rank of the free module <var class="Arg">A</var>.</p>

<p><em>Example:</em> Let <code class="code">A</code> be the free associative algebra with one over the rationals on the generators <code class="code">a</code> and <code class="code">b</code>.</p>


<div class="example"><pre>
gap&gt; A:=FreeAssociativeAlgebraWithOne(GF(3),"a","b");;
</pre></div>

<p>Let <code class="code">np</code> be a polynomial in NP format.</p>


<div class="example"><pre>
gap&gt; np:=[ [ [ 2, 1 ], [ 1, 2 ], [  ] ], [ Z(3)^0, Z(3), Z(3) ] ];;
</pre></div>

<p>The polynomial can be converted to the corresponding element of <var class="Arg">A</var> with NP2GP:</p>


<div class="example"><pre>
gap&gt; NP2GP(np,A);
(Z(3)^0)*b*a+(Z(3))*a*b+(Z(3))*&lt;identity ...&gt;
</pre></div>

<p>Note that some information of the coefficient field of a polynomial <code class="code">np</code> in NP format can be obtained from the second list of <code class="code">np</code>.</p>


<div class="example"><pre>
gap&gt; One(np[2][1]);
Z(3)^0
</pre></div>

<p>Now let <code class="code">M</code> be the module <code class="code">A^2</code> and let <code class="code">npm</code> be a polynomial over that module in NPM form.</p>


<div class="example"><pre>
gap&gt; M:=A^2;;
gap&gt; npm:=[ [ [ -1, 1 ], [ -2, 2 ] ], [ Z(3)^0, Z(3)^0 ] ];;
</pre></div>

<p>The element of <var class="Arg">M</var> corresponding to <code class="code">npm</code> is</p>


<div class="example"><pre>
gap&gt; NP2GP(npm,M);
[ (Z(3)^0)*a, (Z(3)^0)*b ]
</pre></div>

<p>If <code class="code">M</code> is a module of dimension 2 over <code class="code">A</code> and <code class="code">Lnp</code> a list of polynomials in NPM format, then the polynomials can be converted to the corresponding polynomials of <code class="code">M</code> as follows:</p>


<div class="example"><pre>
gap&gt; M:=A^2;;
gap&gt; Lnp:=[ [ [ [ -2, 1, 1 ], [ -2, 1 ] ], [ 1, -1 ] ],
&gt;   [ [ [ -1, 2, 2], [-2, 1 ] ], [ 1, -1 ]*Z(3)^0 ] ];;
gap&gt; List(Lnp, m -&gt; NP2GP(m,M));
[ [ &lt;zero&gt; of ..., (Z(3))*a+(Z(3)^0)*a^2 ], [ (Z(3)^0)*b^2, (Z(3))*a ] ]
</pre></div>

<p><a id="X844A23EA7D97150C" name="X844A23EA7D97150C"></a></p>

<h5>3.1-4 NP2GPList</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NP2GPList</code>( <var class="Arg">Lnp</var>, <var class="Arg">A</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The list of polynomials corresponding to <var class="Arg">Lnp</var> in GAP format.</p>

<p>This function will convert the list <var class="Arg">Lnp</var> of polynomials in NP format to a list of GAP polynomials in the free associative algebra <var class="Arg">A</var>.</p>

<p><em>Example:</em> Let <code class="code">A</code> be the free associative algebra with one over the rationals on the generators <code class="code">a</code> and <code class="code">b</code>.</p>


<div class="example"><pre>
gap&gt; A:=FreeAssociativeAlgebraWithOne(Rationals,"a","b");;
</pre></div>

<p>Let <code class="code">Lnp</code> be a list of polynomials in NP format. Then <code class="code">Lnp</code> can be converted to a list of polynomials of <code class="code">A</code> with NP2GPList:</p>


<div class="example"><pre>
gap&gt; Lnp:=[ [ [ [ 1, 1, 1 ], [ 1 ] ], [ 1, -1 ] ],
&gt;   [ [ [ 2, 2 ], [ ] ], [ 1, -1 ] ] ];;
gap&gt; NP2GPList(Lnp,A);
[ (1)*a^3+(-1)*a, (1)*b^2+(-1)*&lt;identity ...&gt; ]
</pre></div>

<p>It has the same effect as the function <code class="code">List</code> applied as follows.</p>


<div class="example"><pre>
gap&gt; List(Lnp, p -&gt; NP2GP(p,A));
[ (1)*a^3+(-1)*a, (1)*b^2+(-1)*&lt;identity ...&gt; ]
</pre></div>

<p>Now let <code class="code">M</code> be a module of dimension 2 over <code class="code">A</code> and <code class="code">Lnp</code> a list of vectors in NPM format. Then polynomials <code class="code">Lnp</code> can be converted to the corresponding vectors of <code class="code">M</code> with NP2GPList:</p>


<div class="example"><pre>
gap&gt; M:=A^2;;
gap&gt; Lnp:=[ [ [ [ -2, 1, 1 ], [ -2, 1 ] ], [ 1, -1 ] ],
&gt;   [ [ [ -1, 1 ], [ -2 ] ], [ 1, -1 ] ] ];;
gap&gt; NP2GPList(Lnp,M);
[ [ &lt;zero&gt; of ..., (-1)*a+(1)*a^2 ], [ (1)*a, (-1)*&lt;identity ...&gt; ] ]
</pre></div>

<p>The same result can be obtained by application of the standard List function:</p>


<div class="example"><pre>
gap&gt; List(Lnp, m -&gt; NP2GP(m,M)) = NP2GPList(Lnp,M) ;
true
</pre></div>

<p><a id="X78F44B01851B1020" name="X78F44B01851B1020"></a></p>

<h4>3.2 <span class="Heading">Printing polynomials in NP format</span></h4>

<p><a id="X7B63BEA87A8D6162" name="X7B63BEA87A8D6162"></a></p>

<h5>3.2-1 PrintNP</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PrintNP</code>( <var class="Arg">np</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>This function prints a polynomial <var class="Arg">np</var> in NP format, using the letters <code class="code">a</code>, <code class="code">b</code>, <code class="code">c</code>, <span class="SimpleMath">...</span> for <span class="SimpleMath">x_1</span>, <span class="SimpleMath">x_2</span>, <span class="SimpleMath">x_3</span>, <span class="SimpleMath">...</span>, except that everything beyond <span class="SimpleMath">l</span> (the 12-th letter) is printed as <span class="SimpleMath">x</span>.</p>

<p>This function prints a polynomial <var class="Arg">np</var> in NP format as configured by the function <code class="func">GBNP.ConfigPrint</code> (<a href="chap3.html#X7F7510A878045D3A"><span class="RefLink">3.2-2</span></a>).</p>

<p><em>Example:</em> Consider the following polynomial in NP format.</p>


<div class="example"><pre>
gap&gt; p := [[[1,1,2],[1,2,2],[]],[1,-2,3]];;
</pre></div>

<p>It can be printed in the guise of a polynomial in <code class="code">a</code> and <code class="code">b</code> by the function <code class="code">PrintNP</code>:</p>


<div class="example"><pre>
gap&gt; PrintNP(p);
 a^2b - 2ab^2 + 3 
</pre></div>

<p><a id="X7F7510A878045D3A" name="X7F7510A878045D3A"></a></p>

<h5>3.2-2 GBNP.ConfigPrint</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GBNP.ConfigPrint</code>( <var class="Arg">arg</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>By default the generators of the algebra are printed as <code class="code">a</code>, ..., <code class="code">l</code> and everything after the twelfth generator as <code class="code">x</code>. By calling <code class="code">ConfigPrint</code> it is possible to alter this printing convention. The argument(s) will be an algebra or arguments used for naming algebras in GAP upon creation. More specifically, we have the following choices.</p>


<dl>
<dt><strong class="Mark"><em>no arguments</em></strong></dt>
<dd><p>When the function is invoked without arguments the printing is reset to the default (see above).</p>

</dd>
<dt><strong class="Mark">algebra</strong></dt>
<dd><p>When the function is invoked with an algebra as argument, generators will be printed as they would be in the algebra.</p>

</dd>
<dt><strong class="Mark">algebra,integer</strong></dt>
<dd><p>When the function is invoked with an algebra and an integer <var class="Arg">n</var> as arguments, generators will be printed as they would be in the algebra and seperated over the <var class="Arg">n</var> dimensions.</p>

</dd>
<dt><strong class="Mark">leftmodule</strong></dt>
<dd><p>When the function is invoked with an leftmodule <span class="SimpleMath">A^n</span> of an associative algebra as argument, generators will be printed as they would be in the algebra, seperated over the <var class="Arg">n</var> dimensions.</p>

</dd>
<dt><strong class="Mark">string</strong></dt>
<dd><p>When the function is invoked with a string as its argument, it is assumed that there is only 1 generator and that this should be named as indicated by the string.</p>

</dd>
<dt><strong class="Mark">integer</strong></dt>
<dd><p>When the function is invoked with an integer as its argument, the <var class="Arg">n</var>-th generator will be printed as <code class="code">x.&lt;n&gt;</code>.</p>

</dd>
<dt><strong class="Mark">integer, string</strong></dt>
<dd><p>When the function is invoked with a non-negative integer and a string as its arguments, generators will be printed as <code class="code">&lt;s&gt;.&lt;n&gt;</code>, where <code class="code">&lt;s&gt;</code> is the string given as argument and <code class="code">&lt;n&gt;</code> the number of the generator. There is no checking whether the number given as argument is really the dimension. So it is possible that higher numbers return in the output. This way of input is useful however, because it is a distinction from the one-dimensional case and compatible with the way a free algebra is created.</p>

</dd>
<dt><strong class="Mark">string, string, ..., string</strong></dt>
<dd><p>When the function is invoked with a sequence of strings, then generators will be printed with the corresponding string or <code class="code">x</code> if the sequence is not long enough.</p>

</dd>
</dl>
<p><em>Example:</em> Consider the following two polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,2],[]],[1,-1]];;
gap&gt; p2 := [[[1,2,2],[]],[1,-1]];;
</pre></div>

<p>They can be printed by the function <code class="code">PrintNP</code>.</p>


<div class="example"><pre>
gap&gt; PrintNP(p1);
 a^2b - 1 
gap&gt; PrintNP(p2);
 ab^2 - 1 
</pre></div>

<p>We can let the variables be printed as <code class="code">x</code> and <code class="code">y</code> instead of <code class="code">a</code> and <code class="code">b</code> by means of <code class="func">GBNP.ConfigPrint</code>.</p>


<div class="example"><pre>
gap&gt; GBNP.ConfigPrint("x","y");
gap&gt; PrintNP(p1);
 x^2y - 1 
gap&gt; PrintNP(p2);
 xy^2 - 1 
</pre></div>

<p>We can also let the variables be printed as <code class="code">x.1</code> and <code class="code">x.2</code> instead of <code class="code">a</code> and <code class="code">b</code> by means of <code class="func">GBNP.ConfigPrint</code>.</p>


<div class="example"><pre>
gap&gt; GBNP.ConfigPrint(2,"x");
gap&gt; PrintNP(p1);
 x.1^2x.2 - 1 
gap&gt; PrintNP(p2);
 x.1x.2^2 - 1 
</pre></div>

<p>We can even assign strings to the variables to be printed like <code class="code">alice</code> and <code class="code">bob</code> instead of <code class="code">a</code> and <code class="code">b</code> by means of <code class="func">GBNP.ConfigPrint</code>.</p>


<div class="example"><pre>
gap&gt; GBNP.ConfigPrint("alice","bob");
gap&gt; PrintNP(p1);
 alice^2bob - 1 
gap&gt; PrintNP(p2);
 alicebob^2 - 1 
</pre></div>

<p>Alternatively, we can introduce the free algebra <var class="Arg">A</var> with two generators, and print the polynomials as members of <var class="Arg">A</var>:</p>


<div class="example"><pre>
gap&gt; A:=FreeAssociativeAlgebraWithOne(Rationals,"a","b");;
gap&gt; GBNP.ConfigPrint(A);
gap&gt; PrintNP(p1);
 a^2b - 1 
gap&gt; PrintNP(p2);
 ab^2 - 1 
</pre></div>

<p><a id="X832103DC79A9E9D0" name="X832103DC79A9E9D0"></a></p>

<h5>3.2-3 PrintNPList</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PrintNPList</code>( <var class="Arg">Lnp</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>This function prints a list <var class="Arg">Lnp</var> of polynomials in NP format, using the function <code class="code">PrintNP</code>.</p>

<p><em>Example:</em> We put two polynomials in NP format into the list <code class="code">Lnp</code>.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,2],[]],[1,-1]];;
gap&gt; p2 := [[[1,2,2],[]],[1,-1]];;
gap&gt; Lnp := [p1,p2];;
</pre></div>

<p>We can print the list with <code class="func">PrintNPList</code>.</p>


<div class="example"><pre>
gap&gt; PrintNPList(Lnp);
 a^2b - 1 
 ab^2 - 1 
</pre></div>

<p>Alternatively, using the function <code class="func">GBNP.ConfigPrint</code> (<a href="chap3.html#X7F7510A878045D3A"><span class="RefLink">3.2-2</span></a>), we can introduce the free algebra <var class="Arg">A</var> with two generators, and print the polynomials of the list as members of <var class="Arg">A</var>:</p>


<div class="example"><pre>
gap&gt; A:=FreeAssociativeAlgebraWithOne(Rationals,"a","b");;
gap&gt; GBNP.ConfigPrint(A);
gap&gt; PrintNPList(Lnp);
 a^2b - 1 
 ab^2 - 1 
</pre></div>

<p><a id="X83DE3F817EA74727" name="X83DE3F817EA74727"></a></p>

<h4>3.3 <span class="Heading">Calculating with polynomials in NP format</span></h4>

<p><a id="X7DB3792385AAA805" name="X7DB3792385AAA805"></a></p>

<h5>3.3-1 NumAlgGensNP</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NumAlgGensNP</code>( <var class="Arg">np</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The minimum number <code class="code">t</code> so that <var class="Arg">np</var> belongs to the free algebra on <code class="code">t</code> generators.</p>

<p>When called with an NP polynomial <var class="Arg">np</var>, this function returns the minimum number of generators needed for the corresponding algebra to contain the <var class="Arg">np</var>. If <var class="Arg">np</var> is a polynomial without generators, that is, equivalent to <span class="SimpleMath">0</span> or <span class="SimpleMath">1</span>, then <code class="code">0</code> is returned.</p>

<p><em>Example:</em> Consider the following polynomial in NP format.</p>


<div class="example"><pre>
gap&gt; np := [[[2,2,2,1,1,1],[4],[3,2,3]],[1,-3,2]];;
gap&gt; PrintNP(np);
 b^3a^3 - 3d + 2cbc 
gap&gt; NumAlgGensNP(np);
4
</pre></div>

<p><a id="X865548F07C74AB0A" name="X865548F07C74AB0A"></a></p>

<h5>3.3-2 NumAlgGensNPList</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NumAlgGensNPList</code>( <var class="Arg">Lnp</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The minimum number <code class="code">t</code> so that each polynomial in <var class="Arg">Lnp</var> belongs to the free algebra on <code class="code">t</code> generators.</p>

<p>When called with a list of NP polynomials <var class="Arg">Lnp</var>, this function returns the minimum number of generators needed for the corresponding algebra to contain the NP polynomials in <var class="Arg">Lnp</var>. If <var class="Arg">Lnp</var> only contains polynomials without generators, that is equivalent to <span class="SimpleMath">0</span> and <span class="SimpleMath">1</span>, then <code class="code">0</code> is returned.</p>

<p><em>Example:</em> Consider the following two polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,2,3,1],[2],[1]],[1,-2,1]];;
gap&gt; p2 := [[[2,2,1,4,3],[]],[1,-1]];;
gap&gt; PrintNPList([p1,p2]);
 a^2bca - 2b + a 
 b^2adc - 1 
gap&gt; NumAlgGensNPList([p1,p2]);
4
</pre></div>

<p><a id="X782647C57D148379" name="X782647C57D148379"></a></p>

<h5>3.3-3 NumModGensNP</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NumModGensNP</code>( <var class="Arg">npm</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The minimum number <code class="code">mt</code> so that <var class="Arg">npm</var> belongs to the free module on <code class="code">mt</code> generators.</p>

<p>When called with a polynomial <var class="Arg">npm</var> in NPM format, this function returns the minimum number of module generators needed for the corresponding algebra to contain <var class="Arg">npm</var>. If <var class="Arg">npm</var> is an NP polynomial that does not contain module generators, then <code class="code">0</code> is returned.</p>

<p><em>Example:</em> Consider the following polynomial in NPM format.</p>


<div class="example"><pre>
gap&gt; np := [[[-1,1,2,3,1],[-2],[-1]],[1,-2,1]];;
gap&gt; PrintNP(np);
[ abca + 1 , - 2 ]
gap&gt; NumModGensNP(np);
2
</pre></div>

<p><a id="X8119282084CA8076" name="X8119282084CA8076"></a></p>

<h5>3.3-4 NumModGensNPList</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NumModGensNPList</code>( <var class="Arg">Lnpm</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The minimum number <code class="code">mt</code> so that each member of <var class="Arg">npm</var> belongs to the free module on <code class="code">mt</code> generators.</p>

<p>When called with a list of polynomials <var class="Arg">Lnpm</var> in NPM format, this function returns the minimum number of module generators needed to contain the polynomials in <var class="Arg">Lnpm</var>. If there are only polynomials in <var class="Arg">Lnpm</var> in NP format, then <code class="code">0</code> is returned.</p>

<p><em>Example:</em> Consider the following two polynomials in NPM format.</p>


<div class="example"><pre>
gap&gt; v1 := [[[-1,1,2,3,1],[-2],[-1]],[1,-2,1]];;
gap&gt; v2 := [[[-2,2,1,4,3],[-3]],[1,-1]];;
gap&gt; PrintNPList([v1,v2]);
[ abca + 1 , - 2 ]
[ 0, badc , - 1 ]
gap&gt; NumModGensNPList([v1,v2]);
3
</pre></div>

<p><a id="X788E1ACA82A833A8" name="X788E1ACA82A833A8"></a></p>

<h5>3.3-5 AddNP</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AddNP</code>( <var class="Arg">u</var>, <var class="Arg">v</var>, <var class="Arg">c</var>, <var class="Arg">d</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: <var class="Arg">c</var><span class="SimpleMath">*</span><var class="Arg">u</var><span class="SimpleMath">+</span><var class="Arg">d</var><span class="SimpleMath">*</span><var class="Arg">v</var></p>

<p>Computes <var class="Arg">c</var><span class="SimpleMath">*</span><var class="Arg">u</var><span class="SimpleMath">+</span><var class="Arg">d</var><span class="SimpleMath">*</span><var class="Arg">v</var> where <var class="Arg">u</var> and <var class="Arg">v</var> are polynomials in NP format and <var class="Arg">c</var> and <var class="Arg">d</var> are scalars.</p>

<p><em>Example:</em> Consider the following two polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,2],[]],[1,-3]];;
gap&gt; p2 := [[[1,2,2],[]],[1,-4]];;
</pre></div>

<p>The second can be subtracted from the first by the function <code class="code">AddNP</code>.</p>


<div class="example"><pre>
gap&gt; PrintNP(AddNP(p1,p2,1,-1));
 - ab^2 + a^2b + 1 
</pre></div>

<p><a id="X84FC611A822D808F" name="X84FC611A822D808F"></a></p>

<h5>3.3-6 BimulNP</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BimulNP</code>( <var class="Arg">ga</var>, <var class="Arg">np</var>, <var class="Arg">dr</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: the polynomial <var class="Arg">ga</var><span class="SimpleMath">*</span><var class="Arg">np</var><span class="SimpleMath">*</span><var class="Arg">dr</var> in NP format</p>

<p>When called with a polynomial <var class="Arg">np</var> and two monomials <var class="Arg">ga</var>, <var class="Arg">dr</var>, the function will return <var class="Arg">ga</var><span class="SimpleMath">*</span><var class="Arg">np</var><span class="SimpleMath">*</span><var class="Arg">dr</var>. Recall from Section <a href="chap2.html#X7FDF3E5E7F33D3A2"><span class="RefLink">2.1</span></a> that monomials are represented as lists.</p>

<p><em>Example:</em> Consider the following two polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,2],[]],[1,-3]];;
gap&gt; p2 := [[[1,2,2],[]],[1,-4]];;
</pre></div>

<p>Multiplying <code class="code">p1</code> from the right by <code class="code">b</code> and multiplying <code class="code">p2</code> from the left by <code class="code">a</code> is possible with the function <code class="code">BimulNP</code>:</p>


<div class="example"><pre>
gap&gt; PrintNP(BimulNP([],p1,[2]));
 a^2b^2 - 3b 
gap&gt; PrintNP(BimulNP([1],p2,[]));
 a^2b^2 - 4a 
</pre></div>

<p><a id="X855F3D4C783000E3" name="X855F3D4C783000E3"></a></p>

<h5>3.3-7 CleanNP</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CleanNP</code>( <var class="Arg">u</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The cleaned up version of <var class="Arg">u</var></p>

<p>Given a polynomial in NP format, this function collects terms with same monomial, removes trivial monomials, and orders the monomials, with biggest one first.</p>

<p><em>Example:</em> Consider the following polynomial in NP format.</p>


<div class="example"><pre>
gap&gt; p := [[[1,1,2],[],[1,1,2],[]],[1,-3,-2,3]];;
gap&gt; PrintNP(p);
 a^2b - 3 - 2a^2b + 3 
</pre></div>

<p>The monomials <code class="code">[1,1,2]</code> and <code class="code">[]</code> occur twice each. For many functions this representation of a polynomial in NP format is not allowed. It needs to be cleaned, as by <code class="func">CleanNP</code>:</p>


<div class="example"><pre>
gap&gt; PrintNP(CleanNP(p));
 - a^2b 
</pre></div>

<p>In order to define a polynomial over <span class="SimpleMath">GF(2)</span>, the coefficients need to be defined over this field. Such a list of coefficients can be obtained in GAP from a list of integers by multiplying with the identity element of the field. The resulting polynomial need not be clean, and so should be made clean again with <code class="code">CleanNP</code>.</p>


<div class="example"><pre>
gap&gt; p := [[[1,1,2],[]],One(GF(2))*[1,-2]];;
gap&gt; CleanNP(p);
[ [ [ 1, 1, 2 ] ], [ Z(2)^0 ] ]
</pre></div>

<p><a id="X7D05B60E83FDA567" name="X7D05B60E83FDA567"></a></p>

<h5>3.3-8 GtNP</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GtNP</code>( <var class="Arg">u</var>, <var class="Arg">v</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: <code class="code">true</code> if <span class="SimpleMath">u &gt; v</span> and <code class="code">false</code> if <span class="SimpleMath">u ≤ v</span></p>

<p>Greater than function for monomials <var class="Arg">u</var> and <var class="Arg">v</var> represented as in Section <a href="chap2.html#X7FDF3E5E7F33D3A2"><span class="RefLink">2.1</span></a>. It tests whether <var class="Arg">u</var><span class="SimpleMath">&gt;</span><var class="Arg">v</var>. The ordering is done by degree and then lexicographically.</p>

<p><em>Example:</em> Consider the following two monomials.</p>


<div class="example"><pre>
gap&gt; u := [1,1,2];
[ 1, 1, 2 ]
gap&gt; v := [2,2,1];
[ 2, 2, 1 ]
</pre></div>

<p>We test whether <code class="code">u</code> is greater than <code class="code">v</code>.</p>


<div class="example"><pre>
gap&gt; GtNP(u,v);
false
</pre></div>

<p><a id="X8075AE7E7A8088FF" name="X8075AE7E7A8088FF"></a></p>

<h5>3.3-9 LtNP</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LtNP</code>( <var class="Arg">u</var>, <var class="Arg">v</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: <code class="code">true</code> if <span class="SimpleMath">u &lt; v</span> and <code class="code">false</code> if <span class="SimpleMath">u ≥ v</span></p>

<p>Less than function for NP monomials, tests whether <var class="Arg">u</var><span class="SimpleMath">&lt;</span><var class="Arg">v</var>. The ordering is done by degree and then lexicographically.</p>

<p><em>Example:</em> Consider the following two monomials.</p>


<div class="example"><pre>
gap&gt; u := [1,1,2];
[ 1, 1, 2 ]
gap&gt; v := [2,2,1];
[ 2, 2, 1 ]
</pre></div>

<p>We test whether <code class="code">u</code> is less than <code class="code">v</code>.</p>


<div class="example"><pre>
gap&gt; LtNP(u,v);
true
</pre></div>

<p><a id="X86ECA4F57C720E45" name="X86ECA4F57C720E45"></a></p>

<h5>3.3-10 LMonsNP</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LMonsNP</code>( <var class="Arg">Lnp</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: A list of leading monomials</p>

<p>This function returns the leading monomials of a list <var class="Arg">Lnp</var> of polynomials in NP format. The polynomials of <var class="Arg">Lnp</var> are required to be clean; see Section <a href="chap3.html#X855F3D4C783000E3"><span class="RefLink">3.3-7</span></a>.</p>

<p><em>Example:</em> We put two polynomials in NP format into the list <code class="code">Lnp</code>.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,2],[]],[1,-1]];;
gap&gt; p2 := [[[1,2,2],[]],[1,-1]];;
gap&gt; Lnp := [p1,p2];;
</pre></div>

<p>The list of leading monomials is computed by <code class="code">LMonsNP</code>:</p>


<div class="example"><pre>
gap&gt; LMonsNP(Lnp);
[ [ 1, 1, 2 ], [ 1, 2, 2 ] ]
</pre></div>

<p>For a nicer printing, the monomials can be converted into polynomials in NP format, and then submitted to PrintNPList:</p>


<div class="example"><pre>
gap&gt; PrintNPList(List(LMonsNP(Lnp), q -&gt; [[q],[1]]));
 a^2b 
 ab^2 
</pre></div>

<p><a id="X878A8C027DA25196" name="X878A8C027DA25196"></a></p>

<h5>3.3-11 MkMonicNP</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MkMonicNP</code>( <var class="Arg">np</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: <var class="Arg">np</var> made monic</p>

<p>This function returns the scalar multiple of a polynomial <var class="Arg">np</var> in NP format that is monic, i.e., has leading coefficient equal to 1.</p>

<p><em>Example:</em> Consider the following polynomial in NP format.</p>


<div class="example"><pre>
gap&gt; p := [[[1,1,2],[]],[2,-1]];;
gap&gt; PrintNP(p);
 2a^2b - 1 
</pre></div>

<p>The coefficient of the leading term is <span class="SimpleMath">2</span>. The function <code class="code">MkMonicNP</code> finds this coefficient and divides all terms by it:</p>


<div class="example"><pre>
gap&gt; PrintNP(MkMonicNP(p));
 a^2b - 1/2 
</pre></div>

<p><a id="X7ABA720E87EFF040" name="X7ABA720E87EFF040"></a></p>

<h5>3.3-12 MulNP</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MulNP</code>( <var class="Arg">np1</var>, <var class="Arg">np2</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: <var class="Arg">np1</var><span class="SimpleMath">*</span><var class="Arg">np2</var></p>

<p>When invoked with two polynomials <var class="Arg">np1</var> and <var class="Arg">np2</var> in NP format, this function will return the product <var class="Arg">np1</var><span class="SimpleMath">*</span><var class="Arg">np2</var>.</p>

<p><em>Example:</em> Consider the following two polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,2],[]],[1,-1]];;
gap&gt; p2 := [[[1,2,2],[]],[1,-1]];;
</pre></div>

<p>The function <code class="code">MulNP</code> multiplies the two polynomials.</p>


<div class="example"><pre>
gap&gt; PrintNP(MulNP(p1,p2));
 a^2bab^2 - ab^2 - a^2b + 1 
</pre></div>

<p>The fact that this multiplication is not commutative is illustrated by the following comparison, using <code class="code">MulNP</code> twice and <code class="code">AddNP</code> once.</p>


<div class="example"><pre>
gap&gt; PrintNP(AddNP(MulNP(p1,p2),MulNP(p2,p1),1,-1));
 - ab^2a^2b + a^2bab^2 
</pre></div>

<p><a id="X81381B2D83D2B9A9" name="X81381B2D83D2B9A9"></a></p>

<h4>3.4 <span class="Heading">Gröbner functions, standard variant</span></h4>

<p><a id="X7CD9F9C97B2563E2" name="X7CD9F9C97B2563E2"></a></p>

<h5>3.4-1 Grobner</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Grobner</code>( <var class="Arg">Lnp</var>[, <var class="Arg">D</var>][, <var class="Arg">max</var>] )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: If the algorithm terminates, a Gröbner Basis or a record if <var class="Arg">max</var> is specified (see description).</p>

<p>For a list <var class="Arg">Lnp</var> of polynomials in NP format this function will use Buchberger's algorithm with normal form to find a Gröbner Basis (if possible, the general problem is unsolvable).</p>

<p>When called with the optional argument <var class="Arg">max</var>, which should be a positive integer, the calculation will be interrupted if it has not ended after <var class="Arg">max</var> iterations. The return value will be a record containing lists <code class="code">G</code> and <code class="code">todo</code> of polynomials in NP format, a boolean <code class="code">completed</code>, and an integer <code class="code">iterations</code>. Here <code class="code">G</code> and <code class="code">todo</code> form a Gröbner pair (see <a href="chapBib.html#biBCohenGijsbersEtAl2007">[Coh07]</a>). The number of performed iterations will be placed in <code class="code">iterations</code>. If the algorithm has terminated, then <code class="code">todo</code> will be the empty list and <code class="code">completed</code> will be equal to <code class="code">true</code>. If the algorithm has not terminated, then <code class="code">todo</code> will be a non-empty list of polynomials in NP format and <code class="code">completed</code> will be <code class="code">false</code>.</p>

<p>By use of the optional argument <var class="Arg">D</var>, it is possible to resume a previously interrupted calculation.</p>

<p><em>Example:</em> Consider the following two polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,2],[]],[1,-1]];;
gap&gt; p2 := [[[1,2,2],[]],[1,-1]];;
gap&gt; PrintNPList([p1,p2]);
 a^2b - 1 
 ab^2 - 1 
</pre></div>

<p>Their Gröbner basis can be computed by the function <code class="code">Grobner</code>.</p>


<div class="example"><pre>
gap&gt; G := Grobner([p1,p2]);;
gap&gt; PrintNPList(G);
 b - a 
 a^3 - 1 
</pre></div>

<p>One iteration of the Gröbner computations is invoked by use of the parameter <code class="code">max</code>:</p>


<div class="example"><pre>
gap&gt; R := Grobner([p1,p2],1);;
gap&gt; PrintNPList(R.G);
 b - a 
gap&gt; PrintNPList(R.todo);
 a^3 - 1 
gap&gt; R.iterations;
1
gap&gt; R.completed;
false
</pre></div>

<p>The above list <code class="code">R.todo</code> can be used to resume the computation of the Gröbner basis computation with the Gröbner pair <code class="code">R.G</code>, <code class="code">R.todo</code>:</p>


<div class="example"><pre>
gap&gt; PrintNPList(Grobner(R.G,R.todo));
 b - a 
 a^3 - 1 
</pre></div>

<p>In order to perform the Gröbner basis computation with polynomials in a free algebra over the field <span class="SimpleMath">GF(2)</span>, the coefficients of the polynomials need to be defined over that field.</p>


<div class="example"><pre>
gap&gt; PrintNPList(Grobner([[p1[1],One(GF(2))*p1[2]],[p2[1],One(GF(2))*p1[2]]]));
 b + a 
 a^3 + Z(2)^0 
</pre></div>

<p><a id="X7FEDA29E78B0CEED" name="X7FEDA29E78B0CEED"></a></p>

<h5>3.4-2 SGrobner</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SGrobner</code>( <var class="Arg">Lnp</var>[, <var class="Arg">todo</var>][, <var class="Arg">max</var>] )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: If the algorithm terminates, a Gröbner Basis or a record if <var class="Arg">max</var> is specified (see description).</p>

<p>For a list <var class="Arg">Lnp</var> of polynomials in NP format this function will use Buchberger's algorithm with strong normal form (see <a href="chapBib.html#biBCohenGijsbersEtAl2007">[Coh07]</a>) to find a Gröbner Basis (if possible, the general problem is unsolvable).</p>

<p>When called with the optional argument <var class="Arg">max</var>, which should be a positive integer, the calculation will be interrupted if it has not ended after <var class="Arg">max</var> iterations. The return value will be a record containing lists <code class="code">G</code> and <code class="code">todo</code> of polynomials in NP format, a boolean <code class="code">completed</code>, and an integer <code class="code">iterations</code>. Here <code class="code">G</code> and <code class="code">todo</code> form a Gröbner pair (see <a href="chapBib.html#biBCohenGijsbersEtAl2007">[Coh07]</a>). The number of performed iterations will be placed in <code class="code">iterations</code>. If the algorithm has terminated, then <code class="code">todo</code> will be the empty list and <code class="code">completed</code> will be equal to <code class="code">true</code>. If the algorithm has not terminated, then <code class="code">todo</code> will be a non-empty list of polynomials in NP format and <code class="code">completed</code> will be <code class="code">false</code>.</p>

<p>By use of the optional argument <var class="Arg">D</var>, it is possible to resume a previously interrupted calculation.</p>

<p><em>Example:</em> Consider the following two polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,2],[]],[1,-1]];;
gap&gt; p2 := [[[1,2,2],[]],[1,-1]];;
gap&gt; PrintNPList([p1,p2]);
 a^2b - 1 
 ab^2 - 1 
</pre></div>

<p>Their Gröbner basis can be computed by the function <code class="code">Grobner</code>.</p>


<div class="example"><pre>
gap&gt; G := SGrobner([p1,p2]);;
gap&gt; PrintNPList(G);
 b - a 
 a^3 - 1 
</pre></div>

<p>One iteration of the Gröbner computations is invoked by use of the parameter <code class="code">max</code>:</p>


<div class="example"><pre>
gap&gt; R := SGrobner([p1,p2],1);;
gap&gt; PrintNPList(R.G);
 b - a 
gap&gt; PrintNPList(R.todo);
 a^3 - 1 
gap&gt; R.iterations;
1
gap&gt; R.completed;
false
</pre></div>

<p>The above list <code class="code">R.todo</code> can be used to resume the computation of the Gröbner basis computation with the Gröbner pair <code class="code">R.G</code>, <code class="code">R.todo</code>:</p>


<div class="example"><pre>
gap&gt; PrintNPList(SGrobner(R.G,R.todo));
 b - a 
 a^3 - 1 
</pre></div>

<p><a id="X80D4D22C7E643C7B" name="X80D4D22C7E643C7B"></a></p>

<h5>3.4-3 IsGrobnerBasis</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsGrobnerBasis</code>( <var class="Arg">G</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: <code class="code">true</code> if <var class="Arg">G</var> is a Gröbner basis and <code class="code">false</code> otherwise</p>

<p>When invoked with a list <var class="Arg">G</var> of polynomials in NP format (see Section <a href="chap2.html#X7FDF3E5E7F33D3A2"><span class="RefLink">2.1</span></a>), this function will check whether the list is a Gröbner basis. The check is based on Theorem 1.4 from <a href="chapBib.html#biBCohenGijsbersEtAl2007">[Coh07]</a>.</p>

<p>Polynomials representing zero are allowed in <var class="Arg">G</var>.</p>

<p><em>Example:</em> Consider the following list of two polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; Lnp := [[[[1,1,2],[]],[1,-1]], [[[1,2,2],[]],[1,-1]]];;
gap&gt; PrintNPList(Lnp);
 a^2b - 1 
 ab^2 - 1 
</pre></div>

<p>The function <code class="code">IsGrobner</code> checks whether the list is a Gröbner basis.</p>


<div class="example"><pre>
gap&gt; IsGrobnerBasis(Lnp);
false
</pre></div>

<p>So the answer should be <code class="code">true</code> for the result of a Gröbner computation:</p>


<div class="example"><pre>
gap&gt; IsGrobnerBasis(Grobner(Lnp));
true
</pre></div>

<p><a id="X7D17F9027F08CF0B" name="X7D17F9027F08CF0B"></a></p>

<h5>3.4-4 IsStrongGrobnerBasis</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsStrongGrobnerBasis</code>( <var class="Arg">G</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: <code class="code">true</code> if <var class="Arg">G</var> is a strong Gröbner basis and <code class="code">false</code> otherwise</p>

<p>When invoked with a list <var class="Arg">G</var> of polynomials in NP format (see Section <a href="chap2.html#X7FDF3E5E7F33D3A2"><span class="RefLink">2.1</span></a>), this function will check whether the polynomials in this list form a strong Gröbner basis (see <a href="chapBib.html#biBCohenGijsbersEtAl2007">[Coh07]</a>).</p>

<p>Polynomials representing zero are allowed in <var class="Arg">G</var>.</p>

<p><em>Example:</em> Consider the following list of two polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; Lnp := [[[[1,1,2],[]],[1,-1]], [[[1,2,2],[]],[1,-1]]];;
gap&gt; PrintNPList(Lnp);
 a^2b - 1 
 ab^2 - 1 
</pre></div>

<p>The function <code class="code">IsStrongGrobner</code> checks whether the list is a strong Gröbner basis.</p>


<div class="example"><pre>
gap&gt; IsStrongGrobnerBasis(Lnp);
false
</pre></div>

<p>But the answer should be <code class="code">true</code> for the result of a strong Gröbner computation:</p>


<div class="example"><pre>
gap&gt; IsStrongGrobnerBasis(SGrobner(Lnp));
true
</pre></div>

<p>A Gröbner basis that is not a strong Gröbner basis:</p>


<div class="example"><pre>
gap&gt; B := SGrobner(Lnp);;
gap&gt; Add(B,AddNP(Lnp[1],B[1],1,-1));;
gap&gt; PrintNPList(B);
 b - a 
 a^3 - 1 
 a^2b - b + a - 1 
gap&gt; IsGrobnerBasis(B);
true
gap&gt; IsStrongGrobnerBasis(B);
false
</pre></div>

<p><a id="X7E0105ED7FF4210F" name="X7E0105ED7FF4210F"></a></p>

<h5>3.4-5 IsGrobnerPair</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsGrobnerPair</code>( <var class="Arg">G</var>, <var class="Arg">D</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: A boolean, which has the value <code class="code">true</code> if the input forms a Gröbner pair</p>

<p>When called with two lists of polynomials in NP format, this function returns true if they form a Gröbner pair. Testing whether <var class="Arg">D</var> is a basic set for <var class="Arg">G</var> might involve computing the Gröbner basis. Instead of this only some simple computations are done to see if it can easily be proven that <var class="Arg">D</var> is a basic set for <var class="Arg">G</var>. If this cannot be proven easily, then <code class="code">false</code> is returned, even though <span class="SimpleMath">G, D</span> might still be a Gröbner pair.</p>

<p><em>Example:</em> Consider the following four polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,2],[]],[1,-1]];;
gap&gt; p2 := [[[1,2,2],[]],[1,-1]];;
gap&gt; q1 := [[[2],[1]],[1,-1]];;
gap&gt; q2 := [[[1,1,1],[]],[1,-1]];;
</pre></div>

<p>The function <code class="code">IsGrobnerPair</code> is used to check whether some combinations of these polynomials in two lists provide Gröbner pairs.</p>


<div class="example"><pre>
gap&gt; IsGrobnerPair([p1,p2,q1],[q2]);
true
gap&gt; IsGrobnerPair([q1,q2],[p1,p2]);
false
</pre></div>

<p>The function <code class="code">IsGrobnerPair</code> applied with an empty list as second argument is a check whether the first argument is a Gröbner basis.</p>


<div class="example"><pre>
gap&gt; IsGrobnerPair([p1,p2],[]) = IsGrobnerBasis([p1,p2]);
true
</pre></div>

<p><a id="X8752DA1A7CAF77D3" name="X8752DA1A7CAF77D3"></a></p>

<h5>3.4-6 MakeGrobnerPair</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MakeGrobnerPair</code>( <var class="Arg">G</var>, <var class="Arg">D</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: A record containing a new Grobner pair</p>

<p>When called with as arguments a pair <span class="SimpleMath">G, D</span>, this function cleans <var class="Arg">G</var> and <var class="Arg">D</var> and adds some obstructions to <var class="Arg">D</var> till it is easily provable that <var class="Arg">D</var> is a basic set for <var class="Arg">G</var> (see <a href="chapBib.html#biBCohenGijsbersEtAl2007">[Coh07]</a>). The result is a record containing the fields <code class="code">G</code> and <code class="code">todo</code> representing the Gröbner pair.</p>

<p><em>Example:</em> Consider the following two polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,2],[]],[1,-1]];;
gap&gt; p2 := [[[1,2,2],[]],[1,-1]];;
</pre></div>

<p>The function <code class="code">MakeGrobnerPair</code> turns the list with these two polynomials into a Gröbner pair, once the empty list is added as a second argument. The result is a record whose fields <code class="code">G</code> and <code class="code">todo</code></p>


<div class="example"><pre>
gap&gt; GP := MakeGrobnerPair([p1,p2],[]);;
gap&gt; PrintNPList(GP.G);
 a^2b - 1 
 ab^2 - 1 
gap&gt; PrintNPList(GP.todo);
 b - a 
</pre></div>

<p>These fields are ready for use in <code class="code">Grobner</code></p>


<div class="example"><pre>
gap&gt; GB := Grobner(GP.G,GP.todo);;
gap&gt; PrintNPList(GB);
 b - a 
 a^3 - 1 
</pre></div>

<p><a id="X7F387F7780425B9A" name="X7F387F7780425B9A"></a></p>

<h4>3.5 <span class="Heading">Finite-dimensional quotient
		algebras</span></h4>

<p><a id="X7EAA04247B2C6330" name="X7EAA04247B2C6330"></a></p>

<h5>3.5-1 BaseQA</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BaseQA</code>( <var class="Arg">G</var>, <var class="Arg">t</var>, <var class="Arg">maxno</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: A list of terms forming a basis of the quotient algebra of the (non-commutative) polynomial algebra in <var class="Arg">t</var> variables by the 2-sided ideal generated by <var class="Arg">G</var></p>

<p>When called with a Gröbner basis <var class="Arg">G</var>, the number <var class="Arg">t</var> of generators of the algebra, and a maximum number of terms to be found <var class="Arg">maxno</var>, BaseQA will return a (partial) base of the quotient algebra. If this function is invoked with <var class="Arg">maxno</var> equal to 0, then a full basis will be given. If the dimension of this quotient algebra is infinite and <var class="Arg">maxno</var> is set to 0, then the algorithm behind this function will not terminate.</p>

<p><em>Example:</em> Consider the following Gröbner basis.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,2],[]],[1,-1]];;
gap&gt; p2 := [[[1,2,2],[]],[1,-1]];;
gap&gt; G := Grobner([p1,p2]);;
gap&gt; PrintNPList(G);
 b - a 
 a^3 - 1 
</pre></div>

<p>The function <code class="code">BaseQA</code> computes a basis for the quotient algebra of the free algebra over the rationals with generators <span class="SimpleMath">a</span> and <span class="SimpleMath">b</span> by the two-sided ideal generated by <code class="code">G</code>.</p>


<div class="example"><pre>
gap&gt; PrintNPList(G);
 b - a 
 a^3 - 1 
gap&gt; BaseQA(G,2,0);
[ [ [ [  ] ], [ 1 ] ], [ [ [ 1 ] ], [ 1 ] ], [ [ [ 1, 1 ] ], [ 1 ] ] ]
gap&gt; PrintNPList(BaseQA(G,2,0));
 1 
 a 
 a^2 
</pre></div>

<p>It is necessary for a correct result that the first argument be a Gröbner basis, as will be clear from the following invocation of <code class="code">BaseQA</code>.</p>


<div class="example"><pre>
gap&gt; PrintNPList(BaseQA([p1,p2],2,10));
 1 
 a 
 b 
 a^2 
 ab 
 ba 
 b^2 
 a^3 
 aba 
 ba^2 
 bab 
 b^2a 
 b^3 
</pre></div>

<p><a id="X81A50EEE7B56C723" name="X81A50EEE7B56C723"></a></p>

<h5>3.5-2 DimQA</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DimQA</code>( <var class="Arg">G</var>, <var class="Arg">t</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The dimension of the quotient algebra</p>

<p>When called with a Gröbner basis <var class="Arg">G</var> and a number of variables <var class="Arg">t</var>, the function <code class="code">DimQA</code> will return the dimension of the quotient algebra of the free algebra generated by <var class="Arg">t</var> variables by the ideal generated by <var class="Arg">G</var> if it is finite. It will not terminate if the dimension is infinite.</p>

<p>If <var class="Arg">t</var>=0, the function will compute the minimal value of <code class="code">t</code> such that the polynomials in <var class="Arg">G</var> belong to the free algebra on <code class="code">t</code> generators.</p>

<p>To check whether the dimension of the quotient algebra is finite and to determine the type of growth if it is infinite, see also the functions <code class="func">FinCheckQA</code> (<a href="chap3.html#X792E39A98717D779"><span class="RefLink">3.6-2</span></a>) and <code class="func">DetermineGrowthQA</code> (<a href="chap3.html#X83C57C3A7DCF0471"><span class="RefLink">3.6-1</span></a>) in Section <a href="chap3.html#X79FE4A3983E2329F"><span class="RefLink">3.6</span></a>.</p>

<p><em>Example:</em> Consider the following Gröbner basis.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,2],[]],[1,-2]];;
gap&gt; p2 := [[[1,2,2],[]],[1,-2]];;
gap&gt; G := Grobner([p1,p2]);;
gap&gt; PrintNPList(G);
 b - a 
 a^3 - 2 
</pre></div>

<p>The function <code class="code">DimQA</code> computes the dimension of the quotient algebra of the free algebra over the rationals with generators <span class="SimpleMath">a</span> and <span class="SimpleMath">b</span> by the two-sided ideal generated by <code class="code">G</code>.</p>


<div class="example"><pre>
gap&gt; DimQA(G,2);
3
</pre></div>

<p><a id="X7DFA841A8425DD94" name="X7DFA841A8425DD94"></a></p>

<h5>3.5-3 MatrixQA</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MatrixQA</code>( <var class="Arg">i</var>, <var class="Arg">B</var>, <var class="Arg">GB</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The matrix representation for the <var class="Arg">i</var>-th generator of the algebra for right multiplication in the quotient algebra</p>

<p>Given a basis <var class="Arg">B</var> of the quotient algebra, a Gröbner basis (record) <var class="Arg">GB</var>, and a natural number <var class="Arg">i</var>, this function creates a matrix representation for the <var class="Arg">i</var>-th generator of the algebra for right multiplication.</p>

<p><em>Example:</em> Consider the following two polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,1,2],[]],[1,-1]];;
gap&gt; p2 := [[[2,2,2,1],[]],[1,-1]];;
</pre></div>

<p>The matrix of right multiplication by the first indeterminate <span class="SimpleMath">a</span> on the quotient algebra with respect to the ideal generated by <code class="code">p1</code> and <code class="code">p2</code> is obtained by applying <code class="code">MatrixQA</code> to the Gröbner basis of these generators and a basis of the quotient algebra as found in <code class="func">BaseQA</code> (<a href="chap3.html#X7EAA04247B2C6330"><span class="RefLink">3.5-1</span></a>):</p>


<div class="example"><pre>
gap&gt; GB := Grobner([p1,p2]);;
gap&gt; B := BaseQA(GB,2,0);;
gap&gt; PrintNPList(B);
 1 
 a 
 b 
 a^2 
 ab 
 a^3 
 a^2b 
 a^4 
gap&gt; Display(MatrixQA(1, B,GB));
[ [  0,  1,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  0,  1,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  1,  0,  0,  0 ],
  [  0,  0,  0,  0,  0,  1,  0,  0 ],
  [  0,  0,  0,  0,  0,  0,  1,  0 ],
  [  0,  0,  0,  0,  0,  0,  0,  1 ],
  [  1,  0,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  1,  0,  0,  0,  0,  0 ] ]
</pre></div>

<p>The function is also applicable to Gröbner basis records for modules. Consider the following two vectors.</p>


<div class="example"><pre>
gap&gt; v1 := [[[-1,1,2],[-1]],[1,-1]];;
gap&gt; v2 := [[[-2,2,2],[-2]],[1,-2]];;
</pre></div>

<p>The Gröbner basis record for this data is found by <code class="func">SGrobnerModule</code> (<a href="chap3.html#X860966487ED88A43"><span class="RefLink">3.9-1</span></a>) and a quotient module basis by <code class="func">BaseQM</code> (<a href="chap3.html#X7E3160E67C504F37"><span class="RefLink">3.9-2</span></a>):</p>


<div class="example"><pre>
gap&gt; GBR := SGrobnerModule([v1,v2],[p1,p2]);;
gap&gt; B := BaseQM(GBR,2,2,0);;
</pre></div>

<p>The matrix of right multiplication by <span class="SimpleMath">a</span>, the first generator of the free algebra, is</p>


<div class="example"><pre>
gap&gt; Display(MatrixQA(1,B,GBR));
[ [  0,  1 ],
  [  1,  0 ] ]
</pre></div>

<p><a id="X78E4BF2F7F0D5E74" name="X78E4BF2F7F0D5E74"></a></p>

<h5>3.5-4 MatricesQA</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MatricesQA</code>( <var class="Arg">t</var>, <var class="Arg">B</var>, <var class="Arg">GB</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The matrix representation for the <var class="Arg">t</var> generators of the algebra for right multiplication in the quotient algebra</p>

<p>Given a basis <var class="Arg">B</var> of the quotient algebra, a Gröbner basis (record) <var class="Arg">GB</var>, and a natural number <var class="Arg">t</var>, this function creates a list of <var class="Arg">t</var> matrices representing the linear transformations of the generators of the algebra by right multiplication on the quotient algebra.</p>

<p><em>Example:</em> Consider the following two polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,1,2],[]],[1,-1]];;
gap&gt; p2 := [[[2,2,2,1],[]],[1,-1]];;
</pre></div>

<p>The function <code class="code">MatricesQA</code> gives the list of matrices found by <code class="func">MatrixQA</code> (<a href="chap3.html#X7DFA841A8425DD94"><span class="RefLink">3.5-3</span></a>) when the first argument takes the integer values between 1 and the number of all algebra generators.</p>


<div class="example"><pre>
gap&gt; GB := Grobner([p1,p2]);;
gap&gt; B := BaseQA(GB,2,0);;
gap&gt; mats := MatricesQA(2,B,GB);;
gap&gt; for mat in mats do Display(mat); Print("\n"); od;
[ [  0,  1,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  0,  1,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  1,  0,  0,  0 ],
  [  0,  0,  0,  0,  0,  1,  0,  0 ],
  [  0,  0,  0,  0,  0,  0,  1,  0 ],
  [  0,  0,  0,  0,  0,  0,  0,  1 ],
  [  1,  0,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  1,  0,  0,  0,  0,  0 ] ]

[ [  0,  0,  1,  0,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  1,  0,  0,  0 ],
  [  0,  0,  0,  1,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  0,  0,  1,  0 ],
  [  0,  0,  0,  0,  0,  1,  0,  0 ],
  [  1,  0,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  0,  0,  0,  0,  0,  1 ],
  [  0,  1,  0,  0,  0,  0,  0,  0 ] ]

</pre></div>

<p>The result is also obtainable by use of the List function:</p>


<div class="example"><pre>
gap&gt; MatricesQA(2,B,GB) = List([1,2], q -&gt; MatrixQA(q,B,GB));
true
</pre></div>

<p><a id="X80C4D0E882B05FDF" name="X80C4D0E882B05FDF"></a></p>

<h5>3.5-5 MulQA</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MulQA</code>( <var class="Arg">p1</var>, <var class="Arg">p2</var>, <var class="Arg">G</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The strong normal form of the product <var class="Arg">p1</var><span class="SimpleMath">*</span><var class="Arg">p2</var> with respect to <var class="Arg">G</var></p>

<p>When called with two polynomials in NP form, <var class="Arg">p1</var> and <var class="Arg">p2</var>, and a Gröbner basis <var class="Arg">G</var>, this function will return the product in the quotient algebra.</p>

<p><em>Example:</em> Consider the following Gröbner basis.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,2],[]],[1,-1]];;
gap&gt; p2 := [[[1,2,2],[]],[1,-1]];;
gap&gt; G := Grobner([p1,p2]);;
gap&gt; PrintNPList(G);
 b - a 
 a^3 - 1 
</pre></div>

<p>Print the product in the quotient algebra of the polynomials <span class="SimpleMath">a-2</span> and <span class="SimpleMath">b-3</span> by use of <code class="code">MulQA</code>:</p>


<div class="example"><pre>
gap&gt; s1 := [[[1],[]],[1,-2]];;
gap&gt; s2 := [[[2],[]],[1,-3]];;
gap&gt; PrintNP(MulQA(s1,s2,G));
 a^2 - 5a + 6 
</pre></div>

<p>The result should be equal to the strong normal form of the product of <span class="SimpleMath">a-2</span> and <span class="SimpleMath">b-3</span> with respect to <code class="code">G</code>:</p>


<div class="example"><pre>
gap&gt; MulQA(s1,s2,G) = StrongNormalFormNP(MulNP(s1,s2),G);
true
</pre></div>

<p><a id="X8563683E7FA604F8" name="X8563683E7FA604F8"></a></p>

<h5>3.5-6 StrongNormalFormNP</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StrongNormalFormNP</code>( <var class="Arg">f</var>, <var class="Arg">G</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The strong normal form of a polynomial with respect to <var class="Arg">G</var></p>

<p>When invoked with a polynomial in NP format (see Section <a href="chap2.html#X7FDF3E5E7F33D3A2"><span class="RefLink">2.1</span></a>) and a finite set <var class="Arg">G</var> of polynomials in NP format, this function will return a strong normal form (that is, a polynomial that is equal to <var class="Arg">f</var> modulo <var class="Arg">G</var>, every monomial of which is a multiple of no leading monomial of an element of <var class="Arg">G</var>).</p>

<p>Note that the StrongNormalForm with respect to a Gröbner basis is uniquely determined, but that for an arbitrary input <var class="Arg">G</var> the result may depend on the order in which the individual reduction steps are implemented.</p>

<p><em>Example:</em> Consider the following two polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,2],[]],[1,-1]];;
gap&gt; p2 := [[[1,2,2],[]],[1,-1]];;
</pre></div>

<p>The strong normal form of the polynomial</p>


<div class="example"><pre>
gap&gt; p := [[[1,1,1,2],[2,1],[]],[1,-1,3]];;
</pre></div>

<p>with respect to the list <code class="code">[p1,p2]</code> is computed by use of the function <code class="code">StrongNormalFormNP</code>:</p>


<div class="example"><pre>
gap&gt; PrintNP(StrongNormalFormNP(p,[p1,p2]));
 - ba + a + 3 
</pre></div>

<p><a id="X79FE4A3983E2329F" name="X79FE4A3983E2329F"></a></p>

<h4>3.6 <span class="Heading">Finiteness and Hilbert series</span></h4>

<p><a id="X83C57C3A7DCF0471" name="X83C57C3A7DCF0471"></a></p>

<h5>3.6-1 DetermineGrowthQA</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DetermineGrowthQA</code>( <var class="Arg">Lm</var>, <var class="Arg">t</var>, <var class="Arg">exact</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: If the quotient algebra is finite dimensional, then the integer <code class="code">0</code> is returned. If the growth is polynomial and the algorithm found a precise degree <code class="code">d</code> of the growth polynomial, then <code class="code">d</code> is returned. If the growth is polynomial and no precise answer is found, an interval <code class="code">[d1,d2]</code> is returned in which the dimension lies. If the growth is exponential, the string <code class="code">"exponential growth"</code> is returned.</p>

<p>Given leading monomials <var class="Arg">Lm</var> of some Gröbner basis (these can be obtained with the function <code class="func">LMonsNP</code> (<a href="chap3.html#X86ECA4F57C720E45"><span class="RefLink">3.3-10</span></a>)), the number <var class="Arg">t</var> of generators of a free algebra, say <span class="SimpleMath">A</span>, in which the monomials lie, and a boolean <var class="Arg">exact</var>, this function checks whether the quotient algebra of <span class="SimpleMath">A</span> by the ideal generated by <var class="Arg">Lm</var> is finite dimensional. In doing so it constructs a graph of normal words which helps with the computations. It also checks for exponential or polynomial growth in the infinite case.</p>

<p>If the precise degree is needed in the polynomial case, the argument <var class="Arg">exact</var> should be set to <code class="code">true</code>.</p>

<p>The function <code class="code">DetermineGrowthQA</code> allows preprocessing, which may speed up the computations. This can be done with the function <code class="func">PreprocessAnalysisQA</code> (<a href="chap3.html#X863124677B933CEE"><span class="RefLink">3.6-4</span></a>).</p>

<p><em>Example:</em> For the list of monomials consisting of a single variable in a free algebra generated by two variables the growth is clearly polynomial of degree 1. This is verified by invoking <code class="code">DetermineGrowthQA</code> with arguments <code class="code">[[1]]</code> (the list of the single monomial consisting of the first variable), the number of generators of the free algebra to which the monomials belong (which is 2 here), and the boolean <code class="code">true</code> indicating that we wish a precise degree in case of polynomial growth.</p>


<div class="example"><pre>
gap&gt; DetermineGrowthQA([[1]],2,true);
1
</pre></div>

<p>Here is an example of polynomial growth of degree 2:</p>


<div class="example"><pre>
gap&gt; L := [[1,2,1],[2,2,1]];
[ [ 1, 2, 1 ], [ 2, 2, 1 ] ]
gap&gt; DetermineGrowthQA(L,2,true);
2
</pre></div>

<p>In order to show how to apply the function to arbitrary polynomials, consider the following two polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; F := GF(256);
GF(2^8)
gap&gt; z := GeneratorsOfField(F)[1];
Z(2^8)
gap&gt; p1 := [[[1,1,1,2],[]],[z,1]];;
gap&gt; p2 := [[[2,2,2,1],[]],[1,z]];;
</pre></div>

<p>The polynomials <code class="code">p1</code> and <code class="code">p2</code> have coefficients in the field <code class="code">F</code> of order 256. In order to study the growth of the quotient algebra we first compute the list of leading monomials of the Gröbner basis elements and next apply <code class="code">DetermineGrowthQA</code>.</p>


<div class="example"><pre>
gap&gt; GB := Grobner([p1,p2]);;
gap&gt; L := LMonsNP(GB);;
gap&gt; for lm  in L  do PrintNP( [ [ lm ], [ 1 ] ] ); od;
 a^3b 
 b^2 
 ba 
 a^5 
gap&gt; DetermineGrowthQA(L,2,true);
0
</pre></div>

<p><a id="X792E39A98717D779" name="X792E39A98717D779"></a></p>

<h5>3.6-2 FinCheckQA</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FinCheckQA</code>( <var class="Arg">Lm</var>, <var class="Arg">t</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: <code class="code">true</code>, if the quotient algebra is finite dimensional and<code class="code"> false</code> otherwise</p>

<p>Given a list <var class="Arg">Lm</var> of leading monomials such that none of these divides another, and the number <var class="Arg">t</var> of generators of a free algebra in which they are embedded, this function checks whether the quotient algebra of the free algebra by the ideal generated by <var class="Arg">Lm</var> is finite dimensional.</p>

<p>When given a Gröbner basis <span class="SimpleMath">G</span>, the dimension of the quotient algebra of the free algebra by the ideal generated by <span class="SimpleMath">G</span> coincides with the the dimension of the quotient algebra of the free algebra by the ideal generated by the leading terms of elements of <span class="SimpleMath">G</span>. These can be obtained from <span class="SimpleMath">G</span> with the function <code class="func">LMonsNP</code> (<a href="chap3.html#X86ECA4F57C720E45"><span class="RefLink">3.3-10</span></a>).</p>

<p>The function <code class="code">FinCheckQA</code> allows for preprocessing with the function <code class="func">PreprocessAnalysisQA</code> (<a href="chap3.html#X863124677B933CEE"><span class="RefLink">3.6-4</span></a>). This may speed up the computation.</p>

<p><em>Example:</em> Consider the following list <code class="code">L</code> of two monomials.</p>


<div class="example"><pre>
gap&gt; L := [[1,2,1],[2,2,1]];;
</pre></div>

<p>Finiteness of the dimension of the quotient algebra of the free algebra by the ideal generated by these two monomials can be decided by means of <code class="code">FinCheckQA</code>. Its arguments are <code class="code">L</code> and the number of generators of the free algebra in which the monomials reside.</p>


<div class="example"><pre>
gap&gt; FinCheckQA(L,2);
false
</pre></div>

<p>This example turns out to be infinite dimensional. Here is a finite-dimensional example.</p>


<div class="example"><pre>
gap&gt; FinCheckQA([[1],[2,2]],2);
true
</pre></div>

<p><a id="X7CFD47367CF309EB" name="X7CFD47367CF309EB"></a></p>

<h5>3.6-3 HilbertSeriesQA</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HilbertSeriesQA</code>( <var class="Arg">Lm</var>, <var class="Arg">t</var>, <var class="Arg">d</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: A list of coefficients of the Hilbert series up to degree <var class="Arg">d</var></p>

<p>Given a set of monomials <var class="Arg">Lm</var>, none of which divides another, and the number <var class="Arg">n</var> of generators of the free algebra in which they occur, this function computes the Hilbert series up to a given degree <var class="Arg">d</var>.</p>

<p>Internally, it builds (part of) the graph of standard words. This function will remove zeroes from the end of the list of coefficients.</p>

<p><em>Example:</em> Consider the following list <code class="code">L</code> of two monomials.</p>


<div class="example"><pre>
gap&gt; L := [[1,2,1],[2,2,1]];;
</pre></div>

<p>Finiteness of the dimension of the quotient algebra of the free algebra by the ideal generated by these two monomials can be decided by means of <code class="code">FinCheckQA</code>. Its arguments are <code class="code">L</code> and the number of generators of the free algebra in which the monomials reside.</p>


<div class="example"><pre>
gap&gt; HilbertSeriesQA(L,2,10);
[ 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20 ]
</pre></div>

<p>This indicates that the growth may be polynomial. <code class="func">DetermineGrowthQA</code> (<a href="chap3.html#X83C57C3A7DCF0471"><span class="RefLink">3.6-1</span></a>) can be used to check this.</p>

<p><a id="X863124677B933CEE" name="X863124677B933CEE"></a></p>

<h5>3.6-4 PreprocessAnalysisQA</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PreprocessAnalysisQA</code>( <var class="Arg">Lm</var>, <var class="Arg">t</var>, <var class="Arg">iterations</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The left-reduced list of `obstructions', obtained by applying left-reduction recursively</p>

<p>This preprocessing of the list <var class="Arg">Lm</var> of monomials can be applied to the set of leading terms of a Gröbner basis before calling the functions <code class="func">FinCheckQA</code> (<a href="chap3.html#X792E39A98717D779"><span class="RefLink">3.6-2</span></a>) or <code class="func">DetermineGrowthQA</code> (<a href="chap3.html#X83C57C3A7DCF0471"><span class="RefLink">3.6-1</span></a>), in order to speed up calculations using these functions. As the name suggests, <var class="Arg">t</var> should be the size of the alphabet. The parameter <var class="Arg">iterations</var> gives the maximum number of recursion steps in the preprocessing (<var class="Arg">0</var> means no restriction). For more information about this function see <a href="chapBib.html#biBKrook2003">[Kro03]</a>.</p>

<p><em>Example:</em> Consider the following two polynomials in NP format of which a Gröbner basis is computed.</p>


<div class="example"><pre>
F := GF(256);
z := GeneratorsOfField(F)[1];
gap&gt; p1 := [[[1,1,1,1,2],[]],[1,-1]];;
gap&gt; p2 := [[[2,2,2,1,1,1],[]],[1,-1]];;
gap&gt; GB := Grobner([p1,p2]);;
gap&gt; PrintNPList(GB);
 a^4b - 1 
 ba - ab 
 b^2 - a 
 a^5 - b 
</pre></div>

<p>Application of <code class="code">PreprocessAnalysisQA</code> is carried out on the leading terms of <code class="code">GB</code>, with 2, 4, 8, recursions, respectively.</p>


<div class="example"><pre>
gap&gt; L := LMonsNP(GB);
[ [ 1, 1, 1, 1, 2 ], [ 2, 1 ], [ 2, 2 ], [ 1, 1, 1, 1, 1 ] ]
gap&gt; L1 := PreprocessAnalysisQA(L,2,2);
[ [ 1, 1, 1 ], [ 2, 1 ], [ 1, 1, 2 ], [ 2, 2 ] ]
gap&gt; L2 := PreprocessAnalysisQA(L1,2,4);
[ [ 1 ], [ 2 ] ]
</pre></div>

<p><a id="X7BA5CAA07890F7AA" name="X7BA5CAA07890F7AA"></a></p>

<h4>3.7 <span class="Heading">Functions of the
			trace variant</span></h4>

<p><a id="X813454F6799B1D57" name="X813454F6799B1D57"></a></p>

<h5>3.7-1 EvalTrace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EvalTrace</code>( <var class="Arg">p</var>, <var class="Arg">Lnp</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The trace evaluated to a polynomial in NP format.</p>

<p>For a traced polynomial <var class="Arg">p</var> and a list <var class="Arg">Lnp</var> of polynomials in NP format, this program evaluates the trace by substituting the polynomials of <var class="Arg">Lnp</var> back in the expression <code class="code">p.trace</code> and computing the resulting polynomial. The result should have the same value as <code class="code">p.pol</code>.</p>

<p><em>Example:</em> First we compute the traced Gröbner basis of the list of the following two polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,2],[]],[1,-1]];;
gap&gt; p2 := [[[2,2,1],[]],[1,-1]];;
gap&gt; Lnp := [p1,p2];;
gap&gt; GBT := SGrobnerTrace(Lnp);;
</pre></div>

<p>In order to check that the polynomials in <code class="code">GBT</code> belong to the ideal generated by <code class="code">p1</code> and <code class="code">p2</code>, we evaluate the trace. For each traced polynomial <code class="code">p</code> in <code class="code">GBT</code>, the polynomial <code class="code">p.pol</code> is equated to the evaluated expression <code class="code">p.trace</code>, in which each occurrence of <code class="code">G(i)</code> is replaced by <code class="code">Lnp[i]</code> by use of <code class="func">EvalTrace</code>.</p>


<div class="example"><pre>
gap&gt; ForAll(GBT,q -&gt; EvalTrace(q,Lnp) = q.pol);
true
</pre></div>

<p><a id="X83D1560C7F2A04BA" name="X83D1560C7F2A04BA"></a></p>

<h5>3.7-2 PrintTraceList</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PrintTraceList</code>( <var class="Arg">G</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>When invoked with a list <var class="Arg">G</var> of traced polynomials, this function prints the traces of that list.</p>

<p><em>Example:</em> First we compute the traced Gröbner basis of the list of two polynomials in NP format and next we print it by use of <code class="code">PrintTraceList</code>.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,2],[]],[1,-1]];;
gap&gt; p2 := [[[2,2,1],[]],[1,-1]];;
gap&gt; GBT := SGrobnerTrace([p1,p2]);;
gap&gt; PrintTraceList(GBT);
 aG(1) - bG(1) - G(1)ba^2b + a^2G(2)ab 

 G(1)ba^2 + bG(1)ba + G(2) - a^2G(2)a - ba^2G(2) 
</pre></div>

<p><a id="X8039BEE77C070FB1" name="X8039BEE77C070FB1"></a></p>

<h5>3.7-3 PrintTracePol</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PrintTracePol</code>( <var class="Arg">p</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>This function prints the trace of an NP polynomial <var class="Arg">p</var>.</p>

<p><em>Example:</em> First we compute the traced Gröbner basis of the list of two polynomials in NP format. Next we print the trace polynomial of the members of the list by use of <code class="code">PrintTracePol</code>.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,2],[]],[1,-1]];;
gap&gt; p2 := [[[2,2,1],[]],[1,-1]];;
gap&gt; GBT := SGrobnerTrace([p1,p2]);;
gap&gt; for np in GBT do PrintTracePol(np); Print("\n"); od;
 aG(1) - bG(1) - G(1)ba^2b + a^2G(2)ab 

 G(1)ba^2 + bG(1)ba + G(2) - a^2G(2)a - ba^2G(2) 

</pre></div>

<p><a id="X7DD0B56D7BD6CD98" name="X7DD0B56D7BD6CD98"></a></p>

<h5>3.7-4 PrintNPListTrace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PrintNPListTrace</code>( <var class="Arg">G</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>When invoked with a set of traced non-commutative polynomials <var class="Arg">G</var>, this function prints the list of the traced polynomials, without the trace.</p>

<p><em>Example:</em> First we compute the traced Gröbner basis of the list of two polynomials in NP format. Next we print the polynomials found by use of <code class="code">PrintNPListTrace</code>.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,2],[]],[1,-1]];;
gap&gt; p2 := [[[2,2,1],[]],[1,-1]];;
gap&gt; GBT := SGrobnerTrace([p1,p2]);;
gap&gt; PrintNPListTrace(GBT);
 b - a 
 a^3 - 1 
</pre></div>

<p><a id="X78AE6EED83B97595" name="X78AE6EED83B97595"></a></p>

<h5>3.7-5 SGrobnerTrace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SGrobnerTrace</code>( <var class="Arg">Lnp</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: Gröbner Basis, traceable</p>

<p>For a list of noncommutative polynomials <var class="Arg">Lnp</var> this function will use Buchberger's algorithm with strong normal form to find a Gröbner Basis <code class="code">G</code> (if possible; the general problem is unsolvable).</p>

<p>The results will be traceable. Functions that can print the Gröbner basis are <code class="func">PrintTraceList</code> (<a href="chap3.html#X83D1560C7F2A04BA"><span class="RefLink">3.7-2</span></a>) (with the trace) and <code class="func">PrintNPListTrace</code> (<a href="chap3.html#X7DD0B56D7BD6CD98"><span class="RefLink">3.7-4</span></a>) (without the trace).</p>

<p><em>Example:</em> For the list of the following two polynomials in NP format, a traced Gröbner basis is computed.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,2],[]],[1,-1]];;
gap&gt; p2 := [[[2,2,1],[]],[1,-1]];;
gap&gt; GBT := SGrobnerTrace([p1,p2]);
[ rec( pol := [ [ [ 2 ], [ 1 ] ], [ 1, -1 ] ], 
      trace := [ [ [  ], 1, [ 2, 1, 1, 2 ], -1 ], [ [ 2 ], 1, [  ], -1 ], 
          [ [ 1 ], 1, [  ], 1 ], [ [ 1, 1 ], 2, [ 1, 2 ], 1 ] ] ), 
  rec( pol := [ [ [ 1, 1, 1 ], [  ] ], [ 1, -1 ] ], 
      trace := [ [ [ 2 ], 1, [ 2, 1 ], 1 ], [ [  ], 1, [ 2, 1, 1 ], 1 ], 
          [ [  ], 2, [  ], 1 ], [ [ 2, 1, 1 ], 2, [  ], -1 ], 
          [ [ 1, 1 ], 2, [ 1 ], -1 ] ] ) ]
</pre></div>

<p><a id="X8219059A86A54130" name="X8219059A86A54130"></a></p>

<h5>3.7-6 StrongNormalFormTraceDiff</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StrongNormalFormTraceDiff</code>( <var class="Arg">np</var>, <var class="Arg">GBT</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The traced polynomial for the difference of <var class="Arg">f</var> with the strong normal form of <var class="Arg">np</var> with respect to <var class="Arg">GBT</var></p>

<p>When invoked with a polynomial <var class="Arg">np</var> in NP format as its first argument, and a traced Gröbner basis <var class="Arg">GBT</var> as generated by <code class="func">SGrobnerTrace</code> (<a href="chap3.html#X78AE6EED83B97595"><span class="RefLink">3.7-5</span></a>), this function returns the difference of <var class="Arg">np</var> with the strong normal form of <var class="Arg">np</var> with respect to <var class="Arg">GBT</var>. This difference <code class="code">d</code> is returned as a traced polynomial. The trace information <code class="code">d.trace</code> gives an expression of <code class="code">d.pol</code> as a combination of polynomials from the list of polynomials to which the trace parts of <var class="Arg">GBT</var> are referring. Typically, this is the set of relations used as input to the computation of <var class="Arg">GBT</var>.</p>

<p>Note that the difference of the polynomials <var class="Arg">np</var> and <code class="code">d.pol</code> is the same as the StrongNormalForm of <var class="Arg">np</var>.</p>

<p><em>Example:</em> First we compute the traced Gröbner basis of the list of the following two polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,2],[]],[1,-1]];;
gap&gt; p2 := [[[2,2,1],[]],[1,-1]];;
gap&gt; GBT := SGrobnerTrace([p1,p2]);;
</pre></div>

<p>Of the polynomial <span class="SimpleMath">a^6</span> we compute its difference with the normal form. The result is printed by used of <code class="func">PrintNP</code> (<a href="chap3.html#X7B63BEA87A8D6162"><span class="RefLink">3.2-1</span></a>) and <code class="func">PrintTraceList</code> (<a href="chap3.html#X83D1560C7F2A04BA"><span class="RefLink">3.7-2</span></a>).</p>


<div class="example"><pre>
gap&gt; f := [[[1,1,1,1,1,1]],[1]];;
gap&gt; sf := StrongNormalFormTraceDiff(f,GBT);;
gap&gt; PrintNP(sf.pol);
 a^6 - 1 
gap&gt; PrintTraceList([sf]);
 G(1)ba^2 + bG(1)ba + G(1)ba^5 + bG(1)ba^4 + G(2) + G(2)a^3 - a^2G(
2)a - ba^2G(2) - a^2G(2)a^4 - ba^2G(2)a^3 
</pre></div>

<p><a id="X7E4E3AD07B2465F9" name="X7E4E3AD07B2465F9"></a></p>

<h4>3.8 <span class="Heading">Functions of the truncated variant</span></h4>

<p><a id="X7A489A5D79DA9E5C" name="X7A489A5D79DA9E5C"></a></p>

<h5>3.8-1 <span class="Heading">Examples</span></h5>

<p>More about these functions can be found in <a href="chapA.html#X79AC59C482A2E4C1"><span class="RefLink">A.4</span></a></p>

<p><a id="X7CD043E081BF2302" name="X7CD043E081BF2302"></a></p>

<h5>3.8-2 SGrobnerTrunc</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SGrobnerTrunc</code>( <var class="Arg">Lnp</var>, <var class="Arg">deg</var>, <var class="Arg">wtv</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: A list of homogeneous NP polynomials if the first argument of the input is a list of homogeneous NP polynomials, and the boolean <code class="code">false</code> otherwise.</p>

<p>This functions should be invoked with a list <var class="Arg">Lnp</var> of polynomials in NP format, a natural number <var class="Arg">deg</var>, and a weight vector <var class="Arg">wtv</var> of length the number of generators of the free algebra <span class="SimpleMath">A</span> containing the elements of <var class="Arg">Lnp</var>, and with positive integers for entries. If the polynomials of <var class="Arg">Lnp</var> are homogeneous with respect to <var class="Arg">wtv</var>, the function will return a Gröbner basis of <var class="Arg">Lnp</var> truncated above <var class="Arg">deg</var>. If the list of polynomials <var class="Arg">Lnp</var> is not homogeneous with respect to <var class="Arg">wtv</var>, it returns <code class="code">false</code>. The homogeneity check can be carried out by <code class="func">CheckHomogeneousNPs</code> (<a href="chap3.html#X83C9E598798D5809"><span class="RefLink">3.8-3</span></a>).</p>

<p><em>Example:</em> Consider the following two polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,2,2,1],[2,1,1,2]],[1,-1]];;
gap&gt; p2 := [[[2,2,2],[1,1]],[1,-1]];;
gap&gt; PrintNPList([p1,p2]);
 ab^2a - ba^2b 
 b^3 - a^2 
</pre></div>

<p>These are homogeneous with respect to weights <span class="SimpleMath">[3,2]</span>. The degrees are <span class="SimpleMath">10</span> and <span class="SimpleMath">6</span>, respectively. The Gröbner basis truncated above degree 12 of the list <code class="code">[p1,p2]</code> is computed and subsequently printed as follows.</p>


<div class="example"><pre>
gap&gt; PrintNPList(SGrobnerTrunc([p1,p2],12,[3,2]));
 ba^2 - a^2b 
 b^3 - a^2 
 ab^2a - a^2b^2 
</pre></div>

<p><a id="X83C9E598798D5809" name="X83C9E598798D5809"></a></p>

<h5>3.8-3 CheckHomogeneousNPs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CheckHomogeneousNPs</code>( <var class="Arg">Lnp</var>, <var class="Arg">wtv</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: A list of weighted degrees of the polynomials if these are homogeneous with respect to <var class="Arg">wtv</var>, and <code class="code">false</code> otherwise.</p>

<p>When invoked with a list of NP polynomials <var class="Arg">Lnp</var> and a weight vector <var class="Arg">wtv</var> (whose entries should be positive integers), this function returns the list of weighted degrees of the polynomials in <var class="Arg">Lnp</var> if these are all homogeneous and nonzero, and <code class="code">false</code> otherwise. Here, a polynomial is (weighted) homogeneous with respect to a weight vector <span class="SimpleMath">w</span> if there is constant <span class="SimpleMath">d</span> such that, for each monomial <span class="SimpleMath">[t_1,...,t_r]</span> of the polynomial the sum of all <span class="SimpleMath">w[t_i]</span> for <span class="SimpleMath">i</span> in <span class="SimpleMath">[1..r]</span> is equal to <span class="SimpleMath">d</span>. The natural number <span class="SimpleMath">d</span> is then called the weighted degree of the polynomial.</p>

<p><em>Example:</em> Consider the following two polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,2,2,1],[2,1,1,2]],[1,-1]];;
gap&gt; p2 := [[[2,2,2],[1,1]],[1,-1]];;
gap&gt; PrintNPList([p1,p2]);
 ab^2a - ba^2b 
 b^3 - a^2 
</pre></div>

<p>These are homogeneous with respect to weights <span class="SimpleMath">[3,2]</span>. The degrees are <span class="SimpleMath">10</span> and <span class="SimpleMath">6</span>, respectively. This is checked as follows.</p>


<div class="example"><pre>
gap&gt; CheckHomogeneousNPs([p1,p2],[3,2]);
[ 10, 6 ]
</pre></div>

<p><a id="X7E33C064875D95CA" name="X7E33C064875D95CA"></a></p>

<h5>3.8-4 BaseQATrunc</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BaseQATrunc</code>( <var class="Arg">Lnp</var>, <var class="Arg">deg</var>, <var class="Arg">wtv</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: A list of monomials if the first argument of the input is a list of homogeneous NP polynomials or <code class="code">false</code>.</p>

<p>When invoked with a list of polynomials <var class="Arg">Lnp</var>, a natural number <var class="Arg">deg</var>, and a weight vector <var class="Arg">wtv</var> of length the number of variables and with positive integers for entries, such that the polynomials of <var class="Arg">Lnp</var> are homogeneous with respect to <var class="Arg">wtv</var>, it returns a list whose <span class="SimpleMath">i</span>-th entry is a basis of monomials of the homogeneous part of degree <span class="SimpleMath">i-1</span> the quotient algebra of the free noncommutative algebra by the weighted homogeneous ideal generated by <var class="Arg">Lnp</var> truncated above <var class="Arg">deg</var>. If the list of polynomials <var class="Arg">Lnp</var> is not homogeneous, it returns <code class="code">false</code>.</p>

<p><em>Example:</em> Consider the truncated Gröbner basis of the following two polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,2,2,1],[2,1,1,2]],[1,-1]];;
gap&gt; p2 := [[[2,2,2],[1,1]],[1,-1]];;
gap&gt; wtv := [3,2];;
gap&gt; GB := SGrobnerTrunc([p1,p2],12,wtv);;
gap&gt; GBNP.ConfigPrint("a","b");
gap&gt; PrintNPList(GB);
 ba^2 - a^2b 
 b^3 - a^2 
 ab^2a - a^2b^2 
</pre></div>

<p>A basis of standard monomials is found and printed as follows.</p>


<div class="example"><pre>
gap&gt; BT := BaseQATrunc(GB,12,wtv);;
gap&gt; for degpart in BT do 
&gt;   for mon in degpart do PrintNP([[mon],[1]]); od;
&gt; od;
 1 
 b 
 a 
 b^2 
 ba 
 ab 
 a^2 
 b^3 
 b^2a 
 bab 
 ab^2 
 aba 
 a^2b 
 b^4 
 a^3 
 b^3a 
 b^2ab 
 bab^2 
 ab^3 
 baba 
 abab 
 a^2b^2 
 b^5 
 a^2ba 
 b^4a 
 a^3b 
 b^3ab 
 b^2ab^2 
 bab^3 
 ab^4 
 a^4 
 b^2aba 
 ab^3a 
 babab 
 abab^2 
 a^2b^3 
 b^6 
</pre></div>

<p><a id="X7C6882DB837A9F5A" name="X7C6882DB837A9F5A"></a></p>

<h5>3.8-5 DimsQATrunc</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DimsQATrunc</code>( <var class="Arg">Lnp</var>, <var class="Arg">deg</var>, <var class="Arg">wtv</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: A list of monomials if the first argument of the input is a list of homogeneous NP polynomials or <code class="code">false</code>.</p>

<p>When invoked with a list of polynomials <var class="Arg">Lnp</var>, a natural number <var class="Arg">deg</var>, and a weight vector <var class="Arg">wtv</var> of length the number of variables and with positive integers for entries, such that the polynomials of <var class="Arg">Lnp</var> are homogeneous with respect to <var class="Arg">wtv</var>, it returns a list of dimensions of the homogeneous parts of the quotient algebra of the free noncommutative algebra by the ideal generated by <var class="Arg">Lnp</var> truncated above <var class="Arg">deg</var>. The <span class="SimpleMath">i</span>-th entry of the list gives the dimension of the homogeneous part of degree <span class="SimpleMath">i-1</span> of the quotient algebra. If the list of polynomials <var class="Arg">Lnp</var> is not homogeneous, it returns <code class="code">false</code>.</p>

<p><em>Example:</em> Consider the truncated Gröbner basis of the following two polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,2,2,1],[2,1,1,2]],[1,-1]];;
gap&gt; p2 := [[[2,2,2],[1,1]],[1,-1]];;
gap&gt; wtv := [3,2];;
gap&gt; GB := SGrobnerTrunc([p1,p2],12,wtv);;
</pre></div>

<p>Information on the dimensions of the homogeneous parts of the quotient algebra is found as follows,</p>


<div class="example"><pre>
gap&gt; DimsQATrunc(GB,12,wtv);
[ 1, 0, 1, 1, 1, 2, 2, 3, 3, 5, 4, 7, 7 ]
</pre></div>

<p><a id="X7FBA7F1D79DA883F" name="X7FBA7F1D79DA883F"></a></p>

<h5>3.8-6 FreqsQATrunc</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FreqsQATrunc</code>( <var class="Arg">Lnp</var>, <var class="Arg">deg</var>, <var class="Arg">wtv</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: A list of multiplicities of frequencies of monomials if the first argument of the input is a list of homogeneous polynomials in NP format, and <code class="code">false</code> otherwise.</p>

<p>The frequency of a monomial is the list of numbers of occurrences of a variable in the monomial for each variable; the multiplicity of a frequency is the number of monomials in the standard basis for a quotient algebra with this frequency. When invoked with a list <var class="Arg">Lnp</var> of polynomials in NP format representing a (truncated) Gröbner basis, a natural number <var class="Arg">deg</var>, and a weight vector <var class="Arg">wtv</var> of length the number of variables and with positive integers for entries, such that the polynomials of <var class="Arg">Lnp</var> are homogeneous with respect to <var class="Arg">wtv</var>, it returns a list of frequencies occurring with their multiplicities for the quotient algebra of the free noncommutative algebra by the ideal generated by <var class="Arg">Lnp</var> truncated above <var class="Arg">deg</var>. The <span class="SimpleMath">i</span>-th entry of the list gives the frequencies of the weight <span class="SimpleMath">(i-1)</span> basis monomials of the quotient algebra. If the list of polynomials <var class="Arg">Lnp</var> is not homogeneous with respect to <var class="Arg">wtv</var>, it returns <code class="code">false</code>.</p>

<p><em>Example:</em> Consider the truncated Gröbner basis of the following two polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,2,2,1],[2,1,1,2]],[1,-1]];;
gap&gt; p2 := [[[2,2,2],[1,1]],[1,-1]];;
gap&gt; wtv := [3,2];;
gap&gt; GB := SGrobnerTrunc([p1,p2],12,wtv);;
gap&gt; PrintNPList(GB);
 ba^2 - a^2b 
 b^3 - a^2 
 ab^2a - a^2b^2 
</pre></div>

<p>The multiplicities of the frequencies of of monomials in a standard basis of the quotient algebra with respect to the ideal generated by <code class="code">GB</code> is found as follows, for weights up to and including 8.</p>


<div class="example"><pre>
gap&gt; F := FreqsQATrunc(GB,8,wtv);
[ [ [ [  ], 1 ] ], [ [ [ 0, 1 ], 1 ] ], [ [ [ 1, 0 ], 1 ] ], 
  [ [ [ 0, 2 ], 1 ] ], [ [ [ 1, 1 ], 2 ] ], 
  [ [ [ 2, 0 ], 1 ], [ [ 0, 3 ], 1 ] ], [ [ [ 1, 2 ], 3 ] ], 
  [ [ [ 2, 1 ], 2 ], [ [ 0, 4 ], 1 ] ] ]
</pre></div>

<p>The interpretation of this data is given by the following lines of code.</p>


<div class="example"><pre>
gap&gt; for f in F do
&gt;   if f[1][1] &lt;&gt; [] then
&gt;     Print("At level ", wtv * (f[1][1]), " the multiplicities are\n");
&gt;     for x in f do
&gt;       Print("  for ",x[1],": ",x[2],"\n");
&gt;     od;
&gt;   else
&gt;     Print("At level ", 0 , " the multiplicity of [] is ",f[1][2],"\n");
&gt;   fi;
&gt;   Print("\n");
&gt; od;
At level 0 the multiplicity of [] is 1

At level 2 the multiplicities are
  for [ 0, 1 ]: 1

At level 3 the multiplicities are
  for [ 1, 0 ]: 1

At level 4 the multiplicities are
  for [ 0, 2 ]: 1

At level 5 the multiplicities are
  for [ 1, 1 ]: 2

At level 6 the multiplicities are
  for [ 2, 0 ]: 1
  for [ 0, 3 ]: 1

At level 7 the multiplicities are
  for [ 1, 2 ]: 3

At level 8 the multiplicities are
  for [ 2, 1 ]: 2
  for [ 0, 4 ]: 1

</pre></div>

<p><a id="X8706DD3287E82019" name="X8706DD3287E82019"></a></p>

<h4>3.9 <span class="Heading">Functions of the module variant</span></h4>

<p><a id="X860966487ED88A43" name="X860966487ED88A43"></a></p>

<h5>3.9-1 SGrobnerModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SGrobnerModule</code>( <var class="Arg">Lnpm</var>, <var class="Arg">Lnp</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: A record <code class="code">GBR</code> containing a Gröbner basis (if found...the general problem is unsolvable) for modules; <code class="code">GBR.p</code> will contain the prefix rules and <code class="code">GBR.ts</code> will contain the two-sided rules, and <code class="code">GBR.pg</code> will be the smallest rank of the free module to which all prefix relations belong</p>

<p>For a list <var class="Arg">Lnpm</var> of vectors in NPM format (see Section <a href="chap2.html#X7FDF3E5E7F33D3A2"><span class="RefLink">2.1</span></a>), and a list <var class="Arg">Lnp</var> of polynomials in NP format, this function will use Buchberger's algorithm with strong normal form applied to the union of <var class="Arg">Lnpm</var>, <var class="Arg">Lnp</var>, the set of polynomials <span class="SimpleMath">x*e-x</span> and <span class="SimpleMath">x*m[i]</span> for <span class="SimpleMath">x</span> a standard indeterminate, a module generator <span class="SimpleMath">m[j]</span> or the dummy indeterminate <span class="SimpleMath">e</span>, and the set of all <span class="SimpleMath">e*x -x</span> for <span class="SimpleMath">x</span> a standard indeterminate, to find a Gröbner Basis record <code class="code">GBR</code> (if possible; the general problem is unsolvable). This record will have a Gröbner Basis <code class="code">GBR.ts</code> for the two-sided ideal generated by <var class="Arg">Lnp</var> and an intersection with the module <code class="code">GBR.p</code> representing the module relations needed to find representative vectors in the module uniquely by means of a strong normal form computation modding out <code class="code">GBR.p</code> and, for the scalars, <code class="code">GBR.ts</code>.</p>

<p><em>Example:</em> Consider the following two polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,2],[]],[1,-2]];;
gap&gt; p2 := [[[1,2,2],[]],[1,-3]];;
</pre></div>

<p>Consider also the following two vectors in NPM format.</p>


<div class="example"><pre>
gap&gt; v1 := [[[-1,1,2],[-1]],[1,-1]];;
gap&gt; v2 := [[[-2,2,2],[-2]],[1,-2]];;
</pre></div>

<p>The Gröbner basis record for this data is found by <code class="func">SGrobnerModule</code>:</p>


<div class="example"><pre>
gap&gt; GBR := SGrobnerModule([v1,v2],[p1,p2]);;
</pre></div>

<p>The record <code class="code">GBR</code> has two fields, <code class="code">p</code> for prefix relations (vectors in the module) and <code class="code">ts</code> for two-sided relations (polynomials in the algebra):</p>


<div class="example"><pre>
gap&gt; PrintNPList(GBR.p);
[ 0, 1 ]
[ 1 , 0]
gap&gt; PrintNPList(GBR.ts);
 b - 3/2a 
 a^3 - 4/3 
</pre></div>

<p><a id="X7E3160E67C504F37" name="X7E3160E67C504F37"></a></p>

<h5>3.9-2 BaseQM</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BaseQM</code>( <var class="Arg">GBR</var>, <var class="Arg">t</var>, <var class="Arg">mt</var>, <var class="Arg">maxno</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: A basis of the module obtained from the free module of rank <var class="Arg">mt</var> over the free algebra on <var class="Arg">t</var> generators by factoring out the submodule generated by the elements of <var class="Arg">GBR</var></p>

<p>When called with a Gröbner basis record <var class="Arg">GBR</var> (see Section <a href="chap2.html#X80DAE0A97CFC95DD"><span class="RefLink">2.8</span></a>), the number of variables <var class="Arg">t</var>, the number of module generators <var class="Arg">mt</var>, and a maximum number of terms to be found, <var class="Arg">maxno</var>, the function <code class="code">BaseQM</code> will return a (partial) base of the quotient module of <span class="SimpleMath">A^mt</span> over the free algebra on <span class="SimpleMath">A</span> on <code class="code">t</code> generators by the right sub <span class="SimpleMath">A</span>-module generated by the elements of <var class="Arg">GBR</var>. Note that the record <var class="Arg">GBR</var> consists of two fields: the list <var class="Arg">GBR.p</var> of vectors in NPM format representing elements of the free module <span class="SimpleMath">A^mt</span>, and the list <var class="Arg">GBR.ts</var> of polynomials in NP format representing elements of <span class="SimpleMath">A</span>. The submodule generated by <var class="Arg">GBR</var> is considered to be the right submodule of <span class="SimpleMath">A^mt</span> generated by <var class="Arg">GBR.p</var> and all elements of the form <span class="SimpleMath">v⋅ np</span> with <span class="SimpleMath">np</span> in the two-sided ideal of <span class="SimpleMath">A</span> generated by <var class="Arg">GBR.ts</var> and <span class="SimpleMath">v</span> in <span class="SimpleMath">A^mt</span>. If this function is invoked with <var class="Arg">maxno</var> equal to 0, then a full basis will be given.</p>

<p>If <var class="Arg">t</var><span class="SimpleMath">=0</span>, then <code class="code">t</code> will be set to the minimal value such that all polynomials of <var class="Arg">GBR.ts</var> and all polynomials occurring in <var class="Arg">GBR.p</var> have at most <code class="code">t</code> variables.</p>

<p>If <var class="Arg">mt</var><span class="SimpleMath">=0</span>, then <code class="code">mt</code> will be set to the minimal value such that all vectors of <var class="Arg">GBR.p</var> belong to <span class="SimpleMath">A^mt</span>.</p>

<p>If the module is cyclic (that is, has a single generator), it is possible to use the Gröbner basis of the ideal in the algebra instead of the Gröbner basis record. This can be done by entering 0 for the number <var class="Arg">mt</var> of module generators.</p>

<p><em>Example:</em> Consider the following two polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,1,2],[]],[1,-1]];;
gap&gt; p2 := [[[2,2,2,1],[]],[1,-1]];;
</pre></div>

<p>Consider also the following two vectors in NPM format.</p>


<div class="example"><pre>
gap&gt; v1 := [[[-1,1,2],[-1]],[1,-1]];;
gap&gt; v2 := [[[-2,2,2],[-2]],[1,-2]];;
</pre></div>

<p>The Gröbner basis record for this data is found by <code class="func">SGrobnerModule</code> (<a href="chap3.html#X860966487ED88A43"><span class="RefLink">3.9-1</span></a>):</p>


<div class="example"><pre>
gap&gt; GBR := SGrobnerModule([v1,v2],[p1,p2]);;
gap&gt; PrintNPList(GBR.ts);
 ba - ab 
 b^2 - a^2 
 a^3b - 1 
 a^5 - b 
gap&gt; PrintNPList(GBR.p);
[ 0, 1 ]
[ b - a , 0]
[ a^2 - 1 , 0]
[ ab - 1 , 0]
</pre></div>

<p>The function <code class="code">BaseQM</code> computes a basis.</p>


<div class="example"><pre>
gap&gt; B := BaseQM(GBR,2,2,0);;
gap&gt; PrintNPList(B);
[ 1 , 0]
[ a , 0]
</pre></div>

<p>The function <code class="code">BaseQM</code> with arguments so as to let the number of dimensions of the module and the number of variables be chosen minimal.</p>


<div class="example"><pre>
gap&gt; B := BaseQM(GBR,0,0,0);;
gap&gt; PrintNPList(B);
[ 1 , 0]
[ a , 0]
</pre></div>

<p>The function <code class="code">BaseQM</code> can also be used to ompute the first three elements of a basis.</p>


<div class="example"><pre>
gap&gt; B := BaseQM(GBR,2,2,3);;
gap&gt; PrintNPList(B);
[ 1 , 0]
[ a , 0]
</pre></div>

<p><a id="X813E6A2C8709C9F3" name="X813E6A2C8709C9F3"></a></p>

<h5>3.9-3 DimQM</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DimQM</code>( <var class="Arg">GBR</var>, <var class="Arg">t</var>, <var class="Arg">mt</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The dimension of the quotient module</p>

<p>When called with a Gröbner basis record <var class="Arg">GBR</var> (see Section <a href="chap2.html#X80DAE0A97CFC95DD"><span class="RefLink">2.8</span></a>), a number of variables <var class="Arg">t</var> at least equal to the number of generators involved in the polynomials of <var class="Arg">GBR.p</var> and <var class="Arg">GBR.ts</var>, and a number of generators <var class="Arg">mt</var> of a free module containing the prefix relations in <var class="Arg">GBR.p</var>, the function <code class="code">DimQM</code> will return the dimension over the coefficient field of the quotient module of the free right module <span class="SimpleMath">A^mt</span> of rank <var class="Arg">mt</var> over the free algebra <span class="SimpleMath">A</span> on <code class="code">t</code> generators by the right sub <span class="SimpleMath">A</span>-module generated by the elements of <var class="Arg">GBR</var>, if this dimension is finite. Otherwise, the computation invoked by the function will not terminate.</p>

<p>If <var class="Arg">t</var><span class="SimpleMath">=0</span>, then <code class="code">t</code> will be set to the minimal value such that all polynomials of <var class="Arg">GBR.ts</var> and all polynomials occurring in <var class="Arg">GBR.p</var> belong to <span class="SimpleMath">A^mt</span>.</p>

<p>If <var class="Arg">mt</var><span class="SimpleMath">=0</span>, then <code class="code">mt</code> will be set to the minimal value such that all vectors of <var class="Arg">GBR.p</var> belong to <span class="SimpleMath">A^mt</span>. <em>Example:</em> Consider the following two polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,1,2],[]],[1,-1]];;
gap&gt; p2 := [[[2,2,2,1],[]],[1,-1]];;
</pre></div>

<p>Consider also the following two vectors in NPM format.</p>


<div class="example"><pre>
gap&gt; v1 := [[[-1,1,2],[-2]],[1,-1]];;
gap&gt; v2 := [[[-2,2,2],[-1]],[1,-2]];;
</pre></div>

<p>The Gröbner basis record for this data is found by <code class="func">SGrobnerModule</code> (<a href="chap3.html#X860966487ED88A43"><span class="RefLink">3.9-1</span></a>):</p>


<div class="example"><pre>
gap&gt; GBR := SGrobnerModule([v1,v2],[p1,p2]);;
</pre></div>

<p>The function <code class="code">DimQM</code> computes the dimension over the rationals of the quotient of the free module over the free algebra on two generators by the submodule generated by the vectors <code class="code">v1</code>, <code class="code">v2</code>, <span class="SimpleMath">[p,q]</span>, where <span class="SimpleMath">p</span> and <span class="SimpleMath">q</span> run over all elements of the two-sided ideal in the free algebra generated by <code class="code">p1</code> and <code class="code">p2</code>.</p>


<div class="example"><pre>
gap&gt; SetInfoLevel(InfoGBNP,2);
gap&gt; DimQM(GBR,2,2);
0
</pre></div>

<p>The answer should be equal to the size of <code class="code">BaseQM(GBR,t,mt,0)</code>.</p>


<div class="example"><pre>
gap&gt; DimQM(GBR,2,2) = Length(BaseQM(GBR,2,2,0));
true
gap&gt; SetInfoLevel(InfoGBNP,0);
</pre></div>

<p><a id="X805FB42A7EEF510F" name="X805FB42A7EEF510F"></a></p>

<h5>3.9-4 MulQM</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MulQM</code>( <var class="Arg">p1</var>, <var class="Arg">p2</var>, <var class="Arg">GBR</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The strong normal form of the product <var class="Arg">p1</var><span class="SimpleMath">*</span><var class="Arg">p2</var> with respect to <var class="Arg">GBR</var></p>

<p>When called with three arguments, the first of which, <var class="Arg">p1</var>, is a module element in NPM format, the second of which, <var class="Arg">p2</var>, is a polynomial in NP format representing an element of the quotient algebra, and the third of which is a Gröbner basis record <var class="Arg">GBR</var>, this function will return the product <code class="code">p1*p2</code> in the module.</p>

<p><em>Example:</em> Consider the following two polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,2],[]],[1,-1]];;
gap&gt; p2 := [[[1,2,2],[]],[1,-1]];;
gap&gt; PrintNPList([p1,p2]);
 a^2b - 1 
 ab^2 - 1 
</pre></div>

<p>Consider also the following two vectors in NPM format.</p>


<div class="example"><pre>
gap&gt; v1 := [[[-1,1,2],[-1]],[1,-1]];;
gap&gt; v2 := [[[-2,2,2],[-2]],[1,-2]];;
gap&gt; PrintNPList([v1,v2]);
[ ab - 1 , 0]
[ 0, b^2 - 2 ]
</pre></div>

<p>The Gröbner basis record for this data is found by <code class="func">SGrobnerModule</code> (<a href="chap3.html#X860966487ED88A43"><span class="RefLink">3.9-1</span></a>):</p>


<div class="example"><pre>
gap&gt; GBR := SGrobnerModule([v1,v2],[p1,p2]);;
gap&gt; PrintNPList(GBR.ts);
 b - a 
 a^3 - 1 
gap&gt; PrintNPList(GBR.p);
[ 0, 1 ]
[ a - 1 , 0]
</pre></div>

<p>The function <code class="code">MulQM</code> computes the product of the vector <code class="code">w</code> with the polynomial <code class="code">q</code>.</p>


<div class="example"><pre>
gap&gt; w := [[[-1,2],[-2,1]],[1,-4]];;
gap&gt; PrintNP(w);
[ b , - 4a ]
gap&gt; q := [[[2,2,1],[1]],[2,3]];;
gap&gt; PrintNP(q);
 2b^2a + 3a 
gap&gt; wq := MulQM(w,q,GBR);;
gap&gt; PrintNP(wq);
[ 5 , 0]
</pre></div>

<p><a id="X87D51A8379C50A80" name="X87D51A8379C50A80"></a></p>

<h5>3.9-5 StrongNormalFormNPM</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StrongNormalFormNPM</code>( <var class="Arg">f</var>, <var class="Arg">GBR</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The strong normal form of a polynomial in NP format with respect to <var class="Arg">GBR</var></p>

<p>When invoked with a polynomial in NP format (see Section <a href="chap2.html#X7FDF3E5E7F33D3A2"><span class="RefLink">2.1</span></a>) and a Gröbner basis record <var class="Arg">GBR</var> (see Section <a href="chap2.html#X80DAE0A97CFC95DD"><span class="RefLink">2.8</span></a>), this function will return the strong normal form (the polynomial reduced by the prefix and two-sided relations of the Gröbner basis combination).</p>

<p>This function assumes that <var class="Arg">GBR.p</var> and <var class="Arg">GBR.ts</var> are ordered (with the ordering <code class="func">LtNP</code> (<a href="chap3.html#X8075AE7E7A8088FF"><span class="RefLink">3.3-9</span></a>)), that the polynomials in <var class="Arg">GBR.ts</var> are monic and clean (see <code class="func">MkMonicNP</code> (<a href="chap3.html#X878A8C027DA25196"><span class="RefLink">3.3-11</span></a>) and <code class="func">CleanNP</code> (<a href="chap3.html#X855F3D4C783000E3"><span class="RefLink">3.3-7</span></a>)), and that the polynomial <var class="Arg">f</var> is clean. Note that a Gröbner basis record as returned by a function like <code class="func">SGrobnerModule</code> (<a href="chap3.html#X860966487ED88A43"><span class="RefLink">3.9-1</span></a>) is in the required form.</p>

<p><em>Example:</em> Consider the following two polynomials in NP format.</p>


<div class="example"><pre>
gap&gt; p1 := [[[1,1,2],[]],[1,-1]];;
gap&gt; p2 := [[[1,2,2],[]],[1,-1]];;
gap&gt; PrintNPList([p1,p2]);
 a^2b - 1 
 ab^2 - 1 
</pre></div>

<p>Consider also the following two vectors in NPM format.</p>


<div class="example"><pre>
gap&gt; v1 := [[[-1,1,2],[-1]],[1,-1]];;
gap&gt; v2 := [[[-2,2,2],[-2]],[1,-2]];;
gap&gt; PrintNPList([v1,v2]);
[ ab - 1 , 0]
[ 0, b^2 - 2 ]
</pre></div>

<p>The Gröbner basis record for this data is found by <code class="func">SGrobnerModule</code> (<a href="chap3.html#X860966487ED88A43"><span class="RefLink">3.9-1</span></a>):</p>


<div class="example"><pre>
gap&gt; GBR := SGrobnerModule([v1,v2],[p1,p2]);;
gap&gt; PrintNPList(GBR.ts);
 b - a 
 a^3 - 1 
gap&gt; PrintNPList(GBR.p);
[ 0, 1 ]
[ a - 1 , 0]
</pre></div>

<p>The vector <code class="code">w</code> is brought into strong normal form with respect to <code class="code">GBR</code>:</p>


<div class="example"><pre>
gap&gt; w := [[[-1,2],[-2,1]],[1,-4]];;
gap&gt; PrintNP(w);
[ b , - 4a ]
gap&gt; v := StrongNormalFormNPM(w,GBR);;
gap&gt; PrintNP(v);
[ 1 , 0]
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chapA.html">A</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
