<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (simpcomp) - Chapter 6: Functions and operations for SCSimplicialComplex</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap6"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chap16.html">16</a>  <a href="chap17.html">17</a>  <a href="chap18.html">18</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap5.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap7.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"></p>
<p><a id="X82BDBFFC81D080D1" name="X82BDBFFC81D080D1"></a></p>
<div class="ChapSects"><a href="chap6.html#X82BDBFFC81D080D1">6 <span class="Heading">Functions and operations for <code class="code">SCSimplicialComplex</code></span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6.html#X7A93E4B08536E2C8">6.1 <span class="Heading">Creating an <code class="code">SCSimplicialComplex</code> object from a facet list</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B5A874584FF34A7">6.1-1 SCFromFacets</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B5470FD7E2320DE">6.1-2 SC</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X827D29DD79A82CFA">6.1-3 SCFromDifferenceCycles</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X804A0B1F85B333C2">6.1-4 SCFromGenerators</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6.html#X867E1FF580230E20">6.2 <span class="Heading">Isomorphism signatures</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7E95E36680C188C4">6.2-1 SCExportToString</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X80098C5F7B80A621">6.2-2 SCExportIsoSig</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7E915DA7821DD513">6.2-3 SCFromIsoSig</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6.html#X79072405786FEA0B">6.3 <span class="Heading">Generating some standard triangulations</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7E04DD807AF33B78">6.3-1 SCBdCyclicPolytope</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X839F3BD37DBA3F3C">6.3-2 SCBdSimplex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X856E48967BBFCF0E">6.3-3 SCEmpty</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7A23532F7A8A3988">6.3-4 SCSimplex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8664A90879248282">6.3-5 SCSeriesTorus</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X87C67A0087F645C1">6.3-6 SCSurface</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X831315CD80BA3654">6.3-7 SCFVectorBdCrossPolytope</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7C010361858F0214">6.3-8 SCFVectorBdCyclicPolytope</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7C3E0F7687AC966E">6.3-9 SCFVectorBdSimplex</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6.html#X814FE0267D7C54A9">6.4 <span class="Heading">Generating infinite series of transitive triangulations</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7EA6421A8156EBDF">6.4-1 SCSeriesAGL</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X85E6FD6D84FF762B">6.4-2 SCSeriesBrehmKuehnelTorus</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X786AD599875BD006">6.4-3 SCSeriesBdHandleBody</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8787A3A4788E950C">6.4-4 SCSeriesBid</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7C0223DF83CC961B">6.4-5 SCSeriesC2n</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7E2927DA7F60D957">6.4-6 SCSeriesConnectedSum</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7D1CEF9F86D3AE66">6.4-7 SCSeriesCSTSurface</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7C56D2B7858A80C7">6.4-8 SCSeriesD2n</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7CCBF8F487036415">6.4-9 SCSeriesHandleBody</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8519C1B678C101BF">6.4-10 SCSeriesHomologySphere</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X78DA125479E1D77F">6.4-11 SCSeriesK</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B8300428516DAD8">6.4-12 SCSeriesKu</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X813C5B0E7FA7C1A3">6.4-13 SCSeriesL</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7EAC6828812A241A">6.4-14 SCSeriesLe</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8280ED8280FF9218">6.4-15 SCSeriesLensSpace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7DDC1B127F21CFA4">6.4-16 SCSeriesPrimeTorus</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7CC3944D7E2F6458">6.4-17 SCSeriesSeifertFibredSpace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B71BC8B7D74AFD5">6.4-18 SCSeriesS2xS2</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6.html#X7899878881EA47F8">6.5 <span class="Heading">A census of regular and chiral maps</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X867D2AFC79B11405">6.5-1 SCChiralMap</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X85BB97CB8240E59B">6.5-2 SCChiralMaps</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B362D25784E7217">6.5-3 SCChiralTori</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7AB15983833FCA6B">6.5-4 SCNrChiralTori</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X87180AD07F799C5A">6.5-5 SCNrRegularTorus</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X83D0946E7E2C4163">6.5-6 SCRegularMap</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7F75F5E183CC097E">6.5-7 SCRegularMaps</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X79B6F47187668CDF">6.5-8 SCRegularTorus</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X87CE08247BE77E44">6.5-9 SCSeriesSymmetricTorus</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6.html#X7F4308DB7C3699D1">6.6 <span class="Heading">Generating new complexes from old</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8255A2F97A7432F9">6.6-1 SCCartesianPower</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X859DA29B83BDE35E">6.6-2 SCCartesianProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X82C9F57780C0B7F8">6.6-3 SCConnectedComponents</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7C63CDF28162C755">6.6-4 SCConnectedProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X81338CE18195607C">6.6-5 SCConnectedSum</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X78B843417D63B408">6.6-6 SCConnectedSumMinus</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X84F3487182AB102A">6.6-7 SCDifferenceCycleCompress</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8510B6CF85070A28">6.6-8 SCDifferenceCycleExpand</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8278E1157A318C32">6.6-9 SCStronglyConnectedComponents</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6.html#X87C1C49987E75A9C">6.7 <span class="Heading">Simplicial complexes from transitive permutation groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7C1592677A76A3E5">6.7-1 SCsFromGroupExt</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7A04D77085D9BE4E">6.7-2 SCsFromGroupByTransitivity</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6.html#X81FDA1407B1E96C9">6.8 <span class="Heading">The classification of cyclic combinatorial 3-manifolds</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X805BBDF58568614F">6.8-1 SCNrCyclic3Mflds</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X84477B9E7CAEED7B">6.8-2 SCCyclic3MfldTopTypes</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X781256E37DA1B69F">6.8-3 SCCyclic3Mfld</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8490744E81DA45BF">6.8-4 SCCyclic3MfldByType</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X86F8AED6843FCD65">6.8-5 SCCyclic3MfldListOfGivenType</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6.html#X81CE90127800B91A">6.9 <span class="Heading">Computing properties of simplicial complexes</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B69B327809F67A0">6.9-1 SCAltshulerSteinberg</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B88925386E197AC">6.9-2 SCAutomorphismGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7A33B8177A7ACD3A">6.9-3 SCAutomorphismGroupInternal</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X78F6EF808047772C">6.9-4 SCAutomorphismGroupSize</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7EAC3A5D7A3339BB">6.9-5 SCAutomorphismGroupStructure</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7E9D5C257F88E5E0">6.9-6 SCAutomorphismGroupTransitivity</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X836DC73380EA7414">6.9-7 SCBoundary</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X812AE7397B4FC88E">6.9-8 SCDehnSommervilleCheck</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X859C3981831B4B81">6.9-9 SCDehnSommervilleMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X80B33CAF7B5476C0">6.9-10 SCDifferenceCycles</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X82351AAE793DCB68">6.9-11 SCDim</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X798175C58050DDBD">6.9-12 SCDualGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X788BAE187D584103">6.9-13 SCEulerCharacteristic</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X81F8071385FD9C1D">6.9-14 SCFVector</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7F8B561C823DDDBA">6.9-15 SCFaceLattice</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7AE0029985BD0775">6.9-16 SCFaceLatticeEx</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7F6FE9B27B8D6922">6.9-17 SCFaces</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B40DFE780A47109">6.9-18 SCFacesEx</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7BDD568184E3419D">6.9-19 SCFacets</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X87DC942881235E25">6.9-20 SCFacetsEx</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X79F60850875BB683">6.9-21 SCFpBettiNumbers</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X875963367A7745FB">6.9-22 SCFundamentalGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B9F77A885E1BABE">6.9-23 SCGVector</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X863CA73D7F66B295">6.9-24 SCGenerators</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X789F8FC77FC0E701">6.9-25 SCGeneratorsEx</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X84FBF0A685547ECD">6.9-26 SCHVector</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X796EBADE7803C622">6.9-27 SCHasBoundary</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7C2A5B4D7E77E444">6.9-28 SCHasInterior</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7A0547F67BBB6546">6.9-29 SCHeegaardSplittingSmallGenus</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7C7335667C162AFA">6.9-30 SCHeegaardSplitting</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X864978877E7D4DA0">6.9-31 SCHomologyClassic</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B0C12F5780FDD9B">6.9-32 SCIncidences</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B4CA6FE78A9880F">6.9-33 SCIncidencesEx</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X862926A079F6DFC2">6.9-34 SCInterior</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8123A6E282CD0174">6.9-35 SCIsCentrallySymmetric</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X81AF20DC814B51A6">6.9-36 SCIsConnected</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X860375D980E9A801">6.9-37 SCIsEmpty</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X83E01C957D2F2458">6.9-38 SCIsEulerianManifold</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X843C3E7F79D8093F">6.9-39 SCIsFlag</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X83F0246384A766F2">6.9-40 SCIsHeegaardSplitting</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7E66FE0C83A3D371">6.9-41 SCIsHomologySphere</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X87BC29AF878E7FD8">6.9-42 SCIsInKd</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7F4BECCA7E67B1B2">6.9-43 SCIsKNeighborly</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X78C860DC851167F7">6.9-44 SCIsOrientable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X79DFCA08808665B7">6.9-45 SCIsPseudoManifold</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7AAA757F842EA23A">6.9-46 SCIsPure</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7EA4F4DB78758652">6.9-47 SCIsShellable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7A2BD5657BBE1CC7">6.9-48 SCIsStronglyConnected</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B935899849C8E40">6.9-49 SCMinimalNonFaces</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7DE069A0823BD56E">6.9-50 SCMinimalNonFacesEx</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X82A224DF787A97BE">6.9-51 SCNeighborliness</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7AC2427184B44C65">6.9-52 SCNumFaces</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X78DACE3478340DB8">6.9-53 SCOrientation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8026B46F8236124D">6.9-54 SCSkel</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X84ACF7D580FE8B76">6.9-55 SCSkelEx</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7E770DE27938B140">6.9-56 SCSpanningTree</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6.html#X8284003382F863A0">6.10 <span class="Heading">Operations on simplicial complexes</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X818757A17DA5CFFC">6.10-1 SCAlexanderDual</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X82D22356858062D6">6.10-2 SCClose</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7CF53D8D7E0FA702">6.10-3 SCCone</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X800BDDD878DFCBDB">6.10-4 SCDeletedJoin</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7FB3D29178076EB4">6.10-5 SCDifference</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7C8D11C684825ADC">6.10-6 SCFillSphere</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7DCB16857D49EC37">6.10-7 SCHandleAddition</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B4BE2C783E6D0BF">6.10-8 SCIntersection</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X85659EC77DFF8183">6.10-9 SCIsIsomorphic</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X81D9CC438313F589">6.10-10 SCIsSubcomplex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8623B92580E8B4E4">6.10-11 SCIsomorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X86576B7287686E2B">6.10-12 SCIsomorphismEx</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X86AC8D81837CC677">6.10-13 SCJoin</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8482E1F67C927BB7">6.10-14 SCNeighbors</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7F8FBEF17ACD0D4F">6.10-15 SCNeighborsEx</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7EDA334983025D3D">6.10-16 SCShelling</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7F967A717D4E41C0">6.10-17 SCShellingExt</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8373598C7FF5D28E">6.10-18 SCShellings</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7987AAE481C31F38">6.10-19 SCSpan</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7AAA4669793C57DC">6.10-20 SCSuspension</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X81DA367A813F7599">6.10-21 SCUnion</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7D5639CB87A0D3F1">6.10-22 SCVertexIdentification</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7E7B17317D1B618D">6.10-23 SCWedge</a></span>
</div></div>
</div>

<h3>6 <span class="Heading">Functions and operations for <code class="code">SCSimplicialComplex</code></span></h3>

<p><a id="X7A93E4B08536E2C8" name="X7A93E4B08536E2C8"></a></p>

<h4>6.1 <span class="Heading">Creating an <code class="code">SCSimplicialComplex</code> object from a facet list</span></h4>

<p>This section contains functions to generate or to construct new simplicial complexes. Some of them obtain new complexes from existing ones, some generate new complexes from scratch.</p>

<p><a id="X7B5A874584FF34A7" name="X7B5A874584FF34A7"></a></p>

<h5>6.1-1 SCFromFacets</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFromFacets</code>( <var class="Arg">facets</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Constructs a simplicial complex object from the given facet list. The facet list <var class="Arg">facets</var> has to be a duplicate free list (or set) which consists of duplicate free entries, which are in turn lists or sets. For the vertex labels (i. e. the entries of the list items of <var class="Arg">facets</var>) an ordering via the less-operator has to be defined. Following Section 4.11 of the <strong class="pkg">GAP</strong> manual this is the case for objects of the following families: rationals <code class="code">IsRat</code>, cyclotomics <code class="code">IsCyclotomic</code>, finite field elements <code class="code">IsFFE</code>, permutations <code class="code">IsPerm</code>, booleans <code class="code">IsBool</code>, characters <code class="code">IsChar</code> and lists (strings) <code class="code">IsList</code>.</p>

<p>Internally the vertices are mapped to the standard labeling <span class="SimpleMath">1..n</span>, where <span class="SimpleMath">n</span> is the number of vertices of the complex and the vertex labels of the original complex are stored in the property ''VertexLabels'', see <code class="func">SCLabels</code> (<a href="chap4.html#X826E9B4482AF2671"><span class="RefLink">4.2-3</span></a>) and the <code class="code">SCRelabel..</code> functions like <code class="func">SCRelabel</code> (<a href="chap4.html#X7B6011907B74EDDA"><span class="RefLink">4.2-6</span></a>) or <code class="func">SCRelabelStandard</code> (<a href="chap4.html#X78E22E3B787DDE90"><span class="RefLink">4.2-7</span></a>).</p>


<div class="example"><pre>
 gap&gt; c:=SCFromFacets([[1,2,5], [1,4,5], [1,4,6], [2,3,5], [3,4,6], [3,5,6]]);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="unnamed complex 9"
  Dim=2
 
 /SimplicialComplex]
 gap&gt; c:=SCFromFacets([["a","b","c"], ["a","b",1], ["a","c",1], ["b","c",1]]);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="unnamed complex 10"
  Dim=2
 
 /SimplicialComplex]
 </pre></div>

<p><a id="X7B5470FD7E2320DE" name="X7B5470FD7E2320DE"></a></p>

<h5>6.1-2 SC</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SC</code>( <var class="Arg">facets</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>A shorter function to create a simplicial complex from a facet list, just calls <code class="func">SCFromFacets</code> (<a href="chap6.html#X7B5A874584FF34A7"><span class="RefLink">6.1-1</span></a>)(<var class="Arg">facets</var>).</p>


<div class="example"><pre>
 gap&gt; c:=SC(Combinations([1..6],5));
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="unnamed complex 11"
  Dim=4
 
 /SimplicialComplex]
 </pre></div>

<p><a id="X827D29DD79A82CFA" name="X827D29DD79A82CFA"></a></p>

<h5>6.1-3 SCFromDifferenceCycles</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFromDifferenceCycles</code>( <var class="Arg">diffcycles</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Creates a simplicial complex object from the list of difference cycles provided. If <var class="Arg">diffcycles</var> is of length <span class="SimpleMath">1</span> the computation is equivalent to the one in <code class="func">SCDifferenceCycleExpand</code> (<a href="chap6.html#X8510B6CF85070A28"><span class="RefLink">6.6-8</span></a>). Otherwise the induced modulus (the sum of all entries of a difference cycle) of all cycles has to be equal and the union of all expanded difference cycles is returned.</p>

<p>A <span class="SimpleMath">n</span>-dimensional difference cycle <span class="SimpleMath">D = (d_1 : ... : d_n+1)</span> induces a simplex <span class="SimpleMath">∆ = ( v_1 , ... , v_n+1 )</span> by <span class="SimpleMath">v_1 = d_1</span>, <span class="SimpleMath">v_i = v_i-1 + d_i</span> and a cyclic group action by <span class="SimpleMath">Z_σ</span> where <span class="SimpleMath">σ = ∑ d_i</span> is the modulus of <span class="SimpleMath">D</span>. The function returns the <span class="SimpleMath">Z_σ</span>-orbit of <span class="SimpleMath">∆</span>.</p>

<p>Note that modulo operations in <strong class="pkg">GAP</strong> are often a little bit cumbersome, since all integer ranges usually start from <span class="SimpleMath">1</span>.</p>


<div class="example"><pre>
 gap&gt; c:=SCFromDifferenceCycles([[1,1,6],[2,3,3]]);;
 gap&gt; c.F;
 [ 8, 24, 16 ]
 gap&gt; c.Homology;
 [ [ 0, [  ] ], [ 2, [  ] ], [ 1, [  ] ] ]
 gap&gt; c.Chi;
 0
 gap&gt; c.HasBoundary;
 false
 gap&gt; SCIsPseudoManifold(c);
 true
 gap&gt; SCIsManifold(c);
 true
 </pre></div>

<p><a id="X804A0B1F85B333C2" name="X804A0B1F85B333C2"></a></p>

<h5>6.1-4 SCFromGenerators</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFromGenerators</code>( <var class="Arg">group</var>, <var class="Arg">generators</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Constructs a simplicial complex object from the set of <var class="Arg">generators</var> on which the group <var class="Arg">group</var> acts, i.e. a complex which has <var class="Arg">group</var> as a subgroup of the automorphism group and a facet list that consists of the <var class="Arg">group</var>-orbits specified by the list of representatives passed in <var class="Arg">generators</var>. Note that <var class="Arg">group</var> is not stored as an attribute of the resulting complex as it might just be a subgroup of the actual automorphism group. Internally calls <code class="code">Orbits</code> and <code class="func">SCFromFacets</code> (<a href="chap6.html#X7B5A874584FF34A7"><span class="RefLink">6.1-1</span></a>).</p>


<div class="example"><pre>
 gap&gt; #group: AGL(1,7) of order 42
 gap&gt; G:=Group([(2,6,5,7,3,4),(1,3,5,7,2,4,6)]);;
 gap&gt; c:=SCFromGenerators(G,[[ 1, 2, 4 ]]);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="complex from generators under unknown group"
  Dim=2
 
 /SimplicialComplex]
 gap&gt; SCLib.DetermineTopologicalType(c);
 [SimplicialComplex
 
  Properties known: BoundaryEx, Dim, FacetsEx, HasBoundary, 
                    IsPseudoManifold, IsPure, Name, SkelExs[], 
                    Vertices.
 
  Name="complex from generators under unknown group"
  Dim=2
  HasBoundary=false
  IsPseudoManifold=true
  IsPure=true
 
 /SimplicialComplex]
 </pre></div>

<p><a id="X867E1FF580230E20" name="X867E1FF580230E20"></a></p>

<h4>6.2 <span class="Heading">Isomorphism signatures</span></h4>

<p>This section contains functions to construct simplicial complexes from isomorphism signatures and to compress closed and strongly connected weak pseudomanifolds to strings.</p>

<p>The isomorphism signature of a closed and strongly connected weak pseudomanifold is a representation which is invariant under relabelings of the underlying complex and thus unique for a combinatorial type, i.e. two complexes are isomorphic iff they have the same isomorphism signature.</p>

<p>To compute the isomorphism signature of a closed and strongly connected weak pseudomanifold <span class="SimpleMath">P</span> we have to compute all canonical labelings of <span class="SimpleMath">P</span> and chose the one that is lexicographically minimal.</p>

<p>A canonical labeling of <span class="SimpleMath">P</span> is determined by chosing a facet <span class="SimpleMath">∆ ∈ P</span> and a numbering <span class="SimpleMath">1, 2, ... , d+1</span> of the vertices of <span class="SimpleMath">∆</span> (which in turn determines a numbering of the co-dimension one faces of <span class="SimpleMath">∆</span> by identifying each face with its opposite vertex). This numbering can then be uniquely extended to a numbering (and thus a labeling) on all vertices of <span class="SimpleMath">P</span> by the weak pseudomanifold property: start at face <span class="SimpleMath">1</span> of <span class="SimpleMath">∆</span> and label the opposite vertex of the unique other facet <span class="SimpleMath">δ</span> meeting face <span class="SimpleMath">1</span> by <span class="SimpleMath">d+2</span>, go on with face <span class="SimpleMath">2</span> of <span class="SimpleMath">∆</span> and so on. After finishing with the first facet we now have a numbering on <span class="SimpleMath">δ</span>, repeat the procedure for <span class="SimpleMath">δ</span>, etc. Whenever the opposite vertex of a face is already labeled (and also, if the vertex occurs for the first time) we note this label. Whenever a facet is already visited we skip this step and keep track of the number of skippings between any two newly discovered facets. This results in a sequence of <span class="SimpleMath">m-1</span> vertex labels together with <span class="SimpleMath">m-1</span> skipping numbers (where <span class="SimpleMath">m</span> denotes the number of facets in <span class="SimpleMath">P</span>) which then can by encoded by characters via a lookup table.</p>

<p>Note that there are precisely <span class="SimpleMath">(d+1)! m</span> canonical labelings we have to check in order to find the lexicographically minimal one. Thus, computing the isomorphism signature of a large or highly dimensional complex can be time consuming. If you are not interested in the isomorphism signature but just in the compressed string representation use <code class="func">SCExportToString</code> (<a href="chap6.html#X7E95E36680C188C4"><span class="RefLink">6.2-1</span></a>) which just computes the first canonical labeling of the complex provided as argument and returns the resulting string.</p>

<p>Note: Another way of storing and loading complexes is provided by simpcomp's library functionality, see Section <a href="chap13.html#X7F84F1AD7AFB97CF"><span class="RefLink">13.1</span></a> for details.</p>

<p><a id="X7E95E36680C188C4" name="X7E95E36680C188C4"></a></p>

<h5>6.2-1 SCExportToString</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCExportToString</code>( <var class="Arg">c</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: string upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes one string representation of a closed and strongly connected weak pseudomanifold. Compare <code class="func">SCExportIsoSig</code> (<a href="chap6.html#X80098C5F7B80A621"><span class="RefLink">6.2-2</span></a>), which returns the lexicographically minimal string representation.</p>


<div class="example"><pre>
 gap&gt; c:=SCSeriesBdHandleBody(3,9);;
 gap&gt; s:=SCExportToString(c); time;
 "deffg.h.f.fahaiciai.i.hai.fbgeiagihbhceceba.g.gag"
 0
 gap&gt; s:=SCExportIsoSig(c); time;
 "deefgaf.hbi.gbh.eaiaeaicg.g.ibf.heg.iff.hggcfffgg"
 9
 </pre></div>

<p><a id="X80098C5F7B80A621" name="X80098C5F7B80A621"></a></p>

<h5>6.2-2 SCExportIsoSig</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCExportIsoSig</code>( <var class="Arg">c</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: string upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the isomorphism signature of a closed, strongly connected weak pseudomanifold. The isomorphism signature is stored as an attribute of the complex.</p>


<div class="example"><pre>
 gap&gt; c:=SCSeriesBdHandleBody(3,9);;
 gap&gt; s:=SCExportIsoSig(c);
 "deefgaf.hbi.gbh.eaiaeaicg.g.ibf.heg.iff.hggcfffgg"
 </pre></div>

<p><a id="X7E915DA7821DD513" name="X7E915DA7821DD513"></a></p>

<h5>6.2-3 SCFromIsoSig</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFromIsoSig</code>( <var class="Arg">str</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a SCSimplicialComplex object upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes a simplicial complex from its isomorphism signature. If a file with isomorphism signatures is provided a list of all complexes is returned.</p>


<div class="example"><pre>
 gap&gt; s:="deeee";;
 gap&gt; c:=SCFromIsoSig(s);;
 gap&gt; SCIsIsomorphic(c,SCBdSimplex(4));
 true
 </pre></div>


<div class="example"><pre>
 gap&gt; s:="deeee";;
 gap&gt; PrintTo("tmp.txt",s,"\n");;
 gap&gt; cc:=SCFromIsoSig("tmp.txt");
 [ [SimplicialComplex
     
      Properties known: Dim, ExportIsoSig, FacetsEx, Name, Vertices.
     
      Name="unnamed complex 9"
      Dim=3
     
     /SimplicialComplex] ]
 gap&gt; cc[1].F;
 [ 5, 10, 10, 5 ]
 </pre></div>

<p><a id="X79072405786FEA0B" name="X79072405786FEA0B"></a></p>

<h4>6.3 <span class="Heading">Generating some standard triangulations</span></h4>

<p><a id="X7E04DD807AF33B78" name="X7E04DD807AF33B78"></a></p>

<h5>6.3-1 SCBdCyclicPolytope</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCBdCyclicPolytope</code>( <var class="Arg">d</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates the boundary complex of the <var class="Arg">d</var>-dimensional cyclic polytope (a combinatorial <span class="SimpleMath">d-1</span>-sphere) on <var class="Arg">n</var> vertices, where <span class="SimpleMath">n≥ d+2</span>.</p>


<div class="example"><pre>
 gap&gt; SCBdCyclicPolytope(3,8); 
 [SimplicialComplex
 
  Properties known: Dim, EulerCharacteristic, FacetsEx, HasBoundary, 
                    Homology, IsConnected, IsStronglyConnected, Name, 
                    NumFaces[], TopologicalType, Vertices.
 
  Name="Bd(C_3(8))"
  Dim=2
  EulerCharacteristic=2
  HasBoundary=false
  Homology=[ [ 0, [ ] ], [ 0, [ ] ], [ 1, [ ] ] ]
  IsConnected=true
  IsStronglyConnected=true
  TopologicalType="S^2"
 
 /SimplicialComplex]
 </pre></div>

<p><a id="X839F3BD37DBA3F3C" name="X839F3BD37DBA3F3C"></a></p>

<h5>6.3-2 SCBdSimplex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCBdSimplex</code>( <var class="Arg">d</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates the boundary of the <span class="SimpleMath">d</span>-simplex <span class="SimpleMath">∆^d</span>, a combinatorial <span class="SimpleMath">d-1</span>-sphere.</p>


<div class="example"><pre>
 gap&gt; SCBdSimplex(5);
 [SimplicialComplex
 
  Properties known: AutomorphismGroup, AutomorphismGroupSize, 
                    AutomorphismGroupStructure, 
                    AutomorphismGroupTransitivity, Dim, 
                    EulerCharacteristic, FacetsEx, GeneratorsEx, 
                    HasBoundary, Homology, IsConnected, 
                    IsStronglyConnected, Name, NumFaces[], 
                    TopologicalType, Vertices.
 
  Name="S^4_6"
  Dim=4
  AutomorphismGroupSize=720
  AutomorphismGroupStructure="S6"
  AutomorphismGroupTransitivity=6
  EulerCharacteristic=2
  HasBoundary=false
  Homology=[ [ 0, [ ] ], [ 0, [ ] ], [ 0, [ ] ], [ 0, [ ] ], [ 1, [ ] ] ]
  IsConnected=true
  IsStronglyConnected=true
  TopologicalType="S^4"
 
 /SimplicialComplex]
 </pre></div>

<p><a id="X856E48967BBFCF0E" name="X856E48967BBFCF0E"></a></p>

<h5>6.3-3 SCEmpty</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCEmpty</code>(  )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates an empty complex (of dimension <span class="SimpleMath">-1</span>), i. e. a <code class="code">SCSimplicialComplex</code> object with empty facet list.</p>


<div class="example"><pre>
 gap&gt; SCEmpty();
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="empty complex"
  Dim=-1
 
 /SimplicialComplex]
 </pre></div>

<p><a id="X7A23532F7A8A3988" name="X7A23532F7A8A3988"></a></p>

<h5>6.3-4 SCSimplex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSimplex</code>( <var class="Arg">d</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates the <var class="Arg">d</var>-simplex.</p>


<div class="example"><pre>
 gap&gt; SCSimplex(3);
 [SimplicialComplex
 
  Properties known: Dim, EulerCharacteristic, FacetsEx, Name, 
                    NumFaces[], TopologicalType, Vertices.
 
  Name="B^3_4"
  Dim=3
  EulerCharacteristic=1
  TopologicalType="B^3"
 
 /SimplicialComplex]
 </pre></div>

<p><a id="X8664A90879248282" name="X8664A90879248282"></a></p>

<h5>6.3-5 SCSeriesTorus</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesTorus</code>( <var class="Arg">d</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates the <span class="SimpleMath">d</span>-torus described in <a href="chapBib.html#biBKuehnel86HigherDimCsaszar">[K\t86]</a>.</p>


<div class="example"><pre>
 gap&gt; t4:=SCSeriesTorus(4);
 [SimplicialComplex
 
  Properties known: DifferenceCycles, Dim, FacetsEx, Name, 
                    TopologicalType, Vertices.
 
  Name="4-torus T^4"
  Dim=4
  TopologicalType="T^4"
 
 /SimplicialComplex]
 gap&gt; t4.Homology;
 [ [ 0, [  ] ], [ 4, [  ] ], [ 6, [  ] ], [ 4, [  ] ], [ 1, [  ] ] ]
 </pre></div>

<p><a id="X87C67A0087F645C1" name="X87C67A0087F645C1"></a></p>

<h5>6.3-6 SCSurface</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSurface</code>( <var class="Arg">g</var>, <var class="Arg">orient</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates the surface of genus <var class="Arg">g</var> where the boolean argument <var class="Arg">orient</var> specifies whether the surface is orientable or not. The surfaces have transitive cyclic group actions and can be described using the minimum amount of <span class="SimpleMath">O(operatornamelog (g))</span> memory. If <var class="Arg">orient</var> is <code class="code">true</code> and <var class="Arg">g</var><span class="SimpleMath">≥ 50</span> or if <var class="Arg">orient</var> is <code class="code">false</code> and <var class="Arg">g</var><span class="SimpleMath">≥ 100</span> only the difference cycles of the surface are returned</p>


<div class="example"><pre>
 gap&gt; c:=SCSurface(23,true); 
 [SimplicialComplex
 
  Properties known: DifferenceCycles, Dim, FacetsEx, Name, 
                    TopologicalType, Vertices.
 
  Name="S_23^or"
  Dim=2
  TopologicalType="(T^2)^#23"
 
 /SimplicialComplex]
 gap&gt; c.Homology;
 [ [ 0, [  ] ], [ 46, [  ] ], [ 1, [  ] ] ]
 gap&gt; c.TopologicalType;
 "(T^2)^#23"
 gap&gt; c:=SCSurface(23,false); 
 [SimplicialComplex
 
  Properties known: DifferenceCycles, Dim, FacetsEx, Name, 
                    TopologicalType, Vertices.
 
  Name="S_23^non"
  Dim=2
  TopologicalType="(RP^2)^#23"
 
 /SimplicialComplex]
 gap&gt; c.Homology;
 [ [ 0, [  ] ], [ 22, [ 2 ] ], [ 0, [  ] ] ]
 gap&gt; c.TopologicalType;
 "(RP^2)^#23"
 </pre></div>


<div class="example"><pre>
 gap&gt; dc:=SCSurface(345,true);
 [ [ 1, 1, 1374 ], [ 2, 343, 1031 ], [ 343, 345, 688 ] ]
 gap&gt; c:=SCFromDifferenceCycles(dc);
 [SimplicialComplex
 
  Properties known: DifferenceCycles, Dim, FacetsEx, Name, Vertices.
 
  Name="complex from diffcycles [ [ 1, 1, 1374 ], [ 2, 343, 1031 ], [ 343, 345,\
  688 ] ]"
  Dim=2
 
 /SimplicialComplex]
 gap&gt; c.Chi;
 -688
 gap&gt; dc:=SCSurface(12345678910,true); time;
 [ [ 1, 1, 24691357816 ], [ 2, 4, 24691357812 ], [ 3, 3, 24691357812 ], 
   [ 4, 12345678907, 12345678907 ] ]
 0
 </pre></div>

<p><a id="X831315CD80BA3654" name="X831315CD80BA3654"></a></p>

<h5>6.3-7 SCFVectorBdCrossPolytope</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFVectorBdCrossPolytope</code>( <var class="Arg">d</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a list of integers of size <code class="code">d + 1</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the <span class="SimpleMath">f</span>-vector of the <span class="SimpleMath">d</span>-dimensional cross polytope without generating the underlying complex.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SCFVectorBdCrossPolytope(50);</span>
[ 100, 4900, 156800, 3684800, 67800320, 1017004800, 12785203200, 
  137440934400, 1282782054400, 10518812846080, 76500457062400, 
  497252970905600, 2907017368371200, 15365663232819200, 73755183517532160, 
  322678927889203200, 1290715711556812800, 4732624275708313600, 
  15941471244491161600, 49418560857922600960, 141195888165493145600, 
  372243705163572838400, 906332499528699084800, 2039248123939572940800, 
  4241636097794311716864, 8156992495758291763200, 14501319992459185356800, 
  23823597130468661657600, 36146147370366245273600, 50604606318512743383040, 
  65296266217435797913600, 77539316133205010022400, 84588344872587283660800, 
  84588344872587283660800, 77337915312079802204160, 64448262760066501836800, 
  48771658304915190579200, 33370081998099867238400, 20535435075753764454400, 
  11294489291664570449920, 5509506971543692902400, 2361217273518725529600, 
  878592473867432755200, 279552150776001331200, 74547240206933688320, 
  16205921784116019200, 2758454771764428800, 344806846470553600, 
  28147497671065600, 1125899906842624 ]
</pre></div>

<p><a id="X7C010361858F0214" name="X7C010361858F0214"></a></p>

<h5>6.3-8 SCFVectorBdCyclicPolytope</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFVectorBdCyclicPolytope</code>( <var class="Arg">d</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a list of integers of size <code class="code">d+1</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the <span class="SimpleMath">f</span>-vector of the <var class="Arg">d</var>-dimensional cyclic polytope on <var class="Arg">n</var> vertices, <span class="SimpleMath">n≥ d+2</span>, without generating the underlying complex.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SCFVectorBdCyclicPolytope(25,198); </span>
[ 198, 19503, 1274196, 62117055, 2410141734, 77526225777, 2126433621312, 
  50768602708824, 1071781612741840, 20256672480820776, 346204947854027808, 
  5395027104058600008, 48354596155522298656, 262068846498922699590, 
  940938105142239825104, 2379003007642628680027, 4396097923113038784642, 
  6062663500381642763609, 6294919173643129209180, 4911378208855785427761, 
  2840750019404460890298, 1183225500922302444568, 335951678686835900832, 
  58265626173398052500, 4661250093871844200 ]
</pre></div>

<p><a id="X7C3E0F7687AC966E" name="X7C3E0F7687AC966E"></a></p>

<h5>6.3-9 SCFVectorBdSimplex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFVectorBdSimplex</code>( <var class="Arg">d</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a list of integers of size <code class="code">d + 1</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the <span class="SimpleMath">f</span>-vector of the <span class="SimpleMath">d</span>-simplex without generating the underlying complex.</p>


<div class="example"><pre>
 gap&gt; SCFVectorBdSimplex(100);
 [ 101, 5050, 166650, 4082925, 79208745, 1267339920, 17199613200, 
   202095455100, 2088319702700, 19212541264840, 158940114100040, 
   1192050855750300, 8160963550905900, 51297485177122800, 297525414027312240, 
   1599199100396803290, 7995995501984016450, 37314645675925410100, 
   163006083742200475700, 668324943343021950370, 2577824781465941808570, 
   9373908296239788394800, 32197337191432316660400, 104641345872155029146300, 
   322295345286237489770604, 942094086221309585483304, 
   2616928017281415515231400, 6916166902815169575968700, 
   17409661513983013070541900, 41783187633559231369300560, 
   95696978128474368620010960, 209337139656037681356273975, 
   437704928371715151926754675, 875409856743430303853509350, 
   1675784582908852295948146470, 3072271735332895875904935195, 
   5397234129638871133346507775, 9090078534128625066688855200, 
   14683973016669317415420458400, 22760158175837441993901710520, 
   33862674359172779551902544920, 48375249084532542217003635600, 
   66375341767149302111702662800, 87494768693060443692698964600, 
   110826707011209895344085355160, 134919469404951176940625649760, 
   157884485473879036845412994400, 177620046158113916451089618700, 
   192119641762857909630770403900, 199804427433372226016001220056, 
   199804427433372226016001220056, 192119641762857909630770403900, 
   177620046158113916451089618700, 157884485473879036845412994400, 
   134919469404951176940625649760, 110826707011209895344085355160, 
   87494768693060443692698964600, 66375341767149302111702662800, 
   48375249084532542217003635600, 33862674359172779551902544920, 
   22760158175837441993901710520, 14683973016669317415420458400, 
   9090078534128625066688855200, 5397234129638871133346507775, 
   3072271735332895875904935195, 1675784582908852295948146470, 
   875409856743430303853509350, 437704928371715151926754675, 
   209337139656037681356273975, 95696978128474368620010960, 
   41783187633559231369300560, 17409661513983013070541900, 
   6916166902815169575968700, 2616928017281415515231400, 
   942094086221309585483304, 322295345286237489770604, 
   104641345872155029146300, 32197337191432316660400, 9373908296239788394800, 
   2577824781465941808570, 668324943343021950370, 163006083742200475700, 
   37314645675925410100, 7995995501984016450, 1599199100396803290, 
   297525414027312240, 51297485177122800, 8160963550905900, 1192050855750300, 
   158940114100040, 19212541264840, 2088319702700, 202095455100, 17199613200, 
   1267339920, 79208745, 4082925, 166650, 5050, 101 ]
 </pre></div>

<p><a id="X814FE0267D7C54A9" name="X814FE0267D7C54A9"></a></p>

<h4>6.4 <span class="Heading">Generating infinite series of transitive triangulations</span></h4>

<p><a id="X7EA6421A8156EBDF" name="X7EA6421A8156EBDF"></a></p>

<h5>6.4-1 SCSeriesAGL</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesAGL</code>( <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a permutation group and a list of <span class="SimpleMath">5</span>-tuples of integers upon success, <code class="keyw">fail</code> otherwise.</p>

<p>For a given prime <var class="Arg">p</var> the automorphism group (AGL<span class="SimpleMath">(1,p)</span>) and the generators of all members of the series of <span class="SimpleMath">2</span>-transitive combinatorial <span class="SimpleMath">4</span>-pseudomanifolds with <var class="Arg">p</var> vertices from <a href="chapBib.html#biBSpreer10Diss">[Spr11a]</a>, Section 5.2, is computed. The affine linear group AGL<span class="SimpleMath">(1,p)</span> is returned as the first argument. If no member of the series with <var class="Arg">p</var> vertices exists only the group is returned.</p>


<div class="example"><pre>
 gap&gt; gens:=SCSeriesAGL(17);
 [ AGL(1,17), [ [ 1, 2, 4, 8, 16 ] ] ]
 gap&gt; c:=SCFromGenerators(gens[1],gens[2]);;
 gap&gt; SCIsManifold(SCLink(c,1));
 true
 </pre></div>


<div class="example"><pre>
 gap&gt; List([19..23],x-&gt;SCSeriesAGL(x));     
 #I  SCSeriesAGL: argument must be a prime &gt; 13.
 #I  SCSeriesAGL: argument must be a prime &gt; 13.
 #I  SCSeriesAGL: argument must be a prime &gt; 13.
 [ [ AGL(1,19), [ [ 1, 2, 10, 12, 17 ] ] ], fail, fail, fail, 
   [ AGL(1,23), [ [ 1, 2, 7, 9, 19 ], [ 1, 2, 4, 8, 22 ] ] ] ]
 gap&gt; for i in [80000..80100] do if IsPrime(i) then Print(i,"\n"); fi; od;
 80021
 80039
 80051
 80071
 80077
 gap&gt; SCSeriesAGL(80021);                                                 
 AGL(1,80021)
 gap&gt; SCSeriesAGL(80039);                                                 
 [ AGL(1,80039), [ [ 1, 2, 6496, 73546, 78018 ] ] ]
 gap&gt; SCSeriesAGL(80051);                                                 
 [ AGL(1,80051), [ [ 1, 2, 31498, 37522, 48556 ] ] ]
 gap&gt; SCSeriesAGL(80071);                                                 
 AGL(1,80071)
 gap&gt; SCSeriesAGL(80077);                                                 
 [ AGL(1,80077), [ [ 1, 2, 4126, 39302, 40778 ] ] ]
 </pre></div>

<p><a id="X85E6FD6D84FF762B" name="X85E6FD6D84FF762B"></a></p>

<h5>6.4-2 SCSeriesBrehmKuehnelTorus</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesBrehmKuehnelTorus</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates a neighborly 3-torus with <var class="Arg">n</var> vertices if <var class="Arg">n</var> is odd and a centrally symmetric 3-torus if <var class="Arg">n</var> is even (<var class="Arg">n</var><span class="SimpleMath">≥ 15</span> . The triangulations are taken from <a href="chapBib.html#biBBrehm09LatticeTrigE33Torus">[BK12]</a></p>


<div class="example"><pre>
 gap&gt; T3:=SCSeriesBrehmKuehnelTorus(15);
 [SimplicialComplex
 
  Properties known: DifferenceCycles, Dim, FacetsEx, Name, 
                    TopologicalType, Vertices.
 
  Name="Neighborly 3-Torus NT3(15)"
  Dim=3
  TopologicalType="T^3"
 
 /SimplicialComplex]
 gap&gt; T3.Homology;
 [ [ 0, [  ] ], [ 3, [  ] ], [ 3, [  ] ], [ 1, [  ] ] ]
 gap&gt; T3.Neighborliness;
 2
 gap&gt; T3:=SCSeriesBrehmKuehnelTorus(16);
 [SimplicialComplex
 
  Properties known: DifferenceCycles, Dim, FacetsEx, Name, 
                    TopologicalType, Vertices.
 
  Name="Centrally symmetric 3-Torus SCT3(16)"
  Dim=3
  TopologicalType="T^3"
 
 /SimplicialComplex]
 gap&gt; T3.Homology;
 [ [ 0, [  ] ], [ 3, [  ] ], [ 3, [  ] ], [ 1, [  ] ] ]
 gap&gt; T3.IsCentrallySymmetric;
 true
 </pre></div>

<p><a id="X786AD599875BD006" name="X786AD599875BD006"></a></p>

<h5>6.4-3 SCSeriesBdHandleBody</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesBdHandleBody</code>( <var class="Arg">d</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p><code class="code">SCSeriesBdHandleBody(d,n)</code> generates a transitive <span class="SimpleMath">d</span>-dimensional sphere bundle (<span class="SimpleMath">d ≥ 2</span>) with <span class="SimpleMath">n</span> vertices (<span class="SimpleMath">n ≥ 2d + 3</span>) which coincides with the boundary of <code class="func">SCSeriesHandleBody</code> (<a href="chap6.html#X7CCBF8F487036415"><span class="RefLink">6.4-9</span></a>)<code class="code">(d,n)</code>. The sphere bundle is orientable if <span class="SimpleMath">d</span> is even or if <span class="SimpleMath">d</span> is odd and <span class="SimpleMath">n</span> is even, otherwise it is not orientable. Internally calls <code class="func">SCFromDifferenceCycles</code> (<a href="chap6.html#X827D29DD79A82CFA"><span class="RefLink">6.1-3</span></a>).</p>


<div class="example"><pre>
 gap&gt; c:=SCSeriesBdHandleBody(2,7);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, IsOrientable, Name, TopologicalType, 
                    Vertices.
 
  Name="Sphere bundle S^1 x S^1"
  Dim=2
  IsOrientable=true
  TopologicalType="S^1 x S^1"
 
 /SimplicialComplex]
 gap&gt; SCLib.DetermineTopologicalType(c);
 [SimplicialComplex
 
  Properties known: BoundaryEx, Dim, FacetsEx, HasBoundary, 
                    IsOrientable, IsPseudoManifold, IsPure, Name, 
                    SkelExs[], TopologicalType, Vertices.
 
  Name="Sphere bundle S^1 x S^1"
  Dim=2
  HasBoundary=false
  IsOrientable=true
  IsPseudoManifold=true
  IsPure=true
  TopologicalType="S^1 x S^1"
 
 /SimplicialComplex]
 gap&gt; SCIsIsomorphic(c,SCSeriesHandleBody(3,7).Boundary);
 true
 </pre></div>

<p><a id="X8787A3A4788E950C" name="X8787A3A4788E950C"></a></p>

<h5>6.4-4 SCSeriesBid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesBid</code>( <var class="Arg">i</var>, <var class="Arg">d</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a simplicial complex upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Constructs the complex <span class="SimpleMath">B(i,d)</span> as described in <a href="chapBib.html#biBKlee11CentSymmMnfFewVert">[KN12]</a>, cf. <a href="chapBib.html#biBEffenberger10Diss">[Eff11a]</a>, <a href="chapBib.html#biBSparla99LBTComb2kMnf">[Spa99]</a>. The complex <span class="SimpleMath">B(i,d)</span> is a <span class="SimpleMath">i</span>-Hamiltonian subcomplex of the <span class="SimpleMath">d</span>-cross polytope and its boundary topologically is a sphere product <span class="SimpleMath">S^i× S^d-i-2</span> with vertex transitive automorphism group.</p>


<div class="example"><pre>
 gap&gt; b26:=SCSeriesBid(2,6);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Reference, Vertices.
 
  Name="B(2,6)"
  Dim=5
 
 /SimplicialComplex]
 gap&gt; s2s2:=SCBoundary(b26);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="Bd(B(2,6))"
  Dim=4
 
 /SimplicialComplex]
 gap&gt; SCFVector(s2s2);
 [ 12, 60, 160, 180, 72 ]
 gap&gt; SCAutomorphismGroup(s2s2); 
 Group([ (1,3)(4,6)(7,9)(10,12), (1,5)(2,10)(4,8)(6,12)(7,11), (1,10,7,4)
 (2,3,8,9)(5,12,11,6) ])
 gap&gt; SCIsManifold(s2s2); 
 true
 gap&gt; SCHomology(s2s2);
 [ [ 0, [  ] ], [ 0, [  ] ], [ 2, [  ] ], [ 0, [  ] ], [ 1, [  ] ] ]
 </pre></div>

<p><a id="X7C0223DF83CC961B" name="X7C0223DF83CC961B"></a></p>

<h5>6.4-5 SCSeriesC2n</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesC2n</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates the combinatorial <span class="SimpleMath">3</span>-manifold <span class="SimpleMath">C_2n</span>, <span class="SimpleMath">n ≥ 8</span>, with <span class="SimpleMath">2n</span> vertices from <a href="chapBib.html#biBSpreer10Diss">[Spr11a]</a>, Section 4.5.3 and Section 5.2. The complex is homeomorphic to <span class="SimpleMath">S^2 × S^1</span> for <span class="SimpleMath">n</span> odd and homeomorphic to <span class="SimpleMath">S^2 dtimes S^1</span> in case <span class="SimpleMath">n</span> is an even number. In the latter case <span class="SimpleMath">C_2n</span> is isomorphic to <span class="SimpleMath">D_2n</span> from <code class="func">SCSeriesD2n</code> (<a href="chap6.html#X7C56D2B7858A80C7"><span class="RefLink">6.4-8</span></a>). The complexes are believed to appear as the vertex links of some of the members of the series of <span class="SimpleMath">2</span>-transitive <span class="SimpleMath">4</span>-pseudomanifolds from <code class="func">SCSeriesAGL</code> (<a href="chap6.html#X7EA6421A8156EBDF"><span class="RefLink">6.4-1</span></a>). Internally calls <code class="func">SCFromDifferenceCycles</code> (<a href="chap6.html#X827D29DD79A82CFA"><span class="RefLink">6.1-3</span></a>).</p>


<div class="example"><pre>
 gap&gt; c:=SCSeriesC2n(8);
 [SimplicialComplex
 
  Properties known: DifferenceCycles, Dim, FacetsEx, Name, 
                    TopologicalType, Vertices.
 
  Name="C_16 = { (1:1:3:11),(1:1:11:3),(1:3:1:11),(2:3:2:9),(2:5:2:7) }"
  Dim=3
  TopologicalType="S^2 ~ S^1"
 
 /SimplicialComplex]
 gap&gt; SCGenerators(c);  
 [ [ [ 1, 2, 3, 6 ], 32 ], [ [ 1, 2, 5, 6 ], 16 ], [ [ 1, 3, 6, 8 ], 16 ], 
   [ [ 1, 3, 8, 10 ], 16 ] ]
 </pre></div>


<div class="example"><pre>
 gap&gt; c:=SCSeriesC2n(8);;
 gap&gt; d:=SCSeriesD2n(8); 
 [SimplicialComplex
 
  Properties known: DifferenceCycles, Dim, FacetsEx, Name, 
                    TopologicalType, Vertices.
 
  Name="D_16 = { (1:1:1:13),(1:2:11:2),(3:4:5:4),(2:3:4:7),(2:7:4:3) }"
  Dim=3
  TopologicalType="S^2 ~ S^1"
 
 /SimplicialComplex]
 gap&gt; SCIsIsomorphic(c,d);
 true
 gap&gt; c:=SCSeriesC2n(11);;
 gap&gt; d:=SCSeriesD2n(11);;
 gap&gt; c.Homology;
 [ [ 0, [  ] ], [ 1, [  ] ], [ 1, [  ] ], [ 1, [  ] ] ]
 gap&gt; d.Homology;
 [ [ 0, [  ] ], [ 1, [  ] ], [ 0, [ 2 ] ], [ 0, [  ] ] ]
 </pre></div>

<p><a id="X7E2927DA7F60D957" name="X7E2927DA7F60D957"></a></p>

<h5>6.4-6 SCSeriesConnectedSum</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesConnectedSum</code>( <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates a combinatorial manifold of type <span class="SimpleMath">(S^2 x S^1)^#k</span> for <span class="SimpleMath">k</span> even. The complex is a combinatorial <span class="SimpleMath">3</span>-manifold with transitive cyclic symmetry as described in <a href="chapBib.html#biBSpreer12VarCyclPolytope">[BS14]</a>.</p>


<div class="example"><pre>
 gap&gt; c:=SCSeriesConnectedSum(12);
 [SimplicialComplex
 
  Properties known: DifferenceCycles, Dim, FacetsEx, Name, 
                    TopologicalType, Vertices.
 
  Name="(S^2xS^1)^#12)"
  Dim=3
  TopologicalType="(S^2xS^1)^#12)"
 
 /SimplicialComplex]
 gap&gt; c.Homology;
 [ [ 0, [  ] ], [ 12, [  ] ], [ 12, [  ] ], [ 1, [  ] ] ]
 gap&gt; g:=SimplifiedFpGroup(SCFundamentalGroup(c));
 &lt;fp group of size infinity on the generators 
 [ [2,3], [2,14], [3,4], [6,7], [9,10], [10,11], [11,12], [12,13], [26,32], 
   [26,34], [29,31], [33,35] ]&gt;
 gap&gt; RelatorsOfFpGroup(g);
 [  ]
 </pre></div>

<p><a id="X7D1CEF9F86D3AE66" name="X7D1CEF9F86D3AE66"></a></p>

<h5>6.4-7 SCSeriesCSTSurface</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesCSTSurface</code>( <var class="Arg">l</var>[, <var class="Arg">j</var>], <var class="Arg">2k</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p><code class="code">SCSeriesCSTSurface(l,j,2k)</code> generates the centrally symmetric transitive (cst) surface <span class="SimpleMath">S_(l,j,2k)</span>, <code class="code">SCSeriesCSTSurface(l,2k)</code> generates the cst surface <span class="SimpleMath">S_(l,2k)</span> from <a href="chapBib.html#biBSpreer10PartBetaK">[Spr12]</a>, Section 4.4.</p>


<div class="example"><pre>
 gap&gt; SCSeriesCSTSurface(2,4,14);
 [SimplicialComplex
 
  Properties known: DifferenceCycles, Dim, FacetsEx, Name, Vertices.
 
  Name="cst surface S_{(2,4,14)} = { (2:4:8),(2:8:4) }"
  Dim=2
 
 /SimplicialComplex]
 gap&gt; last.Homology;
 [ [ 1, [  ] ], [ 4, [  ] ], [ 2, [  ] ] ]
 gap&gt; SCSeriesCSTSurface(2,10);  
 [SimplicialComplex
 
  Properties known: DifferenceCycles, Dim, FacetsEx, Name, Vertices.
 
  Name="cst surface S_{(2,10)} = { (2:2:6),(3:3:4) }"
  Dim=2
 
 /SimplicialComplex]
 gap&gt; last.Homology;                    
 [ [ 0, [  ] ], [ 1, [ 2 ] ], [ 0, [  ] ] ]
 </pre></div>

<p><a id="X7C56D2B7858A80C7" name="X7C56D2B7858A80C7"></a></p>

<h5>6.4-8 SCSeriesD2n</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesD2n</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates the combinatorial <span class="SimpleMath">3</span>-manifold <span class="SimpleMath">D_2n</span>, <span class="SimpleMath">n ≥ 8</span>, <span class="SimpleMath">n ≠ 9</span>, with <span class="SimpleMath">2n</span> vertices from <a href="chapBib.html#biBSpreer10Diss">[Spr11a]</a>, Section 4.5.3 and Section 5.2. The complex is homeomorphic to <span class="SimpleMath">S^2 dtimes S^1</span>. In the case that <span class="SimpleMath">n</span> is even <span class="SimpleMath">D_2n</span> is isomorphic to <span class="SimpleMath">C_2n</span> from <code class="func">SCSeriesC2n</code> (<a href="chap6.html#X7C0223DF83CC961B"><span class="RefLink">6.4-5</span></a>). The complexes are believed to appear as the vertex links of some of the members of the series of <span class="SimpleMath">2</span>-transitive <span class="SimpleMath">4</span>-pseudomanifolds from <code class="func">SCSeriesAGL</code> (<a href="chap6.html#X7EA6421A8156EBDF"><span class="RefLink">6.4-1</span></a>). Internally calls <code class="func">SCFromDifferenceCycles</code> (<a href="chap6.html#X827D29DD79A82CFA"><span class="RefLink">6.1-3</span></a>).</p>


<div class="example"><pre>
 gap&gt; d:=SCSeriesD2n(15);
 [SimplicialComplex
 
  Properties known: DifferenceCycles, Dim, FacetsEx, Name, 
                    TopologicalType, Vertices.
 
  Name="D_30 = { (1:1:1:27),(1:2:25:2),(3:11:5:11),(2:3:11:14),(2:14:11:3) }"
  Dim=3
  TopologicalType="S^2 ~ S^1"
 
 /SimplicialComplex]
 gap&gt; SCAutomorphismGroup(d);  
 Group([ (1,3)(4,30)(5,29)(6,28)(7,27)(8,26)(9,25)(10,24)(11,23)(12,22)(13,21)
 (14,20)(15,19)(16,18), (1,4)(2,3)(5,30)(6,29)(7,28)(8,27)(9,26)(10,25)(11,24)
 (12,23)(13,22)(14,21)(15,20)(16,19)(17,18) ])
 gap&gt; StructureDescription(last);
 "D60"
 </pre></div>


<div class="example"><pre>
 gap&gt; c:=SCSeriesC2n(8);;
 gap&gt; d:=SCSeriesD2n(8); 
 [SimplicialComplex
 
  Properties known: DifferenceCycles, Dim, FacetsEx, Name, 
                    TopologicalType, Vertices.
 
  Name="D_16 = { (1:1:1:13),(1:2:11:2),(3:4:5:4),(2:3:4:7),(2:7:4:3) }"
  Dim=3
  TopologicalType="S^2 ~ S^1"
 
 /SimplicialComplex]
 gap&gt; SCIsIsomorphic(c,d);
 true
 gap&gt; c:=SCSeriesC2n(11);;
 gap&gt; d:=SCSeriesD2n(11);;
 gap&gt; c.Homology;
 [ [ 0, [  ] ], [ 1, [  ] ], [ 1, [  ] ], [ 1, [  ] ] ]
 gap&gt; d.Homology;
 [ [ 0, [  ] ], [ 1, [  ] ], [ 0, [ 2 ] ], [ 0, [  ] ] ]
 </pre></div>

<p><a id="X7CCBF8F487036415" name="X7CCBF8F487036415"></a></p>

<h5>6.4-9 SCSeriesHandleBody</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesHandleBody</code>( <var class="Arg">d</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p><code class="code">SCSeriesHandleBody(d,n)</code> generates a transitive <span class="SimpleMath">d</span>-dimensional handle body (<span class="SimpleMath">d ≥ 3</span>) with <span class="SimpleMath">n</span> vertices (<span class="SimpleMath">n ≥ 2d + 1</span>). The handle body is orientable if <span class="SimpleMath">d</span> is odd or if <span class="SimpleMath">d</span> and <span class="SimpleMath">n</span> are even, otherwise it is not orientable. The complex equals the difference cycle <span class="SimpleMath">(1 : ... : 1 : n-d)</span> To obtain the boundary complexes of <code class="code">SCSeriesHandleBody(d,n)</code> use the function <code class="func">SCSeriesBdHandleBody</code> (<a href="chap6.html#X786AD599875BD006"><span class="RefLink">6.4-3</span></a>). Internally calls <code class="func">SCFromDifferenceCycles</code> (<a href="chap6.html#X827D29DD79A82CFA"><span class="RefLink">6.1-3</span></a>).</p>


<div class="example"><pre>
 gap&gt; c:=SCSeriesHandleBody(3,7);
 [SimplicialComplex
 
  Properties known: DifferenceCycles, Dim, FacetsEx, IsOrientable, 
                    Name, TopologicalType, Vertices.
 
  Name="Handle body B^2 x S^1"
  Dim=3
  IsOrientable=true
  TopologicalType="B^2 x S^1"
 
 /SimplicialComplex]
 gap&gt; SCAutomorphismGroup(c);    
 Group([ (1,3)(4,7)(5,6), (1,4)(2,3)(5,7) ])
 gap&gt; bd:=SCBoundary(c);;
 gap&gt; SCAutomorphismGroup(bd);
 Group([ (1,2)(3,7)(4,6), (1,4,2)(3,5,6) ])
 gap&gt; SCIsIsomorphic(bd,SCSeriesBdHandleBody(2,7));
 true
 </pre></div>

<p><a id="X8519C1B678C101BF" name="X8519C1B678C101BF"></a></p>

<h5>6.4-10 SCSeriesHomologySphere</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesHomologySphere</code>( <var class="Arg">p</var>, <var class="Arg">q</var>, <var class="Arg">r</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates a combinatorial Brieskorn homology sphere of type <span class="SimpleMath">Σ (p,q,r)</span>, <span class="SimpleMath">p</span>, <span class="SimpleMath">q</span> and <span class="SimpleMath">r</span> pairwise co-prime. The complex is a combinatorial <span class="SimpleMath">3</span>-manifold with transitive cyclic symmetry as described in <a href="chapBib.html#biBSpreer12VarCyclPolytope">[BS14]</a>.</p>


<div class="example"><pre>
 gap&gt; c:=SCSeriesHomologySphere(2,3,5);
 [SimplicialComplex
 
  Properties known: DifferenceCycles, Dim, FacetsEx, Name, 
                    TopologicalType, Vertices.
 
  Name="Homology sphere Sigma(2,3,5)"
  Dim=3
  TopologicalType="Sigma(2,3,5)"
 
 /SimplicialComplex]
 gap&gt; c.Homology;
 [ [ 0, [  ] ], [ 0, [  ] ], [ 0, [  ] ], [ 1, [  ] ] ]
 gap&gt; c:=SCSeriesHomologySphere(3,4,13);
 [SimplicialComplex
 
  Properties known: DifferenceCycles, Dim, FacetsEx, Name, 
                    TopologicalType, Vertices.
 
  Name="Homology sphere Sigma(3,4,13)"
  Dim=3
  TopologicalType="Sigma(3,4,13)"
 
 /SimplicialComplex]
 gap&gt; c.Homology;
 [ [ 0, [  ] ], [ 0, [  ] ], [ 0, [  ] ], [ 1, [  ] ] ]
 </pre></div>

<p><a id="X78DA125479E1D77F" name="X78DA125479E1D77F"></a></p>

<h5>6.4-11 SCSeriesK</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesK</code>( <var class="Arg">i</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates the <var class="Arg">k</var>-th member (<span class="SimpleMath">k ≥ 0</span>) of the series <var class="Arg">K^i</var> (<span class="SimpleMath">1 ≤ i ≤ 396</span>) from <a href="chapBib.html#biBSpreer10Diss">[Spr11a]</a>. The <span class="SimpleMath">396</span> series describe a complete classification of all dense series (i. e. there is a member of the series for every integer, <span class="SimpleMath">f_0 (K^i (k+1) ) = f_0 (K^i (k)) +1</span>) of cyclic <span class="SimpleMath">3</span>-manifolds with a fixed number of difference cycles and at least one member with less than <span class="SimpleMath">23</span> vertices. See <code class="func">SCSeriesL</code> (<a href="chap6.html#X813C5B0E7FA7C1A3"><span class="RefLink">6.4-13</span></a>) for a list of series of order <span class="SimpleMath">2</span>.</p>


<div class="example"><pre>
 gap&gt; cc:=List([1..10],x-&gt;SCSeriesK(x,0));;                                                                                                                                                                                                  
 gap&gt; Set(List(cc,x-&gt;x.F));                                                                                                                                                                                                                        
 [ [ 9, 36, 54, 27 ], [ 11, 55, 88, 44 ], [ 13, 65, 104, 52 ], 
   [ 13, 78, 130, 65 ], [ 15, 90, 150, 75 ], [ 15, 105, 180, 90 ] ]
 gap&gt; cc:=List([1..10],x-&gt;SCSeriesK(x,10));;
 gap&gt; gap&gt; cc:=List([1..10],x-&gt;SCSeriesK(x,10));;
 gap&gt; Set(List(cc,x-&gt;x.Homology));
 [ [ [ 0, [  ] ], [ 1, [  ] ], [ 0, [ 2 ] ], [ 0, [  ] ] ] ]
 gap&gt; Set(List(cc,x-&gt;x.IsManifold));
 [ true ]
 </pre></div>

<p><a id="X7B8300428516DAD8" name="X7B8300428516DAD8"></a></p>

<h5>6.4-12 SCSeriesKu</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesKu</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the symmetric orientable sphere bundle Ku<span class="SimpleMath">(n)</span> with <span class="SimpleMath">4n</span> vertices from <a href="chapBib.html#biBSpreer10Diss">[Spr11a]</a>, Section 4.5.2. The series is defined as a generalization of the slicings from <a href="chapBib.html#biBSpreer10Diss">[Spr11a]</a>, Section 3.3.</p>


<div class="example"><pre>
 gap&gt; c:=SCSeriesKu(4);                                    
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="Sl_16 = G{ [1,2,5,9],[1,2,9,10],[1,5,9,16] }"
  Dim=3
 
 /SimplicialComplex]
 gap&gt; SCSlicing(c,[[1,2,3,4,9,10,11,12],[5,6,7,8,13,14,15,16]]);
 [NormalSurface
 
  Properties known: ConnectedComponents, Dim, EulerCharacteristic, FVector, Fac\
 etsEx, Genus, IsConnected, IsOrientable, NSTriangulation, Name, TopologicalTyp\
 e, Vertices.
 
  Name="slicing [ [ 1, 2, 3, 4, 9, 10, 11, 12 ], [ 5, 6, 7, 8, 13, 14, 15, 16 ]\
  ] of Sl_16 = G{ [1,2,5,9],[1,2,9,10],[1,5,9,16] }"
  Dim=2
  FVector=[ 32, 80, 32, 16 ]
  EulerCharacteristic=0
  IsOrientable=true
  TopologicalType="T^2"
 
 /NormalSurface]
 gap&gt; Mminus:=SCSpan(c,[1,2,3,4,9,10,11,12]);;                  
 gap&gt; Mplus:=SCSpan(c,[5,6,7,8,13,14,15,16]);;                  
 gap&gt; SCCollapseGreedy(Mminus).Facets;
 [ [ 3, 4 ], [ 3, 10 ], [ 4, 12 ], [ 9, 10 ], [ 9, 12 ] ]
 gap&gt; SCCollapseGreedy(Mplus).Facets; 
 [ [ 5, 6 ], [ 5, 8 ], [ 6, 14 ], [ 7, 8 ], [ 7, 15 ], [ 14, 15 ] ]
 </pre></div>

<p><a id="X813C5B0E7FA7C1A3" name="X813C5B0E7FA7C1A3"></a></p>

<h5>6.4-13 SCSeriesL</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesL</code>( <var class="Arg">i</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates the <var class="Arg">k</var>-th member (<span class="SimpleMath">k ≥ 0</span>) of the series <var class="Arg">L^i</var>, <span class="SimpleMath">1 ≤ i ≤ 18</span> from <a href="chapBib.html#biBSpreer10Diss">[Spr11a]</a>. The <span class="SimpleMath">18</span> series describe a complete classification of all series of cyclic <span class="SimpleMath">3</span>-manifolds with a fixed number of difference cycles of order <span class="SimpleMath">2</span> (i. e. there is a member of the series for every second integer, <span class="SimpleMath">f_0 (L^i (k+1) ) = f_0 (L^i (k)) +2</span>) and at least one member with less than <span class="SimpleMath">15</span> vertices where each series does not appear as a sub series of one of the series <span class="SimpleMath">K^i</span> from <code class="func">SCSeriesK</code> (<a href="chap6.html#X78DA125479E1D77F"><span class="RefLink">6.4-11</span></a>).</p>


<div class="example"><pre>
 gap&gt; cc:=List([1..18],x-&gt;SCSeriesL(x,0));;
 gap&gt; Set(List(cc,x-&gt;x.F));
 [ [ 10, 45, 70, 35 ], [ 12, 60, 96, 48 ], [ 12, 66, 108, 54 ], 
   [ 14, 77, 126, 63 ], [ 14, 84, 140, 70 ], [ 14, 91, 154, 77 ] ]
 gap&gt; cc:=List([1..18],x-&gt;SCSeriesL(x,10));; 
 gap&gt; Set(List(cc,x-&gt;x.IsManifold));
 [ true ]
 </pre></div>

<p><a id="X7EAC6828812A241A" name="X7EAC6828812A241A"></a></p>

<h5>6.4-14 SCSeriesLe</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesLe</code>( <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates the <var class="Arg">k</var>-th member (<span class="SimpleMath">k ≥ 7</span>) of the series <code class="code">Le</code> from <a href="chapBib.html#biBSpreer10Diss">[Spr11a]</a>, Section 4.5.1. The series can be constructed as the generalization of the boundary of a genus <span class="SimpleMath">1</span> handlebody decomposition of the manifold <code class="code">manifold_3_14_1_5</code> from the classification in <a href="chapBib.html#biBLutz03TrigMnfFewVertVertTrans">[Lut03]</a>.</p>


<div class="example"><pre>
 gap&gt; c:=SCSeriesLe(7);                     
 [SimplicialComplex
 
  Properties known: DifferenceCycles, Dim, FacetsEx, Name, Vertices.
 
  Name="Le_14 = { (1:1:1:11),(1:2:4:7),(1:4:2:7),(2:1:4:7),(2:5:2:5),(2:4:2:6) \
 }"
  Dim=3
 
 /SimplicialComplex]
 gap&gt; d:=SCLib.DetermineTopologicalType(c);;
 gap&gt; SCReference(d);
 "manifold_3_14_1_5 in F.H.Lutz: 'The Manifold Page', http://www.math.tu-berlin\
 .de/diskregeom/stellar/,\r\nF.H.Lutz: 'Triangulated manifolds with few vertice\
 s and vertex-transitive group actions', Doctoral Thesis TU Berlin 1999, Shaker\
 -Verlag, Aachen 1999"
 </pre></div>

<p><a id="X8280ED8280FF9218" name="X8280ED8280FF9218"></a></p>

<h5>6.4-15 SCSeriesLensSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesLensSpace</code>( <var class="Arg">p</var>, <var class="Arg">q</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates the lens space <span class="SimpleMath">L(p,q)</span> whenever <span class="SimpleMath">p = (k+2)^2-1</span> and <span class="SimpleMath">q = k+2</span> or <span class="SimpleMath">p = 2k+3</span> and <span class="SimpleMath">q = 1</span> for a <span class="SimpleMath">k ≥ 0</span> and <code class="keyw">fail</code> otherwise. All complexes have a transitive cyclic automorphism group.</p>


<div class="example"><pre>
 gap&gt; l154:=SCSeriesLensSpace(15,4);
 [SimplicialComplex
 
  Properties known: DifferenceCycles, Dim, FacetsEx, Name, 
                    TopologicalType, Vertices.
 
  Name="Lens space L(15,4)"
  Dim=3
  TopologicalType="L(15,4)"
 
 /SimplicialComplex]
 gap&gt; l154.Homology;
 [ [ 0, [  ] ], [ 0, [ 15 ] ], [ 0, [  ] ], [ 1, [  ] ] ]
 gap&gt; g:=SimplifiedFpGroup(SCFundamentalGroup(l154));
 &lt;fp group on the generators [ [2,5] ]&gt;
 gap&gt; StructureDescription(g);
 "C15"
 </pre></div>


<div class="example"><pre>
 gap&gt; l151:=SCSeriesLensSpace(15,1);
 [SimplicialComplex
 
  Properties known: DifferenceCycles, Dim, FacetsEx, Name, 
                    TopologicalType, Vertices.
 
  Name="Lens space L(15,1)"
  Dim=3
  TopologicalType="L(15,1)"
 
 /SimplicialComplex]
 gap&gt; l151.Homology;
 [ [ 0, [  ] ], [ 0, [ 15 ] ], [ 0, [  ] ], [ 1, [  ] ] ]
 gap&gt; g:=SimplifiedFpGroup(SCFundamentalGroup(l151));
 &lt;fp group on the generators [ [2,3] ]&gt;
 gap&gt; StructureDescription(g);
 "C15"
 </pre></div>

<p><a id="X7DDC1B127F21CFA4" name="X7DDC1B127F21CFA4"></a></p>

<h5>6.4-16 SCSeriesPrimeTorus</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesPrimeTorus</code>( <var class="Arg">l</var>, <var class="Arg">j</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates the well known triangulated torus <span class="SimpleMath">{ (l:j:p-l-j),(l:p-l-j:j) }</span> with <span class="SimpleMath">p</span> vertices, <span class="SimpleMath">3p</span> edges and <span class="SimpleMath">2p</span> triangles where <span class="SimpleMath">j</span> has to be greater than <span class="SimpleMath">l</span> and <span class="SimpleMath">p</span> must be any prime number greater than <span class="SimpleMath">6</span>.</p>


<div class="example"><pre>
 gap&gt; l:=List([2..19],x-&gt;SCSeriesPrimeTorus(1,x,41));; 
 gap&gt; Set(List(l,x-&gt;SCHomology(x)));
 [ [ [ 0, [  ] ], [ 2, [  ] ], [ 1, [  ] ] ] ]
 </pre></div>

<p><a id="X7CC3944D7E2F6458" name="X7CC3944D7E2F6458"></a></p>

<h5>6.4-17 SCSeriesSeifertFibredSpace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesSeifertFibredSpace</code>( <var class="Arg">p</var>, <var class="Arg">q</var>, <var class="Arg">r</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates a combinatorial Seifert fibred space of type</p>

<p class="pcenter">SFS [ (\mathbb{T}^2)^{(a-1)(b-1)} : (p/a,b_1)^b , (q/b,b_2)^a, (r/ab,b_3) ]</p>

<p>where <span class="SimpleMath">p</span> and <span class="SimpleMath">q</span> are co-prime, <span class="SimpleMath">a = operatornamegcd (p,r)</span>, <span class="SimpleMath">b = operatornamegcd (p,r)</span>, and the <span class="SimpleMath">b_i</span> are given by the identity</p>

<p class="pcenter">\frac{b_1}{p} + \frac{b_2}{q} + \frac{b_3}{r} = \frac{\pm ab}{pqr}.</p>

<p>This <span class="SimpleMath">3</span>-parameter family of combinatorial <span class="SimpleMath">3</span>-manifolds contains the families generated by <code class="func">SCSeriesHomologySphere</code> (<a href="chap6.html#X8519C1B678C101BF"><span class="RefLink">6.4-10</span></a>), <code class="func">SCSeriesConnectedSum</code> (<a href="chap6.html#X7E2927DA7F60D957"><span class="RefLink">6.4-6</span></a>) and parts of <code class="func">SCSeriesLensSpace</code> (<a href="chap6.html#X8280ED8280FF9218"><span class="RefLink">6.4-15</span></a>), internally calls <code class="keyw">SCIntFunc.SeifertFibredSpace(p,q,r)</code>. The complexes are combinatorial <span class="SimpleMath">3</span>-manifolds with transitive cyclic symmetry as described in <a href="chapBib.html#biBSpreer12VarCyclPolytope">[BS14]</a>.</p>


<div class="example"><pre>
 gap&gt; c:=SCSeriesSeifertFibredSpace(2,3,15);
 [SimplicialComplex
 
  Properties known: DifferenceCycles, Dim, FacetsEx, Name, 
                    TopologicalType, Vertices.
 
  Name="SFS [ S^2 : (2,b1)^3, (5,b3) ]"
  Dim=3
  TopologicalType="SFS [ S^2 : (2,b1)^3, (5,b3) ]"
 
 /SimplicialComplex]
 gap&gt; c.Homology;
 [ [ 0, [  ] ], [ 0, [ 2, 2 ] ], [ 0, [  ] ], [ 1, [  ] ] ]
 </pre></div>

<p><a id="X7B71BC8B7D74AFD5" name="X7B71BC8B7D74AFD5"></a></p>

<h5>6.4-18 SCSeriesS2xS2</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesS2xS2</code>( <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Generates a combinatorial version of <span class="SimpleMath">(S^2 × S^2)^# k</span>.</p>


<div class="example"><pre>
 gap&gt; c:=SCSeriesS2xS2(3);
 [SimplicialComplex
 
  Properties known: DifferenceCycles, Dim, FacetsEx, Name, 
                    TopologicalType, Vertices.
 
  Name="(S^2 x S^2)^(# 3)"
  Dim=4
  TopologicalType="(S^2 x S^2)^(# 3)"
 
 /SimplicialComplex]
 gap&gt; c.Homology;
 [ [ 0, [  ] ], [ 0, [  ] ], [ 6, [  ] ], [ 0, [  ] ], [ 1, [  ] ] ]
 </pre></div>

<p><a id="X7899878881EA47F8" name="X7899878881EA47F8"></a></p>

<h4>6.5 <span class="Heading">A census of regular and chiral maps</span></h4>

<p><a id="X867D2AFC79B11405" name="X867D2AFC79B11405"></a></p>

<h5>6.5-1 SCChiralMap</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCChiralMap</code>( <var class="Arg">m</var>, <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a <code class="keyw">SCSimplicialComplex</code> object upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns the (hyperbolic) chiral map of vertex valence <var class="Arg">m</var> and genus <var class="Arg">g</var> if existent and <code class="keyw">fail</code> otherwise. The list was generated with the help of the classification of regular maps by Marston Conder <a href="chapBib.html#biBConder09RegMapsOfBdChi">[Con09]</a>. Use <code class="func">SCChiralMaps</code> (<a href="chap6.html#X85BB97CB8240E59B"><span class="RefLink">6.5-2</span></a>) to get a list of all chiral maps available.</p>


<div class="example"><pre>
 gap&gt; SCChiralMaps();
 [ [ 7, 17 ], [ 8, 10 ], [ 8, 28 ], [ 8, 37 ], [ 8, 46 ], [ 8, 82 ], 
   [ 9, 43 ], [ 10, 73 ], [ 12, 22 ], [ 12, 33 ], [ 12, 40 ], [ 12, 51 ], 
   [ 12, 58 ], [ 12, 64 ], [ 12, 85 ], [ 12, 94 ], [ 12, 97 ], [ 18, 28 ] ]
 gap&gt; c:=SCChiralMap(8,10);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, TopologicalType, Vertices.
 
  Name="Chiral map {8,10}"
  Dim=2
  TopologicalType="(T^2)^#10"
 
 /SimplicialComplex]
 gap&gt; c.Homology;
 [ [ 0, [  ] ], [ 20, [  ] ], [ 1, [  ] ] ]
 </pre></div>

<p><a id="X85BB97CB8240E59B" name="X85BB97CB8240E59B"></a></p>

<h5>6.5-2 SCChiralMaps</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCChiralMaps</code>(  )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a list of lists upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns a list of all simplicial (hyperbolic) chiral maps of orientable genus up to <span class="SimpleMath">100</span>. The list was generated with the help of the classification of regular maps by Marston Conder <a href="chapBib.html#biBConder09RegMapsOfBdChi">[Con09]</a>. Every chiral map is given by a <span class="SimpleMath">2</span>-tuple <span class="SimpleMath">(m,g)</span> where <span class="SimpleMath">m</span> is the vertex valence and <span class="SimpleMath">g</span> is the genus of the map. Use the <span class="SimpleMath">2</span>-tuples of the list together with <code class="func">SCChiralMap</code> (<a href="chap6.html#X867D2AFC79B11405"><span class="RefLink">6.5-1</span></a>) to get the corresponding triangulations.</p>


<div class="example"><pre>
 gap&gt; ll:=SCChiralMaps();
 [ [ 7, 17 ], [ 8, 10 ], [ 8, 28 ], [ 8, 37 ], [ 8, 46 ], [ 8, 82 ], 
   [ 9, 43 ], [ 10, 73 ], [ 12, 22 ], [ 12, 33 ], [ 12, 40 ], [ 12, 51 ], 
   [ 12, 58 ], [ 12, 64 ], [ 12, 85 ], [ 12, 94 ], [ 12, 97 ], [ 18, 28 ] ]
 gap&gt; c:=SCChiralMap(ll[18][1],ll[18][2]);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, TopologicalType, Vertices.
 
  Name="Chiral map {18,28}"
  Dim=2
  TopologicalType="(T^2)^#28"
 
 /SimplicialComplex]
 gap&gt; SCHomology(c);
 [ [ 0, [  ] ], [ 56, [  ] ], [ 1, [  ] ] ]
 </pre></div>

<p><a id="X7B362D25784E7217" name="X7B362D25784E7217"></a></p>

<h5>6.5-3 SCChiralTori</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCChiralTori</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a <code class="keyw">SCSimplicialComplex</code> object upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns a list of chiral triangulations of the torus with <span class="SimpleMath">n</span> vertices. See <a href="chapBib.html#biBBrehm08EquivMapsTorus">[BK08]</a> for details.</p>


<div class="example"><pre>
 gap&gt; cc:=SCChiralTori(91);
 [ [SimplicialComplex
     
      Properties known: AutomorphismGroup, Dim, FacetsEx, Name, 
                        TopologicalType, Vertices.
     
      Name="{3,6}_(9,1)"
      Dim=2
      TopologicalType="T^2"
     
     /SimplicialComplex], [SimplicialComplex
     
      Properties known: AutomorphismGroup, Dim, FacetsEx, Name, 
                        TopologicalType, Vertices.
     
      Name="{3,6}_(6,5)"
      Dim=2
      TopologicalType="T^2"
     
     /SimplicialComplex] ]
 gap&gt; SCIsIsomorphic(cc[1],cc[2]);
 false
 </pre></div>

<p><a id="X7AB15983833FCA6B" name="X7AB15983833FCA6B"></a></p>

<h5>6.5-4 SCNrChiralTori</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCNrChiralTori</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: an integer upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns the number of simplicial chiral maps on the torus with <span class="SimpleMath">n</span> vertices, cf. <a href="chapBib.html#biBBrehm08EquivMapsTorus">[BK08]</a> for details.</p>


<div class="example"><pre>
 gap&gt; SCNrChiralTori(7);
 1
 gap&gt; SCNrChiralTori(343);
 2
 </pre></div>

<p><a id="X87180AD07F799C5A" name="X87180AD07F799C5A"></a></p>

<h5>6.5-5 SCNrRegularTorus</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCNrRegularTorus</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: an integer upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns the number of simplicial regular maps on the torus with <span class="SimpleMath">n</span> vertices, cf. <a href="chapBib.html#biBBrehm08EquivMapsTorus">[BK08]</a> for details.</p>


<div class="example"><pre>
 gap&gt; SCNrRegularTorus(9);
 1
 gap&gt; SCNrRegularTorus(10);
 0
 </pre></div>

<p><a id="X83D0946E7E2C4163" name="X83D0946E7E2C4163"></a></p>

<h5>6.5-6 SCRegularMap</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCRegularMap</code>( <var class="Arg">m</var>, <var class="Arg">g</var>, <var class="Arg">orient</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a <code class="keyw">SCSimplicialComplex</code> object upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns the (hyperbolic) regular map of vertex valence <var class="Arg">m</var>, genus <var class="Arg">g</var> and orientability <var class="Arg">orient</var> if existent and <code class="keyw">fail</code> otherwise. The triangulations were generated with the help of the classification of regular maps by Marston Conder <a href="chapBib.html#biBConder09RegMapsOfBdChi">[Con09]</a>. Use <code class="func">SCRegularMaps</code> (<a href="chap6.html#X7F75F5E183CC097E"><span class="RefLink">6.5-7</span></a>) to get a list of all regular maps available.</p>


<div class="example"><pre>
 gap&gt; SCRegularMaps(){[1..10]};
 [ [ 7, 3, true ], [ 7, 7, true ], [ 7, 8, false ], [ 7, 14, true ], 
   [ 7, 15, false ], [ 7, 147, false ], [ 8, 3, true ], [ 8, 5, true ], 
   [ 8, 8, true ], [ 8, 9, false ] ]
 gap&gt; c:=SCRegularMap(7,7,true);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, TopologicalType, Vertices.
 
  Name="Orientable regular map {7,7}"
  Dim=2
  TopologicalType="(T^2)^#7"
 
 /SimplicialComplex]
 gap&gt; g:=SCAutomorphismGroup(c);
 #I  group not listed
 C2 x PSL(2,8)
 gap&gt; Size(g);
 1008
 </pre></div>

<p><a id="X7F75F5E183CC097E" name="X7F75F5E183CC097E"></a></p>

<h5>6.5-7 SCRegularMaps</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCRegularMaps</code>(  )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a list of lists upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns a list of all simplicial (hyperbolic) regular maps of orientable genus up to <span class="SimpleMath">100</span> or non-orientable genus up to <span class="SimpleMath">200</span>. The list was generated with the help of the classification of regular maps by Marston Conder <a href="chapBib.html#biBConder09RegMapsOfBdChi">[Con09]</a>. Every regular map is given by a <span class="SimpleMath">3</span>-tuple <span class="SimpleMath">(m,g,or)</span> where <span class="SimpleMath">m</span> is the vertex valence, <span class="SimpleMath">g</span> is the genus and <span class="SimpleMath">or</span> is a boolean stating if the map is orientable or not. Use the <span class="SimpleMath">3</span>-tuples of the list together with <code class="func">SCRegularMap</code> (<a href="chap6.html#X83D0946E7E2C4163"><span class="RefLink">6.5-6</span></a>) to get the corresponding triangulations. <span class="SimpleMath">g</span></p>


<div class="example"><pre>
 gap&gt; ll:=SCRegularMaps(){[1..10]};
 [ [ 7, 3, true ], [ 7, 7, true ], [ 7, 8, false ], [ 7, 14, true ], 
   [ 7, 15, false ], [ 7, 147, false ], [ 8, 3, true ], [ 8, 5, true ], 
   [ 8, 8, true ], [ 8, 9, false ] ]
 gap&gt; c:=SCRegularMap(ll[5][1],ll[5][2],ll[5][3]);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, TopologicalType, Vertices.
 
  Name="Non-orientable regular map {7,15}"
  Dim=2
  TopologicalType="(RP^2)^#15"
 
 /SimplicialComplex]
 gap&gt; SCHomology(c);
 [ [ 0, [  ] ], [ 14, [ 2 ] ], [ 0, [  ] ] ]
 gap&gt; SCGenerators(c);
 [ [ [ 1, 4, 7 ], 182 ] ]
 </pre></div>

<p><a id="X79B6F47187668CDF" name="X79B6F47187668CDF"></a></p>

<h5>6.5-8 SCRegularTorus</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCRegularTorus</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a <code class="keyw">SCSimplicialComplex</code> object upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns a list of regular triangulations of the torus with <span class="SimpleMath">n</span> vertices (the length of the list will be at most <span class="SimpleMath">1</span>). See <a href="chapBib.html#biBBrehm08EquivMapsTorus">[BK08]</a> for details.</p>


<div class="example"><pre>
 gap&gt; cc:=SCRegularTorus(9);
 [ [SimplicialComplex
     
      Properties known: AutomorphismGroup, Dim, FacetsEx, Name, 
                        TopologicalType, Vertices.
     
      Name="{3,6}_(3,0)"
      Dim=2
      TopologicalType="T^2"
     
     /SimplicialComplex] ]
 gap&gt; g:=SCAutomorphismGroup(cc[1]);
 Group([ (2,7)(3,4)(5,9), (1,4,2)(3,7,9)(5,8,6), (2,8,7,3,6,4)(5,9) ])
 gap&gt; SCNumFaces(cc[1],0)*12 = Size(g);
 true
 </pre></div>

<p><a id="X87CE08247BE77E44" name="X87CE08247BE77E44"></a></p>

<h5>6.5-9 SCSeriesSymmetricTorus</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSeriesSymmetricTorus</code>( <var class="Arg">p</var>, <var class="Arg">q</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a <code class="keyw">SCSimplicialComplex</code> object upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns the equivarient triangulation of the torus <span class="SimpleMath">{ 3,6 }_(p,q)</span> with fundamental domain <span class="SimpleMath">(p,q)</span> on the <span class="SimpleMath">2</span>-dimensional integer lattice. See <a href="chapBib.html#biBBrehm08EquivMapsTorus">[BK08]</a> for details.</p>


<div class="example"><pre>
 gap&gt; c:=SCSeriesSymmetricTorus(2,1);
 [SimplicialComplex
 
  Properties known: AutomorphismGroup, Dim, FacetsEx, Name, 
                    TopologicalType, Vertices.
 
  Name="{3,6}_(2,1)"
  Dim=2
  TopologicalType="T^2"
 
 /SimplicialComplex]
 gap&gt; SCFVector(c);
 [ 7, 21, 14 ]
 </pre></div>

<p>See also <code class="func">SCSurface</code> (<a href="chap6.html#X87C67A0087F645C1"><span class="RefLink">6.3-6</span></a>) for example triangulations of all compact closed surfaces with transitive cyclic automorphism group.</p>

<p><a id="X7F4308DB7C3699D1" name="X7F4308DB7C3699D1"></a></p>

<h4>6.6 <span class="Heading">Generating new complexes from old</span></h4>

<p><a id="X8255A2F97A7432F9" name="X8255A2F97A7432F9"></a></p>

<h5>6.6-1 SCCartesianPower</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCCartesianPower</code>( <var class="Arg">complex</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>The new complex is <span class="SimpleMath">PL</span>-homeomorphic to <span class="SimpleMath">n</span> times the cartesian product of <var class="Arg">complex</var>, of dimensions <span class="SimpleMath">n ⋅ d</span> and has <span class="SimpleMath">f_d^n ⋅ n ⋅ frac2n-12^n-1}!</span> facets where <span class="SimpleMath">d</span> denotes the dimension and <span class="SimpleMath">f_d</span> denotes the number of facets of <var class="Arg">complex</var>. Note that the complex returned by the function is not the <span class="SimpleMath">n</span>-fold cartesian product <var class="Arg">complex</var><span class="SimpleMath">^n</span> of <var class="Arg">complex</var> (which, in general, is not simplicial) but a simplicial subdivision of <var class="Arg">complex</var><span class="SimpleMath">^n</span>.</p>


<div class="example"><pre>
 gap&gt; c:=SCBdSimplex(2);;
 gap&gt; 4torus:=SCCartesianPower(c,4);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, TopologicalType, Vertices.
 
  Name="(S^1_3)^4"
  Dim=4
  TopologicalType="(S^1)^4"
 
 /SimplicialComplex]
 gap&gt; 4torus.Homology;
 [ [ 0, [  ] ], [ 4, [  ] ], [ 6, [  ] ], [ 4, [  ] ], [ 1, [  ] ] ]
 gap&gt; 4torus.Chi;
 0
 gap&gt; 4torus.F;
 [ 81, 1215, 4050, 4860, 1944 ]
 </pre></div>

<p><a id="X859DA29B83BDE35E" name="X859DA29B83BDE35E"></a></p>

<h5>6.6-2 SCCartesianProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCCartesianProduct</code>( <var class="Arg">complex1</var>, <var class="Arg">complex2</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the simplicial cartesian product of <var class="Arg">complex1</var> and <var class="Arg">complex2</var> where <var class="Arg">complex1</var> and <var class="Arg">complex2</var> are pure, simplicial complexes. The original vertex labeling of <var class="Arg">complex1</var> and <var class="Arg">complex2</var> is changed into the standard one. The new complex has vertex labels of type <span class="SimpleMath">[v_i, v_j]</span> where <span class="SimpleMath">v_i</span> is a vertex of <var class="Arg">complex1</var> and <span class="SimpleMath">v_j</span> is a vertex of <var class="Arg">complex2</var>.</p>

<p>If <span class="SimpleMath">n_i</span>, <span class="SimpleMath">i=1,2</span>, are the number facets and <span class="SimpleMath">d_i</span>, <span class="SimpleMath">i=1,2</span>, are the dimensions of <var class="Arg">complexi</var>, then the new complex has <span class="SimpleMath">n_1 ⋅ n_2 ⋅ d_1+d_2 choose d_1</span> facets. The number of vertices of the new complex equals the product of the numbers of vertices of the arguments.</p>


<div class="example"><pre>
 gap&gt; c1:=SCBdSimplex(2);;
 gap&gt; c2:=SCBdSimplex(3);;
 gap&gt; c3:=SCCartesianProduct(c1,c2);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, TopologicalType, Vertices.
 
  Name="S^1_3xS^2_4"
  Dim=3
  TopologicalType="S^1xS^2"
 
 /SimplicialComplex]
 gap&gt; c3.Homology;
 [ [ 0, [  ] ], [ 1, [  ] ], [ 1, [  ] ], [ 1, [  ] ] ]
 gap&gt; c3.F;
 [ 12, 48, 72, 36 ]
 </pre></div>

<p><a id="X82C9F57780C0B7F8" name="X82C9F57780C0B7F8"></a></p>

<h5>6.6-3 SCConnectedComponents</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCConnectedComponents</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list of simplicial complexes of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes all connected components of an arbitrary simplicial complex.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2,3],[3,4,5],[4,5,6,7,8]]);;
 gap&gt; SCRename(c,"connected complex");;
 gap&gt; SCConnectedComponents(c);
 [ [SimplicialComplex
     
      Properties known: Dim, FacetsEx, Name, Vertices.
     
      Name="Connected component #1 of connected complex"
      Dim=4
     
     /SimplicialComplex] ]
 gap&gt; c:=SC([[1,2,3],[4,5],[6,7,8]]);;
 gap&gt; SCRename(c,"non-connected complex");;
 gap&gt; SCConnectedComponents(c);
 [ [SimplicialComplex
     
      Properties known: Dim, FacetsEx, Name, Vertices.
     
      Name="Connected component #1 of non-connected complex"
      Dim=2
     
     /SimplicialComplex], [SimplicialComplex
     
      Properties known: Dim, FacetsEx, Name, Vertices.
     
      Name="Connected component #2 of non-connected complex"
      Dim=1
     
     /SimplicialComplex], [SimplicialComplex
     
      Properties known: Dim, FacetsEx, Name, Vertices.
     
      Name="Connected component #3 of non-connected complex"
      Dim=2
     
     /SimplicialComplex] ]
 </pre></div>

<p><a id="X7C63CDF28162C755" name="X7C63CDF28162C755"></a></p>

<h5>6.6-4 SCConnectedProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCConnectedProduct</code>( <var class="Arg">complex</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>If <span class="SimpleMath">n ≥ 2</span>, the function internally calls <span class="SimpleMath">1 ×</span> <code class="func">SCConnectedSum</code> (<a href="chap6.html#X81338CE18195607C"><span class="RefLink">6.6-5</span></a>) and <span class="SimpleMath">(n-2) ×</span> <code class="func">SCConnectedSumMinus</code> (<a href="chap6.html#X78B843417D63B408"><span class="RefLink">6.6-6</span></a>).</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("T^2"){[1..6]};
 [ [ 4, "T^2 (VT)" ], [ 5, "T^2 (VT)" ], [ 9, "T^2 (VT)" ], [ 10, "T^2 (VT)" ],
   [ 18, "T^2 (VT)" ], [ 20, "(T^2)#2" ] ]
 gap&gt; torus:=SCLib.Load(last[1][1]);;
 gap&gt; genus10:=SCConnectedProduct(torus,10);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="T^2 (VT)#+-T^2 (VT)#+-T^2 (VT)#+-T^2 (VT)#+-T^2 (VT)#+-T^2 (VT)#+-T^2 (\
 VT)#+-T^2 (VT)#+-T^2 (VT)#+-T^2 (VT)"
  Dim=2
 
 /SimplicialComplex]
 gap&gt; genus10.Chi;
 -18
 gap&gt; genus10.F;
 [ 43, 183, 122 ]
 </pre></div>

<p><a id="X81338CE18195607C" name="X81338CE18195607C"></a></p>

<h5>6.6-5 SCConnectedSum</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCConnectedSum</code>( <var class="Arg">complex1</var>, <var class="Arg">complex2</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>In a lexicographic ordering the smallest facet of both <var class="Arg">complex1</var> and <var class="Arg">complex2</var> is removed and the complexes are glued together along the resulting boundaries. The bijection used to identify the vertices of the boundaries differs from the one chosen in <code class="func">SCConnectedSumMinus</code> (<a href="chap6.html#X78B843417D63B408"><span class="RefLink">6.6-6</span></a>) by a transposition. Thus, the topological type of <code class="code">SCConnectedSum</code> is different from the one of <code class="func">SCConnectedSumMinus</code> (<a href="chap6.html#X78B843417D63B408"><span class="RefLink">6.6-6</span></a>) whenever <var class="Arg">complex1</var> and <var class="Arg">complex2</var> do not allow an orientation reversing homeomorphism.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("T^2"){[1..6]};
 [ [ 4, "T^2 (VT)" ], [ 5, "T^2 (VT)" ], [ 9, "T^2 (VT)" ], [ 10, "T^2 (VT)" ],
   [ 18, "T^2 (VT)" ], [ 20, "(T^2)#2" ] ]
 gap&gt; torus:=SCLib.Load(last[1][1]);;
 gap&gt; genus2:=SCConnectedSum(torus,torus);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="T^2 (VT)#+-T^2 (VT)"
  Dim=2
 
 /SimplicialComplex]
 gap&gt; genus2.Homology;
 [ [ 0, [  ] ], [ 4, [  ] ], [ 1, [  ] ] ]
 gap&gt; genus2.Chi;
 -2
 </pre></div>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("CP^2");
 [ [ 16, "CP^2 (VT)" ], [ 99, "CP^2#CP^2" ], [ 100, "CP^2#-CP^2" ], 
   [ 400, "CP^2#(S^2xS^2)" ], [ 2486, "Gaifullin CP^2" ], 
   [ 4401, "(S^3~S^1)#(CP^2)^{#5} (VT)" ] ]
 gap&gt; cp2:=SCLib.Load(last[1][1]);;
 gap&gt; c1:=SCConnectedSum(cp2,cp2);;
 gap&gt; c2:=SCConnectedSumMinus(cp2,cp2);;
 gap&gt; c1.F=c2.F;
 true
 gap&gt; c1.ASDet=c2.ASDet;
 true
 gap&gt; SCIsIsomorphic(c1,c2);
 false
 gap&gt; PrintArray(SCIntersectionForm(c1));
 [ [  1,  0 ],
   [  0,  1 ] ]
 gap&gt; PrintArray(SCIntersectionForm(c2));
 [ [   1,   0 ],
   [   0,  -1 ] ]
 </pre></div>

<p><a id="X78B843417D63B408" name="X78B843417D63B408"></a></p>

<h5>6.6-6 SCConnectedSumMinus</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCConnectedSumMinus</code>( <var class="Arg">complex1</var>, <var class="Arg">complex2</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>In a lexicographic ordering the smallest facet of both <var class="Arg">complex1</var> and <var class="Arg">complex2</var> is removed and the complexes are glued together along the resulting boundaries. The bijection used to identify the vertices of the boundaries differs from the one chosen in <code class="func">SCConnectedSum</code> (<a href="chap6.html#X81338CE18195607C"><span class="RefLink">6.6-5</span></a>) by a transposition. Thus, the topological type of <code class="code">SCConnectedSumMinus</code> is different from the one of <code class="func">SCConnectedSum</code> (<a href="chap6.html#X81338CE18195607C"><span class="RefLink">6.6-5</span></a>) whenever <var class="Arg">complex1</var> and <var class="Arg">complex2</var> do not allow an orientation reversing homeomorphism.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("T^2"){[1..6]};
 [ [ 4, "T^2 (VT)" ], [ 5, "T^2 (VT)" ], [ 9, "T^2 (VT)" ], [ 10, "T^2 (VT)" ],
   [ 18, "T^2 (VT)" ], [ 20, "(T^2)#2" ] ]
 gap&gt; torus:=SCLib.Load(last[1][1]);;
 gap&gt; genus2:=SCConnectedSumMinus(torus,torus);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="T^2 (VT)#+-T^2 (VT)"
  Dim=2
 
 /SimplicialComplex]
 gap&gt; genus2.Homology;
 [ [ 0, [  ] ], [ 4, [  ] ], [ 1, [  ] ] ]
 gap&gt; genus2.Chi;
 -2
 </pre></div>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("CP^2");
 [ [ 16, "CP^2 (VT)" ], [ 99, "CP^2#CP^2" ], [ 100, "CP^2#-CP^2" ], 
   [ 400, "CP^2#(S^2xS^2)" ], [ 2486, "Gaifullin CP^2" ], 
   [ 4401, "(S^3~S^1)#(CP^2)^{#5} (VT)" ] ]
 gap&gt; cp2:=SCLib.Load(last[1][1]);;
 gap&gt; c1:=SCConnectedSum(cp2,cp2);;
 gap&gt; c2:=SCConnectedSumMinus(cp2,cp2);;
 gap&gt; c1.F=c2.F;
 true
 gap&gt; c1.ASDet=c2.ASDet;
 true
 gap&gt; SCIsIsomorphic(c1,c2);
 false
 gap&gt; PrintArray(SCIntersectionForm(c1));
 [ [  1,  0 ],
   [  0,  1 ] ]
 gap&gt; PrintArray(SCIntersectionForm(c2));
 [ [   1,   0 ],
   [   0,  -1 ] ]
 </pre></div>

<p><a id="X84F3487182AB102A" name="X84F3487182AB102A"></a></p>

<h5>6.6-7 SCDifferenceCycleCompress</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCDifferenceCycleCompress</code>( <var class="Arg">simplex</var>, <var class="Arg">modulus</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: list with possibly duplicate entries upon success, <code class="keyw">fail</code> otherwise.</p>

<p>A difference cycle is returned, i. e. a list of integer values of length <span class="SimpleMath">(d+1)</span>, if <span class="SimpleMath">d</span> is the dimension of <var class="Arg">simplex</var>, and a sum equal to <var class="Arg">modulus</var>. In some sense this is the inverse operation of <code class="func">SCDifferenceCycleExpand</code> (<a href="chap6.html#X8510B6CF85070A28"><span class="RefLink">6.6-8</span></a>).</p>


<div class="example"><pre>
 gap&gt; sphere:=SCBdSimplex(4);;
 gap&gt; gens:=SCGenerators(sphere);
 [ [ [ 1, 2, 3, 4 ], [ 5 ] ] ]
 gap&gt; diffcycle:=SCDifferenceCycleCompress(gens[1][1],5);
 [ 1, 1, 1, 2 ]
 gap&gt; c:=SCDifferenceCycleExpand([1,1,1,2]);;
 gap&gt; c.Facets;
 [ [ 1, 2, 3, 4 ], [ 1, 2, 3, 5 ], [ 1, 2, 4, 5 ], [ 1, 3, 4, 5 ], 
   [ 2, 3, 4, 5 ] ]
 </pre></div>

<p><a id="X8510B6CF85070A28" name="X8510B6CF85070A28"></a></p>

<h5>6.6-8 SCDifferenceCycleExpand</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCDifferenceCycleExpand</code>( <var class="Arg">diffcycle</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p><var class="Arg">diffcycle</var> induces a simplex <span class="SimpleMath">∆ = ( v_1 , ... , v_n+1 )</span> by <span class="SimpleMath">v_1 =</span><var class="Arg">diffcycle[1]</var>, <span class="SimpleMath">v_i = v_i-1 +</span> <var class="Arg">diffcycle[i]</var> and a cyclic group action by <span class="SimpleMath">Z_σ</span> where <span class="SimpleMath">σ = ∑</span> <var class="Arg">diffcycle[i]</var> is the modulus of <code class="code">diffcycle</code>. The function returns the <span class="SimpleMath">Z_σ</span>-orbit of <span class="SimpleMath">∆</span>.</p>

<p>Note that modulo operations in <strong class="pkg">GAP</strong> are often a little bit cumbersome, since all integer ranges usually start from <span class="SimpleMath">1</span>.</p>


<div class="example"><pre>
 gap&gt; c:=SCDifferenceCycleExpand([1,1,2]);;
 gap&gt; c.Facets;
 [ [ 1, 2, 3 ], [ 1, 2, 4 ], [ 1, 3, 4 ], [ 2, 3, 4 ] ]
 </pre></div>

<p><a id="X8278E1157A318C32" name="X8278E1157A318C32"></a></p>

<h5>6.6-9 SCStronglyConnectedComponents</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCStronglyConnectedComponents</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list of simplicial complexes of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes all strongly connected components of a pure simplicial complex.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2,3],[2,3,4],[4,5,6],[5,6,7]]);;
 gap&gt; comps:=SCStronglyConnectedComponents(c);
 [ [SimplicialComplex
     
      Properties known: Dim, FacetsEx, Name, Vertices.
     
      Name="Strongly connected component #1 of unnamed complex 82"
      Dim=2
     
     /SimplicialComplex], [SimplicialComplex
     
      Properties known: Dim, FacetsEx, Name, Vertices.
     
      Name="Strongly connected component #2 of unnamed complex 82"
      Dim=2
     
     /SimplicialComplex] ]
 gap&gt; comps[1].Facets;
 [ [ 1, 2, 3 ], [ 2, 3, 4 ] ]
 gap&gt; comps[2].Facets;
 [ [ 4, 5, 6 ], [ 5, 6, 7 ] ]
 </pre></div>

<p><a id="X87C1C49987E75A9C" name="X87C1C49987E75A9C"></a></p>

<h4>6.7 <span class="Heading">Simplicial complexes from transitive permutation groups</span></h4>

<p>Beginning from Version 1.3.0, <strong class="pkg">simpcomp</strong> is able to generate triangulations from a prescribed transitive group action on its set of vertices. Note that the corresponding group is a subgroup of the full automorphism group, but not necessarily the full automorphism group of the triangulations obtained in this way. The methods and algorithms are based on the works of Frank H. Lutz <a href="chapBib.html#biBLutz03TrigMnfFewVertVertTrans">[Lut03]</a>, <a href="chapBib.html#biBLutz08ManifoldPage">[Lut]</a> and in particular his program <code class="code">MANIFOLD_VT</code>.</p>

<p><a id="X7C1592677A76A3E5" name="X7C1592677A76A3E5"></a></p>

<h5>6.7-1 SCsFromGroupExt</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCsFromGroupExt</code>( <var class="Arg">G</var>, <var class="Arg">n</var>, <var class="Arg">d</var>, <var class="Arg">objectType</var>, <var class="Arg">cache</var>, <var class="Arg">removeDoubleEntries</var>, <var class="Arg">outfile</var>, <var class="Arg">maxLinkSize</var>, <var class="Arg">subset</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a list of simplicial complexes of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes all combinatorial <var class="Arg">d</var>-pseudomanifolds, <span class="SimpleMath">d=2</span> / all strongly connected combinatorial <var class="Arg">d</var>-pseudomanifolds, <span class="SimpleMath">d ≥ 3</span>, as a union of orbits of the group action of <var class="Arg">G</var> on <code class="code">(d+1)</code>-tuples on the set of <var class="Arg">n</var> vertices, see <a href="chapBib.html#biBLutz03TrigMnfFewVertVertTrans">[Lut03]</a>. The integer argument <var class="Arg">objectType</var> specifies, whether complexes exceeding the maximal size of each vertex link for combinatorial manifolds are sorted out (<code class="code">objectType = 0</code>) or not (<code class="code">objectType = 1</code>, in this case some combinatorial pseudomanifolds won't be found, but no combinatorial manifold will be sorted out). The integer argument <var class="Arg">cache</var> specifies if the orbits are held in memory during the computation, a value of <code class="code">0</code> means that the orbits are discarded, trading speed for memory, any other value means that they are kept, trading memory for speed. The boolean argument <var class="Arg">removeDoubleEntries</var> specifies whether the results are checked for combinatorial isomorphism, preventing isomorphic entries. The argument <var class="Arg">outfile</var> specifies an output file containing all complexes found by the algorithm, if <var class="Arg">outfile</var> is anything else than a string, not output file is generated. The argument <var class="Arg">maxLinkSize</var> determines a maximal link size of any output complex. If <var class="Arg">maxLinkSize</var><span class="SimpleMath">=0</span> or if <var class="Arg">maxLinkSize</var> is anything else than an integer the argument is ignored. The argument <var class="Arg">subset</var> specifies a set of orbits (given by a list of indices of <code class="code">repHigh</code>) which have to be contained in any output complex. If <var class="Arg">subset</var> is anything else than a subset of <code class="code">matrixAllowedRows</code> the argument is ignored.</p>


<div class="example"><pre>
 gap&gt; G:=PrimitiveGroup(8,5);
 PGL(2, 7)
 gap&gt; Size(G);
 336
 gap&gt; Transitivity(G);
 3
 gap&gt; list:=SCsFromGroupExt(G,8,3,1,0,true,false,0,[]);
 [ "defgh.g.h.fah.e.gaf.h.eag.e.faf.a.haa.g.fah.a.gjhzh" ]
 gap&gt; c:=SCFromIsoSig(list[1]);
 [SimplicialComplex
 
  Properties known: Dim, ExportIsoSig, FacetsEx, Name, Vertices.
 
  Name="unnamed complex 6"
  Dim=3
 
 /SimplicialComplex]
 gap&gt; SCNeighborliness(c); 
 3
 gap&gt; c.F;
 [ 8, 28, 56, 28 ]
 gap&gt; c.IsManifold; 
 false
 gap&gt; SCLibDetermineTopologicalType(SCLink(c,1));
 [SimplicialComplex
 
  Properties known: BoundaryEx, Dim, FacetsEx, HasBoundary, 
                    IsPseudoManifold, IsPure, Name, SkelExs[], 
                    Vertices.
 
  Name="lk([ 1 ]) in unnamed complex 6"
  Dim=2
  HasBoundary=false
  IsPseudoManifold=true
  IsPure=true
 
 /SimplicialComplex]
 gap&gt; # there are no 3-neighborly 3-manifolds with 8 vertices
 gap&gt; list:=SCsFromGroupExt(PrimitiveGroup(8,5),8,3,0,0,true,false,0,[]); 
 gap&gt; [  ]
 </pre></div>

<p><a id="X7A04D77085D9BE4E" name="X7A04D77085D9BE4E"></a></p>

<h5>6.7-2 SCsFromGroupByTransitivity</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCsFromGroupByTransitivity</code>( <var class="Arg">n</var>, <var class="Arg">d</var>, <var class="Arg">k</var>, <var class="Arg">maniflag</var>, <var class="Arg">computeAutGroup</var>, <var class="Arg">removeDoubleEntries</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a list of simplicial complexes of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes all combinatorial <var class="Arg">d</var>-pseudomanifolds, <span class="SimpleMath">d = 2</span> / all strongly connected combinatorial <var class="Arg">d</var>-pseudomanifolds, <span class="SimpleMath">d ≥ 3</span>, as union of orbits of group actions for all <var class="Arg">k</var>-transitive groups on <code class="code">(d+1)</code>-tuples on the set of <var class="Arg">n</var> vertices, see <a href="chapBib.html#biBLutz03TrigMnfFewVertVertTrans">[Lut03]</a>. The boolean argument <var class="Arg">maniflag</var> specifies, whether the resulting complexes should be listed separately by combinatorial manifolds, combinatorial pseudomanifolds and complexes where the verification that the object is at least a combinatorial pseudomanifold failed. The boolean argument <var class="Arg">computeAutGroup</var> specifies whether or not the real automorphism group should be computed (note that a priori the generating group is just a subgroup of the automorphism group). The boolean argument <var class="Arg">removeDoubleEntries</var> specifies whether the results are checked for combinatorial isomorphism, preventing isomorphic entries. Internally calls <code class="func">SCsFromGroupExt</code> (<a href="chap6.html#X7C1592677A76A3E5"><span class="RefLink">6.7-1</span></a>) for every group.</p>


<div class="example"><pre>
 gap&gt; list:=SCsFromGroupByTransitivity(8,3,2,true,true,true);
 #I  SCsFromGroupByTransitivity: Building list of groups...
 #I  SCsFromGroupByTransitivity: ...2 groups found.
 #I  degree 8: [ AGL(1, 8), PSL(2, 7) ]
 #I  SCsFromGroupByTransitivity: Processing dimension 3.
 #I  SCsFromGroupByTransitivity: Processing degree 8.
 #I  SCsFromGroupByTransitivity: 1 / 2 groups calculated, found 0 complexes.
 #I  SCsFromGroupByTransitivity: Calculating 0 automorphism and homology groups...
 #I  SCsFromGroupByTransitivity: ...all automorphism groups calculated for group 1 / 2.
 #I  SCsFromGroupByTransitivity: 2 / 2 groups calculated, found 1 complexes.
 #I  SCsFromGroupByTransitivity: Calculating 1 automorphism and homology groups...
 #I  group not listed
 #I  SCsFromGroupByTransitivity: 1 / 1 automorphism groups calculated.
 #I  SCsFromGroupByTransitivity: ...all automorphism groups calculated for group 2 / 2.
 #I  SCsFromGroupByTransitivity: ...done dim = 3, deg =  8, 0 manifolds, 1 pseudomanifolds, 0 candidates found.
 #I  SCsFromGroupByTransitivity: ...done dim = 3.
 [ [  ], [  ], [  ] ]
 </pre></div>

<p><a id="X81FDA1407B1E96C9" name="X81FDA1407B1E96C9"></a></p>

<h4>6.8 <span class="Heading">The classification of cyclic combinatorial 3-manifolds</span></h4>

<p>This section contains functions to access the classification of combinatorial 3-manifolds with transitive cyclic symmetry and up to 22 vertices as presented in <a href="chapBib.html#biBSpreer11CyclicCombMflds">[Spr14]</a>.</p>

<p><a id="X805BBDF58568614F" name="X805BBDF58568614F"></a></p>

<h5>6.8-1 SCNrCyclic3Mflds</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCNrCyclic3Mflds</code>( <var class="Arg">i</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: integer upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns the number of combinatorial 3-manifolds with transitive cyclic symmetry with <var class="Arg">i</var> vertices. See <a href="chapBib.html#biBSpreer11CyclicCombMflds">[Spr14]</a> for more about the classification of combinatorial 3-manifolds with transitive cyclic symmetry up to <span class="SimpleMath">22</span> vertices.</p>


<div class="example"><pre>
 gap&gt; SCNrCyclic3Mflds(22);
 3090
 </pre></div>

<p><a id="X84477B9E7CAEED7B" name="X84477B9E7CAEED7B"></a></p>

<h5>6.8-2 SCCyclic3MfldTopTypes</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCCyclic3MfldTopTypes</code>( <var class="Arg">i</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a list of strings upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns a list of all topological types that occur in the classification combinatorial 3-manifolds with transitive cyclic symmetry with <var class="Arg">i</var> vertices. See <a href="chapBib.html#biBSpreer11CyclicCombMflds">[Spr14]</a> for more about the classification of combinatorial 3-manifolds with transitive cyclic symmetry up to <span class="SimpleMath">22</span> vertices.</p>


<div class="example"><pre>
 gap&gt; SCCyclic3MfldTopTypes(19);
 [ "B2", "RP^2xS^1", "SFS[RP^2:(2,1)(3,1)]", "S^2~S^1", "S^3", "Sigma(2,3,7)", 
   "T^3" ]
 </pre></div>

<p><a id="X781256E37DA1B69F" name="X781256E37DA1B69F"></a></p>

<h5>6.8-3 SCCyclic3Mfld</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCCyclic3Mfld</code>( <var class="Arg">i</var>, <var class="Arg">j</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns the <var class="Arg">j</var>th combinatorial 3-manifold with <var class="Arg">i</var> vertices in the classification of combinatorial 3-manifolds with transitive cyclic symmetry. See <a href="chapBib.html#biBSpreer11CyclicCombMflds">[Spr14]</a> for more about the classification of combinatorial 3-manifolds with transitive cyclic symmetry up to <span class="SimpleMath">22</span> vertices.</p>


<div class="example"><pre>
 gap&gt; SCCyclic3Mfld(15,34);
 [SimplicialComplex
 
  Properties known: AutomorphismGroupTransitivity, DifferenceCycles, 
                    Dim, FacetsEx, IsManifold, Name, TopologicalType, 
                    Vertices.
 
  Name="Cyclic 3-mfld (15,34): T^3"
  Dim=3
  AutomorphismGroupTransitivity=1
  TopologicalType="T^3"
 
 /SimplicialComplex]
 </pre></div>

<p><a id="X8490744E81DA45BF" name="X8490744E81DA45BF"></a></p>

<h5>6.8-4 SCCyclic3MfldByType</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCCyclic3MfldByType</code>( <var class="Arg">type</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns the smallest combinatorial 3-manifolds in the classification of combinatorial 3-manifolds with transitive cyclic symmetry of topological type <var class="Arg">type</var>. See <a href="chapBib.html#biBSpreer11CyclicCombMflds">[Spr14]</a> for more about the classification of combinatorial 3-manifolds with transitive cyclic symmetry up to <span class="SimpleMath">22</span> vertices.</p>


<div class="example"><pre>
 gap&gt; SCCyclic3MfldByType("T^3");
 [SimplicialComplex
 
  Properties known: AutomorphismGroupTransitivity, DifferenceCycles, 
                    Dim, FacetsEx, IsManifold, Name, TopologicalType, 
                    Vertices.
 
  Name="Cyclic 3-mfld (15,34): T^3"
  Dim=3
  AutomorphismGroupTransitivity=1
  TopologicalType="T^3"
 
 /SimplicialComplex]
 </pre></div>

<p><a id="X86F8AED6843FCD65" name="X86F8AED6843FCD65"></a></p>

<h5>6.8-5 SCCyclic3MfldListOfGivenType</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCCyclic3MfldListOfGivenType</code>( <var class="Arg">type</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns a list of indices <span class="SimpleMath">{ (i_1, j_1) , (i_1, j_1) , ... (i_n, j_n) }</span> of all combinatorial 3-manifolds in the classification of combinatorial 3-manifolds with transitive cyclic symmetry of topological type <var class="Arg">type</var>. Complexes can be obtained by calling <code class="func">SCCyclic3Mfld</code> (<a href="chap6.html#X781256E37DA1B69F"><span class="RefLink">6.8-3</span></a>) using these indices. See <a href="chapBib.html#biBSpreer11CyclicCombMflds">[Spr14]</a> for more about the classification of combinatorial 3-manifolds with transitive cyclic symmetry up to <span class="SimpleMath">22</span> vertices.</p>


<div class="example"><pre>
 gap&gt; SCCyclic3MfldListOfGivenType("Sigma(2,3,7)");
 [ [ 19, 100 ], [ 19, 118 ], [ 19, 120 ], [ 19, 130 ] ]
 </pre></div>

<p><a id="X81CE90127800B91A" name="X81CE90127800B91A"></a></p>

<h4>6.9 <span class="Heading">Computing properties of simplicial complexes</span></h4>

<p>The following functions compute basic properties of simplicial complexes of type <code class="code">SCSimplicialComplex</code>. None of these functions alter the complex. All properties are returned as immutable objects (this ensures data consistency of the cached properties of a simplicial complex). Use <code class="code">ShallowCopy</code> or the internal <strong class="pkg">simpcomp</strong> function <code class="code">SCIntFunc.DeepCopy</code> to get a mutable copy.</p>

<p>Note: every simplicial complex is internally stored with the standard vertex labeling from <span class="SimpleMath">1</span> to <span class="SimpleMath">n</span> and a maptable to restore the original vertex labeling. Thus, we have to relabel some of the complex properties (facets, face lattice, generators, etc...) whenever we want to return them to the user. As a consequence, some of the functions exist twice, one of them with the appendix "Ex". These functions return the standard labeling whereas the other ones relabel the result to the original labeling.</p>

<p><a id="X7B69B327809F67A0" name="X7B69B327809F67A0"></a></p>

<h5>6.9-1 SCAltshulerSteinberg</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCAltshulerSteinberg</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a non-negative integer upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the Altshuler-Steinberg determinant.</p>

<p>Definition: Let <span class="SimpleMath">v_i</span>, <span class="SimpleMath">1 ≤ i ≤ n</span> be the vertices and let <span class="SimpleMath">F_j</span>, <span class="SimpleMath">1 ≤ j ≤ m</span> be the facets of a pure simplicial complex <span class="SimpleMath">C</span>, then the determinant of <span class="SimpleMath">AS ∈ Z^n × m</span>, <span class="SimpleMath">AS_ij=1</span> if <span class="SimpleMath">v_i ∈ F_j</span>, <span class="SimpleMath">AS_ij=0</span> otherwise, is called the Altshuler-Steinberg matrix. The Altshuler-Steinberg determinant is the determinant of the quadratic matrix <span class="SimpleMath">AS ⋅ AS^T</span>.</p>

<p>The Altshuler-Steinberg determinant is a combinatorial invariant of <span class="SimpleMath">C</span> and can be checked before searching for an isomorphism between two simplicial complexes.</p>


<div class="example"><pre>
 gap&gt; list:=SCLib.SearchByName("T^2");; 
 gap&gt; torus:=SCLib.Load(last[1][1]);;
 gap&gt; SCAltshulerSteinberg(torus);
 73728
 gap&gt; c:=SCBdSimplex(3);;
 gap&gt; SCAltshulerSteinberg(c);
 9
 gap&gt; c:=SCBdSimplex(4);;
 gap&gt; SCAltshulerSteinberg(c);
 16
 gap&gt; c:=SCBdSimplex(5);;
 gap&gt; SCAltshulerSteinberg(c);
 25
 </pre></div>

<p><a id="X7B88925386E197AC" name="X7B88925386E197AC"></a></p>

<h5>6.9-2 SCAutomorphismGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCAutomorphismGroup</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">GAP</strong> permutation group upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the automorphism group of a strongly connected pseudomanifold <var class="Arg">complex</var>, i. e. the group of all automorphisms on the set of vertices of <var class="Arg">complex</var> that do not change the complex as a whole. Necessarily the group is a subgroup of the symmetric group <span class="SimpleMath">S_n</span> where <span class="SimpleMath">n</span> is the number of vertices of the simplicial complex.</p>

<p>The function uses an efficient algorithm provided by the package <strong class="pkg">GRAPE</strong> (see <a href="chapBib.html#biBSoicher06GRAPE">[Soi12]</a>, which is based on the program <code class="code">nauty</code> by Brendan McKay <a href="chapBib.html#biBMcKay84Nauty">[MP14]</a>). If the package <strong class="pkg">GRAPE</strong> is not available, this function call falls back to <code class="func">SCAutomorphismGroupInternal</code> (<a href="chap6.html#X7A33B8177A7ACD3A"><span class="RefLink">6.9-3</span></a>).</p>

<p>The position of the group in the <strong class="pkg">GAP</strong> libraries of small groups, transitive groups or primitive groups is given. If the group is not listed, its structure description, provided by the <strong class="pkg">GAP</strong> function <code class="code">StructureDescription()</code>, is returned as the name of the group. Note that the latter form is not always unique, since every non trivial semi-direct product is denoted by ''<code class="code">:</code>''.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("K3");            
 [ [ 7494, "K3_16" ], [ 7513, "K3_17" ] ]
 gap&gt; k3surf:=SCLib.Load(last[1][1]);; 
 gap&gt; SCAutomorphismGroup(k3surf);               
 Group([ (1,3,8,4,9,16,15,2,14,12,6,7,13,5,10), (1,13)(2,14)(3,15)(4,16)(5,9)
 (6,10)(7,11)(8,12) ])
 </pre></div>

<p><a id="X7A33B8177A7ACD3A" name="X7A33B8177A7ACD3A"></a></p>

<h5>6.9-3 SCAutomorphismGroupInternal</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCAutomorphismGroupInternal</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">GAP</strong> permutation group upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the automorphism group of a strongly connected pseudomanifold <var class="Arg">complex</var>, i. e. the group of all automorphisms on the set of vertices of <var class="Arg">complex</var> that do not change the complex as a whole. Necessarily the group is a subgroup of the symmetric group <span class="SimpleMath">S_n</span> where <span class="SimpleMath">n</span> is the number of vertices of the simplicial complex.</p>

<p>The position of the group in the <strong class="pkg">GAP</strong> libraries of small groups, transitive groups or primitive groups is given. If the group is not listed, its structure description, provided by the <strong class="pkg">GAP</strong> function <code class="code">StructureDescription()</code>, is returned as the name of the group. Note that the latter form is not always unique, since every non trivial semi-direct product is denoted by ''<code class="code">:</code>''.</p>


<div class="example"><pre>
 gap&gt; c:=SCBdSimplex(5);;
 gap&gt; SCAutomorphismGroupInternal(c);
 Sym( [ 1 .. 6 ] )
 </pre></div>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2],[2,3],[1,3]]);;
 gap&gt; g:=SCAutomorphismGroupInternal(c);
 Group([ (2,3), (1,2,3) ])
 gap&gt; List(g);
 [ (), (1,2,3), (1,3,2), (2,3), (1,2), (1,3) ]
 gap&gt; StructureDescription(g);
 "S3"
 </pre></div>

<p><a id="X78F6EF808047772C" name="X78F6EF808047772C"></a></p>

<h5>6.9-4 SCAutomorphismGroupSize</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCAutomorphismGroupSize</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a positive integer group upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the size of the automorphism group of a strongly connected pseudomanifold <var class="Arg">complex</var>, see <code class="func">SCAutomorphismGroup</code> (<a href="chap6.html#X7B88925386E197AC"><span class="RefLink">6.9-2</span></a>).</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("K3");            
 [ [ 7494, "K3_16" ], [ 7513, "K3_17" ] ]
 gap&gt; k3surf:=SCLib.Load(last[1][1]);;           
 gap&gt; SCAutomorphismGroupSize(k3surf);               
 240
 </pre></div>

<p><a id="X7EAC3A5D7A3339BB" name="X7EAC3A5D7A3339BB"></a></p>

<h5>6.9-5 SCAutomorphismGroupStructure</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCAutomorphismGroupStructure</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the <strong class="pkg">GAP</strong> structure description upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the <strong class="pkg">GAP</strong> structure description of the automorphism group of a strongly connected pseudomanifold <var class="Arg">complex</var>, see <code class="func">SCAutomorphismGroup</code> (<a href="chap6.html#X7B88925386E197AC"><span class="RefLink">6.9-2</span></a>).</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("K3");     
 [ [ 7494, "K3_16" ], [ 7513, "K3_17" ] ]
 gap&gt; k3surf:=SCLib.Load(last[1][1]);;      
 gap&gt; SCAutomorphismGroupStructure(k3surf);
 "((C2 x C2 x C2 x C2) : C5) : C3"
 </pre></div>

<p><a id="X7E9D5C257F88E5E0" name="X7E9D5C257F88E5E0"></a></p>

<h5>6.9-6 SCAutomorphismGroupTransitivity</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCAutomorphismGroupTransitivity</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a positive integer upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the transitivity of the automorphism group of a strongly connected pseudomanifold <var class="Arg">complex</var>, i. e. the maximal integer <span class="SimpleMath">t</span> such that for any two ordered <span class="SimpleMath">t</span>-tuples <span class="SimpleMath">T_1</span> and <span class="SimpleMath">T_2</span> of vertices of <var class="Arg">complex</var>, there exists an element <span class="SimpleMath">g</span> in the automorphism group of <var class="Arg">complex</var> for which <span class="SimpleMath">gT_1=T_2</span>, see <a href="chapBib.html#biBHuppert67EndlGruppen">[Hup67]</a>.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("K3");            
 [ [ 7494, "K3_16" ], [ 7513, "K3_17" ] ]
 gap&gt; k3surf:=SCLib.Load(last[1][1]);;           
 gap&gt; SCAutomorphismGroupTransitivity(k3surf);               
 2
 </pre></div>

<p><a id="X836DC73380EA7414" name="X836DC73380EA7414"></a></p>

<h5>6.9-7 SCBoundary</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCBoundary</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>The function computes the boundary of a simplicial complex <var class="Arg">complex</var> satisfying the weak pseudomanifold property and returns it as a simplicial complex. In addition, it is stored as a property of <var class="Arg">complex</var>.</p>

<p>The boundary of a simplicial complex is defined as the simplicial complex consisting of all <span class="SimpleMath">d-1</span>-faces that are contained in exactly one facet.</p>

<p>If <var class="Arg">complex</var> does not fulfill the weak pseudomanifold property (i. e. if the valence of any <span class="SimpleMath">d-1</span>-face exceeds <span class="SimpleMath">2</span>) the function returns <code class="keyw">fail</code>.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2,3,4],[1,2,3,5],[1,2,4,5],[1,3,4,5]]);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="unnamed complex 52"
  Dim=3
 
 /SimplicialComplex]
 gap&gt; SCBoundary(c);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="Bd(unnamed complex 52)"
  Dim=2
 
 /SimplicialComplex]
 gap&gt; c;  
 [SimplicialComplex
 
  Properties known: BoundaryEx, Dim, FacetsEx, HasBoundary, 
                    IsPseudoManifold, IsPure, Name, SkelExs[], 
                    Vertices.
 
  Name="unnamed complex 52"
  Dim=3
  HasBoundary=true
  IsPseudoManifold=true
  IsPure=true
 
 /SimplicialComplex]
 </pre></div>

<p><a id="X812AE7397B4FC88E" name="X812AE7397B4FC88E"></a></p>

<h5>6.9-8 SCDehnSommervilleCheck</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCDehnSommervilleCheck</code>( <var class="Arg">c</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks if the simplicial complex <var class="Arg">c</var> fulfills the Dehn Sommerville equations: <span class="SimpleMath">h_j - h_d+1-j = (-1)^d+1-j d+1 choose j (χ (M) - 2)</span> for <span class="SimpleMath">0 ≤ j ≤ fracd2</span> and <span class="SimpleMath">d</span> even, and <span class="SimpleMath">h_j - h_d+1-j = 0</span> for <span class="SimpleMath">0 ≤ j ≤ fracd-12</span> and <span class="SimpleMath">d</span> odd. Where <span class="SimpleMath">h_j</span> is the <span class="SimpleMath">j</span>th component of the <span class="SimpleMath">h</span>-vector, see <code class="func">SCHVector</code> (<a href="chap6.html#X84FBF0A685547ECD"><span class="RefLink">6.9-26</span></a>).</p>


<div class="example"><pre>
 gap&gt; c:=SCBdCrossPolytope(6);;
 gap&gt; SCDehnSommervilleCheck(c);
 true
 gap&gt; c:=SC([[1,2,3],[1,4,5]]);;
 gap&gt; SCDehnSommervilleCheck(c);
 false
 </pre></div>

<p><a id="X859C3981831B4B81" name="X859C3981831B4B81"></a></p>

<h5>6.9-9 SCDehnSommervilleMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCDehnSommervilleMatrix</code>( <var class="Arg">d</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a <code class="code">(d+1)</code><span class="SimpleMath">×</span><code class="code">Int(d+1/2)</code> matrix with integer entries upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the coefficients of the Dehn Sommerville equations for dimension <code class="code">d</code>: <span class="SimpleMath">h_j - h_d+1-j = (-1)^d+1-j d+1 choose j (χ (M) - 2)</span> for <span class="SimpleMath">0 ≤ j ≤ fracd2</span> and <span class="SimpleMath">d</span> even, and <span class="SimpleMath">h_j - h_d+1-j = 0</span> for <span class="SimpleMath">0 ≤ j ≤ fracd-12</span> and <span class="SimpleMath">d</span> odd. Where <span class="SimpleMath">h_j</span> is the <span class="SimpleMath">j</span>th component of the <span class="SimpleMath">h</span>-vector, see <code class="func">SCHVector</code> (<a href="chap6.html#X84FBF0A685547ECD"><span class="RefLink">6.9-26</span></a>).</p>


<div class="example"><pre>
 gap&gt; m:=SCDehnSommervilleMatrix(6);;
 gap&gt; PrintArray(m);
 [ [    1,   -1,    1,   -1,    1,   -1,    1 ],
   [    0,   -2,    3,   -4,    5,   -6,    7 ],
   [    0,    0,    0,   -4,   10,  -20,   35 ],
   [    0,    0,    0,    0,    0,   -6,   21 ] ]
 </pre></div>

<p><a id="X80B33CAF7B5476C0" name="X80B33CAF7B5476C0"></a></p>

<h5>6.9-10 SCDifferenceCycles</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCDifferenceCycles</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list of lists upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the difference cycles of <var class="Arg">complex</var> in standard labeling if <var class="Arg">complex</var> is invariant under a shift of the vertices of type <span class="SimpleMath">v ↦ v+1 mod n</span>. The function returns the difference cycles as lists where the sum of the entries equals the number of vertices <span class="SimpleMath">n</span> of <var class="Arg">complex</var>.</p>


<div class="example"><pre>
 gap&gt; torus:=SCFromDifferenceCycles([[1,2,4],[1,4,2]]);
 [SimplicialComplex
 
  Properties known: DifferenceCycles, Dim, FacetsEx, Name, Vertices.
 
  Name="complex from diffcycles [ [ 1, 2, 4 ], [ 1, 4, 2 ] ]"
  Dim=2
 
 /SimplicialComplex]
 gap&gt; torus.Homology;
 [ [ 0, [  ] ], [ 2, [  ] ], [ 1, [  ] ] ]
 gap&gt; torus.DifferenceCycles;
 [ [ 1, 2, 4 ], [ 1, 4, 2 ] ]
 </pre></div>

<p><a id="X82351AAE793DCB68" name="X82351AAE793DCB68"></a></p>

<h5>6.9-11 SCDim</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCDim</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: an integer <span class="SimpleMath">≥ -1</span> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the dimension of a simplicial complex. If the complex is not pure, the dimension of the highest dimensional simplex is returned.</p>


<div class="example"><pre>
 gap&gt; complex:=SC([[1,2,3], [1,2,4], [1,3,4], [2,3,4]]);;
 gap&gt; SCDim(complex);                                    
 2
 gap&gt; c:=SC([[1], [2,4], [3,4], [5,6,7,8]]);;
 gap&gt; SCDim(c);
 3
 </pre></div>

<p><a id="X798175C58050DDBD" name="X798175C58050DDBD"></a></p>

<h5>6.9-12 SCDualGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCDualGraph</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: 1-dimensional simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the dual graph of the pure simplicial complex <var class="Arg">complex</var>.</p>


<div class="example"><pre>
 gap&gt; sphere:=SCBdSimplex(5);;
 gap&gt; graph:=SCFaces(sphere,1);       
 [ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 1, 5 ], [ 1, 6 ], [ 2, 3 ], [ 2, 4 ], 
   [ 2, 5 ], [ 2, 6 ], [ 3, 4 ], [ 3, 5 ], [ 3, 6 ], [ 4, 5 ], [ 4, 6 ], 
   [ 5, 6 ] ]
 gap&gt; graph:=SC(graph);;              
 gap&gt; dualGraph:=SCDualGraph(sphere); 
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="dual graph of S^4_6"
  Dim=1
 
 /SimplicialComplex]
 gap&gt; graph.Facets = dualGraph.Facets;
 true
 </pre></div>

<p><a id="X788BAE187D584103" name="X788BAE187D584103"></a></p>

<h5>6.9-13 SCEulerCharacteristic</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCEulerCharacteristic</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: integer upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the Euler characteristic <span class="Math"> \chi(C)=\sum \limits_{i=0}^{d} (-1)^{i} f_i </span> of a simplicial complex <span class="SimpleMath">C</span>, where <span class="SimpleMath">f_i</span> denotes the <span class="SimpleMath">i</span>-th component of the <span class="SimpleMath">f</span>-vector.</p>


<div class="example"><pre>
 gap&gt; complex:=SCFromFacets([[1,2,3], [1,2,4], [1,3,4], [2,3,4]]);;
 gap&gt; SCEulerCharacteristic(complex);
 2
 gap&gt; s2:=SCBdSimplex(3);;
 gap&gt; s2.EulerCharacteristic;
 2
 </pre></div>

<p><a id="X81F8071385FD9C1D" name="X81F8071385FD9C1D"></a></p>

<h5>6.9-14 SCFVector</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFVector</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list of non-negative integers upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the <span class="SimpleMath">f</span>-vector of the simplicial complex <var class="Arg">complex</var>, i. e. the number of <span class="SimpleMath">i</span>-dimensional faces for <span class="SimpleMath">0 ≤ i ≤ d</span>, where <span class="SimpleMath">d</span> is the dimension of <var class="Arg">complex</var>. A memory-saving implicit algorithm is used that avoids calculating the face lattice of the complex. Internally calls <code class="func">SCNumFaces</code> (<a href="chap6.html#X7AC2427184B44C65"><span class="RefLink">6.9-52</span></a>).</p>


<div class="example"><pre>
 gap&gt; complex:=SC([[1,2,3], [1,2,4], [1,3,4], [2,3,4]]);;
 gap&gt; SCFVector(complex);
 [ 4, 6, 4 ]
 </pre></div>

<p><a id="X7F8B561C823DDDBA" name="X7F8B561C823DDDBA"></a></p>

<h5>6.9-15 SCFaceLattice</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFaceLattice</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list of face lists upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the entire face lattice of a <span class="SimpleMath">d</span>-dimensional simplicial complex, i. e. all of its <span class="SimpleMath">i</span>-skeletons for <span class="SimpleMath">0 ≤ i ≤ d</span>. The faces are returned in the original labeling.</p>


<div class="example"><pre>
 gap&gt; c:=SC([["a","b","c"],["a","b","d"], ["a","c","d"], ["b","c","d"]]);;
 gap&gt; SCFaceLattice(c);
 [ [ [ "a" ], [ "b" ], [ "c" ], [ "d" ] ], 
   [ [ "a", "b" ], [ "a", "c" ], [ "a", "d" ], [ "b", "c" ], [ "b", "d" ], 
       [ "c", "d" ] ], 
   [ [ "a", "b", "c" ], [ "a", "b", "d" ], [ "a", "c", "d" ], 
       [ "b", "c", "d" ] ] ]
 </pre></div>

<p><a id="X7AE0029985BD0775" name="X7AE0029985BD0775"></a></p>

<h5>6.9-16 SCFaceLatticeEx</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFaceLatticeEx</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list of face lists upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the entire face lattice of a <span class="SimpleMath">d</span>-dimensional simplicial complex, i. e. all of its <span class="SimpleMath">i</span>-skeletons for <span class="SimpleMath">0 ≤ i ≤ d</span>. The faces are returned in the standard labeling.</p>


<div class="example"><pre>
 gap&gt; c:=SC([["a","b","c"],["a","b","d"], ["a","c","d"], ["b","c","d"]]);;
 gap&gt; SCFaceLatticeEx(c);
 [ [ [ 1 ], [ 2 ], [ 3 ], [ 4 ] ], 
   [ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 2, 4 ], [ 3, 4 ] ], 
   [ [ 1, 2, 3 ], [ 1, 2, 4 ], [ 1, 3, 4 ], [ 2, 3, 4 ] ] ]
 </pre></div>

<p><a id="X7F6FE9B27B8D6922" name="X7F6FE9B27B8D6922"></a></p>

<h5>6.9-17 SCFaces</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFaces</code>( <var class="Arg">complex</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a face list upon success, <code class="keyw">fail</code> otherwise.</p>

<p>This is a synonym of the function <code class="func">SCSkel</code> (<a href="chap7.html#X8026B46F8236124D"><span class="RefLink">7.3-13</span></a>).</p>

<p><a id="X7B40DFE780A47109" name="X7B40DFE780A47109"></a></p>

<h5>6.9-18 SCFacesEx</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFacesEx</code>( <var class="Arg">complex</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a face list upon success, <code class="keyw">fail</code> otherwise.</p>

<p>This is a synonym of the function <code class="func">SCSkelEx</code> (<a href="chap7.html#X84ACF7D580FE8B76"><span class="RefLink">7.3-14</span></a>).</p>

<p><a id="X7BDD568184E3419D" name="X7BDD568184E3419D"></a></p>

<h5>6.9-19 SCFacets</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFacets</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a facet list upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns the facets of a simplicial complex in the original vertex labeling.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[2,3],[3,4],[4,2]]);;
 gap&gt; SCFacets(c);
 [ [ 2, 3 ], [ 2, 4 ], [ 3, 4 ] ]
 </pre></div>

<p><a id="X87DC942881235E25" name="X87DC942881235E25"></a></p>

<h5>6.9-20 SCFacetsEx</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFacetsEx</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a facet list upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns the facets of a simplicial complex as they are stored, i. e. with standard vertex labeling from 1 to n.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[2,3],[3,4],[4,2]]);;
 gap&gt; SCFacetsEx(c);
 [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ] ]
 </pre></div>

<p><a id="X79F60850875BB683" name="X79F60850875BB683"></a></p>

<h5>6.9-21 SCFpBettiNumbers</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFpBettiNumbers</code>( <var class="Arg">complex</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list of non-negative integers upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the Betti numbers of a simplicial complex with respect to the field <span class="SimpleMath">F_p</span> for any prime number <code class="code">p</code>.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("K^2");    
 [ [ 17, "K^2 (VT)" ], [ 571, "K^2 (VT)" ] ]
 gap&gt; kleinBottle:=SCLib.Load(last[1][1]);; 
 gap&gt; SCHomology(kleinBottle);      
 [ [ 0, [  ] ], [ 1, [ 2 ] ], [ 0, [  ] ] ]
 gap&gt; SCFpBettiNumbers(kleinBottle,2);
 [ 1, 2, 1 ]
 gap&gt; SCFpBettiNumbers(kleinBottle,3);
 [ 1, 1, 0 ]
 </pre></div>

<p><a id="X875963367A7745FB" name="X875963367A7745FB"></a></p>

<h5>6.9-22 SCFundamentalGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFundamentalGroup</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a <strong class="pkg">GAP</strong> fp group upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the first fundamental group of <var class="Arg">complex</var>, which must be a connected simplicial complex, and returns it in form of a finitely presented group. The generators of the group are given as 2-tuples that correspond to the edges of <var class="Arg">complex</var> in standard labeling. You can use GAP's <code class="code">SimplifiedFpGroup</code> to simplify the group presenation.</p>


<div class="example"><pre>
 gap&gt; list:=SCLib.SearchByName("RP^2");
 [ [ 3, "RP^2 (VT)" ], [ 645, "RP^2xS^1" ] ]
 gap&gt; c:=SCLib.Load(list[1][1]);
 [SimplicialComplex
 
  Properties known: AltshulerSteinberg, AutomorphismGroup, 
                    AutomorphismGroupSize, AutomorphismGroupStructure, 
                    AutomorphismGroupTransitivity, ConnectedComponents, 
                    Dim, DualGraph, EulerCharacteristic, FVector, 
                    FacetsEx, GVector, GeneratorsEx, HVector, 
                    HasBoundary, HasInterior, Homology, Interior, 
                    IsCentrallySymmetric, IsConnected, 
                    IsEulerianManifold, IsManifold, IsOrientable, 
                    IsPseudoManifold, IsPure, IsStronglyConnected, 
                    MinimalNonFacesEx, Name, Neighborliness, 
                    NumFaces[], Orientation, Reference, SkelExs[], 
                    Vertices.
 
  Name="RP^2 (VT)"
  Dim=2
  AltshulerSteinberg=3645
  AutomorphismGroupSize=60
  AutomorphismGroupStructure="A5"
  AutomorphismGroupTransitivity=2
  EulerCharacteristic=1
  FVector=[ 6, 15, 10 ]
  GVector=[ 2, 3 ]
  HVector=[ 3, 6, 0 ]
  HasBoundary=false
  HasInterior=true
  Homology=[ [ 0, [ ] ], [ 0, [ 2 ] ], [ 0, [ ] ] ]
  IsCentrallySymmetric=false
  IsConnected=true
  IsEulerianManifold=true
  IsOrientable=false
  IsPseudoManifold=true
  IsPure=true
  IsStronglyConnected=true
  Neighborliness=2
 
 /SimplicialComplex]
 gap&gt; g:=SCFundamentalGroup(c);;
 gap&gt; StructureDescription(g);
 "C2"
 </pre></div>

<p><a id="X7B9F77A885E1BABE" name="X7B9F77A885E1BABE"></a></p>

<h5>6.9-23 SCGVector</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCGVector</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list of integers upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the g-vector of a simplicial complex. The <span class="SimpleMath">g</span>-vector is defined as follows:</p>

<p>Let <span class="SimpleMath">h</span> be the <span class="SimpleMath">h</span>-vector of a <span class="SimpleMath">d</span>-dimensional simplicial complex C, then <span class="Math">g_i:=h_{i+1} - h_{i} ; \quad \frac{d}{2} \geq i \geq 0 </span> is called the <span class="SimpleMath">g</span>-vector of <span class="SimpleMath">C</span>. For the definition of the <span class="SimpleMath">h</span>-vector see <code class="func">SCHVector</code> (<a href="chap6.html#X84FBF0A685547ECD"><span class="RefLink">6.9-26</span></a>). The information contained in <span class="SimpleMath">g</span> suffices to determine the <span class="SimpleMath">f</span>-vector of <span class="SimpleMath">C</span>.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("RP^2");
 [ [ 3, "RP^2 (VT)" ], [ 645, "RP^2xS^1" ] ]
 gap&gt; rp2_6:=SCLib.Load(last[1][1]);;
 gap&gt; SCFVector(rp2_6);
 [ 6, 15, 10 ]
 gap&gt; SCHVector(rp2_6);
 [ 3, 6, 0 ]
 gap&gt; SCGVector(rp2_6);
 [ 2, 3 ]
 </pre></div>

<p><a id="X863CA73D7F66B295" name="X863CA73D7F66B295"></a></p>

<h5>6.9-24 SCGenerators</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCGenerators</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list of pairs of the form <code class="code">[ list, integer ]</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the generators of a simplicial complex in the original vertex labeling.</p>

<p>The generating set of a simplicial complex is a list of simplices that will generate the complex by uniting their <span class="SimpleMath">G</span>-orbits if <span class="SimpleMath">G</span> is the automorphism group of <var class="Arg">complex</var>.</p>

<p>The function returns the simplices together with the length of their orbits.</p>


<div class="example"><pre>
 gap&gt; list:=SCLib.SearchByName("T^2");;
 gap&gt; torus:=SCLib.Load(list[1][1]);;
 gap&gt; SCGenerators(torus); 
 [ [ [ 1, 2, 4 ], 14 ] ]
 </pre></div>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("K3");
 [ [ 7494, "K3_16" ], [ 7513, "K3_17" ] ]
 gap&gt; SCLib.Load(last[1][1]);
 [SimplicialComplex
 
  Properties known: AltshulerSteinberg, AutomorphismGroup, 
                    AutomorphismGroupSize, AutomorphismGroupStructure, 
                    AutomorphismGroupTransitivity, ConnectedComponents, 
                    Dim, DualGraph, EulerCharacteristic, FVector, 
                    FacetsEx, GVector, GeneratorsEx, HVector, 
                    HasBoundary, HasInterior, Homology, Interior, 
                    IsCentrallySymmetric, IsConnected, 
                    IsEulerianManifold, IsManifold, IsOrientable, 
                    IsPseudoManifold, IsPure, IsStronglyConnected, 
                    MinimalNonFacesEx, Name, Neighborliness, 
                    NumFaces[], Orientation, SkelExs[], Vertices.
 
  Name="K3_16"
  Dim=4
  AltshulerSteinberg=883835714748069945165599539200
  AutomorphismGroupSize=240
  AutomorphismGroupStructure="((C2 x C2 x C2 x C2) : C5) : C3"
  AutomorphismGroupTransitivity=2
  EulerCharacteristic=24
  FVector=[ 16, 120, 560, 720, 288 ]
  GVector=[ 10, 55, 220 ]
  HVector=[ 11, 66, 286, -99, 23 ]
  HasBoundary=false
  HasInterior=true
  Homology=[ [ 0, [ ] ], [ 0, [ ] ], [ 22, [ ] ], [ 0, [ ] ], [ 1, [ ] ] ]
  IsCentrallySymmetric=false
  IsConnected=true
  IsEulerianManifold=true
  IsOrientable=true
  IsPseudoManifold=true
  IsPure=true
  IsStronglyConnected=true
  Neighborliness=3
 
 /SimplicialComplex]
 gap&gt; SCGenerators(last);
 [ [ [ 1, 2, 3, 8, 12 ], 240 ], [ [ 1, 2, 5, 8, 14 ], 48 ] ]
 </pre></div>

<p><a id="X789F8FC77FC0E701" name="X789F8FC77FC0E701"></a></p>

<h5>6.9-25 SCGeneratorsEx</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCGeneratorsEx</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list of pairs of the form <code class="code">[ list, integer ]</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the generators of a simplicial complex in the standard vertex labeling.</p>

<p>The generating set of a simplicial complex is a list of simplices that will generate the complex by uniting their <span class="SimpleMath">G</span>-orbits if <span class="SimpleMath">G</span> is the automorphism group of <var class="Arg">complex</var>.</p>

<p>The function returns the simplices together with the length of their orbits.</p>


<div class="example"><pre>
 gap&gt; list:=SCLib.SearchByName("T^2");;
 gap&gt; torus:=SCLib.Load(list[1][1]);;
 gap&gt; SCGeneratorsEx(torus); 
 [ [ [ 1, 2, 4 ], 14 ] ]
 </pre></div>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("K3");
 [ [ 7494, "K3_16" ], [ 7513, "K3_17" ] ]
 gap&gt; SCLib.Load(last[1][1]);
 [SimplicialComplex
 
  Properties known: AltshulerSteinberg, AutomorphismGroup, 
                    AutomorphismGroupSize, AutomorphismGroupStructure, 
                    AutomorphismGroupTransitivity, ConnectedComponents, 
                    Dim, DualGraph, EulerCharacteristic, FVector, 
                    FacetsEx, GVector, GeneratorsEx, HVector, 
                    HasBoundary, HasInterior, Homology, Interior, 
                    IsCentrallySymmetric, IsConnected, 
                    IsEulerianManifold, IsManifold, IsOrientable, 
                    IsPseudoManifold, IsPure, IsStronglyConnected, 
                    MinimalNonFacesEx, Name, Neighborliness, 
                    NumFaces[], Orientation, SkelExs[], Vertices.
 
  Name="K3_16"
  Dim=4
  AltshulerSteinberg=883835714748069945165599539200
  AutomorphismGroupSize=240
  AutomorphismGroupStructure="((C2 x C2 x C2 x C2) : C5) : C3"
  AutomorphismGroupTransitivity=2
  EulerCharacteristic=24
  FVector=[ 16, 120, 560, 720, 288 ]
  GVector=[ 10, 55, 220 ]
  HVector=[ 11, 66, 286, -99, 23 ]
  HasBoundary=false
  HasInterior=true
  Homology=[ [ 0, [ ] ], [ 0, [ ] ], [ 22, [ ] ], [ 0, [ ] ], [ 1, [ ] ] ]
  IsCentrallySymmetric=false
  IsConnected=true
  IsEulerianManifold=true
  IsOrientable=true
  IsPseudoManifold=true
  IsPure=true
  IsStronglyConnected=true
  Neighborliness=3
 
 /SimplicialComplex]
 gap&gt; SCGeneratorsEx(last);
 [ [ [ 1, 2, 3, 8, 12 ], 240 ], [ [ 1, 2, 5, 8, 14 ], 48 ] ]
 </pre></div>

<p><a id="X84FBF0A685547ECD" name="X84FBF0A685547ECD"></a></p>

<h5>6.9-26 SCHVector</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCHVector</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list of integers upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the <span class="SimpleMath">h</span>-vector of a simplicial complex. The <span class="SimpleMath">h</span>-vector is defined as <span class="Math"> h_{k}:= \sum \limits_{i=-1}^{k-1} (-1)^{k-i-1}{d-i-1 \choose k-i-1} f_i</span> for <span class="SimpleMath">0 ≤ k ≤ d</span>, where <span class="SimpleMath">f_-1 := 1</span>. For all simplicial complexes we have <span class="SimpleMath">h_0 = 1</span>, hence the returned list starts with the second entry of the <span class="SimpleMath">h</span>-vector.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("RP^2");
 [ [ 3, "RP^2 (VT)" ], [ 645, "RP^2xS^1" ] ]
 gap&gt; rp2_6:=SCLib.Load(last[1][1]);;
 gap&gt; SCFVector(rp2_6);
 [ 6, 15, 10 ]
 gap&gt; SCHVector(rp2_6);
 [ 3, 6, 0 ]
 </pre></div>

<p><a id="X796EBADE7803C622" name="X796EBADE7803C622"></a></p>

<h5>6.9-27 SCHasBoundary</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCHasBoundary</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks if a simplicial complex <var class="Arg">complex</var> that fulfills the weak pseudo manifold property has a boundary, i. e. <span class="SimpleMath">d-1</span>-faces of valence <span class="SimpleMath">1</span>. If <var class="Arg">complex</var> is closed <code class="keyw">false</code> is returned, if <var class="Arg">complex</var> does not fulfill the weak pseudomanifold property, <code class="keyw">fail</code> is returned, otherwise <code class="keyw">true</code> is returned.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("K^2"); 
 [ [ 17, "K^2 (VT)" ], [ 571, "K^2 (VT)" ] ]
 gap&gt; kleinBottle:=SCLib.Load(last[1][1]);;
 gap&gt; SCHasBoundary(kleinBottle);
 false
 </pre></div>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2,3,4],[1,2,3,5],[1,2,4,5],[1,3,4,5]]);;
 gap&gt; SCHasBoundary(c);
 true
 </pre></div>

<p><a id="X7C2A5B4D7E77E444" name="X7C2A5B4D7E77E444"></a></p>

<h5>6.9-28 SCHasInterior</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCHasInterior</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns <code class="keyw">true</code> if a simplicial complex <var class="Arg">complex</var> that fulfills the weak pseudomanifold property has at least one <span class="SimpleMath">d-1</span>-face of valence <span class="SimpleMath">2</span>, i. e. if there exist at least one <span class="SimpleMath">d-1</span>-face that is not in the boundary of <var class="Arg">complex</var>, if no such face can be found <code class="keyw">false</code> is returned. It <var class="Arg">complex</var> does not fulfill the weak pseudomanifold property <code class="keyw">fail</code> is returned.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2,3,4],[1,2,3,5],[1,2,4,5],[1,3,4,5]]);;
 gap&gt; SCHasInterior(c)
 true
 gap&gt; c:=SC([[1,2,3,4]]);;
 gap&gt; SCHasInterior(c);
 false
 </pre></div>

<p><a id="X7A0547F67BBB6546" name="X7A0547F67BBB6546"></a></p>

<h5>6.9-29 SCHeegaardSplittingSmallGenus</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCHeegaardSplittingSmallGenus</code>( <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list of an integer, a list of two sublists and a string upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes a Heegaard splitting of the combinatorial <span class="SimpleMath">3</span>-manifold <var class="Arg">M</var> of small genus. The function returns the genus of the Heegaard splitting, the vertex partition of the Heegaard splitting and information whether the splitting is minimal or just small (i. e. the Heegaard genus could not be determined). See also <code class="func">SCHeegaardSplitting</code> (<a href="chap6.html#X7C7335667C162AFA"><span class="RefLink">6.9-30</span></a>) for a faster computation of a Heegaard splitting of arbitrary genus and <code class="func">SCIsHeegaardSplitting</code> (<a href="chap6.html#X83F0246384A766F2"><span class="RefLink">6.9-40</span></a>) for a test whether or not a given splitting defines a Heegaard splitting.</p>


<div class="example"><pre> 
 gap&gt; c:=SCSeriesBdHandleBody(3,10);;
 gap&gt; M:=SCConnectedProduct(c,3);;
 gap&gt; list:=SCHeegaardSplittingSmallGenus(M);
 This creates an error
 </pre></div>

<p><a id="X7C7335667C162AFA" name="X7C7335667C162AFA"></a></p>

<h5>6.9-30 SCHeegaardSplitting</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCHeegaardSplitting</code>( <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list of an integer, a list of two sublists and a string upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes a Heegaard splitting of the combinatorial <span class="SimpleMath">3</span>-manifold <var class="Arg">M</var>. The function returns the genus of the Heegaard splitting, the vertex partition of the Heegaard splitting and a note, that splitting is arbitrary and in particular possibly not minimal. See also <code class="func">SCHeegaardSplittingSmallGenus</code> (<a href="chap6.html#X7A0547F67BBB6546"><span class="RefLink">6.9-29</span></a>) for the calculation of a Heegaard splitting of small genus and <code class="func">SCIsHeegaardSplitting</code> (<a href="chap6.html#X83F0246384A766F2"><span class="RefLink">6.9-40</span></a>) for a test whether or not a given splitting defines a Heegaard splitting.</p>


<div class="example"><pre>
 gap&gt; M:=SCSeriesBdHandleBody(3,12);;
 gap&gt; list:=SCHeegaardSplitting(M);
 [ 1, [ [ 1, 2, 3, 5, 9 ], [ 4, 6, 7, 8, 10, 11, 12 ] ], "arbitrary" ]
 gap&gt; sl:=SCSlicing(M,list[2]);
 [NormalSurface
 
  Properties known: ConnectedComponents, Dim, EulerCharacteristic, FVector, Fac\
 etsEx, Genus, IsConnected, IsOrientable, NSTriangulation, Name, TopologicalTyp\
 e, Vertices.
 
  Name="slicing [ [ 1, 2, 3, 5, 9 ], [ 4, 6, 7, 8, 10, 11, 12 ] ] of Sphere bun\
 dle S^2 x S^1"
  Dim=2
  FVector=[ 24, 55, 14, 17 ]
  EulerCharacteristic=0
  IsOrientable=true
  TopologicalType="T^2"
 
 /NormalSurface]
 </pre></div>

<p><a id="X864978877E7D4DA0" name="X864978877E7D4DA0"></a></p>

<h5>6.9-31 SCHomologyClassic</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCHomologyClassic</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a list of pairs of the form <code class="code">[ integer, list ]</code>.</p>

<p>Computes the integral simplicial homology groups of a simplicial complex <var class="Arg">complex</var> (internally calls the function <code class="code">SimplicialHomology(complex.FacetsEx)</code> from the <strong class="pkg">homology</strong> package, see <a href="chapBib.html#biBDumas04Homology">[DHSW11]</a>).</p>

<p>If the <strong class="pkg">homology</strong> package is not available, this function call falls back to <code class="func">SCHomologyInternal</code> (<a href="chap8.html#X858989CE797A8366"><span class="RefLink">8.1-5</span></a>). The output is a list of homology groups of the form <span class="SimpleMath">[H_0,....,H_d]</span>, where <span class="SimpleMath">d</span> is the dimension of <var class="Arg">complex</var>. The format of the homology groups <span class="SimpleMath">H_i</span> is given in terms of their maximal cyclic subgroups, i.e. a homology group <span class="SimpleMath">H_i≅ Z^f + Z / t_1 Z × dots × Z / t_n Z</span> is returned in form of a list <span class="SimpleMath">[ f, [t_1,...,t_n] ]</span>, where <span class="SimpleMath">f</span> is the (integer) free part of <span class="SimpleMath">H_i</span> and <span class="SimpleMath">t_i</span> denotes the torsion parts of <span class="SimpleMath">H_i</span> ordered in weakly increasing size.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("K^2");
 [ [ 17, "K^2 (VT)" ], [ 571, "K^2 (VT)" ] ]
 gap&gt; kleinBottle:=SCLib.Load(last[1][1]);;
 gap&gt; kleinBottle.Homology;          
 [ [ 0, [  ] ], [ 1, [ 2 ] ], [ 0, [  ] ] ]
 gap&gt; SCLib.SearchByName("L_"){[1..10]};
 [ [ 161, "L_3_1" ], [ 643, "L_4_1" ], [ 752, "L_5_2" ], 
   [ 2416, "(S^2~S^1)#L_3_1" ], [ 2417, "(S^2xS^1)#L_3_1" ], [ 2490, "L_5_1" ],
   [ 2492, "(S^2xS^1)#2#L_3_1" ], [ 2493, "(S^2~S^1)#2#L_3_1" ], 
   [ 7467, "L_7_2" ], [ 7469, "L_8_3" ] ]
 gap&gt; c:=SCConnectedSum(SCLib.Load(last[9][1]),
                        SCConnectedProduct(SCLib.Load(last[10][1]),2));
 &gt; [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="L_7_2#+-L_8_3#+-L_8_3"
  Dim=3
 
 /SimplicialComplex]
 gap&gt; SCHomology(c);
 [ [ 0, [  ] ], [ 0, [ 8, 56 ] ], [ 0, [  ] ], [ 1, [  ] ] ]
 gap&gt; SCFpBettiNumbers(c,2);
 [ 1, 2, 2, 1 ]
 gap&gt; SCFpBettiNumbers(c,3);
 [ 1, 0, 0, 1 ]
 </pre></div>

<p><a id="X7B0C12F5780FDD9B" name="X7B0C12F5780FDD9B"></a></p>

<h5>6.9-32 SCIncidences</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIncidences</code>( <var class="Arg">complex</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list of face lists upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns a list of all <var class="Arg">k</var>-faces of the simplicial complex <var class="Arg">complex</var>. The list is sorted by the valence of the faces in the <var class="Arg">k</var>+1-skeleton of the complex, i. e. the <span class="SimpleMath">i</span>-th entry of the list contains all <var class="Arg">k</var>-faces of valence <span class="SimpleMath">i</span>. The faces are returned in the original labeling.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2,3],[2,3,4],[3,4,5],[4,5,6],[1,5,6],[1,4,6],[2,3,6]]);;
 gap&gt; SCIncidences(c,1);
 [ [ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 1, 5 ], [ 2, 4 ], [ 2, 6 ], [ 3, 5 ], 
       [ 3, 6 ] ], [ [ 1, 6 ], [ 3, 4 ], [ 4, 5 ], [ 4, 6 ], [ 5, 6 ] ], 
   [ [ 2, 3 ] ] ]
 </pre></div>

<p><a id="X7B4CA6FE78A9880F" name="X7B4CA6FE78A9880F"></a></p>

<h5>6.9-33 SCIncidencesEx</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIncidencesEx</code>( <var class="Arg">complex</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list of face lists upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns a list of all <var class="Arg">k</var>-faces of the simplicial complex <var class="Arg">complex</var>. The list is sorted by the valence of the faces in the <var class="Arg">k</var>+1-skeleton of the complex, i. e. the <span class="SimpleMath">i</span>-th entry of the list contains all <var class="Arg">k</var>-faces of valence <span class="SimpleMath">i</span>. The faces are returned in the standard labeling.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2,3],[2,3,4],[3,4,5],[4,5,6],[1,5,6],[1,4,6],[2,3,6]]);;
 gap&gt; SCIncidences(c,1);
 [ [ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 1, 5 ], [ 2, 4 ], [ 2, 6 ], [ 3, 5 ], 
       [ 3, 6 ] ], [ [ 1, 6 ], [ 3, 4 ], [ 4, 5 ], [ 4, 6 ], [ 5, 6 ] ], 
   [ [ 2, 3 ] ] ]
 </pre></div>

<p><a id="X862926A079F6DFC2" name="X862926A079F6DFC2"></a></p>

<h5>6.9-34 SCInterior</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCInterior</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes all <span class="SimpleMath">d-1</span>-faces of valence <span class="SimpleMath">2</span> of a simplicial complex <var class="Arg">complex</var> that fulfills the weak pseudomanifold property, i. e. the function returns the part of the <span class="SimpleMath">d-1</span>-skeleton of <span class="SimpleMath">C</span> that is not part of the boundary.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2,3,4],[1,2,3,5],[1,2,4,5],[1,3,4,5]]);;
 gap&gt; SCInterior(c).Facets;
 [ [ 1, 2, 3 ], [ 1, 2, 4 ], [ 1, 2, 5 ], [ 1, 3, 4 ], [ 1, 3, 5 ], 
   [ 1, 4, 5 ] ]
 gap&gt; c:=SC([[1,2,3,4]]);;
 gap&gt; SCInterior(c).Facets;
 [  ]
 </pre></div>

<p><a id="X8123A6E282CD0174" name="X8123A6E282CD0174"></a></p>

<h5>6.9-35 SCIsCentrallySymmetric</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsCentrallySymmetric</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks if a simplicial complex <var class="Arg">complex</var> is centrally symmetric, i. e. if its automorphism group contains a fixed point free involution.</p>


<div class="example"><pre>
 gap&gt; c:=SCBdCrossPolytope(4);;
 gap&gt; SCIsCentrallySymmetric(c);
 true
 </pre></div>


<div class="example"><pre>
 gap&gt; c:=SCBdSimplex(4);;
 gap&gt; SCIsCentrallySymmetric(c);
 false
 </pre></div>

<p><a id="X81AF20DC814B51A6" name="X81AF20DC814B51A6"></a></p>

<h5>6.9-36 SCIsConnected</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsConnected</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks if a simplicial complex <var class="Arg">complex</var> is connected.</p>


<div class="example"><pre>
 gap&gt; c:=SCBdSimplex(1);;
 gap&gt; SCIsConnected(c);
 false
 gap&gt; c:=SCBdSimplex(2);;
 gap&gt; SCIsConnected(c);
 true
 </pre></div>

<p><a id="X860375D980E9A801" name="X860375D980E9A801"></a></p>

<h5>6.9-37 SCIsEmpty</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsEmpty</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks if a simplicial complex <var class="Arg">complex</var> is the empty complex, i. e. a <code class="code">SCSimplicialComplex</code> object with empty facet list.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1]]);;
 gap&gt; SCIsEmpty(c);
 false
 gap&gt; c:=SC([]);;
 gap&gt; SCIsEmpty(c);
 true
 gap&gt; c:=SC([[]]);;
 gap&gt; SCIsEmpty(c);
 true
 </pre></div>

<p><a id="X83E01C957D2F2458" name="X83E01C957D2F2458"></a></p>

<h5>6.9-38 SCIsEulerianManifold</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsEulerianManifold</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks whether a given simplicial complex <var class="Arg">complex</var> is a Eulerian manifold or not, i. e. checks if all vertex links of <var class="Arg">complex</var> have the Euler characteristic of a sphere. In particular the function returns <code class="keyw">false</code> in case <var class="Arg">complex</var> has a non-empty boundary.</p>


<div class="example"><pre>
 gap&gt; c:=SCBdSimplex(4);;
 gap&gt; SCIsEulerianManifold(c);
 true
 gap&gt; SCLib.SearchByName("Moebius");
 [ [ 1, "Moebius Strip" ] ]
 gap&gt; moebius:=SCLib.Load(last[1][1]); # a moebius strip
 [SimplicialComplex
 
  Properties known: Dim, EulerCharacteristic, FVector, FacetsEx, 
                    GVector, HVector, HasBoundary, Homology, 
                    IsConnected, IsManifold, IsPseudoManifold, 
                    MinimalNonFacesEx, Name, NumFaces[], SkelExs[], 
                    Vertices.
 
  Name="Moebius Strip"
  Dim=2
  EulerCharacteristic=0
  FVector=[ 5, 10, 5 ]
  GVector=[ 1, 1 ]
  HVector=[ 2, 3, -1 ]
  HasBoundary=true
  Homology=[ [ 0 ], [ 1 ], [ 0 ] ]
  IsConnected=true
  IsPseudoManifold=true
 
 /SimplicialComplex]
 gap&gt; SCIsEulerianManifold(moebius);
 false
 </pre></div>

<p><a id="X843C3E7F79D8093F" name="X843C3E7F79D8093F"></a></p>

<h5>6.9-39 SCIsFlag</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsFlag</code>( <var class="Arg">complex</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks if <var class="Arg">complex</var> is flag. A connected simplicial complex of dimension at least one is a flag complex if all cliques in its 1-skeleton span a face of the complex (cf. <a href="chapBib.html#biBFrohmader08FaceVecFlagCompl">[Fro08]</a>).</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("RP^2");   
 [ [ 3, "RP^2 (VT)" ], [ 645, "RP^2xS^1" ] ]
 gap&gt; rp2_6:=SCLib.Load(last[1][1]);;
 gap&gt; SCIsFlag(rp2_6);
 false
 </pre></div>

<p><a id="X83F0246384A766F2" name="X83F0246384A766F2"></a></p>

<h5>6.9-40 SCIsHeegaardSplitting</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsHeegaardSplitting</code>( <var class="Arg">c</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks whether <var class="Arg">list</var> defines a Heegaard splitting of <var class="Arg">c</var> or not. See also <code class="func">SCHeegaardSplitting</code> (<a href="chap6.html#X7C7335667C162AFA"><span class="RefLink">6.9-30</span></a>) and <code class="func">SCHeegaardSplittingSmallGenus</code> (<a href="chap6.html#X7A0547F67BBB6546"><span class="RefLink">6.9-29</span></a>) for functions to compute Heegaard splittings.</p>


<div class="example"><pre>
 gap&gt; c:=SCSeriesBdHandleBody(3,9);;
 gap&gt; list:=[[1..3],[4..9]];
 [ [ 1 .. 3 ], [ 4 .. 9 ] ]
 gap&gt; SCIsHeegaardSplitting(c,list);
 false
 gap&gt; splitting:=SCHeegaardSplitting(c);
 [ 1, [ [ 1, 2, 3, 6 ], [ 4, 5, 7, 8, 9 ] ], "arbitrary" ]
 gap&gt; SCIsHeegaardSplitting(c,splitting[2]);                                         
 true
 </pre></div>

<p><a id="X7E66FE0C83A3D371" name="X7E66FE0C83A3D371"></a></p>

<h5>6.9-41 SCIsHomologySphere</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsHomologySphere</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks whether a simplicial complex <var class="Arg">complex</var> is a homology sphere, i. e. has the homology of a sphere, or not.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[2,3],[3,4],[4,2]]);;
 gap&gt; SCIsHomologySphere(c);
 true
 </pre></div>

<p><a id="X87BC29AF878E7FD8" name="X87BC29AF878E7FD8"></a></p>

<h5>6.9-42 SCIsInKd</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsInKd</code>( <var class="Arg">complex</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> / <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks whether the simplicial complex <var class="Arg">complex</var> that must be a combinatorial <span class="SimpleMath">d</span>-manifold is in the class <span class="SimpleMath">mathcalK^k(d)</span>, <span class="SimpleMath">1≤ k≤ ⌊fracd+12⌋</span>, of simplicial complexes that only have <span class="SimpleMath">k</span>-stacked spheres as vertex links, see <a href="chapBib.html#biBEffenberger09StackPolyTightTrigMnf">[Eff11b]</a>. Note that it is not checked whether <var class="Arg">complex</var> is a combinatorial manifold -- if not, the algorithm will not succeed. Returns <code class="keyw">true</code> / <code class="keyw">false</code> upon success. If <code class="keyw">true</code> is returned this means that <var class="Arg">complex</var> is at least <var class="Arg">k</var>-stacked and thus that the complex is in the class <span class="SimpleMath">mathcalK^k(d)</span>, i.e. all vertex links are <code class="code">i</code>-stacked spheres. If <code class="keyw">false</code> is returnd the complex cannot be <var class="Arg">k</var>-stacked. In some cases the question can not be decided. In this case <code class="keyw">fail</code> is returned.</p>

<p>Internally calls <code class="func">SCIsKStackedSphere</code> (<a href="chap9.html#X79FBFD6A7F2CC7E7"><span class="RefLink">9.2-5</span></a>) for all links. Please note that this is a radomized algorithm that may give an indefinite answer to the membership problem.</p>


<div class="example"><pre>
 gap&gt; list:=SCLib.SearchByName("S^2~S^1");;{[1..3]};
 gap&gt; c:=SCLib.Load(list[1][1]);;
 gap&gt; c.AutomorphismGroup;
 Group([ (1,3)(4,9)(5,8)(6,7), (1,9,8,7,6,5,4,3,2) ])
 gap&gt; SCIsInKd(c,1);
 #I  SCIsKStackedSphere: checking if complex is a 1-stacked sphere...
 #I  SCIsKStackedSphere: try 1/1
 #I  SCIsKStackedSphere: complex is a 1-stacked sphere.
 true
 </pre></div>

<p><a id="X7F4BECCA7E67B1B2" name="X7F4BECCA7E67B1B2"></a></p>

<h5>6.9-43 SCIsKNeighborly</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsKNeighborly</code>( <var class="Arg">complex</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("RP^2");   
 [ [ 3, "RP^2 (VT)" ], [ 645, "RP^2xS^1" ] ]
 gap&gt; rp2_6:=SCLib.Load(last[1][1]);;
 gap&gt; SCFVector(rp2_6);
 [ 6, 15, 10 ]
 gap&gt; SCIsKNeighborly(rp2_6,2);
 true
 gap&gt; SCIsKNeighborly(rp2_6,3);
 false
 </pre></div>

<p><a id="X78C860DC851167F7" name="X78C860DC851167F7"></a></p>

<h5>6.9-44 SCIsOrientable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsOrientable</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks if a simplicial complex <var class="Arg">complex</var>, satisfying the weak pseudomanifold property, is orientable.</p>


<div class="example"><pre>
 gap&gt; c:=SCBdCrossPolytope(4);;
 gap&gt; SCIsOrientable(c);
 true
 </pre></div>

<p><a id="X79DFCA08808665B7" name="X79DFCA08808665B7"></a></p>

<h5>6.9-45 SCIsPseudoManifold</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsPseudoManifold</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks if a simplicial complex <var class="Arg">complex</var> fulfills the weak pseudomanifold property, i. e. if every <span class="SimpleMath">d-1</span>-face of <var class="Arg">complex</var> is contained in at most <span class="SimpleMath">2</span> facets.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2,3],[1,2,4],[1,3,4],[2,3,4],[1,5,6],[1,5,7],[1,6,7],[5,6,7]]);;
 gap&gt; SCIsPseudoManifold(c);
 true
 gap&gt; c:=SC([[1,2],[2,3],[3,1],[1,4],[4,5],[5,1]]);;
 gap&gt; SCIsPseudoManifold(c);
 false
 </pre></div>

<p><a id="X7AAA757F842EA23A" name="X7AAA757F842EA23A"></a></p>

<h5>6.9-46 SCIsPure</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsPure</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a boolean upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks if a simplicial complex <var class="Arg">complex</var> is pure.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2], [1,4], [2,4], [2,3,4]]);;
 gap&gt; SCIsPure(c);
 false
 gap&gt; c:=SC([[1,2], [1,4], [2,4]]);;
 gap&gt; SCIsPure(c);
 true
 </pre></div>

<p><a id="X7EA4F4DB78758652" name="X7EA4F4DB78758652"></a></p>

<h5>6.9-47 SCIsShellable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsShellable</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>The simplicial complex <var class="Arg">complex</var> must be pure, strongly connected and must fulfill the weak pseudomanifold property with non-empty boundary (cf. <code class="func">SCBoundary</code> (<a href="chap6.html#X836DC73380EA7414"><span class="RefLink">6.9-7</span></a>)).</p>

<p>The function checks whether <var class="Arg">complex</var> is shellable or not. An ordering <span class="SimpleMath">(F_1, F_2, ... , F_r)</span> on the facet list of a simplicial complex is called a shelling if and only if <span class="SimpleMath">F_i ∩ (F_1 ∪ ... ∪ F_i-1)</span> is a pure simplicial complex of dimension <span class="SimpleMath">d-1</span> for all <span class="SimpleMath">i = 1, ... , r</span>. A simplicial complex is called shellable, if at least one shelling exists.</p>

<p>See <a href="chapBib.html#biBZiegler95LectPolytopes">[Zie95]</a>, <a href="chapBib.html#biBPachner87KonstrMethKombHomeo">[Pac87]</a> to learn more about shellings.</p>


<div class="example"><pre>
 gap&gt; c:=SCBdCrossPolytope(4);;       
 gap&gt; c:=Difference(c,SC([[1,3,5,7]]));; # bounded version
 gap&gt; SCIsShellable(c);
 true
 </pre></div>

<p><a id="X7A2BD5657BBE1CC7" name="X7A2BD5657BBE1CC7"></a></p>

<h5>6.9-48 SCIsStronglyConnected</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsStronglyConnected</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Checks if a simplicial complex <var class="Arg">complex</var> is strongly connected, i. e. if for any pair of facets <span class="SimpleMath">(hat∆,tilde∆)</span> there exists a sequence of facets <span class="SimpleMath">( ∆_1 , ... , ∆_k )</span> with <span class="SimpleMath">∆_1 = hat∆</span> and <span class="SimpleMath">∆_k = tilde∆</span> and dim<span class="SimpleMath">(∆_i , ∆_i+1 ) = d - 1</span> for all <span class="SimpleMath">1 ≤ i ≤ k - 1</span>.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2,3],[1,2,4],[1,3,4],[2,3,4], [1,5,6],[1,5,7],[1,6,7],[5,6,7]]);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="unnamed complex 24"
  Dim=2
 
 /SimplicialComplex]
 gap&gt; SCIsConnected(c);        
 true
 gap&gt; SCIsStronglyConnected(c);                                                
 false
 </pre></div>

<p><a id="X7B935899849C8E40" name="X7B935899849C8E40"></a></p>

<h5>6.9-49 SCMinimalNonFaces</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCMinimalNonFaces</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list of face lists upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes all missing proper faces of a simplicial complex <var class="Arg">complex</var> by calling <code class="func">SCMinimalNonFacesEx</code> (<a href="chap6.html#X7DE069A0823BD56E"><span class="RefLink">6.9-50</span></a>). The simplices are returned in the original labeling of <var class="Arg">complex</var>.</p>


<div class="example"><pre>
 gap&gt; c:=SCFromFacets(["abc","abd"]);;
 gap&gt; SCMinimalNonFaces(c);           
 [ [  ], [ "cd" ] ]
 </pre></div>

<p><a id="X7DE069A0823BD56E" name="X7DE069A0823BD56E"></a></p>

<h5>6.9-50 SCMinimalNonFacesEx</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCMinimalNonFacesEx</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list of face lists upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes all missing proper faces of a simplicial complex <var class="Arg">complex</var>, i.e. the missing <span class="SimpleMath">(i+1)</span>-tuples in the <span class="SimpleMath">i</span>-dimensional skeleton of a <var class="Arg">complex</var>. A missing <span class="SimpleMath">i+1</span>-tuple is not listed if it only consists of missing <span class="SimpleMath">i</span>-tuples. Note that whenever <var class="Arg">complex</var> is <span class="SimpleMath">k</span>-neighborly the first <span class="SimpleMath">k+1</span> entries are empty. The simplices are returned in the standard labeling <span class="SimpleMath">1,dots,n</span>, where <span class="SimpleMath">n</span> is the number of vertices of <var class="Arg">complex</var>.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("T^2"){[1..10]}; 
 [ [ 4, "T^2 (VT)" ], [ 5, "T^2 (VT)" ], [ 9, "T^2 (VT)" ], [ 10, "T^2 (VT)" ],
   [ 18, "T^2 (VT)" ], [ 20, "(T^2)#2" ], [ 24, "(T^2)#3" ], 
   [ 41, "T^2 (VT)" ], [ 44, "(T^2)#4" ], [ 65, "T^2 (VT)" ] ]
 gap&gt; torus:=SCLib.Load(last[1][1]);;
 gap&gt; SCFVector(torus);
 [ 7, 21, 14 ]
 gap&gt; SCMinimalNonFacesEx(torus);
 [ [  ], [  ] ]
 gap&gt; SCMinimalNonFacesEx(SCBdCrossPolytope(4));
 [ [  ], [ [ 1, 2 ], [ 3, 4 ], [ 5, 6 ], [ 7, 8 ] ], [  ] ]
 </pre></div>

<p><a id="X82A224DF787A97BE" name="X82A224DF787A97BE"></a></p>

<h5>6.9-51 SCNeighborliness</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCNeighborliness</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a positive integer upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns <span class="SimpleMath">k</span> if a simplicial complex <var class="Arg">complex</var> is <span class="SimpleMath">k</span>-neighborly but not <span class="SimpleMath">(k+1)</span>-neighborly. See also <code class="func">SCIsKNeighborly</code> (<a href="chap6.html#X7F4BECCA7E67B1B2"><span class="RefLink">6.9-43</span></a>).</p>

<p>Note that every complex is at least <span class="SimpleMath">1</span>-neighborly.</p>


<div class="example"><pre>
 gap&gt; c:=SCBdSimplex(4);;
 gap&gt; SCNeighborliness(c);
 4
 gap&gt; c:=SCBdCrossPolytope(4);;
 gap&gt; SCNeighborliness(c);
 1
 gap&gt; SCLib.SearchByAttribute("F[3]=Binomial(F[1],3) and Dim=4");
 [ [ 16, "CP^2 (VT)" ], [ 7494, "K3_16" ] ]
 gap&gt; cp2:=SCLib.Load(last[2][1]);;
 gap&gt; SCNeighborliness(cp2);
 3
 </pre></div>

<p><a id="X7AC2427184B44C65" name="X7AC2427184B44C65"></a></p>

<h5>6.9-52 SCNumFaces</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCNumFaces</code>( <var class="Arg">complex</var>[, <var class="Arg">i</var>] )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: an integer or a list of integers upon success, <code class="keyw">fail</code> otherwise.</p>

<p>If <var class="Arg">i</var> is not specified the function computes the <span class="SimpleMath">f</span>-vector of the simplicial complex <var class="Arg">complex</var> (cf. <code class="func">SCFVector</code> (<a href="chap6.html#X81F8071385FD9C1D"><span class="RefLink">6.9-14</span></a>)). If the optional integer parameter <var class="Arg">i</var> is passed, only the <var class="Arg">i</var>-th position of the <span class="SimpleMath">f</span>-vector of <var class="Arg">complex</var> is calculated. In any case a memory-saving implicit algorithm is used that avoids calculating the face lattice of the complex.</p>


<div class="example"><pre>
 gap&gt; complex:=SC([[1,2,3], [1,2,4], [1,3,4], [2,3,4]]);;
 gap&gt; SCNumFaces(complex,1);
 6
 </pre></div>

<p><a id="X78DACE3478340DB8" name="X78DACE3478340DB8"></a></p>

<h5>6.9-53 SCOrientation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCOrientation</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list of the type <span class="SimpleMath">{ ± 1 }^f_d</span> or <code class="code">[ ]</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>This function tries to compute an orientation of a pure simplicial complex <var class="Arg">complex</var> that fulfills the weak pseudomanifold property. If <var class="Arg">complex</var> is orientable, an orientation in form of a list of orientations for the facets of <var class="Arg">complex</var> is returned, otherwise an empty set.</p>


<div class="example"><pre>
 gap&gt; c:=SCBdCrossPolytope(4);;
 gap&gt; SCOrientation(c);
 [ 1, -1, -1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1 ]
 </pre></div>

<p><a id="X8026B46F8236124D" name="X8026B46F8236124D"></a></p>

<h5>6.9-54 SCSkel</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSkel</code>( <var class="Arg">complex</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a face list or a list of face lists upon success, <code class="keyw">fail</code> otherwise.</p>

<p>If <var class="Arg">k</var> is an integer, the <var class="Arg">k</var>-skeleton of a simplicial complex <var class="Arg">complex</var>, i. e. all <var class="Arg">k</var>-faces of <var class="Arg">complex</var>, is computed. If <var class="Arg">k</var> is a list, a list of all <var class="Arg">k</var><code class="code">[i]</code>-faces of <var class="Arg">complex</var> for each entry <var class="Arg">k</var><code class="code">[i]</code> (which has to be an integer) is returned. The faces are returned in the original labeling.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("RP^2"); 
 [ [ 3, "RP^2 (VT)" ], [ 645, "RP^2xS^1" ] ]
 gap&gt; rp2_6:=SCLib.Load(last[1][1]);;      
 gap&gt; rp2_6:=SC(rp2_6.Facets+10);;
 gap&gt; SCSkelEx(rp2_6,1);
 [ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 1, 5 ], [ 1, 6 ], [ 2, 3 ], [ 2, 4 ], 
   [ 2, 5 ], [ 2, 6 ], [ 3, 4 ], [ 3, 5 ], [ 3, 6 ], [ 4, 5 ], [ 4, 6 ], 
   [ 5, 6 ] ]
 gap&gt; SCSkel(rp2_6,1);  
 [ [ 11, 12 ], [ 11, 13 ], [ 11, 14 ], [ 11, 15 ], [ 11, 16 ], [ 12, 13 ], 
   [ 12, 14 ], [ 12, 15 ], [ 12, 16 ], [ 13, 14 ], [ 13, 15 ], [ 13, 16 ], 
   [ 14, 15 ], [ 14, 16 ], [ 15, 16 ] ]
 </pre></div>

<p><a id="X84ACF7D580FE8B76" name="X84ACF7D580FE8B76"></a></p>

<h5>6.9-55 SCSkelEx</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSkelEx</code>( <var class="Arg">complex</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a face list or a list of face lists upon success, <code class="keyw">fail</code> otherwise.</p>

<p>If <var class="Arg">k</var> is an integer, the <var class="Arg">k</var>-skeleton of a simplicial complex <var class="Arg">complex</var>, i. e. all <var class="Arg">k</var>-faces of <var class="Arg">complex</var>, is computed. If <var class="Arg">k</var> is a list, a list of all <var class="Arg">k</var><code class="code">[i]</code>-faces of <var class="Arg">complex</var> for each entry <var class="Arg">k</var><code class="code">[i]</code> (which has to be an integer) is returned. The faces are returned in the standard labeling.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("RP^2"); 
 [ [ 3, "RP^2 (VT)" ], [ 645, "RP^2xS^1" ] ]
 gap&gt; rp2_6:=SCLib.Load(last[1][1]);;      
 gap&gt; rp2_6:=SC(rp2_6.Facets+10);;
 gap&gt; SCSkelEx(rp2_6,1);
 [ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 1, 5 ], [ 1, 6 ], [ 2, 3 ], [ 2, 4 ], 
   [ 2, 5 ], [ 2, 6 ], [ 3, 4 ], [ 3, 5 ], [ 3, 6 ], [ 4, 5 ], [ 4, 6 ], 
   [ 5, 6 ] ]
 gap&gt; SCSkel(rp2_6,1);  
 [ [ 11, 12 ], [ 11, 13 ], [ 11, 14 ], [ 11, 15 ], [ 11, 16 ], [ 12, 13 ], 
   [ 12, 14 ], [ 12, 15 ], [ 12, 16 ], [ 13, 14 ], [ 13, 15 ], [ 13, 16 ], 
   [ 14, 15 ], [ 14, 16 ], [ 15, 16 ] ]
 </pre></div>

<p><a id="X7E770DE27938B140" name="X7E770DE27938B140"></a></p>

<h5>6.9-56 SCSpanningTree</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSpanningTree</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes a spanning tree of a connected simplicial complex <var class="Arg">complex</var> using a greedy algorithm.</p>


<div class="example"><pre>
 gap&gt; c:=SC([["a","b","c"],["a","b","d"], ["a","c","d"], ["b","c","d"]]);;
 gap&gt; s:=SCSpanningTree(c);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="spanning tree of unnamed complex 1"
  Dim=1
 
 /SimplicialComplex]
 gap&gt; s.Facets;
 [ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ] ]
 </pre></div>

<p><a id="X8284003382F863A0" name="X8284003382F863A0"></a></p>

<h4>6.10 <span class="Heading">Operations on simplicial complexes</span></h4>

<p>The following functions perform operations on simplicial complexes. Most of them return simplicial complexes. Thus, this section is closely related to the Sections <a href="chap6.html#X7F4308DB7C3699D1"><span class="RefLink">6.6</span></a> ''Generate new complexes from old''. However, the data generated here is rather seen as an intrinsic attribute of the original complex and not as an independent complex.</p>

<p><a id="X818757A17DA5CFFC" name="X818757A17DA5CFFC"></a></p>

<h5>6.10-1 SCAlexanderDual</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCAlexanderDual</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>The Alexander dual of a simplicial complex <var class="Arg">complex</var> with set of vertices <span class="SimpleMath">V</span> is the simplicial complex where any subset of <span class="SimpleMath">V</span> spans a face if and only if its complement in <span class="SimpleMath">V</span> is a non-face of <var class="Arg">complex</var>.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2],[2,3],[3,4],[4,1]]);;
 gap&gt; dual:=SCAlexanderDual(c);;
 gap&gt; dual.F;
 [ 4, 2 ]
 gap&gt; dual.IsConnected;
 false
 gap&gt; dual.Facets;
 [ [ 1, 3 ], [ 2, 4 ] ]
 </pre></div>

<p><a id="X82D22356858062D6" name="X82D22356858062D6"></a></p>

<h5>6.10-2 SCClose</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCClose</code>( <var class="Arg">complex</var>[, <var class="Arg">apex</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Closes a simplicial complex <var class="Arg">complex</var> by building a cone over its boundary. If <var class="Arg">apex</var> is specified it is assigned to the apex of the cone and the original vertex labeling of <var class="Arg">complex</var> is preserved, otherwise an arbitrary vertex label is chosen and <var class="Arg">complex</var> is returned in the standard labeling.</p>


<div class="example"><pre>
 gap&gt; s:=SCSimplex(5);;                                       
 gap&gt; b:=SCSimplex(5);;
 gap&gt; s:=SCClose(b,13);;
 gap&gt; SCIsIsomorphic(s,SCBdSimplex(6));                       
 true
 </pre></div>

<p><a id="X7CF53D8D7E0FA702" name="X7CF53D8D7E0FA702"></a></p>

<h5>6.10-3 SCCone</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCCone</code>( <var class="Arg">complex</var>, <var class="Arg">apex</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>If the second argument is passed every facet of the simplicial complex <var class="Arg">complex</var> is united with <var class="Arg">apex</var>. If not, an arbitrary vertex label <span class="SimpleMath">v</span> is used (which is not a vertex of <var class="Arg">complex</var>). In the first case the vertex labeling remains unchanged. In the second case the function returns the new complex in the standard vertex labeling from <span class="SimpleMath">1</span> to <span class="SimpleMath">n+1</span> and the apex of the cone is <span class="SimpleMath">n+1</span>.</p>

<p>If called with a facet list instead of a <code class="code">SCSimplicialComplex</code> object and <var class="Arg">apex</var> is not specified, internally falls back to the homology package <a href="chapBib.html#biBDumas04Homology">[DHSW11]</a>, if available.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("RP^3");
 [ [ 45, "RP^3" ], [ 111, "RP^3=L(2,1) (VT)" ], [ 589, "(S^2~S^1)#RP^3" ], 
   [ 590, "(S^2xS^1)#RP^3" ], [ 644, "(S^2~S^1)#2#RP^3" ], 
   [ 646, "(S^2xS^1)#2#RP^3" ], [ 2414, "RP^3#RP^3" ], 
   [ 2428, "RP^3=L(2,1) (VT)" ], [ 2488, "(S^2~S^1)#3#RP^3" ], 
   [ 2489, "(S^2xS^1)#3#RP^3" ], [ 2503, "RP^3=L(2,1) (VT)" ], 
   [ 7473, "(S^2xS^1)#4#RP^3" ], [ 7474, "(S^2~S^1)#4#RP^3" ], 
   [ 7505, "(S^2xS^1)#5#RP^3" ], [ 7507, "(S^2~S^1)#5#RP^3" ] ]
 gap&gt; rp3:=SCLib.Load(last[1][1]);;
 gap&gt; rp3.F;
 [ 11, 51, 80, 40 ]
 gap&gt; cone:=SCCone(rp3);;
 gap&gt; cone.F;
 [ 12, 62, 131, 120, 40 ]
 </pre></div>


<div class="example"><pre>
 gap&gt; s:=SCBdSimplex(4)+12;;
 gap&gt; s.Facets;             
 [ [ 13, 14, 15, 16 ], [ 13, 14, 15, 17 ], [ 13, 14, 16, 17 ], 
   [ 13, 15, 16, 17 ], [ 14, 15, 16, 17 ] ]
 gap&gt; cc:=SCCone(s,13);;    
 gap&gt; cc:=SCCone(s,12);;
 gap&gt; cc.Facets;
 [ [ 12, 13, 14, 15, 16 ], [ 12, 13, 14, 15, 17 ], [ 12, 13, 14, 16, 17 ], 
   [ 12, 13, 15, 16, 17 ], [ 12, 14, 15, 16, 17 ] ]
 </pre></div>

<p><a id="X800BDDD878DFCBDB" name="X800BDDD878DFCBDB"></a></p>

<h5>6.10-4 SCDeletedJoin</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCDeletedJoin</code>( <var class="Arg">complex1</var>, <var class="Arg">complex2</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Calculates the simplicial deleted join of the simplicial complexes <var class="Arg">complex1</var> and <var class="Arg">complex2</var>. If called with a facet list instead of a <code class="code">SCSimplicialComplex</code> object, the function internally falls back to the <strong class="pkg">homology</strong> package <a href="chapBib.html#biBDumas04Homology">[DHSW11]</a>, if available.</p>


<div class="example"><pre>
 gap&gt; deljoin:=SCDeletedJoin(SCBdSimplex(3),SCBdSimplex(3));
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="S^2_4 deljoin S^2_4"
  Dim=3
 
 /SimplicialComplex]
 gap&gt; bddeljoin:=SCBoundary(deljoin);;
 gap&gt; bddeljoin.Homology;
 [ [ 1, [  ] ], [ 0, [  ] ], [ 2, [  ] ] ]
 gap&gt; deljoin.Facets;
 [ [ [ 1, 1 ], [ 2, 1 ], [ 3, 1 ], [ 4, 2 ] ], 
   [ [ 1, 1 ], [ 2, 1 ], [ 3, 2 ], [ 4, 1 ] ], 
   [ [ 1, 1 ], [ 2, 1 ], [ 3, 2 ], [ 4, 2 ] ], 
   [ [ 1, 1 ], [ 2, 2 ], [ 3, 1 ], [ 4, 1 ] ], 
   [ [ 1, 1 ], [ 2, 2 ], [ 3, 1 ], [ 4, 2 ] ], 
   [ [ 1, 1 ], [ 2, 2 ], [ 3, 2 ], [ 4, 1 ] ], 
   [ [ 1, 1 ], [ 2, 2 ], [ 3, 2 ], [ 4, 2 ] ], 
   [ [ 1, 2 ], [ 2, 1 ], [ 3, 1 ], [ 4, 1 ] ], 
   [ [ 1, 2 ], [ 2, 1 ], [ 3, 1 ], [ 4, 2 ] ], 
   [ [ 1, 2 ], [ 2, 1 ], [ 3, 2 ], [ 4, 1 ] ], 
   [ [ 1, 2 ], [ 2, 1 ], [ 3, 2 ], [ 4, 2 ] ], 
   [ [ 1, 2 ], [ 2, 2 ], [ 3, 1 ], [ 4, 1 ] ], 
   [ [ 1, 2 ], [ 2, 2 ], [ 3, 1 ], [ 4, 2 ] ], 
   [ [ 1, 2 ], [ 2, 2 ], [ 3, 2 ], [ 4, 1 ] ] ]
 </pre></div>

<p><a id="X7FB3D29178076EB4" name="X7FB3D29178076EB4"></a></p>

<h5>6.10-5 SCDifference</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCDifference</code>( <var class="Arg">complex1</var>, <var class="Arg">complex2</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Forms the ``difference'' of two simplicial complexes <var class="Arg">complex1</var> and <var class="Arg">complex2</var> as the simplicial complex formed by the difference of the face lattices of <var class="Arg">complex1</var> minus <var class="Arg">complex2</var>. The two arguments are not altered. Note: for the difference process the vertex labelings of the complexes are taken into account, see also <code class="func">Operation Difference (SCSimplicialComplex, SCSimplicialComplex)</code> (<a href="chap5.html#X80CFABE083100541"><span class="RefLink">5.3-2</span></a>).</p>


<div class="example"><pre>
 gap&gt; c:=SCBdSimplex(3);;
 gap&gt; d:=SC([[1,2,3]]);;
 gap&gt; disc:=SCDifference(c,d);;
 gap&gt; disc.Facets;
 [ [ 1, 2, 4 ], [ 1, 3, 4 ], [ 2, 3, 4 ] ]
 gap&gt; empty:=SCDifference(d,c);;
 gap&gt; empty.Dim;
 -1
 </pre></div>

<p><a id="X7C8D11C684825ADC" name="X7C8D11C684825ADC"></a></p>

<h5>6.10-6 SCFillSphere</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCFillSphere</code>( <var class="Arg">complex</var>[, <var class="Arg">vertex</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise .</p>

<p>Fills the given simplicial sphere <var class="Arg">complex</var> by forming the suspension of the anti star of <var class="Arg">vertex</var> over <var class="Arg">vertex</var>. This is a triangulated <span class="SimpleMath">(d+1)</span>-ball with the boundary <var class="Arg">complex</var>, see <a href="chapBib.html#biBBagchi08LBTNormPseudoMnf">[BD08]</a>. If the optional argument <var class="Arg">vertex</var> is not supplied, the first vertex of <var class="Arg">complex</var> is chosen.</p>

<p>Note that it is not checked whether <var class="Arg">complex</var> really is a simplicial sphere -- this has to be done by the user!</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("S^4");
 [ [ 36, "S^4 (VT)" ], [ 37, "S^4 (VT)" ], [ 38, "S^4 (VT)" ], 
   [ 130, "S^4 (VT)" ], [ 463, "S^4~S^1 (VT)" ], [ 713, "S^4xS^1 (VT)" ], 
   [ 1472, "S^4xS^1 (VT)" ], [ 1473, "S^4xS^1 (VT)" ], 
   [ 1474, "S^4~S^1 (VT)" ], [ 1475, "S^4~S^1 (VT)" ], 
   [ 2477, "S^4~S^1 (VT)" ], [ 2478, "S^4 (VT)" ], [ 3435, "S^4 (VT)" ], 
   [ 4395, "S^4~S^1 (VT)" ], [ 4396, "S^4~S^1 (VT)" ], 
   [ 4397, "S^4~S^1 (VT)" ], [ 4398, "S^4~S^1 (VT)" ], 
   [ 4399, "S^4~S^1 (VT)" ], [ 4402, "S^4~S^1 (VT)" ], 
   [ 4403, "S^4~S^1 (VT)" ], [ 4404, "S^4~S^1 (VT)" ], [ 7478, "S^4xS^2" ], 
   [ 7541, "S^4xS^3" ], [ 7575, "S^4xS^4" ] ]
 gap&gt; s:=SCLib.Load(last[1][1]);;
 gap&gt; filled:=SCFillSphere(s);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="FilledSphere(S^4 (VT)) at vertex [ 1 ]"
  Dim=5
 
 /SimplicialComplex]
 gap&gt; SCHomology(filled);
 [ [ 0, [  ] ], [ 0, [  ] ], [ 0, [  ] ], [ 0, [  ] ], [ 0, [  ] ], 
   [ 0, [  ] ] ]
 gap&gt; SCCollapseGreedy(filled);
 [SimplicialComplex
 
  Properties known: Dim, FVector, FacetsEx, IsPure, Name, NumFaces[], 
                    SkelExs[], Vertices.
 
  Name="collapsed version of FilledSphere(S^4 (VT)) at vertex [ 1 ]"
  Dim=0
  FVector=[ 1 ]
  IsPure=true
 
 /SimplicialComplex]
 gap&gt; bd:=SCBoundary(filled);;
 gap&gt; bd=s;
 true
 </pre></div>

<p><a id="X7DCB16857D49EC37" name="X7DCB16857D49EC37"></a></p>

<h5>6.10-7 SCHandleAddition</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCHandleAddition</code>( <var class="Arg">complex</var>, <var class="Arg">f1</var>, <var class="Arg">f2</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code>, <code class="keyw">fail</code> otherwise.</p>

<p>Returns a simplicial complex obtained by identifying the vertices of facet <var class="Arg">f1</var> with the ones from facet <var class="Arg">f2</var> in <var class="Arg">complex</var>. A combinatorial handle addition is possible, whenever we have d<span class="SimpleMath">(v,w) ≥ 3</span> for any two vertices <span class="SimpleMath">v ∈</span><var class="Arg">f1</var> and <span class="SimpleMath">w ∈</span><var class="Arg">f2</var>, where d<span class="SimpleMath">(⋅,⋅)</span> is the length of the shortest path from <span class="SimpleMath">v</span> to <span class="SimpleMath">w</span>. This condition is not checked by this algorithm. See <a href="chapBib.html#biBBagchi08OnWalkupKd">[BD11]</a> for further information.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2,4],[2,4,5],[2,3,5],[3,5,6],[1,3,6],[1,4,6]]);;
 gap&gt; c:=SCUnion(c,SCUnion(SCCopy(c)+3,SCCopy(c)+6));;
 gap&gt; c:=SCUnion(c,SC([[1,2,3],[10,11,12]]));;
 gap&gt; c.Facets;
 [ [ 1, 2, 3 ], [ 1, 2, 4 ], [ 1, 3, 6 ], [ 1, 4, 6 ], [ 2, 3, 5 ], 
   [ 2, 4, 5 ], [ 3, 5, 6 ], [ 4, 5, 7 ], [ 4, 6, 9 ], [ 4, 7, 9 ], 
   [ 5, 6, 8 ], [ 5, 7, 8 ], [ 6, 8, 9 ], [ 7, 8, 10 ], [ 7, 9, 12 ], 
   [ 7, 10, 12 ], [ 8, 9, 11 ], [ 8, 10, 11 ], [ 9, 11, 12 ], [ 10, 11, 12 ] ]
 gap&gt; c.Homology;
 [ [ 0, [  ] ], [ 0, [  ] ], [ 1, [  ] ] ]
 gap&gt; torus:=SCHandleAddition(c,[1,2,3],[10,11,12]);;
 gap&gt; torus.Homology;
 [ [ 0, [  ] ], [ 2, [  ] ], [ 1, [  ] ] ]
 gap&gt; ism:=SCIsManifold(torus);;
 gap&gt; ism;
 true
 </pre></div>

<p><a id="X7B4BE2C783E6D0BF" name="X7B4BE2C783E6D0BF"></a></p>

<h5>6.10-8 SCIntersection</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIntersection</code>( <var class="Arg">complex1</var>, <var class="Arg">complex2</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Forms the ``intersection'' of two simplicial complexes <var class="Arg">complex1</var> and <var class="Arg">complex2</var> as the simplicial complex formed by the intersection of the face lattices of <var class="Arg">complex1</var> and <var class="Arg">complex2</var>. The two arguments are not altered. Note: for the intersection process the vertex labelings of the complexes are taken into account. See also <code class="func">Operation Intersection (SCSimplicialComplex, SCSimplicialComplex)</code> (<a href="chap5.html#X851CE49F7F7437C3"><span class="RefLink">5.3-3</span></a>).</p>


<div class="example"><pre>
 gap&gt; c:=SCBdSimplex(3);;        
 gap&gt; d:=SCBdSimplex(3)+1;;      
 gap&gt; d.Facets;
 [ [ 2, 3, 4 ], [ 2, 3, 5 ], [ 2, 4, 5 ], [ 3, 4, 5 ] ]
 gap&gt; c:=SCBdSimplex(3);;  
 gap&gt; d:=SCBdSimplex(3);;  
 gap&gt; d:=SCMove(d,[[1,2,3],[]])+1;;
 gap&gt; s1:=SCIntersection(c,d);;
 gap&gt; s1.Facets;               
 [ [ 2, 3 ], [ 2, 4 ], [ 3, 4 ] ]
 </pre></div>

<p><a id="X85659EC77DFF8183" name="X85659EC77DFF8183"></a></p>

<h5>6.10-9 SCIsIsomorphic</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsIsomorphic</code>( <var class="Arg">complex1</var>, <var class="Arg">complex2</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>The function returns <code class="keyw">true</code>, if the simplicial complexes <var class="Arg">complex1</var> and <var class="Arg">complex2</var> are combinatorially isomorphic, <code class="keyw">false</code> if not.</p>


<div class="example"><pre>
 gap&gt; c1:=SC([[11,12,13],[11,12,14],[11,13,14],[12,13,14]]);;
 gap&gt; c2:=SCBdSimplex(3);;
 gap&gt; SCIsIsomorphic(c1,c2);
 true
 gap&gt; c3:=SCBdCrossPolytope(3);;
 gap&gt; SCIsIsomorphic(c1,c3);
 false
 </pre></div>

<p><a id="X81D9CC438313F589" name="X81D9CC438313F589"></a></p>

<h5>6.10-10 SCIsSubcomplex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsSubcomplex</code>( <var class="Arg">sc1</var>, <var class="Arg">sc2</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns <code class="keyw">true</code> if the simplicial complex <var class="Arg">sc2</var> is a sub-complex of simplicial complex <var class="Arg">sc1</var>, <code class="keyw">false</code> otherwise. If dim(<var class="Arg">sc2</var>) <span class="SimpleMath">≤</span> dim(<var class="Arg">sc1</var>) the facets of <var class="Arg">sc2</var> are compared with the dim(<var class="Arg">sc2</var>)-skeleton of <var class="Arg">sc1</var>. Only works for pure simplicial complexes. Note: for the intersection process the vertex labelings of the complexes are taken into account.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByAttribute("F[1]=10"){[1..10]};
 [ [ 17, "K^2 (VT)" ], [ 18, "T^2 (VT)" ], [ 19, "S^3 (VT)" ], 
   [ 20, "(T^2)#2" ], [ 21, "S^2xS^1 (VT)" ], [ 22, "S^3 (VT)" ], 
   [ 23, "S^3 (VT)" ], [ 24, "(T^2)#3" ], [ 25, "(P^2)#7 (VT)" ], 
   [ 26, "S^2~S^1 (VT)" ] ]
 gap&gt; k:=SCLib.Load(last[1][1]);;
 gap&gt; c:=SCBdSimplex(9);;
 gap&gt; k.F;
 [ 10, 30, 20 ]
 gap&gt; c.F;
 [ 10, 45, 120, 210, 252, 210, 120, 45, 10 ]
 gap&gt; SCIsSubcomplex(c,k);
 true
 gap&gt; SCIsSubcomplex(k,c);
 false
 </pre></div>

<p><a id="X8623B92580E8B4E4" name="X8623B92580E8B4E4"></a></p>

<h5>6.10-11 SCIsomorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsomorphism</code>( <var class="Arg">complex1</var>, <var class="Arg">complex2</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list of pairs of vertex labels or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns an isomorphism of simplicial complex <var class="Arg">complex1</var> to simplicial complex <var class="Arg">complex2</var> in the standard labeling if they are combinatorially isomorphic, <code class="keyw">false</code> otherwise. Internally calls <code class="func">SCIsomorphismEx</code> (<a href="chap6.html#X86576B7287686E2B"><span class="RefLink">6.10-12</span></a>).</p>


<div class="example"><pre>
 gap&gt; c1:=SC([[11,12,13],[11,12,14],[11,13,14],[12,13,14]]);;
 gap&gt; c2:=SCBdSimplex(3);;
 gap&gt; SCIsomorphism(c1,c2);
 [ [ 11, 1 ], [ 12, 2 ], [ 13, 3 ], [ 14, 4 ] ]
 gap&gt; SCIsomorphismEx(c1,c2);
 [ [ [ 1, 1 ], [ 2, 2 ], [ 3, 3 ], [ 4, 4 ] ] ]
 </pre></div>

<p><a id="X86576B7287686E2B" name="X86576B7287686E2B"></a></p>

<h5>6.10-12 SCIsomorphismEx</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCIsomorphismEx</code>( <var class="Arg">complex1</var>, <var class="Arg">complex2</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list of pairs of vertex labels or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Returns an isomorphism of simplicial complex <var class="Arg">complex1</var> to simplicial complex <var class="Arg">complex2</var> in the standard labeling if they are combinatorially isomorphic, <code class="keyw">false</code> otherwise. If the <span class="SimpleMath">f</span>-vector and the Altshuler-Steinberg determinant of <var class="Arg">complex1</var> and <var class="Arg">complex2</var> are equal, the internal function <code class="code">SCIntFunc.SCComputeIsomorphismsEx(complex1,complex2,true)</code> is called.</p>


<div class="example"><pre>
 gap&gt; c1:=SC([[11,12,13],[11,12,14],[11,13,14],[12,13,14]]);;
 gap&gt; c2:=SCBdSimplex(3);;
 gap&gt; SCIsomorphism(c1,c2);
 [ [ 11, 1 ], [ 12, 2 ], [ 13, 3 ], [ 14, 4 ] ]
 gap&gt; SCIsomorphismEx(c1,c2);
 [ [ [ 1, 1 ], [ 2, 2 ], [ 3, 3 ], [ 4, 4 ] ] ]
 </pre></div>

<p><a id="X86AC8D81837CC677" name="X86AC8D81837CC677"></a></p>

<h5>6.10-13 SCJoin</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCJoin</code>( <var class="Arg">complex1</var>, <var class="Arg">complex2</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Calculates the simplicial join of the simplicial complexes <var class="Arg">complex1</var> and <var class="Arg">complex2</var>. If facet lists instead of <code class="code">SCSimplicialComplex</code> objects are passed as arguments, the function internally falls back to the homology package <a href="chapBib.html#biBDumas04Homology">[DHSW11]</a>, if available. Note that the vertex labelings of the complexes passed as arguments are not propagated to the new complex.</p>


<div class="example"><pre>
 gap&gt; sphere:=SCJoin(SCBdSimplex(2),SCBdSimplex(2));
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="S^1_3 join S^1_3"
  Dim=3
 
 /SimplicialComplex]
 gap&gt; SCHasBoundary(sphere);
 false
 gap&gt; sphere.Facets;
 [ [ [ 1, 1 ], [ 1, 2 ], [ 2, 1 ], [ 2, 2 ] ], 
   [ [ 1, 1 ], [ 1, 2 ], [ 2, 1 ], [ 2, 3 ] ], 
   [ [ 1, 1 ], [ 1, 2 ], [ 2, 2 ], [ 2, 3 ] ], 
   [ [ 1, 1 ], [ 1, 3 ], [ 2, 1 ], [ 2, 2 ] ], 
   [ [ 1, 1 ], [ 1, 3 ], [ 2, 1 ], [ 2, 3 ] ], 
   [ [ 1, 1 ], [ 1, 3 ], [ 2, 2 ], [ 2, 3 ] ], 
   [ [ 1, 2 ], [ 1, 3 ], [ 2, 1 ], [ 2, 2 ] ], 
   [ [ 1, 2 ], [ 1, 3 ], [ 2, 1 ], [ 2, 3 ] ], 
   [ [ 1, 2 ], [ 1, 3 ], [ 2, 2 ], [ 2, 3 ] ] ]
 gap&gt; sphere.Homology;
 [ [ 0, [  ] ], [ 0, [  ] ], [ 0, [  ] ], [ 1, [  ] ] ]
 </pre></div>


<div class="example"><pre>
 gap&gt; ball:=SCJoin(SC([[1]]),SCBdSimplex(2));
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="unnamed complex 4 join S^1_3"
  Dim=2
 
 /SimplicialComplex]
 gap&gt; ball.Homology;
 [ [ 0, [  ] ], [ 0, [  ] ], [ 0, [  ] ] ]
 gap&gt; ball.Facets;
 [ [ [ 1, 1 ], [ 2, 1 ], [ 2, 2 ] ], [ [ 1, 1 ], [ 2, 1 ], [ 2, 3 ] ], 
   [ [ 1, 1 ], [ 2, 2 ], [ 2, 3 ] ] ]
 </pre></div>

<p><a id="X8482E1F67C927BB7" name="X8482E1F67C927BB7"></a></p>

<h5>6.10-14 SCNeighbors</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCNeighbors</code>( <var class="Arg">complex</var>, <var class="Arg">face</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list of faces upon success, <code class="keyw">fail</code> otherwise.</p>

<p>In a simplicial complex <var class="Arg">complex</var> all neighbors of the <code class="code">k</code>-face <var class="Arg">face</var>, i. e. all <code class="code">k</code>-faces distinct from <var class="Arg">face</var> intersecting with <var class="Arg">face</var> in a common <span class="SimpleMath">(k-1)</span>-face, are returned in the original labeling.</p>


<div class="example"><pre>
 gap&gt; c:=SCFromFacets(Combinations(["a","b","c"],2));
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="unnamed complex 22"
  Dim=1
 
 /SimplicialComplex]
 gap&gt; SCNeighbors(c,["a","d"]);
 [ [ "a", "b" ], [ "a", "c" ] ]
 </pre></div>

<p><a id="X7F8FBEF17ACD0D4F" name="X7F8FBEF17ACD0D4F"></a></p>

<h5>6.10-15 SCNeighborsEx</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCNeighborsEx</code>( <var class="Arg">complex</var>, <var class="Arg">face</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list of faces upon success, <code class="keyw">fail</code> otherwise.</p>

<p>In a simplicial complex <var class="Arg">complex</var> all neighbors of the <code class="code">k</code>-face <var class="Arg">face</var>, i. e. all <code class="code">k</code>-faces distinct from <var class="Arg">face</var> intersecting with <var class="Arg">face</var> in a common <span class="SimpleMath">(k-1)</span>-face, are returned in the standard labeling.</p>


<div class="example"><pre>
 gap&gt; c:=SCFromFacets(Combinations(["a","b","c"],2));
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="unnamed complex 21"
  Dim=1
 
 /SimplicialComplex]
 gap&gt; SCLabels(c);
 [ "a", "b", "c" ]
 gap&gt; SCNeighborsEx(c,[1,2]);
 [ [ 1, 3 ], [ 2, 3 ] ]
 </pre></div>

<p><a id="X7EDA334983025D3D" name="X7EDA334983025D3D"></a></p>

<h5>6.10-16 SCShelling</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCShelling</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a facet list or <code class="keyw">false</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>The simplicial complex <var class="Arg">complex</var> must be pure, strongly connected and must fulfill the weak pseudomanifold property with non-empty boundary (cf. <code class="func">SCBoundary</code> (<a href="chap6.html#X836DC73380EA7414"><span class="RefLink">6.9-7</span></a>)).</p>

<p>An ordering <span class="SimpleMath">(F_1, F_2, ... , F_r)</span> on the facet list of a simplicial complex is a shelling if and only if <span class="SimpleMath">F_i ∩ (F_1 ∪ ... ∪ F_i-1)</span> is a pure simplicial complex of dimension <span class="SimpleMath">d-1</span> for all <span class="SimpleMath">i = 1, ... , r</span>.</p>

<p>The function checks whether <var class="Arg">complex</var> is shellable or not. In the first case a permuted version of the facet list of <var class="Arg">complex</var> is returned encoding a shelling of <var class="Arg">complex</var>, otherwise <code class="keyw">false</code> is returned.</p>

<p>Internally calls <code class="func">SCShellingExt</code> (<a href="chap6.html#X7F967A717D4E41C0"><span class="RefLink">6.10-17</span></a>)<code class="code">(complex,false,[]);</code>. To learn more about shellings see <a href="chapBib.html#biBZiegler95LectPolytopes">[Zie95]</a>, <a href="chapBib.html#biBPachner87KonstrMethKombHomeo">[Pac87]</a>.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2,3],[1,2,4],[1,3,4]]);;
 gap&gt; SCShelling(c);
 [ [ [ 1, 2, 3 ], [ 1, 2, 4 ], [ 1, 3, 4 ] ] ]
 </pre></div>

<p><a id="X7F967A717D4E41C0" name="X7F967A717D4E41C0"></a></p>

<h5>6.10-17 SCShellingExt</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCShellingExt</code>( <var class="Arg">complex</var>, <var class="Arg">all</var>, <var class="Arg">checkvector</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list of facet lists (if <var class="Arg">checkvector = []</var>) or <code class="keyw">true</code> or <code class="keyw">false</code> (if <var class="Arg">checkvector</var> is not empty), <code class="keyw">fail</code> otherwise.</p>

<p>The simplicial complex <var class="Arg">complex</var> must be pure of dimension <span class="SimpleMath">d</span>, strongly connected and must fulfill the weak pseudomanifold property with non-empty boundary (cf. <code class="func">SCBoundary</code> (<a href="chap6.html#X836DC73380EA7414"><span class="RefLink">6.9-7</span></a>)).</p>

<p>An ordering <span class="SimpleMath">(F_1, F_2, ... , F_r)</span> on the facet list of a simplicial complex is a shelling if and only if <span class="SimpleMath">F_i ∩ (F_1 ∪ ... ∪ F_i-1)</span> is a pure simplicial complex of dimension <span class="SimpleMath">d-1</span> for all <span class="SimpleMath">i = 1, ... , r</span>.</p>

<p>If <var class="Arg">all</var> is set to <code class="keyw">true</code> all possible shellings of <var class="Arg">complex</var> are computed. If <var class="Arg">all</var> is set to <code class="keyw">false</code>, at most one shelling is computed.</p>

<p>Every shelling is represented as a permuted version of the facet list of <var class="Arg">complex</var>. The list <var class="Arg">checkvector</var> encodes a shelling in a shorter form. It only contains the indices of the facets. If an order of indices is assigned to <var class="Arg">checkvector</var> the function tests whether it is a valid shelling or not.</p>

<p>See <a href="chapBib.html#biBZiegler95LectPolytopes">[Zie95]</a>, <a href="chapBib.html#biBPachner87KonstrMethKombHomeo">[Pac87]</a> to learn more about shellings.</p>


<div class="example"><pre>
 gap&gt; c:=SCBdSimplex(4);;
 gap&gt; c:=SCDifference(c,SC([c.Facets[1]]));; # bounded version
 gap&gt; all:=SCShellingExt(c,true,[]);;
 gap&gt; Size(all);                                  
 24
 gap&gt; all[1];
 [ [ 1, 2, 3, 5 ], [ 1, 2, 4, 5 ], [ 1, 3, 4, 5 ], [ 2, 3, 4, 5 ] ]
 gap&gt; all:=SCShellingExt(c,false,[]);
 [ [ [ 1, 2, 3, 5 ], [ 1, 2, 4, 5 ], [ 1, 3, 4, 5 ], [ 2, 3, 4, 5 ] ] ]
 gap&gt; all:=SCShellingExt(c,true,[1..4]);
 true
 </pre></div>

<p><a id="X8373598C7FF5D28E" name="X8373598C7FF5D28E"></a></p>

<h5>6.10-18 SCShellings</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCShellings</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: a list of facet lists upon success, <code class="keyw">fail</code> otherwise.</p>

<p>The simplicial complex <var class="Arg">complex</var> must be pure, strongly connected and must fulfill the weak pseudomanifold property with non-empty boundary (cf. <code class="func">SCBoundary</code> (<a href="chap6.html#X836DC73380EA7414"><span class="RefLink">6.9-7</span></a>)).</p>

<p>An ordering <span class="SimpleMath">(F_1, F_2, ... , F_r)</span> on the facet list of a simplicial complex is a shelling if and only if <span class="SimpleMath">F_i ∩ (F_1 ∪ ... ∪ F_i-1)</span> is a pure simplicial complex of dimension <span class="SimpleMath">d-1</span> for all <span class="SimpleMath">i = 1, ... , r</span>.</p>

<p>The function checks whether <var class="Arg">complex</var> is shellable or not. In the first case a list of permuted facet lists of <var class="Arg">complex</var> is returned containing all possible shellings of <var class="Arg">complex</var>, otherwise <code class="keyw">false</code> is returned.</p>

<p>Internally calls <code class="func">SCShellingExt</code> (<a href="chap6.html#X7F967A717D4E41C0"><span class="RefLink">6.10-17</span></a>)<code class="code">(complex,true,[]);</code>. To learn more about shellings see <a href="chapBib.html#biBZiegler95LectPolytopes">[Zie95]</a>, <a href="chapBib.html#biBPachner87KonstrMethKombHomeo">[Pac87]</a>.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2,3],[1,2,4],[1,3,4]]);;
 gap&gt; SCShellings(c);
 [ [ [ 1, 2, 3 ], [ 1, 2, 4 ], [ 1, 3, 4 ] ], 
   [ [ 1, 2, 3 ], [ 1, 3, 4 ], [ 1, 2, 4 ] ], 
   [ [ 1, 2, 4 ], [ 1, 2, 3 ], [ 1, 3, 4 ] ], 
   [ [ 1, 3, 4 ], [ 1, 2, 3 ], [ 1, 2, 4 ] ], 
   [ [ 1, 2, 4 ], [ 1, 3, 4 ], [ 1, 2, 3 ] ], 
   [ [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ] ]
 </pre></div>

<p><a id="X7987AAE481C31F38" name="X7987AAE481C31F38"></a></p>

<h5>6.10-19 SCSpan</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSpan</code>( <var class="Arg">complex</var>, <var class="Arg">subset</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Computes the reduced face lattice of all faces of a simplicial complex <var class="Arg">complex</var> that are spanned by <var class="Arg">subset</var>, a subset of the set of vertices of <var class="Arg">complex</var>.</p>


<div class="example"><pre>
 gap&gt; c:=SCBdCrossPolytope(4);;
 gap&gt; SCVertices(c);
 [ 1 .. 8 ]
 gap&gt; span:=SCSpan(c,[1,2,3,4]);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="span([ 1, 2, 3, 4 ]) in Bd(\beta^4)"
  Dim=1
 
 /SimplicialComplex]
 gap&gt; span.Facets;
 [ [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 2, 4 ] ]
 </pre></div>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2],[1,4,5],[2,3,4]]);;
 gap&gt; span:=SCSpan(c,[2,3,5]);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="span([ 2, 3, 5 ]) in unnamed complex 121"
  Dim=1
 
 /SimplicialComplex]
 gap&gt; SCFacets(span);
 [ [ 2, 3 ], [ 5 ] ]
 </pre></div>

<p><a id="X7AAA4669793C57DC" name="X7AAA4669793C57DC"></a></p>

<h5>6.10-20 SCSuspension</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSuspension</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Calculates the simplicial suspension of the simplicial complex <var class="Arg">complex</var>. Internally falls back to the homology package <a href="chapBib.html#biBDumas04Homology">[DHSW11]</a> (if available) if a facet list is passed as argument. Note that the vertex labelings of the complexes passed as arguments are not propagated to the new complex.</p>


<div class="example"><pre>
 gap&gt; SCLib.SearchByName("Poincare");
 [ [ 7468, "Poincare_sphere" ] ]
 gap&gt; phs:=SCLib.Load(last[1][1]);
 [SimplicialComplex
 
  Properties known: AltshulerSteinberg, AutomorphismGroup, 
                    AutomorphismGroupSize, AutomorphismGroupStructure, 
                    AutomorphismGroupTransitivity, ConnectedComponents, 
                    Dim, DualGraph, EulerCharacteristic, FVector, 
                    FacetsEx, GVector, GeneratorsEx, HVector, 
                    HasBoundary, HasInterior, Homology, Interior, 
                    IsCentrallySymmetric, IsConnected, 
                    IsEulerianManifold, IsManifold, IsOrientable, 
                    IsPseudoManifold, IsPure, IsStronglyConnected, 
                    MinimalNonFacesEx, Name, Neighborliness, 
                    NumFaces[], Orientation, SkelExs[], Vertices.
 
  Name="Poincare_sphere"
  Dim=3
  AltshulerSteinberg=115400413872363901952
  AutomorphismGroupSize=1
  AutomorphismGroupStructure="1"
  AutomorphismGroupTransitivity=0
  EulerCharacteristic=0
  FVector=[ 16, 106, 180, 90 ]
  GVector=[ 11, 52 ]
  HVector=[ 12, 64, 12, 1 ]
  HasBoundary=false
  HasInterior=true
  Homology=[ [ 0, [ ] ], [ 0, [ ] ], [ 0, [ ] ], [ 1, [ ] ] ]
  IsCentrallySymmetric=false
  IsConnected=true
  IsEulerianManifold=true
  IsOrientable=true
  IsPseudoManifold=true
  IsPure=true
  IsStronglyConnected=true
  Neighborliness=1
 
 /SimplicialComplex]
 gap&gt; susp:=SCSuspension(phs);;
 gap&gt; edwardsSphere:=SCSuspension(susp);
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="susp of susp of Poincare_sphere"
  Dim=5
 
 /SimplicialComplex]
 </pre></div>

<p><a id="X81DA367A813F7599" name="X81DA367A813F7599"></a></p>

<h5>6.10-21 SCUnion</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCUnion</code>( <var class="Arg">complex1</var>, <var class="Arg">complex2</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Forms the union of two simplicial complexes <var class="Arg">complex1</var> and <var class="Arg">complex2</var> as the simplicial complex formed by the union of their facets sets. The two arguments are not altered. Note: for the union process the vertex labelings of the complexes are taken into account, see also <code class="func">Operation Union (SCSimplicialComplex, SCSimplicialComplex)</code> (<a href="chap5.html#X82C94EE47E339DD8"><span class="RefLink">5.3-1</span></a>). Facets occurring in both arguments are treated as one facet in the new complex.</p>


<div class="example"><pre>
 gap&gt; c:=SCUnion(SCBdSimplex(3),SCBdSimplex(3)+3); #a wedge of two 2-spheres
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="S^2_4 cup S^2_4"
  Dim=2
 
 /SimplicialComplex]
 </pre></div>

<p><a id="X7D5639CB87A0D3F1" name="X7D5639CB87A0D3F1"></a></p>

<h5>6.10-22 SCVertexIdentification</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCVertexIdentification</code>( <var class="Arg">complex</var>, <var class="Arg">v1</var>, <var class="Arg">v2</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Identifies vertex <var class="Arg">v1</var> with vertex <var class="Arg">v2</var> in a simplicial complex <var class="Arg">complex</var> and returns the result as a new object. A vertex identification of <var class="Arg">v1</var> and <var class="Arg">v2</var> is possible whenever d(<var class="Arg">v1</var>,<var class="Arg">v2</var>) <span class="SimpleMath">≥ 3</span>. This is not checked by this algorithm.</p>


<div class="example"><pre>
 gap&gt; c:=SC([[1,2],[2,3],[3,4]]);;
 gap&gt; circle:=SCVertexIdentification(c,[1],[4]);;
 gap&gt; circle.Facets;
 [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ] ]
 gap&gt; circle.Homology;
 [ [ 0, [  ] ], [ 1, [  ] ] ]
 </pre></div>

<p><a id="X7E7B17317D1B618D" name="X7E7B17317D1B618D"></a></p>

<h5>6.10-23 SCWedge</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCWedge</code>( <var class="Arg">complex1</var>, <var class="Arg">complex2</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: simplicial complex of type <code class="code">SCSimplicialComplex</code> upon success, <code class="keyw">fail</code> otherwise.</p>

<p>Calculates the wedge product of the complexes supplied as arguments. Note that the vertex labelings of the complexes passed as arguments are not propagated to the new complex.</p>


<div class="example"><pre>
 gap&gt; wedge:=SCWedge(SCBdSimplex(2),SCBdSimplex(2));
 [SimplicialComplex
 
  Properties known: Dim, FacetsEx, Name, Vertices.
 
  Name="unnamed complex 17"
  Dim=1
 
 /SimplicialComplex]
 gap&gt; wedge.Facets;
 [ [ 1, [ 1, 2 ] ], [ 1, [ 1, 3 ] ], [ 1, [ 2, 2 ] ], [ 1, [ 2, 3 ] ], 
   [ [ 1, 2 ], [ 1, 3 ] ], [ [ 2, 2 ], [ 2, 3 ] ] ]
 </pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap5.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap7.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chap16.html">16</a>  <a href="chap17.html">17</a>  <a href="chap18.html">18</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
