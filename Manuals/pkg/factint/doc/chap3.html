<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (FactInt) - Chapter 3: The Routines for Specific Factorization Methods</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap3"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap3_mj.html">[MathJax on]</a></p>
<p><a id="X7E7EE1A1785A8009" name="X7E7EE1A1785A8009"></a></p>
<div class="ChapSects"><a href="chap3.html#X7E7EE1A1785A8009">3 <span class="Heading">The Routines for Specific Factorization Methods</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7A0392177E697956">3.1 <span class="Heading">Trial division</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7C4D255A789F54B4">3.1-1 FactorsTD</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X8081FF657DA9C674">3.2 <span class="Heading">Pollard's <span class="SimpleMath">p-1</span></span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7AF95E2E87F58200">3.2-1 FactorsPminus1</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X860B4BE37DABDE10">3.3 <span class="Heading">Williams' <span class="SimpleMath">p+1</span></span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8079A0367DE4FC35">3.3-1 FactorsPplus1</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7837106783A5194B">3.4 <span class="Heading">The Elliptic Curves Method (ECM)</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X87B162F878AD031C">3.4-1 FactorsECM</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X78466BB97BEE5495">3.5 <span class="Heading">The Continued Fraction Algorithm (CFRAC)</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7A5C8BC5861CFC8C">3.5-1 FactorsCFRAC</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7A5C621C7FCFAA8A">3.6 <span class="Heading">The Multiple Polynomial Quadratic Sieve (MPQS)</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X86F8DFB681442E05">3.6-1 FactorsMPQS</a></span>
</div></div>
</div>

<h3>3 <span class="Heading">The Routines for Specific Factorization Methods</span></h3>

<p>Descriptions of the factoring methods implemented in this package can be found in <a href="chapBib.html#biBBressoud89">[Bre89]</a> and <a href="chapBib.html#biBCohen93">[Coh93]</a>. Cohen's book contains also descriptions of the other methods mentioned in the preface.</p>

<p><a id="X7A0392177E697956" name="X7A0392177E697956"></a></p>

<h4>3.1 <span class="Heading">Trial division</span></h4>

<p><a id="X7C4D255A789F54B4" name="X7C4D255A789F54B4"></a></p>

<h5>3.1-1 FactorsTD</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FactorsTD</code>( <var class="Arg">n</var>[, <var class="Arg">Divisors</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a list of two lists: The first list contains the prime factors found, and the second list contains remaining unfactored parts of <var class="Arg">n</var>, if there are any.</p>

<p>This function tries to factor <var class="Arg">n</var> by trial division. The optional argument <var class="Arg">Divisors</var> is the list of trial divisors. If not given, it defaults to the list of primes <span class="SimpleMath">p &lt; 1000</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FactorsTD(12^25+25^12);</span>
[ [ 13, 19, 727 ], [ 5312510324723614735153 ] ]

</pre></div>

<p><a id="X8081FF657DA9C674" name="X8081FF657DA9C674"></a></p>

<h4>3.2 <span class="Heading">Pollard's <span class="SimpleMath">p-1</span></span></h4>

<p><a id="X7AF95E2E87F58200" name="X7AF95E2E87F58200"></a></p>

<h5>3.2-1 FactorsPminus1</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FactorsPminus1</code>( <var class="Arg">n</var>[[, <var class="Arg">a</var>], <var class="Arg">Limit1</var>[, <var class="Arg">Limit2</var>]] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a list of two lists: The first list contains the prime factors found, and the second list contains remaining unfactored parts of <var class="Arg">n</var>, if there are any.</p>

<p>This function tries to factor <var class="Arg">n</var> using Pollard's <span class="SimpleMath">p-1</span>. It uses <var class="Arg">a</var> as base for exponentiation, <var class="Arg">Limit1</var> as first stage limit and <var class="Arg">Limit2</var> as second stage limit. If the function is called with three arguments, these arguments are interpreted as <var class="Arg">n</var>, <var class="Arg">Limit1</var> and <var class="Arg">Limit2</var>. Defaults are chosen for all arguments which are omitted.</p>

<p>Pollard's <span class="SimpleMath">p-1</span> is based on the fact that exponentiation (mod <span class="SimpleMath">n</span>) can be done efficiently enough to compute <span class="SimpleMath">a^k!</span> mod <span class="SimpleMath">n</span> for sufficiently large <span class="SimpleMath">k</span> in a reasonable amount of time. Assume that <span class="SimpleMath">p</span> is a prime factor of <span class="SimpleMath">n</span> which does not divide <span class="SimpleMath">a</span>, and that <span class="SimpleMath">k!</span> is a multiple of <span class="SimpleMath">p-1</span>. Then Lagrange's Theorem states that <span class="SimpleMath">a^k! ≡ 1</span> (mod <span class="SimpleMath">p</span>). If <span class="SimpleMath">k!</span> is not a multiple of <span class="SimpleMath">q-1</span> for another prime factor <span class="SimpleMath">q</span> of <span class="SimpleMath">n</span>, it is likely that the factor <span class="SimpleMath">p</span> can be determined by computing <span class="SimpleMath">gcd(a^k!-1,n)</span>. A prime factor <span class="SimpleMath">p</span> is usually found if the largest prime factor of <span class="SimpleMath">p-1</span> is not larger than <var class="Arg">Limit2</var>, and the second-largest one is not larger than <var class="Arg">Limit1</var>. (Compare with <code class="func">FactorsPplus1</code> (<a href="chap3.html#X8079A0367DE4FC35"><span class="RefLink">3.3-1</span></a>) and <code class="func">FactorsECM</code> (<a href="chap3.html#X87B162F878AD031C"><span class="RefLink">3.4-1</span></a>).)</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FactorsPminus1( Factorial(158) + 1, 100000, 1000000 );</span>
[ [ 2879, 5227, 1452486383317, 9561906969931, 18331561438319, 
      4837142997094837608115811103417329505064932181226548534006749213\
4508231090637045229565481657130504121732305287984292482612133314325471\
3674832962773107806789945715570386038565256719614524924705165110048148\
7161609649806290811760570095669 ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( last[ 1 ]{[ 3, 4, 5 ]}, p -&gt; Factors( p - 1 ) );</span>
[ [ 2, 2, 3, 3, 81937, 492413 ], [ 2, 3, 3, 3, 5, 7, 7, 1481, 488011 ]
    , [ 2, 3001, 7643, 399613 ] ]

</pre></div>

<p><a id="X860B4BE37DABDE10" name="X860B4BE37DABDE10"></a></p>

<h4>3.3 <span class="Heading">Williams' <span class="SimpleMath">p+1</span></span></h4>

<p><a id="X8079A0367DE4FC35" name="X8079A0367DE4FC35"></a></p>

<h5>3.3-1 FactorsPplus1</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FactorsPplus1</code>( <var class="Arg">n</var>[[, <var class="Arg">Residues</var>], <var class="Arg">Limit1</var>[, <var class="Arg">Limit2</var>]] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a list of two lists: The first list contains the prime factors found, and the second list contains remaining unfactored parts of <var class="Arg">n</var>, if there are any.</p>

<p>This function tries to factor <var class="Arg">n</var> using Williams' <span class="SimpleMath">p+1</span>. It tries <var class="Arg">Residues</var> different residues, and uses <var class="Arg">Limit1</var> as first stage limit and <var class="Arg">Limit2</var> as second stage limit. If the function is called with three arguments, these arguments are interpreted as <var class="Arg">n</var>, <var class="Arg">Limit1</var> and <var class="Arg">Limit2</var>. Defaults are chosen for all arguments which are omitted.</p>

<p>Williams' <span class="SimpleMath">p+1</span> is very similar to Pollard's <span class="SimpleMath">p-1</span> (see <code class="func">FactorsPminus1</code> (<a href="chap3.html#X7AF95E2E87F58200"><span class="RefLink">3.2-1</span></a>)). The difference is that the underlying group here can either have order <span class="SimpleMath">p+1</span> or <span class="SimpleMath">p-1</span>, and that the group operation takes more time. A prime factor <span class="SimpleMath">p</span> is usually found if the largest prime factor of the group order is at most <var class="Arg">Limit2</var> and the second-largest one is not larger than <var class="Arg">Limit1</var>. (Compare also with <code class="func">FactorsECM</code> (<a href="chap3.html#X87B162F878AD031C"><span class="RefLink">3.4-1</span></a>).)</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FactorsPplus1( Factorial(55) - 1, 10, 10000, 100000 );</span>
[ [ 73, 39619, 277914269, 148257413069 ], 
  [ 106543529120049954955085076634537262459718863957 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( last[ 1 ], p -&gt; [ Factors( p - 1 ), Factors( p + 1 ) ] );</span>
[ [ [ 2, 2, 2, 3, 3 ], [ 2, 37 ] ], 
  [ [ 2, 3, 3, 31, 71 ], [ 2, 2, 5, 7, 283 ] ], 
  [ [ 2, 2, 2207, 31481 ], [ 2, 3, 5, 9263809 ] ], 
  [ [ 2, 2, 47, 788603261 ], [ 2, 3, 5, 13, 37, 67, 89, 1723 ] ] ]

</pre></div>

<p><a id="X7837106783A5194B" name="X7837106783A5194B"></a></p>

<h4>3.4 <span class="Heading">The Elliptic Curves Method (ECM)</span></h4>

<p><a id="X87B162F878AD031C" name="X87B162F878AD031C"></a></p>

<h5>3.4-1 FactorsECM</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FactorsECM</code>( <var class="Arg">n</var>[, <var class="Arg">Curves</var>[, <var class="Arg">Limit1</var>[, <var class="Arg">Limit2</var>[, <var class="Arg">Delta</var>]]]] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ECM</code>( <var class="Arg">n</var>[, <var class="Arg">Curves</var>[, <var class="Arg">Limit1</var>[, <var class="Arg">Limit2</var>[, <var class="Arg">Delta</var>]]]] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a list of two lists: The first list contains the prime factors found, and the second list contains remaining unfactored parts of <var class="Arg">n</var>, if there are any.</p>

<p>This function tries to factor <var class="Arg">n</var> using the Elliptic Curves Method (ECM). The argument <var class="Arg">Curves</var> is the number of curves to be tried. The argument <var class="Arg">Limit1</var> is the initial first stage limit, and <var class="Arg">Limit2</var> is the initial second stage limit. The argument <var class="Arg">Delta</var> is the increment per curve for the first stage limit. The second stage limit is adjusted appropriately. Defaults are chosen for all arguments which are omitted.</p>

<p><code class="code">FactorsECM</code> recognizes the option <var class="Arg">ECMDeterministic</var>. If set, the choice of the curves is deterministic. This means that in repeated runs of <code class="code">FactorsECM</code> the same curves are used, and hence for the same <span class="SimpleMath">n</span> the same factors are found after the same number of trials.</p>

<p>The Elliptic Curves Method is based on the fact that exponentiation in the elliptic curve groups <span class="SimpleMath">E(a,b)/n</span> can be performed fast enough to compute for example <span class="SimpleMath">g^k!</span> for <span class="SimpleMath">k</span> large enough (e.g. 100000 or so) in a reasonable amount of time and without using much memory, and on Lagrange's Theorem. Assume that <span class="SimpleMath">p</span> is a prime divisor of <span class="SimpleMath">n</span>. Then Lagrange's Theorem states that if <span class="SimpleMath">k!</span> is a multiple of <span class="SimpleMath">|E(a,b)/p|</span>, then for any elliptic curve point <span class="SimpleMath">g</span>, the power <span class="SimpleMath">g^k!</span> is the identity element of <span class="SimpleMath">E(a,b)/p</span>. In this situation -- under reasonable circumstances -- the factor <span class="SimpleMath">p</span> can be determined by taking an appropriate gcd.</p>

<p>In practice, the algorithm chooses in some sense "better" products <span class="SimpleMath">P_k</span> of small primes rather than <span class="SimpleMath">k!</span> as exponents. After reaching the first stage limit with <span class="SimpleMath">P_Limit1</span>, it considers further products <span class="SimpleMath">P_Limit1q</span> for primes <span class="SimpleMath">q</span> up to the second stage limit <var class="Arg">Limit2</var>, which is usually set equal to something like 100 times the first stage limit. The prime <span class="SimpleMath">q</span> corresponds to the largest prime factor of the order of the group <span class="SimpleMath">E(a,b)/p</span>.</p>

<p>A prime divisor <span class="SimpleMath">p</span> is usually found if the largest prime factor of the order of one of the examined elliptic curve groups <span class="SimpleMath">E(a,b)/p</span> is at most <var class="Arg">Limit2</var> and the second-largest one is at most <var class="Arg">Limit1</var>. Thus trying a larger number of curves increases the chance of factoring <var class="Arg">n</var> as well as choosing a larger value for <var class="Arg">Limit1</var> and/or <var class="Arg">Limit2</var>. It turns out to be not optimal either to try a large number of curves with very small <var class="Arg">Limit1</var> and <var class="Arg">Limit2</var> or to try only a few curves with very large limits. (Compare with <code class="func">FactorsPminus1</code> (<a href="chap3.html#X7AF95E2E87F58200"><span class="RefLink">3.2-1</span></a>).)</p>

<p>The elements of the group <span class="SimpleMath">E(a,b)/n</span> are the points <span class="SimpleMath">(x,y)</span> given by the solutions of <span class="SimpleMath">y^2 = x^3 + ax + by</span> in the residue class ring (mod <span class="SimpleMath">n</span>), and an additional point <span class="SimpleMath">∞</span> at infinity, which serves as identity element. To turn this set into a group, define the product (although elliptic curve groups are usually written additively, I prefer using the multiplicative notation here to retain the analogy to <code class="func">FactorsPminus1</code> (<a href="chap3.html#X7AF95E2E87F58200"><span class="RefLink">3.2-1</span></a>) and <code class="func">FactorsPplus1</code> (<a href="chap3.html#X8079A0367DE4FC35"><span class="RefLink">3.3-1</span></a>)) of two points <span class="SimpleMath">p_1</span> and <span class="SimpleMath">p_2</span> as follows: If <span class="SimpleMath">p_1 ≠ p_2</span>, let <span class="SimpleMath">l</span> be the line through <span class="SimpleMath">p_1</span> and <span class="SimpleMath">p_2</span>, otherwise let <span class="SimpleMath">l</span> be the tangent to the curve <span class="SimpleMath">C</span> given by the above equation in the point <span class="SimpleMath">p_1 = p_2</span>. The line <span class="SimpleMath">l</span> intersects <span class="SimpleMath">C</span> in a third point, say <span class="SimpleMath">p_3</span>. If <span class="SimpleMath">l</span> does not intersect the curve in a third affine point, then set <span class="SimpleMath">p_3 := ∞</span>. Define <span class="SimpleMath">p_1 ⋅ p_2</span> by the image of <span class="SimpleMath">p_3</span> under the reflection across the <span class="SimpleMath">x</span>-axis. Define the product of any curve point <span class="SimpleMath">p</span> and <span class="SimpleMath">∞</span> by <span class="SimpleMath">p</span> itself. This -- more or less obviously, checking associativity requires some calculation -- turns the set of points on the given curve into an abelian group <span class="SimpleMath">E(a,b)/n</span>.</p>

<p>However, the calculations are done in projective coordinates to have an explicit representation of the identity element and to avoid calculating inverses (mod <span class="SimpleMath">n</span>) for the group operation. Otherwise this would require using an <span class="SimpleMath">O((log n)^3)</span>-algorithm, while multiplication (mod <span class="SimpleMath">n</span>) is only <span class="SimpleMath">O((log n)^2)</span>. The corresponding equation is given by <span class="SimpleMath">bY^2Z = X^3 + aX^2Z + XZ^2</span>. This form allows even more efficient computations than the Weierstrass model <span class="SimpleMath">Y^2Z = X^3 + aXZ^2 + bZ^3</span>, which is the projective equivalent of the affine representation <span class="SimpleMath">y^2 = x^3 + ax + by</span> mentioned above. The algorithm only keeps track of two of the three coordinates, namely <span class="SimpleMath">X</span> and <span class="SimpleMath">Z</span>. The curves are chosen in a way that ensures the order of the corresponding group to be divisible by 12. This increases the chance that it is smooth enough to find a factor of <span class="SimpleMath">n</span>. The implementation follows the description of R. P. Brent given in <a href="chapBib.html#biBBrent96">[Bre96]</a>, pp. 5 -- 8. In terms of this paper, for the second stage the "improved standard continuation" is used.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FactorsECM(2^256+1,100,10000,1000000,100);</span>
[ [ 1238926361552897, 
      93461639715357977769163558199606896584051237541638188580280321 ]
    , [  ] ]

</pre></div>

<p><a id="X78466BB97BEE5495" name="X78466BB97BEE5495"></a></p>

<h4>3.5 <span class="Heading">The Continued Fraction Algorithm (CFRAC)</span></h4>

<p><a id="X7A5C8BC5861CFC8C" name="X7A5C8BC5861CFC8C"></a></p>

<h5>3.5-1 FactorsCFRAC</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FactorsCFRAC</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CFRAC</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a list of the prime factors of <var class="Arg">n</var>.</p>

<p>This function tries to factor <var class="Arg">n</var> using the Continued Fraction Algorithm (CFRAC), also known as Brillhart-Morrison Algorithm. In case of failure an error is signalled.</p>

<p>Caution: The run time of this function depends only on the size of <var class="Arg">n</var>, and not on the size of the factors. Thus if a small factor is not found during the preprocessing which is done before invoking the sieving process, the run time is as long as if <var class="Arg">n</var> would have two prime factors of roughly equal size.</p>

<p>The Continued Fraction Algorithm tries to find integers <span class="SimpleMath">x</span> and <span class="SimpleMath">y</span> such that <span class="SimpleMath">x^2 ≡ y^2</span> (mod <span class="SimpleMath">n</span>), but not <span class="SimpleMath">± x ≡ ± y</span> (mod <span class="SimpleMath">n</span>). In this situation, taking <span class="SimpleMath">gcd(x - y,n)</span> yields a nontrivial divisor of <span class="SimpleMath">n</span>. For determining such a pair <span class="SimpleMath">(x,y)</span>, the algorithm uses the continued fraction expansion of the square root of <span class="SimpleMath">n</span>. If <span class="SimpleMath">x_i/y_i</span> is a continued fraction approximation of the square root of <span class="SimpleMath">n</span>, then <span class="SimpleMath">c_i := x_i^2 - ny_i^2</span> is bounded by a small constant times the square root of <span class="SimpleMath">n</span>. The algorithm tries to find as many <span class="SimpleMath">c_i</span> as possible which factor completely over a chosen factor base (a list of small primes) or with only one factor not in the factor base. The latter ones can be used if and only if a second <span class="SimpleMath">c_i</span> with the same "large" factor is found. Once enough values <span class="SimpleMath">c_i</span> have been factored, as a final stage Gaussian Elimination over GF(2) is used to determine which of the congruences <span class="SimpleMath">x_i^2 ≡ c_i</span> (mod <span class="SimpleMath">n</span>) have to be multiplied together to obtain a congruence of the desired form <span class="SimpleMath">x^2 ≡ y^2</span> (mod <span class="SimpleMath">n</span>). Let <span class="SimpleMath">M</span> be the corresponding matrix. Then the entries of <span class="SimpleMath">M</span> are given by <span class="SimpleMath">M_ij = 1</span> if an odd power of the <span class="SimpleMath">j</span>-th element of the factor base divides the <span class="SimpleMath">i</span>-th usable factored value, and <span class="SimpleMath">M_ij = 0</span> otherwise. To obtain the desired congruence, it is necessary that the rows of <span class="SimpleMath">M</span> are linearly dependent. In other words, this means that the number of factored <span class="SimpleMath">c_i</span> needs to be larger than the rank of <span class="SimpleMath">M</span>, which is approximately given by the size of the factor base. (Compare with <code class="func">FactorsMPQS</code> (<a href="chap3.html#X86F8DFB681442E05"><span class="RefLink">3.6-1</span></a>).)</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FactorsCFRAC( Factorial(34) - 1 );</span>
[ 10398560889846739639, 28391697867333973241 ]

</pre></div>

<p><a id="X7A5C621C7FCFAA8A" name="X7A5C621C7FCFAA8A"></a></p>

<h4>3.6 <span class="Heading">The Multiple Polynomial Quadratic Sieve (MPQS)</span></h4>

<p><a id="X86F8DFB681442E05" name="X86F8DFB681442E05"></a></p>

<h5>3.6-1 FactorsMPQS</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FactorsMPQS</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MPQS</code>( <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a list of the prime factors of <var class="Arg">n</var>.</p>

<p>This function tries to factor <var class="Arg">n</var> using the Single Large Prime Variation of the Multiple Polynomial Quadratic Sieve (MPQS). In case of failure an error is signalled.</p>

<p>Caution: The run time of this function depends only on the size of <var class="Arg">n</var>, and not on the size of the factors. Thus if a small factor is not found during the preprocessing which is done before invoking the sieving process, the run time is as long as if <var class="Arg">n</var> would have two prime factors of roughly equal size.</p>

<p>The intermediate results of a computation can be saved by interrupting it with <code class="code">[Ctrl][C]</code> and calling <code class="code">Pause();</code> from the break loop. This causes all data needed for resuming the computation again to be pushed as a record <var class="Arg">MPQSTmp</var> on the options stack. When called again with the same argument <var class="Arg">n</var>, <code class="code">FactorsMPQS</code> takes the record from the options stack and continues with the previously computed factorization data. For continuing the factorization process in another session, one needs to write this record to a file. This can be done by the function <code class="code">SaveMPQSTmp(<var class="Arg">filename</var>)</code>. The file written by this function can be read by the standard <code class="code">Read</code>-function of <strong class="pkg">GAP</strong>.</p>

<p>The Multiple Polynomial Quadratic Sieve tries to find integers <span class="SimpleMath">x</span> and <span class="SimpleMath">y</span> such that <span class="SimpleMath">x^2 ≡ y^2</span> (mod <span class="SimpleMath">n</span>), but not <span class="SimpleMath">± x ≡ ± y</span> (mod <span class="SimpleMath">n</span>). In this situation, taking <span class="SimpleMath">gcd(x - y,n)</span> yields a nontrivial divisor of <span class="SimpleMath">n</span>. For determining such a pair <span class="SimpleMath">(x,y)</span>, the algorithm chooses polynomials <span class="SimpleMath">f_a</span> of the form <span class="SimpleMath">f_a(r) = ar^2 + 2br + c</span> with suitably chosen coefficients <span class="SimpleMath">a</span>, <span class="SimpleMath">b</span> and <span class="SimpleMath">c</span> which satisfy <span class="SimpleMath">b^2 ≡ n</span> (mod <span class="SimpleMath">a</span>) and <span class="SimpleMath">c = (b^2 - n)/a</span>. The identity <span class="SimpleMath">a ⋅ f_a(r) = (ar + b)^2 - n</span> yields a congruence (mod <span class="SimpleMath">n</span>) with a perfect square on one side and <span class="SimpleMath">a ⋅ f_a(r)</span> on the other. The algorithm uses a sieving technique similar to the Sieve of Eratosthenes over an appropriately chosen sieving interval to search for factorizations of values <span class="SimpleMath">f_a(r)</span> over a chosen factor base. Any two factorizations with the same single "large" factor which does not belong to the factor base can also be used. Taking more polynomials and hence shorter sieving intervals has the advantage of having to factor smaller values <span class="SimpleMath">f_a(r)</span> over the factor base.</p>

<p>Once enough values <span class="SimpleMath">f_a(r)</span> have been factored, as a final stage Gaussian Elimination over GF(2) is used to determine which congruences have to be multiplied together to obtain a congruence of the desired form <span class="SimpleMath">x^2 ≡ y^2</span> (mod <span class="SimpleMath">n</span>). Let <span class="SimpleMath">M</span> be the corresponding matrix. Then the entries of <span class="SimpleMath">M</span> are given by <span class="SimpleMath">M_ij = 1</span> if an odd power of the <span class="SimpleMath">j</span>-th element of the factor base divides the <span class="SimpleMath">i</span>-th usable factored value, and <span class="SimpleMath">M_ij = 0</span> otherwise. To obtain the desired congruence, it is necessary that the rows of <span class="SimpleMath">M</span> are linearly dependent. In other words, this means that the number of usable factorizations of values <span class="SimpleMath">f_a(r)</span> needs to be larger than the rank of <span class="SimpleMath">M</span>. The latter is approximately equal to the size of the factor base. (Compare with <code class="func">FactorsCFRAC</code> (<a href="chap3.html#X7A5C8BC5861CFC8C"><span class="RefLink">3.5-1</span></a>).)</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FactorsMPQS( Factorial(38) + 1 );</span>
[ 14029308060317546154181, 37280713718589679646221 ]

</pre></div>

<p> </p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
