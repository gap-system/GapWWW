<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (AtlasRep) - Chapter 2: Tutorial for the AtlasRep Package</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap2"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap2.html">[MathJax off]</a></p>
<p><a id="X8171B3798425E183" name="X8171B3798425E183"></a></p>
<div class="ChapSects"><a href="chap2_mj.html#X8171B3798425E183">2 <span class="Heading">Tutorial for the <strong class="pkg">AtlasRep</strong> Package</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X79CECBFE7A8EE2C2">2.1 <span class="Heading">Accessing a Specific Group in <strong class="pkg">AtlasRep</strong></span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X87CD0FFB87D0BDD7">2.1-1 <span class="Heading">Accessing a Group in <strong class="pkg">AtlasRep</strong> via its Name</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X826C681B7EB3B67A">2.1-2 <span class="Heading">Accessing a Maximal Subgroup of a Group in <strong class="pkg">AtlasRep</strong></span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X7F616D9685292471">2.2 <span class="Heading">Accessing Specific Generators in <strong class="pkg">AtlasRep</strong></span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X7D3A29F879B140D3">2.3 <span class="Heading">Basic Concepts used in <strong class="pkg">AtlasRep</strong></span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7E2FB5E5852AD970">2.3-1 <span class="Heading">Groups, Generators, and Representations</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7DC99E4284093FBB">2.3-2 <span class="Heading">Straight Line Programs</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X87ACE06E82B68589">2.4 <span class="Heading">Examples of Using the <strong class="pkg">AtlasRep</strong> Package</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X8563D96878AC685C">2.4-1 <span class="Heading">Example: Class Representatives</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X81C9233778A3A817">2.4-2 <span class="Heading">Example: Permutation and Matrix Representations</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X8284D7E87D38889C">2.4-3 <span class="Heading">Example: Outer Automorphisms</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X794D669E7A507310">2.4-4 <span class="Heading">Example: Using Semi-presentations and Black Box Programs</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7CE7C2068017525C">2.4-5 <span class="Heading">Example: Using the <strong class="pkg">GAP</strong> Library of Tables of Marks</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X82550A9683E0DCA2">2.4-6 <span class="Heading">Example: Index <span class="SimpleMath">\(770\)</span> Subgroups in <span class="SimpleMath">\(M_{22}\)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X84F9D163795B7DE1">2.4-7 <span class="Heading">Example: Index <span class="SimpleMath">\(462\)</span> Subgroups in <span class="SimpleMath">\(M_{22}\)</span></span></a>
</span>
</div></div>
</div>

<h3>2 <span class="Heading">Tutorial for the <strong class="pkg">AtlasRep</strong> Package</span></h3>

<p>This chapter gives an overview of the basic functionality provided by the <strong class="pkg">AtlasRep</strong> package. The main concepts and interface functions are presented in the first three sections, and Section <a href="chap2_mj.html#X87ACE06E82B68589"><span class="RefLink">2.4</span></a> shows a few small examples.</p>

<p>Let us first fix the setup for the examples shown in the package manual.</p>

<ol>
<li><p>First of all, we load the <strong class="pkg">AtlasRep</strong> package. Some of the examples require also the <strong class="pkg">GAP</strong> packages <strong class="pkg">CTblLib</strong> and <strong class="pkg">TomLib</strong>, so we load also these packages.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "AtlasRep", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "CTblLib", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "TomLib", false );</span>
true
</pre></div>

</li>
<li><p>Depending on the terminal capabilities, the output of <code class="func">DisplayAtlasInfo</code> (<a href="chap3_mj.html#X79DACFFA7E2D1A99"><span class="RefLink">3.5-1</span></a>) may contain non-ASCII characters, which are not supported by the LaTeX and HTML versions of <strong class="pkg">GAPDoc</strong> documents. The examples in this manual are used for tests of the package's functionality, thus we set the user preference <code class="code">DisplayFunction</code> (see Section <a href="chap4_mj.html#X81F055037F9D3068"><span class="RefLink">4.2-12</span></a>) to the value <code class="code">"Print"</code> in order to produce output consisting only of ASCII characters, which is assumed to work in any terminal.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">origpref:= UserPreference( "AtlasRep", "DisplayFunction" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetUserPreference( "AtlasRep", "DisplayFunction", "Print" );</span>
</pre></div>

</li>
<li><p>The <strong class="pkg">GAP</strong> output for the examples may look differently if data extensions have been loaded. In order to ignore these extensions in the examples, we unload them.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">priv:= Difference(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    List( AtlasOfGroupRepresentationsInfo.notified, x -&gt; x.ID ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [ "core", "internal" ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Perform( priv, AtlasOfGroupRepresentationsForgetData );</span>
</pre></div>

</li>
<li><p>If the info level of <code class="func">InfoAtlasRep</code> (<a href="chap7_mj.html#X8006BE167EB81E16"><span class="RefLink">7.1-1</span></a>) is larger than zero then additional output appears on the screen. In order to avoid this output, we set the level to zero.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">globallevel:= InfoLevel( InfoAtlasRep );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetInfoLevel( InfoAtlasRep, 0 );</span>
</pre></div>

</li>
</ol>
<p><a id="X79CECBFE7A8EE2C2" name="X79CECBFE7A8EE2C2"></a></p>

<h4>2.1 <span class="Heading">Accessing a Specific Group in <strong class="pkg">AtlasRep</strong></span></h4>

<p>An important database to which the <strong class="pkg">AtlasRep</strong> package gives access is the <strong class="pkg">ATLAS</strong> of Group Representations <a href="chapBib_mj.html#biBAGRv3">[WWT+]</a>. It contains generators and related data for several groups, mainly for extensions of simple groups (see Section <a href="chap2_mj.html#X87CD0FFB87D0BDD7"><span class="RefLink">2.1-1</span></a>) and for their maximal subgroups (see Section <a href="chap2_mj.html#X826C681B7EB3B67A"><span class="RefLink">2.1-2</span></a>).</p>

<p>In general, these data are not part of the package. They are downloaded as soon as they are needed for the first time, see Section <a href="chap4_mj.html#X7C3293A98577EE68"><span class="RefLink">4.2-1</span></a>.</p>

<p><a id="X87CD0FFB87D0BDD7" name="X87CD0FFB87D0BDD7"></a></p>

<h5>2.1-1 <span class="Heading">Accessing a Group in <strong class="pkg">AtlasRep</strong> via its Name</span></h5>

<p>Each group that occurs in this database is specified by a <em>name</em>, which is a string similar to the name used in the <strong class="pkg">ATLAS</strong> of Finite Groups <a href="chapBib_mj.html#biBCCN85">[CCN+85]</a>. For those groups whose character tables are contained in the <strong class="pkg">GAP</strong> Character Table Library <a href="chapBib_mj.html#biBCTblLib">[Bre13]</a>, the names are equal to the <code class="func">Identifier</code> (<a href="../../../doc/ref/chap71_mj.html#X79C40EE97890202F"><span class="RefLink">Reference: Identifier for character tables</span></a>) values of these character tables. Examples of such names are <code class="code">"M24"</code> for the Mathieu group <span class="SimpleMath">\(M_{24}\)</span>, <code class="code">"2.A6"</code> for the double cover of the alternating group <span class="SimpleMath">\(A_6\)</span>, and <code class="code">"2.A6.2_1"</code> for the double cover of the symmetric group <span class="SimpleMath">\(S_6\)</span>. The names that actually occur are listed in the first column of the overview table that is printed by the function <code class="func">DisplayAtlasInfo</code> (<a href="chap3_mj.html#X79DACFFA7E2D1A99"><span class="RefLink">3.5-1</span></a>), called without arguments, see below. The other columns of the table describe the data that are available in the database.</p>

<p>For example, <code class="func">DisplayAtlasInfo</code> (<a href="chap3_mj.html#X79DACFFA7E2D1A99"><span class="RefLink">3.5-1</span></a>) may print the following lines. Omissions are indicated with "<code class="code">...</code>".</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DisplayAtlasInfo();</span>
group                    |  # | maxes | cl | cyc | out | fnd | chk | prs
-------------------------+----+-------+----+-----+-----+-----+-----+----
...
2.A5                     | 26 |     3 |    |     |     |     |  +  |  + 
2.A5.2                   | 11 |     4 |    |     |     |     |  +  |  + 
2.A6                     | 18 |     5 |    |     |     |     |     |    
2.A6.2_1                 |  3 |     6 |    |     |     |     |     |    
2.A7                     | 24 |     2 |    |     |     |     |     |    
2.A7.2                   |  7 |       |    |     |     |     |     |    
...
M22                      | 58 |     8 |  + |  +  |     |  +  |  +  |  + 
M22.2                    | 46 |     7 |  + |  +  |     |  +  |  +  |  + 
M23                      | 66 |     7 |  + |  +  |     |  +  |  +  |  + 
M24                      | 62 |     9 |  + |  +  |     |  +  |  +  |  + 
McL                      | 46 |    12 |  + |  +  |     |  +  |  +  |  + 
McL.2                    | 27 |    10 |    |  +  |     |  +  |  +  |  + 
O7(3)                    | 28 |       |    |     |     |     |     |    
O7(3).2                  |  3 |       |    |     |     |     |     |    
...
Suz                      | 30 |    17 |    |  +  |   2 |  +  |  +  |    
...
</pre></div>

<p>Called with a group name as the only argument, the function <code class="func">AtlasGroup</code> (<a href="chap3_mj.html#X80AABEE783363B70"><span class="RefLink">3.5-8</span></a>) returns a group isomorphic to the group with the given name, or <code class="keyw">fail</code>. If permutation generators are available in the database then a permutation group (of smallest available degree) is returned, otherwise a matrix group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= AtlasGroup( "M24" );</span>
Group([ (1,4)(2,7)(3,17)(5,13)(6,9)(8,15)(10,19)(11,18)(12,21)(14,16)
  (20,24)(22,23), (1,4,6)(2,21,14)(3,9,15)(5,18,10)(13,17,16)
  (19,24,23) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPermGroup( g );  NrMovedPoints( g );  Size( g );</span>
true
24
244823040
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AtlasGroup( "J5" );</span>
fail
</pre></div>

<p><a id="X826C681B7EB3B67A" name="X826C681B7EB3B67A"></a></p>

<h5>2.1-2 <span class="Heading">Accessing a Maximal Subgroup of a Group in <strong class="pkg">AtlasRep</strong></span></h5>

<p>Many maximal subgroups of extensions of simple groups can be constructed using the function <code class="func">AtlasSubgroup</code> (<a href="chap3_mj.html#X7A3E460C82B3D9A3"><span class="RefLink">3.5-9</span></a>). Given the name of the extension of the simple group and the number of the conjugacy class of maximal subgroups, this function returns a representative from this class.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= AtlasSubgroup( "M24", 1 );</span>
Group([ (2,10)(3,12)(4,14)(6,9)(8,16)(15,18)(20,22)(21,24), (1,7,2,9)
  (3,22,10,23)(4,19,8,12)(5,14)(6,18)(13,16,17,24) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPermGroup( g );  NrMovedPoints( g );  Size( g );</span>
true
23
10200960
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AtlasSubgroup( "M24", 100 );</span>
fail
</pre></div>

<p>The classes of maximal subgroups are ordered w. r. t. decreasing subgroup order. So the first class contains maximal subgroups of smallest index.</p>

<p>Note that groups obtained by <code class="func">AtlasSubgroup</code> (<a href="chap3_mj.html#X7A3E460C82B3D9A3"><span class="RefLink">3.5-9</span></a>) may be not very suitable for computations in the sense that much nicer representations exist. For example, the sporadic simple O'Nan group <span class="SimpleMath">\(O'N\)</span> contains a maximal subgroup <span class="SimpleMath">\(S\)</span> isomorphic with the Janko group <span class="SimpleMath">\(J_1\)</span>; the smallest permutation representation of <span class="SimpleMath">\(O'N\)</span> has degree <span class="SimpleMath">\(122760\)</span>, and restricting this representation to <span class="SimpleMath">\(S\)</span> yields a representation of <span class="SimpleMath">\(J_1\)</span> of that degree. However, <span class="SimpleMath">\(J_1\)</span> has a faithful permutation representation of degree <span class="SimpleMath">\(266\)</span>, which admits much more efficient computations. If you are just interested in <span class="SimpleMath">\(J_1\)</span> and not in its embedding into <span class="SimpleMath">\(O'N\)</span> then one possibility to get a "nicer" faithful representation is to call <code class="func">SmallerDegreePermutationRepresentation</code> (<a href="../../../doc/ref/chap43_mj.html#X8086628878AFD3EA"><span class="RefLink">Reference: SmallerDegreePermutationRepresentation</span></a>). In the abovementioned example, this works quite well; note that in general, we cannot expect that we get a representation of smallest degree in this way.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s:= AtlasSubgroup( "ON", 3 );</span>
&lt;permutation group of size 175560 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrMovedPoints( s );  Size( s );</span>
122760
175560
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom:= SmallerDegreePermutationRepresentation( s );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrMovedPoints( Image( hom ) );</span>
1540
</pre></div>

<p>In this particular case, one could of course also ask directly for the group <span class="SimpleMath">\(J_1\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">j1:= AtlasGroup( "J1" );</span>
&lt;permutation group of size 175560 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrMovedPoints( j1 );</span>
266
</pre></div>

<p>If you have a group <span class="SimpleMath">\(G\)</span>, say, and you are really interested in the embedding of a maximal subgroup of <span class="SimpleMath">\(G\)</span> into <span class="SimpleMath">\(G\)</span> then an easy way to get compatible generators is to create <span class="SimpleMath">\(G\)</span> with <code class="func">AtlasGroup</code> (<a href="chap3_mj.html#X80AABEE783363B70"><span class="RefLink">3.5-8</span></a>) and then to call <code class="func">AtlasSubgroup</code> (<a href="chap3_mj.html#X7A3E460C82B3D9A3"><span class="RefLink">3.5-9</span></a>) with first argument the group <span class="SimpleMath">\(G\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= AtlasGroup( "ON" );</span>
&lt;permutation group of size 460815505920 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s:= AtlasSubgroup( g, 3 );</span>
&lt;permutation group of size 175560 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubset( g, s );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubset( g, j1 );</span>
false
</pre></div>

<p><a id="X7F616D9685292471" name="X7F616D9685292471"></a></p>

<h4>2.2 <span class="Heading">Accessing Specific Generators in <strong class="pkg">AtlasRep</strong></span></h4>

<p>The function <code class="func">DisplayAtlasInfo</code> (<a href="chap3_mj.html#X79DACFFA7E2D1A99"><span class="RefLink">3.5-1</span></a>), called with an admissible name of a group as the only argument, lists the <strong class="pkg">ATLAS</strong> data available for this group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DisplayAtlasInfo( "A5" );</span>
Representations for G = A5:    (all refer to std. generators 1)
---------------------------
 1: G &lt;= Sym(5)                  3-trans., on cosets of A4 (1st max.)
 2: G &lt;= Sym(6)                  2-trans., on cosets of D10 (2nd max.)
 3: G &lt;= Sym(10)                 rank 3, on cosets of S3 (3rd max.)
 4: G &lt;= GL(4a,2)                character 4a
 5: G &lt;= GL(4b,2)                character 2ab
 6: G &lt;= GL(4,3)                 character 4a
 7: G &lt;= GL(6,3)                 character 3ab
 8: G &lt;= GL(2a,4)                character 2a
 9: G &lt;= GL(2b,4)                character 2b
10: G &lt;= GL(3,5)                 character 3a
11: G &lt;= GL(5,5)                 character 5a
12: G &lt;= GL(3a,9)                character 3a
13: G &lt;= GL(3b,9)                character 3b
14: G &lt;= GL(4,Z)                 character 4a
15: G &lt;= GL(5,Z)                 character 5a
16: G &lt;= GL(6,Z)                 character 3ab
17: G &lt;= GL(3a,Field([Sqrt(5)])) character 3a
18: G &lt;= GL(3b,Field([Sqrt(5)])) character 3b

Programs for G = A5:    (all refer to std. generators 1)
--------------------
- class repres.*      
- presentation        
- maxes (all 3):
  1:  A4              
  2:  D10             
  3:  S3              
- std. gen. checker:
  (check)             
  (pres)              
</pre></div>

<p>In order to fetch one of the listed permutation groups or matrix groups, you can call <code class="func">AtlasGroup</code> (<a href="chap3_mj.html#X80AABEE783363B70"><span class="RefLink">3.5-8</span></a>) with second argument the function <code class="func">Position</code> (<a href="../../../doc/ref/chap21_mj.html#X79975EC6783B4293"><span class="RefLink">Reference: Position</span></a>) and third argument the position in the list.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AtlasGroup( "A5", Position, 1 );</span>
Group([ (1,2)(3,4), (1,3,5) ])
</pre></div>

<p>Note that this approach may yield a different group after a data extension has been loaded.</p>

<p>Alternatively, you can describe the desired group by conditions, such as the degree in the case of a permutation group, and the dimension and the base ring in the case of a matrix group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AtlasGroup( "A5", NrMovedPoints, 10 );</span>
Group([ (2,4)(3,5)(6,8)(7,10), (1,2,3)(4,6,7)(5,8,9) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AtlasGroup( "A5", Dimension, 4, Ring, GF(2) );</span>
&lt;matrix group of size 60 with 2 generators&gt;
</pre></div>

<p>The same holds for the restriction to maximal subgroups: Use <code class="func">AtlasSubgroup</code> (<a href="chap3_mj.html#X7A3E460C82B3D9A3"><span class="RefLink">3.5-9</span></a>) with the same arguments as <code class="func">AtlasGroup</code> (<a href="chap3_mj.html#X80AABEE783363B70"><span class="RefLink">3.5-8</span></a>), except that additionally the number of the class of maximal subgroups is entered as the last argument. Note that the conditions refer to the group, not to the subgroup; it may happen that the subgroup moves fewer points than the big group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AtlasSubgroup( "A5", Dimension, 4, Ring, GF(2), 1 );</span>
&lt;matrix group of size 12 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= AtlasSubgroup( "A5", NrMovedPoints, 10, 3 );</span>
Group([ (2,4)(3,5)(6,8)(7,10), (1,4)(3,8)(5,7)(6,10) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( g );  NrMovedPoints( g );</span>
6
9
</pre></div>

<p><a id="X7D3A29F879B140D3" name="X7D3A29F879B140D3"></a></p>

<h4>2.3 <span class="Heading">Basic Concepts used in <strong class="pkg">AtlasRep</strong></span></h4>

<p><a id="X7E2FB5E5852AD970" name="X7E2FB5E5852AD970"></a></p>

<h5>2.3-1 <span class="Heading">Groups, Generators, and Representations</span></h5>

<p>Up to now, we have talked only about groups and subgroups. The <strong class="pkg">AtlasRep</strong> package provides access to <em>group generators</em>, and in fact these generators have the property that mapping one set of generators to another set of generators for the same group defines an isomorphism. These generators are called <em>standard generators</em>, see Section <a href="chap3_mj.html#X795DB7E486E0817D"><span class="RefLink">3.3</span></a>.</p>

<p>So instead of thinking about several generating sets of a group <span class="SimpleMath">\(G\)</span>, say, we can think about one abstract group <span class="SimpleMath">\(G\)</span>, with one fixed set of generators, and mapping these generators to any set of generators provided by <strong class="pkg">AtlasRep</strong> defines a representation of <span class="SimpleMath">\(G\)</span>. This viewpoint had motivated the name "<strong class="pkg">ATLAS</strong> of Group Representations" for the core part of the database.</p>

<p>If you are interested in the generators provided by the database rather than in the groups they generate, you can use the function <code class="func">OneAtlasGeneratingSetInfo</code> (<a href="chap3_mj.html#X841478AB7CD06D44"><span class="RefLink">3.5-6</span></a>) instead of <code class="func">AtlasGroup</code> (<a href="chap3_mj.html#X80AABEE783363B70"><span class="RefLink">3.5-8</span></a>), with the same arguments. This will yield a record that describes the representation in question. Calling the function <code class="func">AtlasGenerators</code> (<a href="chap3_mj.html#X7D1CCCF8852DFF39"><span class="RefLink">3.5-3</span></a>) with this record will then yield a record with the additional component <code class="code">generators</code>, which holds the list of generators.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">info:= OneAtlasGeneratingSetInfo( "A5", NrMovedPoints, 10 );</span>
rec( charactername := "1a+4a+5a", constituents := [ 1, 4, 5 ], 
  contents := "core", groupname := "A5", id := "", 
  identifier := [ "A5", [ "A5G1-p10B0.m1", "A5G1-p10B0.m2" ], 1, 10 ],
  isPrimitive := true, maxnr := 3, p := 10, rankAction := 3, 
  repname := "A5G1-p10B0", repnr := 3, size := 60, stabilizer := "S3",
  standardization := 1, transitivity := 1, type := "perm" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">info2:= AtlasGenerators( info );</span>
rec( charactername := "1a+4a+5a", constituents := [ 1, 4, 5 ], 
  contents := "core", 
  generators := [ (2,4)(3,5)(6,8)(7,10), (1,2,3)(4,6,7)(5,8,9) ], 
  groupname := "A5", id := "", 
  identifier := [ "A5", [ "A5G1-p10B0.m1", "A5G1-p10B0.m2" ], 1, 10 ],
  isPrimitive := true, maxnr := 3, p := 10, rankAction := 3, 
  repname := "A5G1-p10B0", repnr := 3, size := 60, stabilizer := "S3",
  standardization := 1, transitivity := 1, type := "perm" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">info2.generators;</span>
[ (2,4)(3,5)(6,8)(7,10), (1,2,3)(4,6,7)(5,8,9) ]
</pre></div>

<p>The record <code class="code">info</code> appears as the value of the attribute <code class="func">AtlasRepInfoRecord</code> (<a href="chap3_mj.html#X87BC7D9C7BA2F27A"><span class="RefLink">3.5-10</span></a>) in groups that are returned by <code class="func">AtlasGroup</code> (<a href="chap3_mj.html#X80AABEE783363B70"><span class="RefLink">3.5-8</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= AtlasGroup( "A5", NrMovedPoints, 10 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AtlasRepInfoRecord( g );</span>
rec( charactername := "1a+4a+5a", constituents := [ 1, 4, 5 ], 
  contents := "core", groupname := "A5", id := "", 
  identifier := [ "A5", [ "A5G1-p10B0.m1", "A5G1-p10B0.m2" ], 1, 10 ],
  isPrimitive := true, maxnr := 3, p := 10, rankAction := 3, 
  repname := "A5G1-p10B0", repnr := 3, size := 60, stabilizer := "S3",
  standardization := 1, transitivity := 1, type := "perm" )
</pre></div>

<p><a id="X7DC99E4284093FBB" name="X7DC99E4284093FBB"></a></p>

<h5>2.3-2 <span class="Heading">Straight Line Programs</span></h5>

<p>For computing certain group elements from standard generators, such as generators of a subgroup or class representatives, <strong class="pkg">AtlasRep</strong> uses <em>straight line programs</em>, see <a href="../../../doc/ref/chap37_mj.html#X7DC99E4284093FBB"><span class="RefLink">Reference: Straight Line Programs</span></a>. Essentially this means to evaluate words in the generators, which is similar to <code class="func">MappedWord</code> (<a href="../../../doc/ref/chap36_mj.html#X7EC17930781D104A"><span class="RefLink">Reference: MappedWord</span></a>) but can be more efficient.</p>

<p>It can be useful to deal with these straight line programs, see <code class="func">AtlasProgram</code> (<a href="chap3_mj.html#X801F2E657C8A79ED"><span class="RefLink">3.5-4</span></a>). For example, an automorphism <span class="SimpleMath">\(\alpha\)</span>, say, of the group <span class="SimpleMath">\(G\)</span>, if available in <strong class="pkg">AtlasRep</strong>, is given by a straight line program that defines the images of standard generators of <span class="SimpleMath">\(G\)</span>. This way, one can for example compute the image of a subgroup <span class="SimpleMath">\(U\)</span> of <span class="SimpleMath">\(G\)</span> under <span class="SimpleMath">\(\alpha\)</span> by first applying the straight line program for <span class="SimpleMath">\(\alpha\)</span> to standard generators of <span class="SimpleMath">\(G\)</span>, and then applying the straight line program for the restriction from <span class="SimpleMath">\(G\)</span> to <span class="SimpleMath">\(U\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prginfo:= AtlasProgramInfo( "A5", "maxes", 1 );</span>
rec( groupname := "A5", identifier := [ "A5", "A5G1-max1W1", 1 ], 
  size := 12, standardization := 1, subgroupname := "A4", 
  version := "1" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prg:= AtlasProgram( prginfo.identifier );</span>
rec( groupname := "A5", identifier := [ "A5", "A5G1-max1W1", 1 ], 
  program := &lt;straight line program&gt;, size := 12, 
  standardization := 1, subgroupname := "A4", version := "1" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( prg.program );</span>
# input:
r:= [ g1, g2 ];
# program:
r[3]:= r[1]*r[2];
r[4]:= r[2]*r[1];
r[5]:= r[3]*r[3];
r[1]:= r[5]*r[4];
# return values:
[ r[1], r[2] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ResultOfStraightLineProgram( prg.program, info2.generators );</span>
[ (1,10)(2,3)(4,9)(7,8), (1,2,3)(4,6,7)(5,8,9) ]
</pre></div>

<p><a id="X87ACE06E82B68589" name="X87ACE06E82B68589"></a></p>

<h4>2.4 <span class="Heading">Examples of Using the <strong class="pkg">AtlasRep</strong> Package</span></h4>

<p><a id="X8563D96878AC685C" name="X8563D96878AC685C"></a></p>

<h5>2.4-1 <span class="Heading">Example: Class Representatives</span></h5>

<p>First we show the computation of class representatives of the Mathieu group <span class="SimpleMath">\(M_{11}\)</span>, in a <span class="SimpleMath">\(2\)</span>-modular matrix representation. We start with the ordinary and Brauer character tables of this group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= CharacterTable( "M11" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">modtbl:= tbl mod 2;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacterDegrees( modtbl );</span>
[ [ 1, 1 ], [ 10, 1 ], [ 16, 2 ], [ 44, 1 ] ]
</pre></div>

<p>The output of <code class="func">CharacterDegrees</code> (<a href="../../../doc/ref/chap71_mj.html#X81FEFF768134481A"><span class="RefLink">Reference: CharacterDegrees</span></a>) means that the <span class="SimpleMath">\(2\)</span>-modular irreducibles of <span class="SimpleMath">\(M_{11}\)</span> have degrees <span class="SimpleMath">\(1\)</span>, <span class="SimpleMath">\(10\)</span>, <span class="SimpleMath">\(16\)</span>, <span class="SimpleMath">\(16\)</span>, and <span class="SimpleMath">\(44\)</span>.</p>

<p>Using <code class="func">DisplayAtlasInfo</code> (<a href="chap3_mj.html#X79DACFFA7E2D1A99"><span class="RefLink">3.5-1</span></a>), we find out that matrix generators for the irreducible <span class="SimpleMath">\(10\)</span>-dimensional representation are available in the database.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DisplayAtlasInfo( "M11", Characteristic, 2 );</span>
Representations for G = M11:    (all refer to std. generators 1)
----------------------------
 6: G &lt;= GL(10,2)  character 10a
 7: G &lt;= GL(32,2)  character 16ab
 8: G &lt;= GL(44,2)  character 44a
16: G &lt;= GL(16a,4) character 16a
17: G &lt;= GL(16b,4) character 16b
</pre></div>

<p>So we decide to work with this representation. We fetch the generators and compute the list of class representatives of <span class="SimpleMath">\(M_{11}\)</span> in the representation. The ordering of class representatives is the same as that in the character table of the <strong class="pkg">ATLAS</strong> of Finite Groups (<a href="chapBib_mj.html#biBCCN85">[CCN+85]</a>), which coincides with the ordering of columns in the <strong class="pkg">GAP</strong> table we have fetched above.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">info:= OneAtlasGeneratingSetInfo( "M11", Characteristic, 2,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                            Dimension, 10 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens:= AtlasGenerators( info.identifier );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ccls:= AtlasProgram( "M11", gens.standardization, "classes" );</span>
rec( groupname := "M11", identifier := [ "M11", "M11G1-cclsW1", 1 ], 
  outputs := [ "1A", "2A", "3A", "4A", "5A", "6A", "8A", "8B", "11A", 
      "11B" ], program := &lt;straight line program&gt;, 
  standardization := 1, version := "1" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">reps:= ResultOfStraightLineProgram( ccls.program, gens.generators );;</span>
</pre></div>

<p>If we would need only a few class representatives, we could use the <strong class="pkg">GAP</strong> library function <code class="func">RestrictOutputsOfSLP</code> (<a href="../../../doc/ref/chap37_mj.html#X7C9CABD17BE4850F"><span class="RefLink">Reference: RestrictOutputsOfSLP</span></a>) to create a straight line program that computes only specified outputs. Here is an example where only the class representatives of order eight are computed.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord8prg:= RestrictOutputsOfSLP( ccls.program,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  Filtered( [ 1 .. 10 ], i -&gt; ccls.outputs[i][1] = '8' ) );</span>
&lt;straight line program&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord8reps:= ResultOfStraightLineProgram( ord8prg, gens.generators );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ord8reps, m -&gt; Position( reps, m ) );</span>
[ 7, 8 ]
</pre></div>

<p>Let us check that the class representatives have the right orders.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( reps, Order ) = OrdersClassRepresentatives( tbl );</span>
true
</pre></div>

<p>From the class representatives, we can compute the Brauer character we had started with. This Brauer character is defined on all classes of the <span class="SimpleMath">\(2\)</span>-modular table. So we first pick only those representatives, using the <strong class="pkg">GAP</strong> function <code class="func">GetFusionMap</code> (<a href="../../../doc/ref/chap73_mj.html#X8464DD23879431D9"><span class="RefLink">Reference: GetFusionMap</span></a>); in this situation, it returns the class fusion from the Brauer table into the ordinary table.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= GetFusionMap( modtbl, tbl );</span>
[ 1, 3, 5, 9, 10 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">modreps:= reps{ fus };;</span>
</pre></div>

<p>Then we call the <strong class="pkg">GAP</strong> function <code class="func">BrauerCharacterValue</code> (<a href="../../../doc/ref/chap72_mj.html#X8304B68E84511685"><span class="RefLink">Reference: BrauerCharacterValue</span></a>), which computes the Brauer character value from the matrix given.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">char:= List( modreps, BrauerCharacterValue );</span>
[ 10, 1, 0, -1, -1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Position( Irr( modtbl ), char );</span>
2
</pre></div>

<p><a id="X81C9233778A3A817" name="X81C9233778A3A817"></a></p>

<h5>2.4-2 <span class="Heading">Example: Permutation and Matrix Representations</span></h5>

<p>The second example shows the computation of a permutation representation from a matrix representation. We work with the <span class="SimpleMath">\(10\)</span>-dimensional representation used above, and consider the action on the <span class="SimpleMath">\(2^{10}\)</span> vectors of the underlying row space.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">grp:= Group( gens.generators );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v:= GF(2)^10;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbs:= Orbits( grp, AsList( v ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( orbs, Length );</span>
[ 1, 396, 55, 330, 66, 165, 11 ]
</pre></div>

<p>We see that there are six nontrivial orbits, and we can compute the permutation actions on these orbits directly using <code class="func">Action</code> (<a href="../../../doc/ref/chap40_mj.html#X86C2BE2481FDC8EE"><span class="RefLink">Reference: Action homomorphisms</span></a>). However, for larger examples, one cannot write down all orbits on the row space, so one has to use another strategy if one is interested in a particular orbit.</p>

<p>Let us assume that we are interested in the orbit of length <span class="SimpleMath">\(11\)</span>. The point stabilizer is the first maximal subgroup of <span class="SimpleMath">\(M_{11}\)</span>, thus the restriction of the representation to this subgroup has a nontrivial fixed point space. This restriction can be computed using the <strong class="pkg">AtlasRep</strong> package.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens:= AtlasGenerators( "M11", 6, 1 );;</span>
</pre></div>

<p>Now computing the fixed point space is standard linear algebra.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id:= IdentityMat( 10, GF(2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sub1:= Subspace( v, NullspaceMat( gens.generators[1] - id ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sub2:= Subspace( v, NullspaceMat( gens.generators[2] - id ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fix:= Intersection( sub1, sub2 );</span>
&lt;vector space of dimension 1 over GF(2)&gt;
</pre></div>

<p>The final step is of course the computation of the permutation action on the orbit.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orb:= Orbit( grp, Basis( fix )[1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">act:= Action( grp, orb );;  Print( act, "\n" );</span>
Group( [ ( 1, 2)( 4, 6)( 5, 8)( 7,10), ( 1, 3, 5, 9)( 2, 4, 7,11) ] )
</pre></div>

<p>Note that this group is <em>not</em> equal to the group obtained by fetching the permutation representation from the database. This is due to a different numbering of the points, thus the groups are permutation isomorphic, that is, they are conjugate in the symmetric group on eleven points.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">permgrp:= Group( AtlasGenerators( "M11", 1 ).generators );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Print( permgrp, "\n" );</span>
Group( [ ( 2,10)( 4,11)( 5, 7)( 8, 9), ( 1, 4, 3, 8)( 2, 5, 6, 9) ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">permgrp = act;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsConjugate( SymmetricGroup(11), permgrp, act );</span>
true
</pre></div>

<p><a id="X8284D7E87D38889C" name="X8284D7E87D38889C"></a></p>

<h5>2.4-3 <span class="Heading">Example: Outer Automorphisms</span></h5>

<p>The straight line programs for applying outer automorphisms to standard generators can of course be used to define the automorphisms themselves as <strong class="pkg">GAP</strong> mappings.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DisplayAtlasInfo( "G2(3)", IsStraightLineProgram );</span>
Programs for G = G2(3):    (all refer to std. generators 1)
-----------------------
- class repres.            
- presentation             
- repr. cyc. subg.         
- std. gen. checker        
- automorphisms:
  2                        
- maxes (all 10):
   1:  U3(3).2             
   2:  U3(3).2             
   3:  (3^(1+2)+x3^2):2S4  
   4:  (3^(1+2)+x3^2):2S4  
   5:  L3(3).2             
   6:  L3(3).2             
   7:  L2(8).3             
   8:  2^3.L3(2)           
   9:  L2(13)              
  10:  2^(1+4)+:3^2.2      
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prog:= AtlasProgram( "G2(3)", "automorphism", "2" ).program;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">info:= OneAtlasGeneratingSetInfo( "G2(3)", Dimension, 7 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens:= AtlasGenerators( info ).generators;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">imgs:= ResultOfStraightLineProgram( prog, gens );;</span>
</pre></div>

<p>If we are not suspicious whether the script really describes an automorphism then we should tell this to <strong class="pkg">GAP</strong>, in order to avoid the expensive checks of the properties of being a homomorphism and bijective (see Section <a href="../../../doc/ref/chap40_mj.html#X81A7BB0F7D81B247"><span class="RefLink">Reference: Creating Group Homomorphisms</span></a>). This looks as follows.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Group( gens );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">aut:= GroupHomomorphismByImagesNC( g, g, gens, imgs );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetIsBijective( aut, true );</span>
</pre></div>

<p>If we are suspicious whether the script describes an automorphism then we might have the idea to check it with <strong class="pkg">GAP</strong>, as follows.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">aut:= GroupHomomorphismByImages( g, g, gens, imgs );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsBijective( aut );</span>
true
</pre></div>

<p>(Note that even for a comparatively small group such as <span class="SimpleMath">\(G_2(3)\)</span>, this was a difficult task for <strong class="pkg">GAP</strong> before version 4.3.)</p>

<p>Often one can form images under an automorphism <span class="SimpleMath">\(\alpha\)</span>, say, without creating the homomorphism object. This is obvious for the standard generators of the group <span class="SimpleMath">\(G\)</span> themselves, but also for generators of a maximal subgroup <span class="SimpleMath">\(M\)</span> computed from standard generators of <span class="SimpleMath">\(G\)</span>, provided that the straight line programs in question refer to the same standard generators. Note that the generators of <span class="SimpleMath">\(M\)</span> are given by evaluating words in terms of standard generators of <span class="SimpleMath">\(G\)</span>, and their images under <span class="SimpleMath">\(\alpha\)</span> can be obtained by evaluating the same words at the images under <span class="SimpleMath">\(\alpha\)</span> of the standard generators of <span class="SimpleMath">\(G\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">max1:= AtlasProgram( "G2(3)", 1 ).program;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mgens:= ResultOfStraightLineProgram( max1, gens );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comp:= CompositionOfStraightLinePrograms( max1, prog );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mimgs:= ResultOfStraightLineProgram( comp, gens );;</span>
</pre></div>

<p>The list <code class="code">mgens</code> is the list of generators of the first maximal subgroup of <span class="SimpleMath">\(G_2(3)\)</span>, <code class="code">mimgs</code> is the list of images under the automorphism given by the straight line program <code class="code">prog</code>. Note that applying the program returned by <code class="func">CompositionOfStraightLinePrograms</code> (<a href="../../../doc/ref/chap37_mj.html#X8274C7948248C053"><span class="RefLink">Reference: CompositionOfStraightLinePrograms</span></a>) means to apply first <code class="code">prog</code> and then <code class="code">max1</code>. Since we have already constructed the <strong class="pkg">GAP</strong> object representing the automorphism, we can check whether the results are equal.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mimgs = List( mgens, x -&gt; x^aut );</span>
true
</pre></div>

<p>However, it should be emphasized that using <code class="code">aut</code> requires a huge machinery of computations behind the scenes, whereas applying the straight line programs <code class="code">prog</code> and <code class="code">max1</code> involves only elementary operations with the generators. The latter is feasible also for larger groups, for which constructing the <strong class="pkg">GAP</strong> automorphism might be too hard.</p>

<p><a id="X794D669E7A507310" name="X794D669E7A507310"></a></p>

<h5>2.4-4 <span class="Heading">Example: Using Semi-presentations and Black Box Programs</span></h5>

<p>Let us suppose that we want to restrict a representation of the Mathieu group <span class="SimpleMath">\(M_{12}\)</span> to a non-maximal subgroup of the type <span class="SimpleMath">\(L_2(11)\)</span>. The idea is that this subgroup can be found as a maximal subgroup of a maximal subgroup of the type <span class="SimpleMath">\(M_{11}\)</span>, which is itself maximal in <span class="SimpleMath">\(M_{12}\)</span>. For that, we fetch a representation of <span class="SimpleMath">\(M_{12}\)</span> and use a straight line program for restricting it to the first maximal subgroup, which has the type <span class="SimpleMath">\(M_{11}\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">info:= OneAtlasGeneratingSetInfo( "M12", NrMovedPoints, 12 );</span>
rec( charactername := "1a+11a", constituents := [ 1, 2 ], 
  contents := "core", groupname := "M12", id := "a", 
  identifier := [ "M12", [ "M12G1-p12aB0.m1", "M12G1-p12aB0.m2" ], 1, 
      12 ], isPrimitive := true, maxnr := 1, p := 12, rankAction := 2,
  repname := "M12G1-p12aB0", repnr := 1, size := 95040, 
  stabilizer := "M11", standardization := 1, transitivity := 5, 
  type := "perm" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gensM12:= AtlasGenerators( info.identifier );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">restM11:= AtlasProgram( "M12", "maxes", 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gensM11:= ResultOfStraightLineProgram( restM11.program,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                          gensM12.generators );</span>
[ (3,9)(4,12)(5,10)(6,8), (1,4,11,5)(2,10,8,3) ]
</pre></div>

<p>Now we <em>cannot</em> simply apply a straight line program for a group to some generators, since they are not necessarily <em>standard</em> generators of the group. We check this property using a semi-presentation for <span class="SimpleMath">\(M_{11}\)</span>, see <a href="chap6_mj.html#X7C94ECAC8583CEAE"><span class="RefLink">6.1-7</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">checkM11:= AtlasProgram( "M11", "check" );</span>
rec( groupname := "M11", identifier := [ "M11", "M11G1-check1", 1, 1 ]
    , program := &lt;straight line decision&gt;, standardization := 1, 
  version := "1" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ResultOfStraightLineDecision( checkM11.program, gensM11 );</span>
true
</pre></div>

<p>So we are lucky that applying the appropriate program for <span class="SimpleMath">\(M_{11}\)</span> will give us the required generators for <span class="SimpleMath">\(L_2(11)\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">restL211:= AtlasProgram( "M11", "maxes", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gensL211:= ResultOfStraightLineProgram( restL211.program, gensM11 );</span>
[ (3,9)(4,12)(5,10)(6,8), (1,11,9)(2,12,8)(3,6,10) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:= Group( gensL211 );;  Size( G );  IsSimple( G );</span>
660
true
</pre></div>

<p>In this case, we could also use the information that is stored about <span class="SimpleMath">\(M_{11}\)</span>, as follows.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DisplayAtlasInfo( "M11", IsStraightLineProgram );</span>
Programs for G = M11:    (all refer to std. generators 1)
---------------------
- presentation                                        
- repr. cyc. subg.                                    
- std. gen. finder                                    
- class repres.:
  (direct)                                            
  (composed)                                          
- maxes (all 5):
  1:  A6.2_3                                          
  1:  A6.2_3                                  (std. 1)
  2:  L2(11)                                          
  2:  L2(11)                                  (std. 1)
  3:  3^2:Q8.2                                        
  4:  S5                                              
  4:  S5                                      (std. 1)
  5:  2.S4                                            
- standardizations of maxes:
  from 1st max., version 1 to A6.2_3, std. 1          
  from 2nd max., version 1 to L2(11), std. 1          
  from 4th max., version 1 to A5.2, std. 1            
- std. gen. checker:
  (check)                                             
  (pres)                                              
</pre></div>

<p>The entry "std.1" in the line about the maximal subgroup of type <span class="SimpleMath">\(L_2(11)\)</span> means that a straight line program for computing <em>standard</em> generators (in standardization 1) of the subgroup. This program can be fetched as follows.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">restL211std:= AtlasProgram( "M11", "maxes", 2, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ResultOfStraightLineProgram( restL211std.program, gensM11 );</span>
[ (3,9)(4,12)(5,10)(6,8), (1,11,9)(2,12,8)(3,6,10) ]
</pre></div>

<p>We see that we get the same generators for the subgroup as above. (In fact the second approach first applies the same program as is given by <code class="code">restL211.program</code>, and then applies a program to the results that does nothing.)</p>

<p>Usually representations are not given in terms of standard generators. For example, let us take the <span class="SimpleMath">\(M_{11}\)</span> type group returned by the <strong class="pkg">GAP</strong> function <code class="func">MathieuGroup</code> (<a href="../../../doc/ref/chap50_mj.html#X788FA7DE84E0FE6A"><span class="RefLink">Reference: MathieuGroup</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:= MathieuGroup( 11 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens:= GeneratorsOfGroup( G );</span>
[ (1,2,3,4,5,6,7,8,9,10,11), (3,7,11,8)(4,10,5,6) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ResultOfStraightLineDecision( checkM11.program, gens );</span>
false
</pre></div>

<p>If we want to compute an <span class="SimpleMath">\(L_2(11)\)</span> type subgroup of this group, we can use a black box program for computing standard generators, and then apply the straight line program for computing the restriction.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">find:= AtlasProgram( "M11", "find" );</span>
rec( groupname := "M11", identifier := [ "M11", "M11G1-find1", 1, 1 ],
  program := &lt;black box program&gt;, standardization := 1, 
  version := "1" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">stdgens:= ResultOfBBoxProgram( find.program, Group( gens ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( stdgens, Order );</span>
[ 2, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ResultOfStraightLineDecision( checkM11.program, stdgens );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gensL211:= ResultOfStraightLineProgram( restL211.program, stdgens );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( gensL211, Order );</span>
[ 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:= Group( gensL211 );;  Size( G );  IsSimple( G );</span>
660
true
</pre></div>

<p>Note that applying the black box program several times may yield different group elements, because computations of random elements are involved, see <code class="func">ResultOfBBoxProgram</code> (<a href="chap6_mj.html#X869BACFB80A3CC87"><span class="RefLink">6.2-4</span></a>). All what the black box program promises is to construct standard generators, and these are defined only up to conjugacy in the automorphism group of the group in question.</p>

<p><a id="X7CE7C2068017525C" name="X7CE7C2068017525C"></a></p>

<h5>2.4-5 <span class="Heading">Example: Using the <strong class="pkg">GAP</strong> Library of Tables of Marks</span></h5>

<p>The <strong class="pkg">GAP</strong> Library of Tables of Marks (the <strong class="pkg">GAP</strong> package <strong class="pkg">TomLib</strong>, <a href="chapBib_mj.html#biBTomLib">[NMP18]</a>) provides, for many almost simple groups, information for constructing representatives of all conjugacy classes of subgroups. If this information is compatible with the standard generators of the <strong class="pkg">ATLAS</strong> of Group Representations then we can use it to restrict any representation from the <strong class="pkg">ATLAS</strong> to prescribed subgroups. This is useful in particular for those subgroups for which the <strong class="pkg">ATLAS</strong> of Group Representations itself does not contain a straight line program.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tom:= TableOfMarks( "A5" );</span>
TableOfMarks( "A5" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">info:= StandardGeneratorsInfo( tom );</span>
[ rec( ATLAS := true, description := "|a|=2, |b|=3, |ab|=5", 
      generators := "a, b", 
      script := [ [ 1, 2 ], [ 2, 3 ], [ 1, 1, 2, 1, 5 ] ], 
      standardization := 1 ) ]
</pre></div>

<p>The <code class="keyw">true</code> value of the component <code class="code">ATLAS</code> indicates that the information stored on <code class="code">tom</code> refers to the standard generators of type <span class="SimpleMath">\(1\)</span> in the <strong class="pkg">ATLAS</strong> of Group Representations.</p>

<p>We want to restrict a <span class="SimpleMath">\(4\)</span>-dimensional integral representation of <span class="SimpleMath">\(A_5\)</span> to a Sylow <span class="SimpleMath">\(2\)</span> subgroup of <span class="SimpleMath">\(A_5\)</span>, and use <code class="func">RepresentativeTomByGeneratorsNC</code> (<a href="../../../doc/ref/chap70_mj.html#X7F625AB880B73AC3"><span class="RefLink">Reference: RepresentativeTomByGeneratorsNC</span></a>) for that.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">info:= OneAtlasGeneratingSetInfo( "A5", Ring, Integers, Dimension, 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">stdgens:= AtlasGenerators( info.identifier );</span>
rec( charactername := "4a", constituents := [ 4 ], contents := "core",
  dim := 4, 
  generators := 
    [ 
      [ [ 1, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 1, 0, 0 ], 
          [ -1, -1, -1, -1 ] ], 
      [ [ 0, 1, 0, 0 ], [ 0, 0, 0, 1 ], [ 0, 0, 1, 0 ], 
          [ 1, 0, 0, 0 ] ] ], groupname := "A5", id := "", 
  identifier := [ "A5", "A5G1-Zr4B0.g", 1, 4 ], 
  repname := "A5G1-Zr4B0", repnr := 14, ring := Integers, size := 60, 
  standardization := 1, type := "matint" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orders:= OrdersTom( tom );</span>
[ 1, 2, 3, 4, 5, 6, 10, 12, 60 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pos:= Position( orders, 4 );</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sub:= RepresentativeTomByGeneratorsNC( tom, pos, stdgens.generators );</span>
&lt;matrix group of size 4 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsOfGroup( sub );</span>
[ [ [ 1, 0, 0, 0 ], [ -1, -1, -1, -1 ], [ 0, 0, 0, 1 ], 
      [ 0, 0, 1, 0 ] ], 
  [ [ 1, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 1, 0, 0 ], 
      [ -1, -1, -1, -1 ] ] ]
</pre></div>

<p><a id="X82550A9683E0DCA2" name="X82550A9683E0DCA2"></a></p>

<h5>2.4-6 <span class="Heading">Example: Index <span class="SimpleMath">\(770\)</span> Subgroups in <span class="SimpleMath">\(M_{22}\)</span></span></h5>

<p>The sporadic simple Mathieu group <span class="SimpleMath">\(M_{22}\)</span> contains a unique class of subgroups of index <span class="SimpleMath">\(770\)</span> (and order <span class="SimpleMath">\(576\)</span>). This can be seen for example using <strong class="pkg">GAP</strong>'s Library of Tables of Marks.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tom:= TableOfMarks( "M22" );</span>
TableOfMarks( "M22" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">subord:= Size( UnderlyingGroup( tom ) ) / 770;</span>
576
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord:= OrdersTom( tom );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tomstabs:= Filtered( [ 1 .. Length( ord ) ], i -&gt; ord[i] = subord );</span>
[ 144 ]
</pre></div>

<p>The permutation representation of <span class="SimpleMath">\(M_{22}\)</span> on the right cosets of such a subgroup <span class="SimpleMath">\(S\)</span> is contained in the <strong class="pkg">ATLAS</strong> of Group Representations.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DisplayAtlasInfo( "M22", NrMovedPoints, 770 );</span>
Representations for G = M22:    (all refer to std. generators 1)
----------------------------
12: G &lt;= Sym(770) rank 9, on cosets of (A4xA4):4 &lt; 2^4:A6
</pre></div>

<p>Now we verify the information shown about the point stabilizer and about the maximal overgroups of <span class="SimpleMath">\(S\)</span> in <span class="SimpleMath">\(M_{22}\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">maxtom:= MaximalSubgroupsTom( tom );</span>
[ [ 155, 154, 153, 152, 151, 150, 146, 145 ], 
  [ 22, 77, 176, 176, 231, 330, 616, 672 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( tomstabs, i -&gt; List( maxtom[1], j -&gt; ContainedTom( tom, i, j ) ) );</span>
[ [ 0, 10, 0, 0, 0, 0, 0, 0 ] ]
</pre></div>

<p>We see that the only maximal subgroups of <span class="SimpleMath">\(M_{22}\)</span> that contain <span class="SimpleMath">\(S\)</span> have index <span class="SimpleMath">\(77\)</span> in <span class="SimpleMath">\(M_{22}\)</span>. According to the <strong class="pkg">ATLAS</strong> of Finite Groups, these maximal subgroups have the structure <span class="SimpleMath">\(2^4:A_6\)</span>. From that and from the structure of <span class="SimpleMath">\(A_6\)</span>, we conclude that <span class="SimpleMath">\(S\)</span> has the structure <span class="SimpleMath">\(2^4:(3^2:4)\)</span>.</p>

<p>Alternatively, we look at the permutation representation of degree <span class="SimpleMath">\(770\)</span>. We fetch it from the <strong class="pkg">ATLAS</strong> of Group Representations. There is exactly one nontrivial block system for this representation, with <span class="SimpleMath">\(77\)</span> blocks of length <span class="SimpleMath">\(10\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= AtlasGroup( "M22", NrMovedPoints, 770 );</span>
&lt;permutation group of size 443520 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">allbl:= AllBlocks( g );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( allbl, Length );</span>
[ 10 ]
</pre></div>

<p>Furthermore, <strong class="pkg">GAP</strong> computes that the point stabilizer <span class="SimpleMath">\(S\)</span> has the structure <span class="SimpleMath">\((A_4 \times A_4):4\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">stab:= Stabilizer( g, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription( stab : nice );</span>
"(A4 x A4) : C4"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">blocks:= Orbit( g, allbl[1], OnSets );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">act:= Action( g, blocks, OnSets );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription( Stabilizer( act, 1 ) );</span>
"(C2 x C2 x C2 x C2) : A6"
</pre></div>

<p><a id="X84F9D163795B7DE1" name="X84F9D163795B7DE1"></a></p>

<h5>2.4-7 <span class="Heading">Example: Index <span class="SimpleMath">\(462\)</span> Subgroups in <span class="SimpleMath">\(M_{22}\)</span></span></h5>

<p>The <strong class="pkg">ATLAS</strong> of Group Representations contains three degree <span class="SimpleMath">\(462\)</span> permutation representations of the group <span class="SimpleMath">\(M_{22}\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DisplayAtlasInfo( "M22", NrMovedPoints, 462 );</span>
Representations for G = M22:    (all refer to std. generators 1)
----------------------------
7: G &lt;= Sym(462a) rank 5, on cosets of 2^4:A5 &lt; 2^4:A6
8: G &lt;= Sym(462b) rank 8, on cosets of 2^4:A5 &lt; L3(4), 2^4:S5
9: G &lt;= Sym(462c) rank 8, on cosets of 2^4:A5 &lt; L3(4), 2^4:A6
</pre></div>

<p>The point stabilizers in these three representations have the structure <span class="SimpleMath">\(2^4:A_5\)</span>. Using <strong class="pkg">GAP</strong>'s Library of Tables of Marks, we can show that these stabilizers are exactly the three classes of subgroups of order <span class="SimpleMath">\(960\)</span> in <span class="SimpleMath">\(M_{22}\)</span>. For that, we first verify that the group generators stored in <strong class="pkg">GAP</strong>'s table of marks coincide with the standard generators used by the <strong class="pkg">ATLAS</strong> of Group Representations.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tom:= TableOfMarks( "M22" );</span>
TableOfMarks( "M22" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">genstom:= GeneratorsOfGroup( UnderlyingGroup( tom ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">checkM22:= AtlasProgram( "M22", "check" );</span>
rec( groupname := "M22", identifier := [ "M22", "M22G1-check1", 1, 1 ]
    , program := &lt;straight line decision&gt;, standardization := 1, 
  version := "1" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ResultOfStraightLineDecision( checkM22.program, genstom );</span>
true
</pre></div>

<p>There are indeed three classes of subgroups of order <span class="SimpleMath">\(960\)</span> in <span class="SimpleMath">\(M_{22}\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord:= OrdersTom( tom );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tomstabs:= Filtered( [ 1 .. Length( ord ) ], i -&gt; ord[i] = 960 );</span>
[ 147, 148, 149 ]
</pre></div>

<p>Now we compute representatives of these three classes in the three representations <code class="code">462a</code>, <code class="code">462b</code>, and <code class="code">462c</code>. We see that each of the three classes occurs as a point stabilizer in exactly one of the three representations.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">atlasreps:= AllAtlasGeneratingSetInfos( "M22", NrMovedPoints, 462 );</span>
[ rec( charactername := "1a+21a+55a+154a+231a", 
      constituents := [ 1, 2, 5, 7, 9 ], contents := "core", 
      groupname := "M22", id := "a", 
      identifier := 
        [ "M22", [ "M22G1-p462aB0.m1", "M22G1-p462aB0.m2" ], 1, 462 ],
      isPrimitive := false, p := 462, rankAction := 5, 
      repname := "M22G1-p462aB0", repnr := 7, size := 443520, 
      stabilizer := "2^4:A5 &lt; 2^4:A6", standardization := 1, 
      transitivity := 1, type := "perm" ), 
  rec( charactername := "1a+21a^2+55a+154a+210a", 
      constituents := [ 1, [ 2, 2 ], 5, 7, 8 ], contents := "core", 
      groupname := "M22", id := "b", 
      identifier := 
        [ "M22", [ "M22G1-p462bB0.m1", "M22G1-p462bB0.m2" ], 1, 462 ],
      isPrimitive := false, p := 462, rankAction := 8, 
      repname := "M22G1-p462bB0", repnr := 8, size := 443520, 
      stabilizer := "2^4:A5 &lt; L3(4), 2^4:S5", standardization := 1, 
      transitivity := 1, type := "perm" ), 
  rec( charactername := "1a+21a^2+55a+154a+210a", 
      constituents := [ 1, [ 2, 2 ], 5, 7, 8 ], contents := "core", 
      groupname := "M22", id := "c", 
      identifier := 
        [ "M22", [ "M22G1-p462cB0.m1", "M22G1-p462cB0.m2" ], 1, 462 ],
      isPrimitive := false, p := 462, rankAction := 8, 
      repname := "M22G1-p462cB0", repnr := 9, size := 443520, 
      stabilizer := "2^4:A5 &lt; L3(4), 2^4:A6", standardization := 1, 
      transitivity := 1, type := "perm" ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">atlasreps:= List( atlasreps, AtlasGroup );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tomstabreps:= List( atlasreps, G -&gt; List( tomstabs,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">i -&gt; RepresentativeTomByGenerators( tom, i, GeneratorsOfGroup( G ) ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( tomstabreps, x -&gt; List( x, NrMovedPoints ) );</span>
[ [ 462, 462, 461 ], [ 460, 462, 462 ], [ 462, 461, 462 ] ]
</pre></div>

<p>More precisely, we see that the point stabilizers in the three representations <code class="code">462a</code>, <code class="code">462b</code>, <code class="code">462c</code> lie in the subgroup classes <span class="SimpleMath">\(149\)</span>, <span class="SimpleMath">\(147\)</span>, <span class="SimpleMath">\(148\)</span>, respectively, of the table of marks.</p>

<p>The point stabilizers in the representations <code class="code">462b</code> and <code class="code">462c</code> are isomorphic, but not isomorphic with the point stabilizer in <code class="code">462a</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">stabs:= List( atlasreps, G -&gt; Stabilizer( G, 1 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( stabs, IdGroup );</span>
[ [ 960, 11358 ], [ 960, 11357 ], [ 960, 11357 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( stabs, PerfectIdentification );</span>
[ [ 960, 2 ], [ 960, 1 ], [ 960, 1 ] ]
</pre></div>

<p>The three representations are imprimitive. The containment of the point stabilizers in maximal subgroups of <span class="SimpleMath">\(M_{22}\)</span> can be computed using the table of marks of <span class="SimpleMath">\(M_{22}\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">maxtom:= MaximalSubgroupsTom( tom );</span>
[ [ 155, 154, 153, 152, 151, 150, 146, 145 ], 
  [ 22, 77, 176, 176, 231, 330, 616, 672 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( tomstabs, i -&gt; List( maxtom[1], j -&gt; ContainedTom( tom, i, j ) ) );</span>
[ [ 21, 0, 0, 0, 1, 0, 0, 0 ], [ 21, 6, 0, 0, 0, 0, 0, 0 ], 
  [ 0, 6, 0, 0, 0, 0, 0, 0 ] ]
</pre></div>

<p>We see:</p>


<ul>
<li><p>The point stabilizers in <code class="code">462a</code> (subgroups in the class <span class="SimpleMath">\(149\)</span> of the table of marks) are contained only in maximal subgroups in class <span class="SimpleMath">\(154\)</span>; these groups have the structure <span class="SimpleMath">\(2^4:A_6\)</span>.</p>

</li>
<li><p>The point stabilizers in <code class="code">462b</code> (subgroups in the class <span class="SimpleMath">\(147\)</span>) are contained in maximal subgroups in the classes <span class="SimpleMath">\(155\)</span> and <span class="SimpleMath">\(151\)</span>; these groups have the structures <span class="SimpleMath">\(L_3(4)\)</span> and <span class="SimpleMath">\(2^4:S_5\)</span>, respectively.</p>

</li>
<li><p>The point stabilizers in <code class="code">462c</code> (subgroups in the class <span class="SimpleMath">\(148\)</span>) are contained in maximal subgroups in the classes <span class="SimpleMath">\(155\)</span> and <span class="SimpleMath">\(154\)</span>.</p>

</li>
</ul>
<p>We identify the supergroups of the point stabilizers by computing the block systems.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bl:= List( atlasreps, AllBlocks );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( bl, Length );</span>
[ 1, 3, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( bl, l -&gt; List( l, Length ) );</span>
[ [ 6 ], [ 21, 21, 2 ], [ 21, 6 ] ]
</pre></div>

<p>Note that the two block systems with blocks of length <span class="SimpleMath">\(21\)</span> for <code class="code">462b</code> belong to the same supergroups (of the type <span class="SimpleMath">\(L_3(4)\)</span>); each of these subgroups fixes two different subsets of <span class="SimpleMath">\(21\)</span> points.</p>

<p>The representation <code class="code">462a</code> is <em>multiplicity-free</em>, that is, it splits into a sum of pairwise nonisomorphic irreducible representations. This can be seen from the fact that the rank of this permutation representation (that is, the number of orbits of the point stabilizer) is five; each permutation representation with this property is multiplicity-free.</p>

<p>The other two representations have rank eight. We have seen the ranks in the overview that was shown by <code class="func">DisplayAtlasInfo</code> (<a href="chap3_mj.html#X79DACFFA7E2D1A99"><span class="RefLink">3.5-1</span></a>) in the beginning. Now we compute the ranks from the permutation groups.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( atlasreps, RankAction );</span>
[ 5, 8, 8 ]
</pre></div>

<p>In fact the two representations <code class="code">462b</code> and <code class="code">462c</code> have the same permutation character. We check this by computing the possible permutation characters of degree <span class="SimpleMath">\(462\)</span> for <span class="SimpleMath">\(M_{22}\)</span>, and decomposing them into irreducible characters, using the character table from <strong class="pkg">GAP</strong>'s Character Table Library.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "M22" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">perms:= PermChars( t, 462 );</span>
[ Character( CharacterTable( "M22" ),
  [ 462, 30, 3, 2, 2, 2, 3, 0, 0, 0, 0, 0 ] ), 
  Character( CharacterTable( "M22" ),
  [ 462, 30, 12, 2, 2, 2, 0, 0, 0, 0, 0, 0 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MatScalarProducts( t, Irr( t ), perms );</span>
[ [ 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0 ], 
  [ 1, 2, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0 ] ]
</pre></div>

<p>In particular, we see that the rank eight characters are not multiplicity-free.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
