<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (IdRel) - Chapter 3: Logged Rewriting Systems</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap3"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap3.html">[MathJax off]</a></p>
<p><a id="X7B8D727485966AF8" name="X7B8D727485966AF8"></a></p>
<div class="ChapSects"><a href="chap3_mj.html#X7B8D727485966AF8">3 <span class="Heading">Logged Rewriting Systems</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X797732E87F1FE197">3.1 <span class="Heading">Logged Knuth-Bendix Completion</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X80075D5180A8F1A5">3.1-1 LoggedOnePassKB</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X87D1E3A578AAAFCB">3.1-2 LoggedKnuthBendix</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X831A93087918AA5D">3.2 <span class="Heading">Logged reduction of a word</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7C5094AF784A8BA7">3.2-1 LoggedReduceWordKB</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X8652CEEF7802DA46">3.2-2 LoggedRewritingSystemFpGroup</a></span>
</div></div>
</div>

<h3>3 <span class="Heading">Logged Rewriting Systems</span></h3>

<p>A <em>logged rewrite system</em> is associated with a group presentation. Each <em>logged rewrite rule</em> contains, in addition to the standard rewrite rule, a record or <em>log component</em> which expresses the rule in terms of the original relators of the group. We represent such a rule by a triple <code class="code">[ u, [L1,L2,..,Lk], v]</code>, where <code class="code">[u,v]</code> is a rewrite rule and <span class="SimpleMath">\(L_i = [n_i,w_i]\)</span> where <span class="SimpleMath">\(n_i\)</span> is a group relator and <span class="SimpleMath">\(w_i\)</span> is a word. These three components obey the identity <span class="SimpleMath">\(u = n_1^{w_1} \ldots n_k^{w_k} v\)</span>.</p>

<p>Rules of the form <span class="SimpleMath">\(g^+g^- \to \rm{id}\)</span> apply to the monoid presentation, but not to the group presentation, so are given an empty logged component.</p>

<p><a id="X797732E87F1FE197" name="X797732E87F1FE197"></a></p>

<h4>3.1 <span class="Heading">Logged Knuth-Bendix Completion</span></h4>

<p>The functions in this section are the logged versions of those in the previous chapter.</p>

<p><a id="X80075D5180A8F1A5" name="X80075D5180A8F1A5"></a></p>

<h5>3.1-1 LoggedOnePassKB</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LoggedOnePassKB</code>( <var class="Arg">grp</var>, <var class="Arg">loggedrules</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Given a logged rewrite system for the group <code class="code">grp</code>, this function finds all the rules that would be added to complete the rewrite system of <code class="code">OnePassKB</code> in <a href="chap2_mj.html#X7F0CD1EB7C220D40"><span class="RefLink">2.2-3</span></a>, and also the logs which relate the new rules to the originals. The result of applying this function to <code class="code">loggedrules</code> is to add new logged rules to the system without changing the monoid it defines.</p>

<p>In the example, we first convert the presentation for <code class="code">q8</code> into an initial set of logged rules, and then apply one pass of Knuth-Bendix.</p>

<p>The function returns a two-element list of lists. The first element is a set of logged rules and the second element is an empty list of r-sequences, which will be explained later.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l0 := ListWithIdenticalEntries( 8, 0 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for j in [1..8] do </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       r := r0[j];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       if ( j&lt;5 ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          l0[j] := [ r[1], [ [j,id] ], r[2] ];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          l0[j] := [ r[1], [ ], r[2] ];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l0;</span>
[ [ q8_M1^4, [ [ 1, &lt;identity ...&gt;] ], &lt;identity. ..&gt; ], 
  [ q8_M2^4, [ [ 2, &lt;identity ...&gt;] ], &lt;identity ...&gt; ], 
  [ q8_M1*q8_M2*q8_M1*q8_M4, [ [ 3, &lt;identity ...&gt; ] ], &lt;identity ...&gt; ],   
  [ q8_M1^2*q8_M2^2, [ [ 4, &lt;identity ...&gt; ] ], &lt;identity ...&gt; ], 
  [ q8_M1*q8_M3, [ ], &lt;identity ...&gt; ], [ q8_M2*q8_M4, [ ], &lt;identity ...&gt; ], 
  [ q8_M3*q8_M1, [ ], &lt;identity ...&gt; ], [ q8_M4*q8_M2, [ ], &lt;identity ...&gt; ] ] 
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l1 := LoggedOnePassKB( q8, l0 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( l1[1] ); </span>
21
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l1[1][16];</span>
[ q8_M2^2, [ [ -4, &lt;identity ...&gt; ], [ 2, q8_M3^2 ] ], q8_M1^2 ]

</pre></div>

<p>Note that the length <span class="SimpleMath">\(21\)</span> of <code class="code">l1</code> is, as expected, the same as that of <code class="code">r1</code> in <a href="chap2_mj.html#X7F0CD1EB7C220D40"><span class="RefLink">2.2-3</span></a>. If we write <span class="SimpleMath">\(a^+,b^+,a^-,b^-\)</span> for <code class="code">M1,M2,M3,M4</code> and label the four original relators as <span class="SimpleMath">\(q=a^{+4},r=b^{+4},s=a^+b^+a^+b^-,t=a^{+2}b^{+2}\)</span> then the sixteenth identity (for example) says that <span class="SimpleMath">\(b^{+2} = (t^{-1}r^{a^{-2}})a^{+2}\)</span>. To verify this, we may expand the right-hand side as follows:</p>

<p class="center">\[
(b^{-2}a^{-2}).a^{+2}(b^{+4})a^{-2}.a^{+2} 
~=~ b^{-2}(a^{+2}a^{-2})b^{+4}(a^{-2}a^{+2}) 
~=~ b^{-2}b^{+4} 
~=~ b^{+2}. 
\]</p>

<p><a id="X87D1E3A578AAAFCB" name="X87D1E3A578AAAFCB"></a></p>

<h5>3.1-2 LoggedKnuthBendix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LoggedKnuthBendix</code>( <var class="Arg">grp</var>, <var class="Arg">loggedrules</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LoggedRewriteReduce</code>( <var class="Arg">grp</var>, <var class="Arg">loggedrules</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The function <code class="code">LoggedRewriteReduce</code> removes unnecessary rules from a logged rewrite system. It works on the same principle as <code class="code">RewriteReduce</code> in <a href="chap2_mj.html#X7F0CD1EB7C220D40"><span class="RefLink">2.2-3</span></a>.</p>

<p>The function <code class="code">LoggedKnuthBendix</code> repeatedly applies functions <code class="code">LoggedOnePassKB</code> and <code class="code">LoggedRewriteReduce</code> until no new rules are added and no unnecessary ones are included. The output is a reduced complete logged rewrite system.</p>

<p>As a further example, consider the second rule in <code class="code">l2</code> which shows how <span class="SimpleMath">\(b^+a^+\)</span> reduces to <span class="SimpleMath">\(a^+b^-\)</span>. For this rule <code class="code">[u,L,v]</code> we will verify that <span class="SimpleMath">\(u = n_1^{w_1}n_2^{w_2}n_3^{w_3} v\)</span>, as in the introduction to this chapter. The rule is:</p>


<div class="example"><pre>

[ q8_M2*q8_M1, [ [3,q8_M1], [-1,&lt;identity...&gt;], [4,q8_M3] ], q8_M1*q8_M4 ]. 

</pre></div>

<p>The relators <span class="SimpleMath">\(3 \equiv s,\; 4 \equiv t\)</span> and the inverse relator <span class="SimpleMath">\(-1 \equiv q^{-1}\)</span> are <span class="SimpleMath">\(a^+b^+a^+b^-,\; a^{+2}b^{+2}\)</span> and <span class="SimpleMath">\(a^{-4}\)</span>, and these are conjugated by <span class="SimpleMath">\((a^-)^{-1}=a^+, (a^+)^{-1}=a^-\)</span> and the identity respectively. So the second and third parts of the rule expand to:</p>

<p class="center">\[
(a^-(a^+b^+a^+b^-)a^+)(a^{-4})(a^+(a^{+2}b^{+2})a^-)a^+b^- 
~=~ 
(a^-a^+)b^+a^+(b^-(a^+a^{-4}a^{+3})b^+)(b^+(a^-a^+)b^-) 
\]</p>

<p>which reduces to the first part of the rule, <span class="SimpleMath">\(b^+a^+\)</span>.</p>

<p>In version 2.41 of this package the function <code class="code">LoggedOnePassKB</code> was modified to return a two-element list of lists. The first element is a set of logged rules (as has been returned by earlier versions) while the second element is a list of <span class="SimpleMath">\(51\)</span> identities. See chapter <a href="chap6_mj.html#X78038BF07E998E21"><span class="RefLink">6</span></a> for more information about identities.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l11 := LoggedRewriteReduce( q8, l1[1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Perform( l11, Display );</span>
[ q8_M1*q8_M3, [  ], &lt;identity ...&gt; ]
[ q8_M2^2, [ [ -4, &lt;identity ...&gt; ], [ 2, q8_M3^2 ] ], q8_M1^2 ]
[ q8_M2*q8_M4, [  ], &lt;identity ...&gt; ]
[ q8_M3*q8_M1, [  ], &lt;identity ...&gt; ]
[ q8_M4*q8_M2, [  ], &lt;identity ...&gt; ]
[ q8_M1^3, [ [ 1, &lt;identity ...&gt; ] ], q8_M3 ]
[ q8_M1^2*q8_M2, [ [ 4, &lt;identity ...&gt; ] ], q8_M4 ]
[ q8_M1*q8_M2*q8_M1, [ [ 3, &lt;identity ...&gt; ] ], q8_M2 ]
[ q8_M2*q8_M1*q8_M4, [ [ 3, q8_M1 ] ], q8_M3 ] 
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( l11 );</span>
9
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l2 := LoggedKnuthBendix( q8, l11 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l2[1]; </span>
[ [ q8_M1*q8_M3, [  ], &lt;identity ...&gt; ], 
  [ q8_M2*q8_M1, [ [ 3, q8_M1 ], [ -1, &lt;identity ...&gt; ], [ 4, q8_M3 ] ], 
      q8_M1*q8_M4 ], 
  [ q8_M2^2, [ [ -4, &lt;identity ...&gt; ], [ 2, q8_M3^2 ] ], q8_M1^2 ], 
  [ q8_M2*q8_M3, [ [ -3, &lt;identity ...&gt; ] ], q8_M1*q8_M2 ], 
  [ q8_M2*q8_M4, [  ], &lt;identity ...&gt; ], [ q8_M3*q8_M1, [  ], &lt;identity ...&gt; ]
    , [ q8_M3*q8_M2, [ [ -1, &lt;identity ...&gt; ], [ 4, q8_M3 ] ], q8_M1*q8_M4 ], 
  [ q8_M3^2, [ [ -1, &lt;identity ...&gt; ] ], q8_M1^2 ], 
  [ q8_M3*q8_M4, 
      [ [ -1, &lt;identity ...&gt; ], [ -2, q8_M3^2 ], [ 4, &lt;identity ...&gt; ], 
          [ 3, q8_M1*q8_M4 ], [ -3, &lt;identity ...&gt; ] ], q8_M1*q8_M2 ], 
  [ q8_M4*q8_M1, [ [ -4, &lt;identity ...&gt; ], [ 3, q8_M3 ] ], q8_M1*q8_M2 ], 
  [ q8_M4*q8_M2, [  ], &lt;identity ...&gt; ], 
  [ q8_M4*q8_M3, [ [ -3, q8_M1*q8_M2 ] ], q8_M1*q8_M4 ], 
  [ q8_M4^2, [ [ -4, &lt;identity ...&gt; ] ], q8_M1^2 ], 
  [ q8_M1^3, [ [ 1, &lt;identity ...&gt; ] ], q8_M3 ], 
  [ q8_M1^2*q8_M2, [ [ 4, &lt;identity ...&gt; ] ], q8_M4 ], 
  [ q8_M1^2*q8_M4, [ [ -4, q8_M3^2 ], [ 1, &lt;identity ...&gt; ] ], q8_M2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( l2[1] );</span>
16
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( l2[2] );</span>
51

</pre></div>

<p><a id="X831A93087918AA5D" name="X831A93087918AA5D"></a></p>

<h4>3.2 <span class="Heading">Logged reduction of a word</span></h4>

<p><a id="X7C5094AF784A8BA7" name="X7C5094AF784A8BA7"></a></p>

<h5>3.2-1 LoggedReduceWordKB</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LoggedReduceWordKB</code>( <var class="Arg">word</var>, <var class="Arg">loggedrules</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LoggedOnePassReduceWord</code>( <var class="Arg">word</var>, <var class="Arg">loggedrules</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ShorterLoggedRule</code>( <var class="Arg">logrule1</var>, <var class="Arg">logrule2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Given a word and a logged rewrite system, the function <code class="code">LoggedOnePassReduceWord</code> makes one reduction pass of the word (possibly involving several reductions) (as does <code class="code">OnePassReduceWord</code> in <a href="chap2_mj.html#X83BD6C0A80D88C2C"><span class="RefLink">2.2-2</span></a>) and records this, using the log part of the rule(s) used and the position in the original word of the replaced part.</p>

<p>The function <code class="code">LoggedReduceWordKB</code> repeatedly applies <code class="code">OnePassLoggedReduceWord</code> until the word can no longer be reduced. Each step of the reduction is logged, showing how the original word can be expressed in terms of the original relators and the irreducible word. When <code class="code">loggedrules</code> is complete the reduced word is a unique normal form for that group element. The log of the reduction depends on the order in which the rules are applied.</p>

<p>The function <code class="code">ShorterLoggedrule</code> decides whether one logged rule is better than another, using the same criteria as <code class="code">ShorterRule</code> in <a href="chap2_mj.html#X7F0CD1EB7C220D40"><span class="RefLink">2.2-3</span></a>. In the example we perform logged reductions of <span class="SimpleMath">\(w_0 = a^9b^9\)</span> corresponding to the ordinary reductions performed in the previous chapter (section <a href="chap2_mj.html#X83BD6C0A80D88C2C"><span class="RefLink">2.2-2</span></a>).</p>

<p>In order to clarify the following output, note that, in the log below, <span class="SimpleMath">\(b^9a^9\)</span> reduces to <span class="SimpleMath">\(b^5a^5\)</span> in <code class="code">lw1</code> and to <span class="SimpleMath">\(ba\)</span> in the first <code class="code">lw2</code>. These expand to the initial <code class="code">w0</code> using the given logged parts as follows:</p>

<p class="center">\[
(b^{+9}a^{+4}b^{-9})(b^{+4})b^{+5}a^{+5} ~=~ b^{+9}a^{+9} 
~=~ (b^{+9}a^{+4}b^{-9})(b^{+4})(b^{+5}a^{+4}b^{-5})(b^{+4})b^+a^+\,.  
\]</p>

<p>The corresponding expansion of the final <code class="code">lw2</code> is too lengthy to include here. (It's hard to believe that the logged part of this identity is the simplest possible. Further investigation is needed to determine whether or not this logged part can be simplified.)</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w0; </span>
q8_M2^9*q8_M1^9
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lw1 := LoggedOnePassReduceWord( w0, l0 );</span>
[ [ [ 1, q8_M2^-9 ], [ 2, &lt;identity ...&gt; ] ], q8_M2^5*q8_M1^5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lw2 := LoggedReduceWordKB( w0, l0 ); </span>
[ [ [ 1, q8_M2^-9 ], [ 2, &lt;identity ...&gt; ], [ 1, q8_M2^-5 ], 
      [ 2, &lt;identity ...&gt; ] ], q8_M2*q8_M1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lw2 := LoggedReduceWordKB( w0, l2[1] ); </span>
[ [ [ 3, q8_M1*q8_M2^-8 ], [ -1, q8_M2^-8 ], [ 4, q8_M3*q8_M2^-8 ], 
      [ -4, &lt;identity ...&gt; ], [ 2, q8_M3^2 ], 
      [ -4, q8_M1^-1*q8_M2^-6*q8_M1^-2 ], 
      [ 3, q8_M3*q8_M1^-1*q8_M2^-6*q8_M1^-2 ], 
      [ 1, q8_M2^-1*q8_M1^-2*q8_M2^-6*q8_M1^-2 ], [ 4, &lt;identity ...&gt; ], 
      [ 3, q8_M1*q8_M2^-4*q8_M4^-1 ], [ -1, q8_M2^-4*q8_M4^-1 ], 
      [ 4, q8_M3*q8_M2^-4*q8_M4^-1 ], [ -4, q8_M4^-1 ], 
      [ 2, q8_M3^2*q8_M4^-1 ], 
      [ -3, q8_M1^-1*q8_M4^-1*q8_M1^-1*q8_M2^-2*q8_M1^-2*q8_M4^-1 ], 
      [ -4, &lt;identity ...&gt; ], [ 3, q8_M3 ], 
      [ 1, q8_M2^-1*q8_M1^-2*q8_M4^-1*q8_M1^-1*q8_M2^-1*(q8_M2^-1*q8_M1^-1)^2 
         ], [ 4, q8_M4^-1*q8_M1^-1*q8_M2^-1*(q8_M2^-1*q8_M1^-1)^2 ], 
      [ 3, &lt;identity ...&gt; ], [ -1, q8_M1^-1 ], [ 4, q8_M3*q8_M1^-1 ], 
      [ -4, q8_M4^-1*q8_M1^-2 ], [ 2, q8_M3^2*q8_M4^-1*q8_M1^-2 ], 
      [ -4, q8_M1^-2 ], [ 3, q8_M3*q8_M1^-2 ], 
      [ -4, q8_M1^-2*q8_M2^-1*q8_M1^-3 ], [ 1, &lt;identity ...&gt; ], 
      [ 3, q8_M1*q8_M3^-1 ], [ -1, q8_M3^-1 ], [ 4, &lt;identity ...&gt; ], 
      [ -4, &lt;identity ...&gt; ], [ 3, q8_M3 ], [ 3, &lt;identity ...&gt; ], 
      [ -1, q8_M1^-1 ], [ 4, q8_M3*q8_M1^-1 ], [ -4, q8_M1^-2 ], 
      [ 3, q8_M3*q8_M1^-2 ], [ 1, &lt;identity ...&gt; ], [ -1, &lt;identity ...&gt; ], 
      [ 4, q8_M3 ] ], q8_M1*q8_M4 ]

</pre></div>

<p><a id="X8652CEEF7802DA46" name="X8652CEEF7802DA46"></a></p>

<h5>3.2-2 LoggedRewritingSystemFpGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LoggedRewritingSystemFpGroup</code>( <var class="Arg">grp</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Given a group presentation, the function <code class="code">LoggedRewritingSystemFpGroup</code> determines a logged rewrite system based on the relators. The initial logged rewrite system associated with a group presentation consists of two types of rule. These are logged versions of the two types of rule in the monoid presentation. Corresponding to the j-th relator <code class="code">rel</code> of the group there is a logged rule <code class="code">[rel,[[j,id]],id]</code>. For each inverse relator there is a logged rule <code class="code">[ gen*inv, [], id ]</code>. The function then attempts a completion of the logged rewrite system. The rules in the final system are partially ordered by the function <code class="code">ShorterLoggedRule</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lrws := LoggedRewritingSystemFpGroup( q8 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Perform( lrws, Display ); </span>
[ q8_M4*q8_M2, [  ], &lt;identity ...&gt; ]
[ q8_M3*q8_M1, [  ], &lt;identity ...&gt; ]
[ q8_M2*q8_M4, [  ], &lt;identity ...&gt; ]
[ q8_M1*q8_M3, [  ], &lt;identity ...&gt; ]
[ q8_M1^2*q8_M4, [ [ -8, q8_M3^2 ], [ 5, &lt;identity ...&gt; ] ], q8_M2 ]
[ q8_M1^2*q8_M2, [ [ 8, &lt;identity ...&gt; ] ], q8_M4 ]
[ q8_M1^3, [ [ 5, &lt;identity ...&gt; ] ], q8_M3 ]
[ q8_M4^2, [ [ -8, &lt;identity ...&gt; ] ], q8_M1^2 ]
[ q8_M4*q8_M3, [ [ -7, q8_M1*q8_M2 ] ], q8_M1*q8_M4 ]
[ q8_M4*q8_M1, [ [ -8, &lt;identity ...&gt; ], [ 7, q8_M3 ] ], q8_M1*q8_M2 ]
[ q8_M3*q8_M4, 
  [ [ -5, &lt;identity ...&gt; ], [ -6, q8_M3^2 ], [ 8, &lt;identity ...&gt; ], 
      [ 7, q8_M1*q8_M4 ], [ -7, &lt;identity ...&gt; ] ], q8_M1*q8_M2 ]
[ q8_M3^2, [ [ -5, &lt;identity ...&gt; ] ], q8_M1^2 ]
[ q8_M3*q8_M2, [ [ -5, &lt;identity ...&gt; ], [ 8, q8_M3 ] ], q8_M1*q8_M4 ]
[ q8_M2*q8_M3, [ [ -7, &lt;identity ...&gt; ] ], q8_M1*q8_M2 ]
[ q8_M2^2, [ [ -8, &lt;identity ...&gt; ], [ 6, q8_M3^2 ] ], q8_M1^2 ]
[ q8_M2*q8_M1, [ [ 7, q8_M1 ], [ -5, &lt;identity ...&gt; ], [ 8, q8_M3 ] ],
  q8_M1*q8_M4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( lrws );</span>
16

</pre></div>

<p>Consider now the two-generator abelian group <span class="SimpleMath">\(T\)</span> considered in the previous chapter (<a href="chap2_mj.html#X858ECE3E807C7363"><span class="RefLink">2.2-1</span></a>). Using the alternative ordering on the monoid generators, <code class="code">[ T_M1</code><span class="SimpleMath">\(=a^+\)</span>, <code class="code">T_M2</code><span class="SimpleMath">\(=a^-\)</span>, <code class="code">T_M3</code><span class="SimpleMath">\(=b^+\)</span>, <code class="code">T_M4</code><span class="SimpleMath">\(=b^-\)</span> <code class="code">]</code>, we obtain the following set of <span class="SimpleMath">\(8\)</span> logged rules. The last of these may be checked as follows:</p>

<p class="center">\[
(b^+a^+(b^-a^-b^+a^+)a^-b^-)a^+b^+ ~=~ 
b^+a^+(b^-(a^-(b^+(a^+a^-)b^-)a^+)b^+) 
\]</p>

<p>and is a logged version of the rule <span class="SimpleMath">\(b^+a^+ \to a^+b^+\)</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lrwsT := LoggedRewritingSystemFpGroup( T );</span>
[ [ T_M4*T_M3, [  ], &lt;identity ...&gt; ], [ T_M3*T_M4, [  ], &lt;identity ...&gt; ], 
  [ T_M2*T_M1, [  ], &lt;identity ...&gt; ], [ T_M1*T_M2, [  ], &lt;identity ...&gt; ], 
  [ T_M4*T_M2, [ [ -5, &lt;identity ...&gt; ] ], T_M2*T_M4 ], 
  [ T_M4*T_M1, [ [ 5, T_M2 ] ], T_M1*T_M4 ], 
  [ T_M3*T_M2, [ [ 5, T_M4 ] ], T_M2*T_M3 ], 
  [ T_M3*T_M1, [ [ -5, T_M2*T_M4 ] ], T_M1*T_M3 ] ]

</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
