<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (polycyclic) - Chapter 7: Higher level methods for pcp-groups</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap7"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chapA_mj.html">A</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap6_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap8_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap7.html">[MathJax off]</a></p>
<p><a id="X85BB6FE078679DAF" name="X85BB6FE078679DAF"></a></p>
<div class="ChapSects"><a href="chap7_mj.html#X85BB6FE078679DAF">7 <span class="Heading">Higher level methods for pcp-groups</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7_mj.html#X8266A0A2821D98A1">7.1 <span class="Heading">Subgroup series in pcp-groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X8037DAD77A19D9B2">7.1-1 PcpSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X86C633357ACD342C">7.1-2 EfaSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X80ED4F8380DC477E">7.1-3 SemiSimpleEfaSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X7A879948834BD889">7.1-4 DerivedSeriesOfGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X866D4C5C79F26611">7.1-5 RefinedDerivedSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X86F7DE927DE3B5CD">7.1-6 RefinedDerivedSeriesDown</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X879D55A67DB42676">7.1-7 LowerCentralSeriesOfGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X8428592E8773CD7B">7.1-8 UpperCentralSeriesOfGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X83CA5DE785AE3F2C">7.1-9 TorsionByPolyEFSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X7E39431286969377">7.1-10 PcpsBySeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X79789A1C82139854">7.1-11 PcpsOfEfaSeries</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7_mj.html#X7CE2DA437FD2B383">7.2 <span class="Heading">Orbit stabilizer methods for pcp-groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X83E17DB483B33AB5">7.2-1 PcpOrbitStabilizer</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X80694BA480F69A0E">7.2-2 StabilizerIntegralAction</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X875BE4077B32A411">7.2-3 NormalizerIntegralAction</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7_mj.html#X80E3B42E792532B3">7.3 <span class="Heading">Centralizers, Normalizers and Intersections</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X7A2BF4527E08803C">7.3-1 Centralizer</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X7A2BF4527E08803C">7.3-2 Centralizer</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X851069107CACF98E">7.3-3 Intersection</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7_mj.html#X7CF015E87A2B2388">7.4 <span class="Heading">Finite subgroups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X8036FA507A170DC4">7.4-1 TorsionSubgroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X8082CD337972DC63">7.4-2 NormalTorsionSubgroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X86D92DA17DCE22DD">7.4-3 IsTorsionFree</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X819058217B4F3DC0">7.4-4 FiniteSubgroupClasses</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X7E7C32EA81A297B6">7.4-5 FiniteSubgroupClassesBySeries</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7_mj.html#X7D9F737F80F6E396">7.5 <span class="Heading">Subgroups of finite index and maximal subgroups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X87D62D497A8715FB">7.5-1 MaximalSubgroupClassesByIndex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X7800133F81BC7674">7.5-2 LowIndexSubgroupClasses</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X7F7067C77F2DC32C">7.5-3 LowIndexNormalSubgroups</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X85A5BC447D83175F">7.5-4 NilpotentByAbelianNormalSubgroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7_mj.html#X785E0E877AB1D549">7.6 <span class="Heading">Further attributes for pcp-groups based on the Fitting subgroup</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X780552B57C30DD8F">7.6-1 FittingSubgroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X86BD63DC844731DF">7.6-2 IsNilpotentByFinite</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X847ABE6F781C7FE8">7.6-3 Centre</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X861C36368435EB09">7.6-4 FCCentre</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X7E75E2BC806746AC">7.6-5 PolyZNormalSubgroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X86800BF783E30D4A">7.6-6 NilpotentByAbelianByFiniteSeries</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7_mj.html#X878DBDC77CCA4F7E">7.7 <span class="Heading">Functions for nilpotent groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X81D15723804771E2">7.7-1 MinimalGeneratingSet</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7_mj.html#X8640F9D47A1F7434">7.8 <span class="Heading">Random methods for pcp-groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X7E5FE3E879D4E6BF">7.8-1 RandomCentralizerPcpGroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7_mj.html#X824142B784453DB9">7.9 <span class="Heading">Non-abelian tensor product and Schur extensions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X79EF28D9845878C9">7.9-1 SchurExtension</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X84B60EC978A9A05E">7.9-2 SchurExtensionEpimorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X7DD1E37987612042">7.9-3 SchurCover</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X792BC39D7CEB1D27">7.9-4 AbelianInvariantsMultiplier</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X822ED5978647C93B">7.9-5 NonAbelianExteriorSquareEpimorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X8739CD4686301A0E">7.9-6 NonAbelianExteriorSquare</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X86553D7B7DABF38F">7.9-7 NonAbelianTensorSquareEpimorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X7C0DF7C97F78C666">7.9-8 NonAbelianTensorSquare</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X7AE75EC1860FFE7A">7.9-9 NonAbelianExteriorSquarePlusEmbedding</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X7D96C84E87925B0F">7.9-10 NonAbelianTensorSquarePlusEpimorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X8746533787C4E8BC">7.9-11 NonAbelianTensorSquarePlus</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X78F9184078B2761A">7.9-12 WhiteheadQuadraticFunctor</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7_mj.html#X7D3023697BA5CE5A">7.10 <span class="Heading">Schur covers</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X7D90B44E7B96AFF1">7.10-1 SchurCovers</a></span>
</div></div>
</div>

<h3>7 <span class="Heading">Higher level methods for pcp-groups</span></h3>

<p>This is a description of some higher level functions of the <strong class="pkg">Polycyclic</strong> package of GAP 4. Throughout this chapter we let <var class="Arg">G</var> be a pc-presented group and we consider algorithms for subgroups <var class="Arg">U</var> and <var class="Arg">V</var> of <var class="Arg">G</var>. For background and a description of the underlying algorithms we refer to <a href="chapBib_mj.html#biBEic01b">[Eic01a]</a>.</p>

<p><a id="X8266A0A2821D98A1" name="X8266A0A2821D98A1"></a></p>

<h4>7.1 <span class="Heading">Subgroup series in pcp-groups</span></h4>

<p>Many algorithm for pcp-groups work by induction using some series through the group. In this section we provide a number of useful series for pcp-groups. An <em>efa series</em> is a normal series with elementary or free abelian factors. See <a href="chapBib_mj.html#biBEic00">[Eic00]</a> for outlines on the algorithms of a number of the available series.</p>

<p><a id="X8037DAD77A19D9B2" name="X8037DAD77A19D9B2"></a></p>

<h5>7.1-1 PcpSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PcpSeries</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns the polycyclic series of <var class="Arg">U</var> defined by an igs of <var class="Arg">U</var>.</p>

<p><a id="X86C633357ACD342C" name="X86C633357ACD342C"></a></p>

<h5>7.1-2 EfaSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EfaSeries</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns a normal series of <var class="Arg">U</var> with elementary or free abelian factors.</p>

<p><a id="X80ED4F8380DC477E" name="X80ED4F8380DC477E"></a></p>

<h5>7.1-3 SemiSimpleEfaSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SemiSimpleEfaSeries</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns an efa series of <var class="Arg">U</var> such that every factor in the series is semisimple as a module for <var class="Arg">U</var> over a finite field or over the rationals.</p>

<p><a id="X7A879948834BD889" name="X7A879948834BD889"></a></p>

<h5>7.1-4 DerivedSeriesOfGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DerivedSeriesOfGroup</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>the derived series of <var class="Arg">U</var>.</p>

<p><a id="X866D4C5C79F26611" name="X866D4C5C79F26611"></a></p>

<h5>7.1-5 RefinedDerivedSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RefinedDerivedSeries</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>the derived series of <var class="Arg">U</var> refined to an efa series such that in each abelian factor of the derived series the free abelian factor is at the top.</p>

<p><a id="X86F7DE927DE3B5CD" name="X86F7DE927DE3B5CD"></a></p>

<h5>7.1-6 RefinedDerivedSeriesDown</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RefinedDerivedSeriesDown</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>the derived series of <var class="Arg">U</var> refined to an efa series such that in each abelian factor of the derived series the free abelian factor is at the bottom.</p>

<p><a id="X879D55A67DB42676" name="X879D55A67DB42676"></a></p>

<h5>7.1-7 LowerCentralSeriesOfGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LowerCentralSeriesOfGroup</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>the lower central series of <var class="Arg">U</var>. If <var class="Arg">U</var> does not have a largest nilpotent quotient group, then this function may not terminate.</p>

<p><a id="X8428592E8773CD7B" name="X8428592E8773CD7B"></a></p>

<h5>7.1-8 UpperCentralSeriesOfGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UpperCentralSeriesOfGroup</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>the upper central series of <var class="Arg">U</var>. This function always terminates, but it may terminate at a proper subgroup of <var class="Arg">U</var>.</p>

<p><a id="X83CA5DE785AE3F2C" name="X83CA5DE785AE3F2C"></a></p>

<h5>7.1-9 TorsionByPolyEFSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TorsionByPolyEFSeries</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns an efa series of <var class="Arg">U</var> such that all torsion-free factors are at the top and all finite factors are at the bottom. Such a series might not exist for <var class="Arg">U</var> and in this case the function returns fail.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := ExamplesOfSomePcpGroups(5);</span>
Pcp-group with orders [ 2, 0, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Igs(G);</span>
[ g1, g2, g3, g4 ]

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PcpSeries(G);</span>
[ Pcp-group with orders [ 2, 0, 0, 0 ],
  Pcp-group with orders [ 0, 0, 0 ],
  Pcp-group with orders [ 0, 0 ],
  Pcp-group with orders [ 0 ],
  Pcp-group with orders [  ] ]

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( PcpSeries(G), Igs );</span>
[ [ g1, g2, g3, g4 ], [ g2, g3, g4 ], [ g3, g4 ], [ g4 ], [  ] ]
</pre></div>

<p>Algorithms for pcp-groups often use an efa series of <span class="SimpleMath">\(G\)</span> and work down over the factors of this series. Usually, pcp's of the factors are more useful than the actual factors. Hence we provide the following.</p>

<p><a id="X7E39431286969377" name="X7E39431286969377"></a></p>

<h5>7.1-10 PcpsBySeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PcpsBySeries</code>( <var class="Arg">ser</var>[, <var class="Arg">flag</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns a list of pcp's corresponding to the factors of the series. If the parameter <var class="Arg">flag</var> is present and equals the string "snf", then each pcp corresponds to a decomposition of the abelian groups into direct factors.</p>

<p><a id="X79789A1C82139854" name="X79789A1C82139854"></a></p>

<h5>7.1-11 PcpsOfEfaSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PcpsOfEfaSeries</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns a list of pcps corresponding to an efa series of <var class="Arg">U</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := ExamplesOfSomePcpGroups(5);</span>
Pcp-group with orders [ 2, 0, 0, 0 ]

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PcpsBySeries( DerivedSeriesOfGroup(G));</span>
[ Pcp [ g1, g2, g3, g4 ] with orders [ 2, 2, 2, 2 ],
  Pcp [ g2^-2, g3^-2, g4^2 ] with orders [ 0, 0, 4 ],
  Pcp [ g4^8 ] with orders [ 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PcpsBySeries( RefinedDerivedSeries(G));</span>
[ Pcp [ g1, g2, g3 ] with orders [ 2, 2, 2 ],
  Pcp [ g4 ] with orders [ 2 ],
  Pcp [ g2^2, g3^2 ] with orders [ 0, 0 ],
  Pcp [ g4^2 ] with orders [ 2 ],
  Pcp [ g4^4 ] with orders [ 2 ],
  Pcp [ g4^8 ] with orders [ 0 ] ]

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PcpsBySeries( DerivedSeriesOfGroup(G), "snf" );</span>
[ Pcp [ g2, g3, g1 ] with orders [ 2, 2, 4 ],
  Pcp [ g4^2, g3^-2, g2^2*g4^2 ] with orders [ 4, 0, 0 ],
  Pcp [ g4^8 ] with orders [ 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G.1^4 in DerivedSubgroup( G );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G.1^2 = G.4;</span>
true

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"> PcpsOfEfaSeries( G );</span>
[ Pcp [ g1 ] with orders [ 2 ],
  Pcp [ g2 ] with orders [ 0 ],
  Pcp [ g3 ] with orders [ 0 ],
  Pcp [ g4 ] with orders [ 0 ] ]
</pre></div>

<p><a id="X7CE2DA437FD2B383" name="X7CE2DA437FD2B383"></a></p>

<h4>7.2 <span class="Heading">Orbit stabilizer methods for pcp-groups</span></h4>

<p>Let <var class="Arg">U</var> be a pcp-group which acts on a set <span class="SimpleMath">\(\Omega\)</span>. One of the fundamental problems in algorithmic group theory is the determination of orbits and stabilizers of points in <span class="SimpleMath">\(\Omega\)</span> under the action of <var class="Arg">U</var>. We distinguish two cases: the case that all considered orbits are finite and the case that there are infinite orbits. In the latter case, an orbit cannot be listed and a description of the orbit and its corresponding stabilizer is much harder to obtain.</p>

<p>If the considered orbits are finite, then the following two functions can be applied to compute the considered orbits and their corresponding stabilizers.</p>

<p><a id="X83E17DB483B33AB5" name="X83E17DB483B33AB5"></a></p>

<h5>7.2-1 PcpOrbitStabilizer</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PcpOrbitStabilizer</code>( <var class="Arg">point</var>, <var class="Arg">gens</var>, <var class="Arg">acts</var>, <var class="Arg">oper</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PcpOrbitsStabilizers</code>( <var class="Arg">points</var>, <var class="Arg">gens</var>, <var class="Arg">acts</var>, <var class="Arg">oper</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>The input <var class="Arg">gens</var> can be an igs or a pcp of a pcp-group <var class="Arg">U</var>. The elements in the list <var class="Arg">gens</var> act as the elements in the list <var class="Arg">acts</var> via the function <var class="Arg">oper</var> on the given points; that is, <var class="Arg">oper( point, acts[i] )</var> applies the <span class="SimpleMath">\(i\)</span>th generator to a given point. Thus the group defined by <var class="Arg">acts</var> must be a homomorphic image of the group defined by <var class="Arg">gens</var>. The first function returns a record containing the orbit as component 'orbit' and and igs for the stabilizer as component 'stab'. The second function returns a list of records, each record contains 'repr' and 'stab'. Both of these functions run forever on infinite orbits.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := DihedralPcpGroup( 0 );</span>
Pcp-group with orders [ 2, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats := [ [[-1,0],[0,1]], [[1,1],[0,1]] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pcp := Pcp(G);</span>
Pcp [ g1, g2 ] with orders [ 2, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PcpOrbitStabilizer( [0,1], pcp, mats, OnRight );</span>
rec( orbit := [ [ 0, 1 ] ],
     stab := [ g1, g2 ],
     word := [ [ [ 1, 1 ] ], [ [ 2, 1 ] ] ] )
</pre></div>

<p>If the considered orbits are infinite, then it may not always be possible to determine a description of the orbits and their stabilizers. However, as shown in <a href="chapBib_mj.html#biBEOs01">[EO02]</a> and <a href="chapBib_mj.html#biBEic02">[Eic02]</a>, it is possible to determine stabilizers and check if two elements are contained in the same orbit if the given action of the polycyclic group is a unimodular linear action on a vector space. The following functions are available for this case.</p>

<p><a id="X80694BA480F69A0E" name="X80694BA480F69A0E"></a></p>

<h5>7.2-2 StabilizerIntegralAction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StabilizerIntegralAction</code>( <var class="Arg">U</var>, <var class="Arg">mats</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OrbitIntegralAction</code>( <var class="Arg">U</var>, <var class="Arg">mats</var>, <var class="Arg">v</var>, <var class="Arg">w</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>The first function computes the stabilizer in <var class="Arg">U</var> of the vector <var class="Arg">v</var> where the pcp group <var class="Arg">U</var> acts via <var class="Arg">mats</var> on an integral space and <var class="Arg">v</var> and <var class="Arg">w</var> are elements in this integral space. The second function checks whether <var class="Arg">v</var> and <var class="Arg">w</var> are in the same orbit and the function returns either <var class="Arg">false</var> or a record containing an element in <var class="Arg">U</var> mapping <var class="Arg">v</var> to <var class="Arg">w</var> and the stabilizer of <var class="Arg">v</var>.</p>

<p><a id="X875BE4077B32A411" name="X875BE4077B32A411"></a></p>

<h5>7.2-3 NormalizerIntegralAction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NormalizerIntegralAction</code>( <var class="Arg">U</var>, <var class="Arg">mats</var>, <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConjugacyIntegralAction</code>( <var class="Arg">U</var>, <var class="Arg">mats</var>, <var class="Arg">B</var>, <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>The first function computes the normalizer in <var class="Arg">U</var> of the lattice with the basis <var class="Arg">B</var>, where the pcp group <var class="Arg">U</var> acts via <var class="Arg">mats</var> on an integral space and <var class="Arg">B</var> is a subspace of this integral space. The second functions checks whether the two lattices with the bases <var class="Arg">B</var> and <var class="Arg">C</var> are contained in the same orbit under <var class="Arg">U</var>. The function returns either <var class="Arg">false</var> or a record with an element in <var class="Arg">U</var> mapping <var class="Arg">B</var> to <var class="Arg">C</var> and the stabilizer of <var class="Arg">B</var>.</p>


<div class="example"><pre>
# get a pcp group and a free abelian normal subgroup
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := ExamplesOfSomePcpGroups(8);</span>
Pcp-group with orders [ 0, 0, 0, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">efa := EfaSeries(G);</span>
[ Pcp-group with orders [ 0, 0, 0, 0, 0 ],
  Pcp-group with orders [ 0, 0, 0, 0 ],
  Pcp-group with orders [ 0, 0, 0 ],
  Pcp-group with orders [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N := efa[3];</span>
Pcp-group with orders [ 0, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsFreeAbelian(N);</span>
true

# create conjugation action on N
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats := LinearActionOnPcp(Igs(G), Pcp(N));</span>
[ [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ],
  [ [ 0, 0, 1 ], [ 1, -1, 1 ], [ 0, 1, 0 ] ],
  [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ],
  [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ],
  [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] ]

# take an arbitrary vector and compute its stabilizer
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StabilizerIntegralAction(G,mats, [2,3,4]);</span>
Pcp-group with orders [ 0, 0, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Igs(last);</span>
[ g1, g3, g4, g5 ]

# check orbits with some other vectors
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrbitIntegralAction(G,mats, [2,3,4],[3,1,5]);</span>
rec( stab := Pcp-group with orders [ 0, 0, 0, 0 ], prei := g2 )

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrbitIntegralAction(G,mats, [2,3,4], [4,6,8]);</span>
false

# compute the orbit of a subgroup of Z^3 under the action of G
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NormalizerIntegralAction(G, mats, [[1,0,0],[0,1,0]]);</span>
Pcp-group with orders [ 0, 0, 0, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Igs(last);</span>
[ g1, g2^2, g3, g4, g5 ]
</pre></div>

<p><a id="X80E3B42E792532B3" name="X80E3B42E792532B3"></a></p>

<h4>7.3 <span class="Heading">Centralizers, Normalizers and Intersections</span></h4>

<p>In this section we list a number of operations for which there are methods installed to compute the corresponding features in polycyclic groups.</p>

<p><a id="X7A2BF4527E08803C" name="X7A2BF4527E08803C"></a></p>

<h5>7.3-1 Centralizer</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Centralizer</code>( <var class="Arg">U</var>, <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsConjugate</code>( <var class="Arg">U</var>, <var class="Arg">g</var>, <var class="Arg">h</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>These functions solve the conjugacy problem for elements in pcp-groups and they can be used to compute centralizers. The first method returns a subgroup of the given group <var class="Arg">U</var>, the second method either returns a conjugating element or false if no such element exists.</p>

<p>The methods are based on the orbit stabilizer algorithms described in <a href="chapBib_mj.html#biBEOs01">[EO02]</a>. For nilpotent groups, an algorithm to solve the conjugacy problem for elements is described in <a href="chapBib_mj.html#biBSims94">[Sim94]</a>.</p>

<p><a id="X7A2BF4527E08803C" name="X7A2BF4527E08803C"></a></p>

<h5>7.3-2 Centralizer</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Centralizer</code>( <var class="Arg">U</var>, <var class="Arg">V</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Normalizer</code>( <var class="Arg">U</var>, <var class="Arg">V</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsConjugate</code>( <var class="Arg">U</var>, <var class="Arg">V</var>, <var class="Arg">W</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>These three functions solve the conjugacy problem for subgroups and compute centralizers and normalizers of subgroups. The first two functions return subgroups of the input group <var class="Arg">U</var>, the third function returns a conjugating element or false if no such element exists.</p>

<p>The methods are based on the orbit stabilizer algorithms described in <a href="chapBib_mj.html#biBEic02">[Eic02]</a>. For nilpotent groups, an algorithm to solve the conjugacy problems for subgroups is described in <a href="chapBib_mj.html#biBLo98">[Lo98b]</a>.</p>

<p><a id="X851069107CACF98E" name="X851069107CACF98E"></a></p>

<h5>7.3-3 Intersection</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Intersection</code>( <var class="Arg">U</var>, <var class="Arg">N</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>A general method to compute intersections of subgroups of a pcp-group is described in <a href="chapBib_mj.html#biBEic01b">[Eic01a]</a>, but it is not yet implemented here. However, intersections of subgroups <span class="SimpleMath">\(U, N \leq G\)</span> can be computed if <span class="SimpleMath">\(N\)</span> is normalising <span class="SimpleMath">\(U\)</span>. See <a href="chapBib_mj.html#biBSims94">[Sim94]</a> for an outline of the algorithm.</p>

<p><a id="X7CF015E87A2B2388" name="X7CF015E87A2B2388"></a></p>

<h4>7.4 <span class="Heading">Finite subgroups</span></h4>

<p>There are various finite subgroups of interest in polycyclic groups. See <a href="chapBib_mj.html#biBEic00">[Eic00]</a> for a description of the algorithms underlying the functions in this section.</p>

<p><a id="X8036FA507A170DC4" name="X8036FA507A170DC4"></a></p>

<h5>7.4-1 TorsionSubgroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TorsionSubgroup</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>If the set of elements of finite order forms a subgroup, then we call it the <em>torsion subgroup</em>. This function determines the torsion subgroup of <var class="Arg">U</var>, if it exists, and returns fail otherwise. Note that a torsion subgroup does always exist if <var class="Arg">U</var> is nilpotent.</p>

<p><a id="X8082CD337972DC63" name="X8082CD337972DC63"></a></p>

<h5>7.4-2 NormalTorsionSubgroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NormalTorsionSubgroup</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Each polycyclic groups has a unique largest finite normal subgroup. This function computes it for <var class="Arg">U</var>.</p>

<p><a id="X86D92DA17DCE22DD" name="X86D92DA17DCE22DD"></a></p>

<h5>7.4-3 IsTorsionFree</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsTorsionFree</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>This function checks if <var class="Arg">U</var> is torsion free. It returns true or false.</p>

<p><a id="X819058217B4F3DC0" name="X819058217B4F3DC0"></a></p>

<h5>7.4-4 FiniteSubgroupClasses</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FiniteSubgroupClasses</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>There exist only finitely many conjugacy classes of finite subgroups in a polycyclic group <var class="Arg">U</var> and this function can be used to compute them. The algorithm underlying this function proceeds by working down a normal series of <var class="Arg">U</var> with elementary or free abelian factors. The following function can be used to give the algorithm a specific series.</p>

<p><a id="X7E7C32EA81A297B6" name="X7E7C32EA81A297B6"></a></p>

<h5>7.4-5 FiniteSubgroupClassesBySeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FiniteSubgroupClassesBySeries</code>( <var class="Arg">U</var>, <var class="Arg">pcps</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>

<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := ExamplesOfSomePcpGroups(15);</span>
Pcp-group with orders [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TorsionSubgroup(G);</span>
Pcp-group with orders [ 5, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NormalTorsionSubgroup(G);</span>
Pcp-group with orders [ 5, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsTorsionFree(G);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FiniteSubgroupClasses(G);</span>
[ Pcp-group with orders [ 5, 2 ]^G,
  Pcp-group with orders [ 2 ]^G,
  Pcp-group with orders [ 5 ]^G,
  Pcp-group with orders [  ]^G ]

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := DihedralPcpGroup( 0 );</span>
Pcp-group with orders [ 2, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TorsionSubgroup(G);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NormalTorsionSubgroup(G);</span>
Pcp-group with orders [  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsTorsionFree(G);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FiniteSubgroupClasses(G);</span>
[ Pcp-group with orders [ 2 ]^G,
  Pcp-group with orders [ 2 ]^G,
  Pcp-group with orders [  ]^G ]
</pre></div>

<p><a id="X7D9F737F80F6E396" name="X7D9F737F80F6E396"></a></p>

<h4>7.5 <span class="Heading">Subgroups of finite index and maximal subgroups</span></h4>

<p>Here we outline functions to determine various types of subgroups of finite index in polycyclic groups. Again, see <a href="chapBib_mj.html#biBEic00">[Eic00]</a> for a description of the algorithms underlying the functions in this section. Also, we refer to <a href="chapBib_mj.html#biBLo99">[Lo98a]</a> for an alternative approach.</p>

<p><a id="X87D62D497A8715FB" name="X87D62D497A8715FB"></a></p>

<h5>7.5-1 MaximalSubgroupClassesByIndex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MaximalSubgroupClassesByIndex</code>( <var class="Arg">U</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Each maximal subgroup of a polycyclic group <var class="Arg">U</var> has <var class="Arg">p</var>-power index for some prime <var class="Arg">p</var>. This function can be used to determine the conjugacy classes of all maximal subgroups of <var class="Arg">p</var>-power index for a given prime <var class="Arg">p</var>.</p>

<p><a id="X7800133F81BC7674" name="X7800133F81BC7674"></a></p>

<h5>7.5-2 LowIndexSubgroupClasses</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LowIndexSubgroupClasses</code>( <var class="Arg">U</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>There are only finitely many subgroups of a given index in a polycyclic group <var class="Arg">U</var>. This function computes conjugacy classes of all subgroups of index <var class="Arg">n</var> in <var class="Arg">U</var>.</p>

<p><a id="X7F7067C77F2DC32C" name="X7F7067C77F2DC32C"></a></p>

<h5>7.5-3 LowIndexNormalSubgroups</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LowIndexNormalSubgroups</code>( <var class="Arg">U</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>This function computes the normal subgroups of index <var class="Arg">n</var> in <var class="Arg">U</var>.</p>

<p><a id="X85A5BC447D83175F" name="X85A5BC447D83175F"></a></p>

<h5>7.5-4 NilpotentByAbelianNormalSubgroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NilpotentByAbelianNormalSubgroup</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function returns a normal subgroup <var class="Arg">N</var> of finite index in <var class="Arg">U</var> such that <var class="Arg">N</var> is nilpotent-by-abelian. Such a subgroup exists in every polycyclic group and this function computes such a subgroup using LowIndexNormal. However, we note that this function is not very efficient and the function NilpotentByAbelianByFiniteSeries may well be more efficient on this task.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := ExamplesOfSomePcpGroups(2);</span>
Pcp-group with orders [ 0, 0, 0, 0, 0, 0 ]

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MaximalSubgroupClassesByIndex( G, 61 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">max := List( last, Representative );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( max, x -&gt; Index( G, x ) );</span>
[ 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
  61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
  61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
  61, 61, 61, 61, 61, 61, 226981 ]

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LowIndexSubgroupClasses( G, 61 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">low := List( last, Representative );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( low, x -&gt; Index( G, x ) );</span>
[ 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
  61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
  61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
  61, 61, 61, 61, 61, 61 ]
</pre></div>

<p><a id="X785E0E877AB1D549" name="X785E0E877AB1D549"></a></p>

<h4>7.6 <span class="Heading">Further attributes for pcp-groups based on the Fitting subgroup</span></h4>

<p>In this section we provide a variety of other attributes for pcp-groups. Most of the methods below are based or related to the Fitting subgroup of the given group. We refer to <a href="chapBib_mj.html#biBEic01">[Eic01b]</a> for a description of the underlying methods.</p>

<p><a id="X780552B57C30DD8F" name="X780552B57C30DD8F"></a></p>

<h5>7.6-1 FittingSubgroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FittingSubgroup</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns the Fitting subgroup of <var class="Arg">U</var>; that is, the largest nilpotent normal subgroup of <var class="Arg">U</var>.</p>

<p><a id="X86BD63DC844731DF" name="X86BD63DC844731DF"></a></p>

<h5>7.6-2 IsNilpotentByFinite</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsNilpotentByFinite</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>checks whether the Fitting subgroup of <var class="Arg">U</var> has finite index.</p>

<p><a id="X847ABE6F781C7FE8" name="X847ABE6F781C7FE8"></a></p>

<h5>7.6-3 Centre</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Centre</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>returns the centre of <var class="Arg">U</var>.</p>

<p><a id="X861C36368435EB09" name="X861C36368435EB09"></a></p>

<h5>7.6-4 FCCentre</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FCCentre</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>returns the FC-centre of <var class="Arg">U</var>; that is, the subgroup containing all elements having a finite conjugacy class in <var class="Arg">U</var>.</p>

<p><a id="X7E75E2BC806746AC" name="X7E75E2BC806746AC"></a></p>

<h5>7.6-5 PolyZNormalSubgroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolyZNormalSubgroup</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns a normal subgroup <var class="Arg">N</var> of finite index in <var class="Arg">U</var>, such that <var class="Arg">N</var> has a polycyclic series with infinite factors only.</p>

<p><a id="X86800BF783E30D4A" name="X86800BF783E30D4A"></a></p>

<h5>7.6-6 NilpotentByAbelianByFiniteSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NilpotentByAbelianByFiniteSeries</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns a normal series <span class="SimpleMath">\(1 \leq F \leq A \leq U\)</span> such that <span class="SimpleMath">\(F\)</span> is nilpotent, <span class="SimpleMath">\(A/F\)</span> is abelian and <span class="SimpleMath">\(U/A\)</span> is finite. This series is computed using the Fitting subgroup and the centre of the Fitting factor.</p>

<p><a id="X878DBDC77CCA4F7E" name="X878DBDC77CCA4F7E"></a></p>

<h4>7.7 <span class="Heading">Functions for nilpotent groups</span></h4>

<p>There are (very few) functions which are available for nilpotent groups only. First, there are the different central series. These are available for all groups, but for nilpotent groups they terminate and provide series through the full group. Secondly, the determination of a minimal generating set is available for nilpotent groups only.</p>

<p><a id="X81D15723804771E2" name="X81D15723804771E2"></a></p>

<h5>7.7-1 MinimalGeneratingSet</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MinimalGeneratingSet</code>( <var class="Arg">U</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>

<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := ExamplesOfSomePcpGroups(14);</span>
Pcp-group with orders [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 0, 5, 5, 4, 0, 6,
  5, 5, 4, 0, 10, 6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsNilpotent(G);</span>
true

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PcpsBySeries( LowerCentralSeriesOfGroup(G));</span>
[ Pcp [ g1, g2 ] with orders [ 0, 0 ],
  Pcp [ g3 ] with orders [ 0 ],
  Pcp [ g4 ] with orders [ 0 ],
  Pcp [ g5 ] with orders [ 0 ],
  Pcp [ g6, g7 ] with orders [ 0, 0 ],
  Pcp [ g8 ] with orders [ 0 ],
  Pcp [ g9, g10 ] with orders [ 0, 0 ],
  Pcp [ g11, g12, g13 ] with orders [ 5, 4, 0 ],
  Pcp [ g14, g15, g16, g17, g18 ] with orders [ 5, 5, 4, 0, 6 ],
  Pcp [ g19, g20, g21, g22, g23, g24 ] with orders [ 5, 5, 4, 0, 10, 6 ] ]

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PcpsBySeries( UpperCentralSeriesOfGroup(G));</span>
[ Pcp [ g1, g2 ] with orders [ 0, 0 ],
  Pcp [ g3 ] with orders [ 0 ],
  Pcp [ g4 ] with orders [ 0 ],
  Pcp [ g5 ] with orders [ 0 ],
  Pcp [ g6, g7 ] with orders [ 0, 0 ],
  Pcp [ g8 ] with orders [ 0 ],
  Pcp [ g9, g10 ] with orders [ 0, 0 ],
  Pcp [ g11, g12, g13 ] with orders [ 5, 4, 0 ],
  Pcp [ g14, g15, g16, g17, g18 ] with orders [ 5, 5, 4, 0, 6 ],
  Pcp [ g19, g20, g21, g22, g23, g24 ] with orders [ 5, 5, 4, 0, 10, 6 ] ]

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MinimalGeneratingSet(G);</span>
[ g1, g2 ]
</pre></div>

<p><a id="X8640F9D47A1F7434" name="X8640F9D47A1F7434"></a></p>

<h4>7.8 <span class="Heading">Random methods for pcp-groups</span></h4>

<p>Below we introduce a function which computes orbit and stabilizer using a random method. This function tries to approximate the orbit and the stabilizer, but the returned orbit or stabilizer may be incomplete. This function is used in the random methods to compute normalizers and centralizers. Note that deterministic methods for these purposes are also available.</p>

<p><a id="X7E5FE3E879D4E6BF" name="X7E5FE3E879D4E6BF"></a></p>

<h5>7.8-1 RandomCentralizerPcpGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RandomCentralizerPcpGroup</code>( <var class="Arg">U</var>, <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RandomCentralizerPcpGroup</code>( <var class="Arg">U</var>, <var class="Arg">V</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RandomNormalizerPcpGroup</code>( <var class="Arg">U</var>, <var class="Arg">V</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>

<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := DihedralPcpGroup(0);</span>
Pcp-group with orders [ 2, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats := [[[-1, 0],[0,1]], [[1,1],[0,1]]];</span>
[ [ [ -1, 0 ], [ 0, 1 ] ], [ [ 1, 1 ], [ 0, 1 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pcp := Pcp(G);</span>
Pcp [ g1, g2 ] with orders [ 2, 0 ]

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomPcpOrbitStabilizer( [1,0], pcp, mats, OnRight ).stab;</span>
#I  Orbit longer than limit: exiting.
[  ]

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := Igs(G)[1];</span>
g1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomCentralizerPcpGroup( G, g );</span>
#I  Stabilizer not increasing: exiting.
Pcp-group with orders [ 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Igs(last);</span>
[ g1 ]
</pre></div>

<p><a id="X824142B784453DB9" name="X824142B784453DB9"></a></p>

<h4>7.9 <span class="Heading">Non-abelian tensor product and Schur extensions</span></h4>

<p><a id="X79EF28D9845878C9" name="X79EF28D9845878C9"></a></p>

<h5>7.9-1 SchurExtension</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SchurExtension</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">G</var> be a polycyclic group with a polycyclic generating sequence consisting of <span class="SimpleMath">\(n\)</span> elements. This function computes the largest central extension <var class="Arg">H</var> of <var class="Arg">G</var> such that <var class="Arg">H</var> is generated by <span class="SimpleMath">\(n\)</span> elements. If <span class="SimpleMath">\(F/R\)</span> is the underlying polycyclic presentation for <var class="Arg">G</var>, then <var class="Arg">H</var> is isomorphic to <span class="SimpleMath">\(F/[R,F]\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := DihedralPcpGroup( 0 );</span>
Pcp-group with orders [ 2, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Centre( G );</span>
Pcp-group with orders [  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := SchurExtension( G );</span>
Pcp-group with orders [ 2, 0, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Centre( H );</span>
Pcp-group with orders [ 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H/Centre(H);</span>
Pcp-group with orders [ 2, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Subgroup( H, [H.1,H.2] ) = H;</span>
true
</pre></div>

<p><a id="X84B60EC978A9A05E" name="X84B60EC978A9A05E"></a></p>

<h5>7.9-2 SchurExtensionEpimorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SchurExtensionEpimorphism</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns the projection from the Schur extension <span class="SimpleMath">\(G^{*}\)</span> of <var class="Arg">G</var> onto <var class="Arg">G</var>. See the function <code class="code">SchurExtension</code>. The kernel of this epimorphism is the direct product of the Schur multiplicator of <var class="Arg">G</var> and a direct product of <span class="SimpleMath">\(n\)</span> copies of <span class="SimpleMath">\(ℤ\)</span> where <span class="SimpleMath">\(n\)</span> is the number of generators in the polycyclic presentation for <var class="Arg">G</var>. The Schur multiplicator is the intersection of the kernel and the derived group of the source. See also the function <code class="code">SchurCover</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gl23 := Range( IsomorphismPcpGroup( GL(2,3) ) );</span>
Pcp-group with orders [ 2, 3, 2, 2, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SchurExtensionEpimorphism( gl23 );</span>
[ g1, g2, g3, g4, g5, g6, g7, g8, g9, g10 ] -&gt; [ g1, g2, g3, g4, g5,
id, id, id, id, id ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Kernel( last );</span>
Pcp-group with orders [ 0, 0, 0, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AbelianInvariantsMultiplier( gl23 );</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Intersection( Kernel(epi), DerivedSubgroup( Source(epi) ) );</span>
[  ]
</pre></div>

<p>There is a crossed pairing from <var class="Arg">G</var> into <span class="SimpleMath">\((G^{*})'\)</span> which can be defined via this epimorphism:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := DihedralPcpGroup(0);</span>
Pcp-group with orders [ 2, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">epi := SchurExtensionEpimorphism( G );</span>
[ g1, g2, g3, g4 ] -&gt; [ g1, g2, id, id ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreImagesRepresentative( epi, G.1 );</span>
g1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreImagesRepresentative( epi, G.2 );</span>
g2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Comm( last, last2 );</span>
g2^-2*g4
</pre></div>

<p><a id="X7DD1E37987612042" name="X7DD1E37987612042"></a></p>

<h5>7.9-3 SchurCover</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SchurCover</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>computes a Schur covering group of the polycyclic group <var class="Arg">G</var>. A Schur covering is a largest central extension <var class="Arg">H</var> of <var class="Arg">G</var> such that the kernel <var class="Arg">M</var> of the projection of <var class="Arg">H</var> onto <var class="Arg">G</var> is contained in the commutator subgroup of <var class="Arg">H</var>.</p>

<p>If <var class="Arg">G</var> is given by a presentation <span class="SimpleMath">\(F/R\)</span>, then <var class="Arg">M</var> is isomorphic to the subgroup <span class="SimpleMath">\(R \cap [F,F] / [R,F]\)</span>. Let <span class="SimpleMath">\(C\)</span> be a complement to <span class="SimpleMath">\(R \cap [F,F] / [R,F]\)</span> in <span class="SimpleMath">\(R/[R,F]\)</span>. Then <span class="SimpleMath">\(F/C\)</span> is isomorphic to <var class="Arg">H</var> and <span class="SimpleMath">\(R/C\)</span> is isomorphic to <var class="Arg">M</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := AbelianPcpGroup( 3,[] );</span>
Pcp-group with orders [ 0, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ext := SchurCover( G );</span>
Pcp-group with orders [ 0, 0, 0, 0, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Centre( ext );</span>
Pcp-group with orders [ 0, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubgroup( DerivedSubgroup( ext ), last );</span>
true
</pre></div>

<p><a id="X792BC39D7CEB1D27" name="X792BC39D7CEB1D27"></a></p>

<h5>7.9-4 AbelianInvariantsMultiplier</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AbelianInvariantsMultiplier</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>returns a list of the abelian invariants of the Schur multiplier of G.</p>

<p>Note that the Schur multiplicator of a polycyclic group is a finitely generated abelian group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := DihedralPcpGroup( 0 );</span>
Pcp-group with orders [ 2, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DirectProduct( G, AbelianPcpGroup( 2, [] ) );</span>
Pcp-group with orders [ 0, 0, 2, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AbelianInvariantsMultiplier( last );</span>
[ 0, 2, 2, 2, 2 ]
</pre></div>

<p><a id="X822ED5978647C93B" name="X822ED5978647C93B"></a></p>

<h5>7.9-5 NonAbelianExteriorSquareEpimorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NonAbelianExteriorSquareEpimorphism</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns the epimorphism of the non-abelian exterior square of a polycyclic group <var class="Arg">G</var> onto the derived group of <var class="Arg">G</var>. The non-abelian exterior square can be defined as the derived subgroup of a Schur cover of <var class="Arg">G</var>. The isomorphism type of the non-abelian exterior square is unique despite the fact that the isomorphism type of a Schur cover of a polycyclic groups need not be unique. The derived group of a Schur cover has a natural projection onto the derived group of <var class="Arg">G</var> which is what the function returns.</p>

<p>The kernel of the epimorphism is isomorphic to the Schur multiplicator of <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := ExamplesOfSomePcpGroups( 3 );</span>
Pcp-group with orders [ 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := DirectProduct( G,G );</span>
Pcp-group with orders [ 0, 0, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AbelianInvariantsMultiplier( G );</span>
[ [ 0, 1 ], [ 2, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">epi := NonAbelianExteriorSquareEpimorphism( G );</span>
[ g2^-2*g5, g4^-2*g10, g6, g7, g8, g9 ] -&gt; [ g2^-2, g4^-2, id, id, id, id ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Kernel( epi );</span>
Pcp-group with orders [ 0, 2, 2, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Collected( AbelianInvariants( last ) );</span>
[ [ 0, 1 ], [ 2, 3 ] ]
</pre></div>

<p><a id="X8739CD4686301A0E" name="X8739CD4686301A0E"></a></p>

<h5>7.9-6 NonAbelianExteriorSquare</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NonAbelianExteriorSquare</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>computes the non-abelian exterior square of a polycylic group <var class="Arg">G</var>. See the explanation for <code class="code">NonAbelianExteriorSquareEpimorphism</code>. The natural projection of the non-abelian exterior square onto the derived group of <var class="Arg">G</var> is stored in the component <code class="code">!.epimorphism</code>.</p>

<p>There is a crossed pairing from <var class="Arg">G</var> into <span class="SimpleMath">\(G\wedge G\)</span>. See the function <code class="code">SchurExtensionEpimorphism</code> for details. The crossed pairing is stored in the component <code class="code">!.crossedPairing</code>. This is the crossed pairing <span class="SimpleMath">\(\lambda\)</span> in <a href="chapBib_mj.html#biBEickNickel07">[EN08]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := DihedralPcpGroup(0);</span>
Pcp-group with orders [ 2, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GwG := NonAbelianExteriorSquare( G );</span>
Pcp-group with orders [ 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lambda := GwG!.crossedPairing;</span>
function( g, h ) ... end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lambda( G.1, G.2 );</span>
g2^2*g4^-1
</pre></div>

<p><a id="X86553D7B7DABF38F" name="X86553D7B7DABF38F"></a></p>

<h5>7.9-7 NonAbelianTensorSquareEpimorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NonAbelianTensorSquareEpimorphism</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns for a polycyclic group <var class="Arg">G</var> the projection of the non-abelian tensor square <span class="SimpleMath">\(G\otimes G\)</span> onto the non-abelian exterior square <span class="SimpleMath">\(G\wedge G\)</span>. The range of that epimorphism has the component <code class="code">!.epimorphism</code> set to the projection of the non-abelian exterior square onto the derived group of <var class="Arg">G</var>. See also the function <code class="code">NonAbelianExteriorSquare</code>.</p>

<p>With the result of this function one can compute the groups in the commutative diagram at the beginning of the paper <a href="chapBib_mj.html#biBEickNickel07">[EN08]</a>. The kernel of the returned epimorphism is the group <span class="SimpleMath">\(\nabla(G)\)</span>. The kernel of the composition of this epimorphism and the above mention projection onto <span class="SimpleMath">\(G'\)</span> is the group <span class="SimpleMath">\(J(G)\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := DihedralPcpGroup(0);</span>
Pcp-group with orders [ 2, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := DirectProduct(G,G);</span>
Pcp-group with orders [ 2, 0, 2, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := NonAbelianTensorSquareEpimorphism( G );</span>
[ g9*g25^-1, g10*g26^-1, g11*g27, g12*g28, g13*g29, g14*g30, g15, g16,
g17,
  g18, g19, g20, g21, g22, g23, g24 ] -&gt; [ g2^-2*g6, g4^-2*g12, g8,
  g9, g10,
  g11, id, id, id, id, id, id, id, id, id, id ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := Range( alpha )!.epimorphism;</span>
[ g2^-2*g6, g4^-2*g12, g8, g9, g10, g11 ] -&gt; [ g2^-2, g4^-2, id, id,
id, id ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">JG := Kernel( alpha * gamma );</span>
Pcp-group with orders [ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Image( alpha, JG );</span>
Pcp-group with orders [ 2, 2, 2, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AbelianInvariantsMultiplier( G );</span>
[ [ 2, 4 ] ]
</pre></div>

<p><a id="X7C0DF7C97F78C666" name="X7C0DF7C97F78C666"></a></p>

<h5>7.9-8 NonAbelianTensorSquare</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NonAbelianTensorSquare</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>computes for a polycyclic group <var class="Arg">G</var> the non-abelian tensor square <span class="SimpleMath">\(G\otimes G\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := AlternatingGroup( IsPcGroup, 4 );</span>
&lt;pc group of size 12 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PcGroupToPcpGroup( G );</span>
Pcp-group with orders [ 3, 2, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NonAbelianTensorSquare( last );</span>
Pcp-group with orders [ 2, 2, 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PcpGroupToPcGroup( last );</span>
&lt;pc group of size 24 with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DirectFactorsOfGroup( last );</span>
[ Group([ f1, f2, f3 ]), Group([ f4 ]) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( last, Size );</span>
[ 8, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdGroup( last2[1] );</span>
[ 8, 4 ]       # the quaternion group of Order 8

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := DihedralPcpGroup( 0 );</span>
Pcp-group with orders [ 2, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ten := NonAbelianTensorSquare( G );</span>
Pcp-group with orders [ 0, 2, 2, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAbelian( ten );</span>
true
</pre></div>

<p><a id="X7AE75EC1860FFE7A" name="X7AE75EC1860FFE7A"></a></p>

<h5>7.9-9 NonAbelianExteriorSquarePlusEmbedding</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NonAbelianExteriorSquarePlusEmbedding</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns an embedding from the non-abelian exterior square <span class="SimpleMath">\(G\wedge G\)</span> into an extensions of <span class="SimpleMath">\(G\wedge G\)</span> by <span class="SimpleMath">\(G\times G\)</span>. For the significance of the group see the paper <a href="chapBib_mj.html#biBEickNickel07">[EN08]</a>. The range of the epimorphism is the group <span class="SimpleMath">\(\tau(G)\)</span> in that paper.</p>

<p><a id="X7D96C84E87925B0F" name="X7D96C84E87925B0F"></a></p>

<h5>7.9-10 NonAbelianTensorSquarePlusEpimorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NonAbelianTensorSquarePlusEpimorphism</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns an epimorphisms of <span class="SimpleMath">\(\nu(G)\)</span> onto <span class="SimpleMath">\(\tau(G)\)</span>. The group <span class="SimpleMath">\(\nu(G)\)</span> is an extension of the non-abelian tensor square <span class="SimpleMath">\(G\otimes G\)</span> of <span class="SimpleMath">\(G\)</span> by <span class="SimpleMath">\(G\times G\)</span>. The group <span class="SimpleMath">\(\tau(G)\)</span> is an extension of the non-abelian exterior square <span class="SimpleMath">\(G\wedge G\)</span> by <span class="SimpleMath">\(G\times G\)</span>. For details see <a href="chapBib_mj.html#biBEickNickel07">[EN08]</a>.</p>

<p><a id="X8746533787C4E8BC" name="X8746533787C4E8BC"></a></p>

<h5>7.9-11 NonAbelianTensorSquarePlus</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NonAbelianTensorSquarePlus</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns the group <span class="SimpleMath">\(\nu(G)\)</span> in <a href="chapBib_mj.html#biBEickNickel07">[EN08]</a>.</p>

<p><a id="X78F9184078B2761A" name="X78F9184078B2761A"></a></p>

<h5>7.9-12 WhiteheadQuadraticFunctor</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WhiteheadQuadraticFunctor</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>returns Whitehead's universal quadratic functor of <span class="SimpleMath">\(G\)</span>, see <a href="chapBib_mj.html#biBEickNickel07">[EN08]</a> for a description.</p>

<p><a id="X7D3023697BA5CE5A" name="X7D3023697BA5CE5A"></a></p>

<h4>7.10 <span class="Heading">Schur covers</span></h4>

<p>This section contains a function to determine the Schur covers of a finite <span class="SimpleMath">\(p\)</span>-group up to isomorphism.</p>

<p><a id="X7D90B44E7B96AFF1" name="X7D90B44E7B96AFF1"></a></p>

<h5>7.10-1 SchurCovers</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SchurCovers</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">G</var> be a finite <span class="SimpleMath">\(p\)</span>-group defined as a pcp group. This function returns a complete and irredundant set of isomorphism types of Schur covers of <var class="Arg">G</var>. The algorithm implements a method of Nickel's Phd Thesis.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap6_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap8_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chapA_mj.html">A</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
