<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (LieRing) - Chapter 2: The functions</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap2"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap2_mj.html">[MathJax on]</a></p>
<p><a id="X8173135A7D187358" name="X8173135A7D187358"></a></p>
<div class="ChapSects"><a href="chap2.html#X8173135A7D187358">2 <span class="Heading">The functions</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X865892E97C9D1E6D">2.1 <span class="Heading">The free Lie ring</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7E52D2B884457822">2.1-1 FreeLieRing</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X826A861E7E7D944E">2.1-2 Degree</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7BDAF9F47EBC6C0E">2.2 <span class="Heading"> Creating Lie rings </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X784B8B28809EAC37">2.2-1 IsLieRing</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7DEFFA797BB7E432">2.2-2 LieRingByStructureConstants</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7D58E7AB7B2788D2">2.2-3 FpLieRing</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7D2CC3FF80F73EF8">2.2-4 FpLieAlgebra</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7876A08584CBABAE">2.3 <span class="Heading"> Working with Lie rings </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X837BE54C80DE368E">2.3-1 Basis</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X804ADF0280F67CDC">2.3-2 StructureConstantsTable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7BF95CA07861A1AF">2.3-3 Torsion</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X80B32F667BF6AFD8">2.3-4 Coefficients</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7BC3398686B25634">2.3-5 SubLieRing</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7E97DBD778358F19">2.3-6 LieRingIdeal</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X83D53D98809EC461">2.3-7 NaturalHomomorphismByIdeal</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7900D17E7BA26A48">2.3-8 LieLowerCentralSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X790A24857D0E559A">2.3-9 LieLowerPCentralSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X8111F58E7DE3E25C">2.3-10 LieCentre</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X819C15027E16E335">2.3-11 TensorWithField</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7994DA6587ABDA2D">2.4 <span class="Heading">The Lazard correspondence</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X81FC256983DC2A94">2.4-1 PGroupToLieRing</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7E683E5F80B27375">2.4-2 LieRingToPGroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7CB9E82C84258435">2.5 <span class="Heading">The database of <span class="SimpleMath">n</span>-Engel Lie rings</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7F6C2B1D82E381D0">2.5-1 SmallNEngelLieRing</a></span>
</div></div>
</div>

<h3>2 <span class="Heading">The functions</span></h3>

<p><a id="X865892E97C9D1E6D" name="X865892E97C9D1E6D"></a></p>

<h4>2.1 <span class="Heading">The free Lie ring</span></h4>

<p><a id="X7E52D2B884457822" name="X7E52D2B884457822"></a></p>

<h5>2.1-1 FreeLieRing</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FreeLieRing</code>( <var class="Arg">R</var>, <var class="Arg">names</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FreeLieRing</code>( <var class="Arg">R</var>, <var class="Arg">names</var>, <var class="Arg">deg</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FreeLieRing</code>( <var class="Arg">R</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FreeLieRing</code>( <var class="Arg">R</var>, <var class="Arg">k</var>, <var class="Arg">deg</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">R</var> is a ring, which has to be either the integers, or a field. <var class="Arg">names</var> is a list of strings, which will be the names of the generators. This function returns the free Lie ring over <var class="Arg">R</var>, with generators named as in <var class="Arg">names </var>. If <var class="Arg">L</var> denotes the output, then <var class="Arg">L.i</var> will be the i-th generator. If a third argument <var class="Arg">deg</var> is given then this must be a list of positive integers. Then each generator will have a degree equal to the corresponding element of the list <var class="Arg">deg</var>.</p>

<p>Monomials in the free Lie ring of the form <span class="SimpleMath">(a,b)</span> with <span class="SimpleMath">a&gt;b</span> are automatically rewritten as <span class="SimpleMath">-(b,a)</span>. Monomials of the form <span class="SimpleMath">(a,a)</span> are rewritten as zero. There is no other rewriting done. Therefore, the object returned by this function is strictly speaking not the same as the free Lie ring, it rather is the free anticommutative algebra.</p>

<p>Monomials in the free Lie ring are printed as bracketed expressions. In a printed element the monomials appear in increasing order; in particular the last monomial is the leading monomial.</p>

<p>If instead of the list <var class="Arg">names</var> a positive integer <var class="Arg">k</var> is given, then the free Lie ring on that number of generators is returned. Again we can give each generator a degree different from 1 by adding a third argument <var class="Arg">deg</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= FreeLieRing( Integers, ["a","b"] );</span>
&lt;Free algebra over Integers generators: a, b &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a:= L.1; b:= L.2;</span>
a
b
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">(a*b)*b+2*a*b;       </span>
(2)*(a,b)+(-1)*(b,(a,b))
</pre></div>

<p><a id="X826A861E7E7D944E" name="X826A861E7E7D944E"></a></p>

<h5>2.1-2 Degree</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Degree</code>( <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">f</var> is an element of a free Lie ring. Its degree is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= FreeLieRing( Integers, ["a","b"] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a:= L.1;; b:= L.2;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f:=(a*b)*b+2*a*b;</span>
(2)*(a,b)+(-1)*(b,(a,b))
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Degree(f);</span>
3
</pre></div>

<p><a id="X7BDAF9F47EBC6C0E" name="X7BDAF9F47EBC6C0E"></a></p>

<h4>2.2 <span class="Heading"> Creating Lie rings </span></h4>

<p>The package can deal with finite-dimensional Lie rings given by a multiplication table (which follow the format for multiplication tables in the <strong class="pkg">GAP</strong> library), and a list of moduli. This list has to have the same length as the number of basis elements of the Lie ring. If the i-th element of this list is <span class="SimpleMath">m</span> then the additive order of the i-th basis edlement if <span class="SimpleMath">m</span>. If <span class="SimpleMath">m=0</span> then the additive order is infinite.</p>

<p><a id="X784B8B28809EAC37" name="X784B8B28809EAC37"></a></p>

<h5>2.2-1 IsLieRing</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLieRing</code></td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>This is the category of finite-dimensional Lie rings.</p>

<p><a id="X7DEFFA797BB7E432" name="X7DEFFA797BB7E432"></a></p>

<h5>2.2-2 LieRingByStructureConstants</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieRingByStructureConstants</code>( <var class="Arg">tor</var>, <var class="Arg">T</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">T</var> is a multiplication table, and <var class="Arg">tor</var> is a list of moduli. This function returns the corresponding Lie ring. In the example below we create the Lie ring with basis elements <span class="SimpleMath">x,y,z</span>, with <span class="SimpleMath">[x,y]=z</span>, <span class="SimpleMath">3x=6y=3z=0</span>.</p>

<p>The multiplication table has to be created using the <strong class="pkg">GAP</strong> functions for constructing multiplication tables of Lie algebras. In particular, we refer to the <strong class="pkg">GAP</strong> reference manual for descriptions of the functions <code class="func">EmptySCTable</code> (<a href="../../../doc/ref/chap62_mj.html#X7F1203A1793411DF"><span class="RefLink">Reference: EmptySCTable</span></a>) <code class="func">SetEntrySCTable</code> (<a href="../../../doc/ref/chap62_mj.html#X817BD086876EC1C4"><span class="RefLink">Reference: SetEntrySCTable</span></a>)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T:= EmptySCTable( 3, 0, "antisymmetric" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetEntrySCTable( T, 1, 2, [1,3] );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LieRingByStructureConstants( [3,6,3], T );</span>
&lt;Lie ring with 3 generators&gt;
</pre></div>

<p><a id="X7D58E7AB7B2788D2" name="X7D58E7AB7B2788D2"></a></p>

<h5>2.2-3 FpLieRing</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FpLieRing</code>( <var class="Arg">L</var>, <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">L</var> is a free Lie ring defined over the integers, and <var class="Arg">R</var> is a set of elements of <var class="Arg">L</var>. This function returns the Lie ring given by structure constants, that is isomorphic to <var class="Arg">L</var> modulo the ideal generated by <var class="Arg">R</var>.</p>

<p>It is possible to set the option <var class="Arg">maxdeg</var> to a positive value <var class="Arg">d</var>. Then a nilpotent quotient is computed, i.e., all elements of <var class="Arg">L</var> of degree strictly greater than <var class="Arg">d</var> will be treated as relations.</p>

<p>The algebra that is output by this function has an attribute, <var class="Arg">CanonicalProjection</var>, which is a function mapping elements of the free Lie ring <var class="Arg">L</var> to their projections in the output algebra.</p>

<p>The algorithm behind this function has been described in <a href="chapBib.html#biBcicgra1">[CdG07]</a> and <a href="chapBib.html#biBcicgra2">[CdG09]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= FreeLieRing( Integers, ["x","y"], [1,2] );                   </span>
&lt;Free algebra over Integers generators: x, y &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:= L.1;; y:= L.2;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= [((y*x)*x)*x-6*(y*x)*y, 3*((((y*x)*x)*x)*x)*x-20*(((y*x)*x)*x)*y ];</span>
[ (-1)*(x,(x,(x,y)))+(-6)*(y,(x,y)), 
  (-3)*(x,(x,(x,(x,(x,y)))))+(-20)*(y,(x,(x,(x,y)))) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K:= FpLieRing( L, R : maxdeg:= 15 );</span>
&lt;Lie ring with 75 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f:=CanonicalProjection(K);</span>
function( elm ) ... end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f(R[1]);</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f(x);</span>
v_1
</pre></div>

<p><a id="X7D2CC3FF80F73EF8" name="X7D2CC3FF80F73EF8"></a></p>

<h5>2.2-4 FpLieAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FpLieAlgebra</code>( <var class="Arg">L</var>, <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This is similar to <var class="Arg">FpLieRing</var>, with the difference that the free Lie ring <var class="Arg">L</var> must be defined over a field. Then the algorithms become a lot faster (in most cases). The result however is a Lie algebra, and not a Lie ring.</p>

<p><a id="X7876A08584CBABAE" name="X7876A08584CBABAE"></a></p>

<h4>2.3 <span class="Heading"> Working with Lie rings </span></h4>

<p><a id="X837BE54C80DE368E" name="X837BE54C80DE368E"></a></p>

<h5>2.3-1 Basis</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Basis</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">L</var> a Lie ring. Its basis is returned.</p>

<p>We note that in <strong class="pkg">LieRing</strong> Lie rings have one basis that is computed by the system; one should not try to set a basis.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T:= EmptySCTable( 3, 0, "antisymmetric" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetEntrySCTable( T, 1, 2, [1,3] );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K:= LieRingByStructureConstants( [3,6,3], T );</span>
&lt;Lie ring with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Basis(K); </span>
Basis( &lt;Lie ring with 3 generators&gt;, [ v_1, v_2, v_3 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BasisVectors( Basis(K) );</span>
[ v_1, v_2, v_3 ]
</pre></div>

<p><a id="X804ADF0280F67CDC" name="X804ADF0280F67CDC"></a></p>

<h5>2.3-2 StructureConstantsTable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StructureConstantsTable</code>( <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">B</var> is the basis of a Lie ring. Its structure constants table is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T:= EmptySCTable( 3, 0, "antisymmetric" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetEntrySCTable( T, 1, 2, [1,3] );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K:= LieRingByStructureConstants( [3,6,3], T );</span>
&lt;Lie ring with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureConstantsTable( Basis(K) );</span>
[ [ [ [  ], [  ] ], [ [ 3 ], [ 1 ] ], [ [  ], [  ] ] ], 
  [ [ [ 3 ], [ -1 ] ], [ [  ], [  ] ], [ [  ], [  ] ] ], 
  [ [ [  ], [  ] ], [ [  ], [  ] ], [ [  ], [  ] ] ], -1, 0 ]
</pre></div>

<p><a id="X7BF95CA07861A1AF" name="X7BF95CA07861A1AF"></a></p>

<h5>2.3-3 Torsion</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Torsion</code>( <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">B</var> is the basis of a Lie ring. The list of torsion moduli of its basis elements is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T:= EmptySCTable( 3, 0, "antisymmetric" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetEntrySCTable( T, 1, 2, [1,3] );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K:= LieRingByStructureConstants( [3,6,3], T );</span>
&lt;Lie ring with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Torsion( Basis(K) );</span>
[ 3, 6, 3 ]
</pre></div>

<p><a id="X80B32F667BF6AFD8" name="X80B32F667BF6AFD8"></a></p>

<h5>2.3-4 Coefficients</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Coefficients</code>( <var class="Arg">B</var>, <var class="Arg">elm</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">B</var> is the basis of a Lie ring, and <var class="Arg">elm</var> is an element of the same Lie ring. The coefficients of <var class="Arg">elm</var> with respect to <var class="Arg">B</var> are returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= FreeLieRing( Integers, ["x","y"] );; x:= L.1;; y:= L.2;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rr:=[((y*x)*x)*x-6*(y*x)*y, 3*((((y*x)*x)*x)*x)*x-20*(((y*x)*x)*x)*y ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K:= FpLieRing( L, rr : maxdeg:= 6 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C:=LieCentre(K);</span>
&lt;Lie ring with 9 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Coefficients( Basis(K), Basis(C)[6] );</span>
[ 5, 5, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Coefficients( Basis(C), Basis(C)[6] );</span>
[ 0, 0, 0, 0, 0, 1, 0, 0, 0 ]
</pre></div>

<p><a id="X7BC3398686B25634" name="X7BC3398686B25634"></a></p>

<h5>2.3-5 SubLieRing</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SubLieRing</code>( <var class="Arg">L</var>, <var class="Arg">gens</var>[, <var class="Arg">string</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">L</var> is a Lie ring, and <var class="Arg">gens</var> a list of elements of <var class="Arg">L</var>. This function constructs the subring generated by the elements in <var class="Arg">gens</var>. If these elements are known to form a basis of the subalgebra, then as a third argument the string <var class="Arg">"basis"</var> can be added. That makes the execution of the function a lot faster.</p>

<p>This function depends on hermite and Smith normal form computations. Therefore in practice, for bigger inputs, it can be slow.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= FreeLieRing( Integers, ["x","y"] );;                         </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:= L.1;; y:= L.2;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rr:=[((y*x)*x)*x-6*(y*x)*y, 3*((((y*x)*x)*x)*x)*x-20*(((y*x)*x)*x)*y ];; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K:= FpLieRing( L, rr : maxdeg:= 8 );</span>
&lt;Lie ring with 41 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b:= Basis(K);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M:= SubLieRing( K, [ b[30], b[40] ] );</span>
&lt;Lie ring with 6 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Torsion(Basis(M));</span>
[ 3, 6, 6, 12, 360, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Basis(M)[2];</span>
3*v_2+2*v_3+2*v_10+4*v_12+4*v_13+5*v_14+v_15+3*v_17+3*v_18+6*v_20+10*v_22+6*v_
24+6*v_25+10*v_26+4*v_27+18*v_28+30*v_29+60*v_30+360*v_31+5040*v_32
</pre></div>

<p><a id="X7E97DBD778358F19" name="X7E97DBD778358F19"></a></p>

<h5>2.3-6 LieRingIdeal</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieRingIdeal</code>( <var class="Arg">L</var>, <var class="Arg">gens</var>[, <var class="Arg">string</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>This is the same as <var class="Arg">SubLieRing</var> except that the output is an ideal (on the level of data structures that is the same as a Lie subring).</p>

<p><a id="X83D53D98809EC461" name="X83D53D98809EC461"></a></p>

<h5>2.3-7 NaturalHomomorphismByIdeal</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NaturalHomomorphismByIdeal</code>( <var class="Arg">L</var>, <var class="Arg">I</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">L</var> is a Lie ring, and <var class="Arg">I</var> an ideal of <var class="Arg">L</var>. This function constructs the canonical projection of <var class="Arg">L</var> on the quotient of <var class="Arg">L</var> by <var class="Arg">I</var>.</p>

<p>We remark that it is <em>not checked</em> whether <var class="Arg">I</var> is an ideal or not. if <var class="Arg">I</var> is just a subalgebra, then nothing is guaranteed about the result of this function.</p>

<p>Also this function depends on Smith normal form computations; therefore it can be slow on bigger inputs.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= FreeLieRing( Integers, ["x","y"] );;                         </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:= L.1;; y:= L.2;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rr:=[((y*x)*x)*x-6*(y*x)*y, 3*((((y*x)*x)*x)*x)*x-20*(((y*x)*x)*x)*y ];; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K:= FpLieRing( L, rr : maxdeg:= 8 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b:= Basis(K);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">I:= LieRingIdeal( K, [ b[29] ] );</span>
&lt;Lie ring with 23 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f:= NaturalHomomorphismByIdeal( K, I );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M:= Range(f);</span>
&lt;Lie ring with 27 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Torsion(Basis(M));</span>
[ 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6, 6, 12, 12, 12, 120, 720, 10080, 0, 0, 0, 
  0, 0, 0, 0, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Image( f, b[30] );</span>
v_16+716*v_17
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreImagesRepresentative( f, Basis(M)[10] );</span>
4*v_2+4*v_3+4*v_4+4*v_5+5*v_6+v_7+5*v_8+v_9+5*v_10+v_11+5*v_12+v_13+5*v_14+v_
24+v_25+11*v_26+v_29+10*v_30+100*v_31
</pre></div>

<p><a id="X7900D17E7BA26A48" name="X7900D17E7BA26A48"></a></p>

<h5>2.3-8 LieLowerCentralSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieLowerCentralSeries</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">L</var> is a Lie ring. Its lower central series is returned.</p>

<p>This repeatedly constructs ideals of <var class="Arg">L</var>; therefore also this function can be rather slow on bigger inputs.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= FreeLieRing( Integers, ["x","y"] );; x:= L.1;; y:= L.2;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rr:=[((y*x)*x)*x-6*(y*x)*y, 3*((((y*x)*x)*x)*x)*x-20*(((y*x)*x)*x)*y ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K:= FpLieRing( L, rr : maxdeg:= 7 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LieLowerCentralSeries(K);</span>
[ &lt;Lie ring with 26 generators&gt;, &lt;Lie ring with 24 generators&gt;, 
  &lt;Lie ring with 23 generators&gt;, &lt;Lie ring with 22 generators&gt;, 
  &lt;Lie ring with 21 generators&gt;, &lt;Lie ring with 19 generators&gt;, 
  &lt;Lie ring with 16 generators&gt;, &lt;Lie ring with 0 generators&gt; ]
</pre></div>

<p><a id="X790A24857D0E559A" name="X790A24857D0E559A"></a></p>

<h5>2.3-9 LieLowerPCentralSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieLowerPCentralSeries</code>( <var class="Arg">L</var>, <var class="Arg">p</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">L</var> is a Lie ring, and <var class="Arg">p</var> is a prime. The lower <var class="Arg">p</var>-central series of <var class="Arg">L</var> is returned. This is the series where the <span class="SimpleMath">L^k+1</span> is generated by <span class="SimpleMath">[L,L^k]</span> and <span class="SimpleMath">pL^k</span>. Note that this may not be a finite series, if <span class="SimpleMath">L</span> is not of exponent <span class="SimpleMath">p^n</span> (as abelian group). The function does not check this; if the series is infinite, then it will loop forever.</p>

<p>This repeatedly constructs ideals of <var class="Arg">L</var>; therefore also this function can be rather slow on bigger inputs.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= FreeLieRing( Integers, ["x","y"] );; x:= L.1;; y:= L.2;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rr:=[((y*x)*x)*x-7*(y*x)*y, 7*((((y*x)*x)*x)*x)*x-49*(((y*x)*x)*x)*y, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">7*x, 49*y ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K:= FpLieRing( L, rr : maxdeg:= 5 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LieLowerPCentralSeries(K,7);</span>
[ &lt;Lie ring with 11 generators&gt;, &lt;Lie ring with 10 generators&gt;, 
  &lt;Lie ring with 8 generators&gt;, &lt;Lie ring with 6 generators&gt;, 
  &lt;Lie ring with 4 generators&gt;, &lt;Lie ring with 0 generators&gt; ]
</pre></div>

<p><a id="X8111F58E7DE3E25C" name="X8111F58E7DE3E25C"></a></p>

<h5>2.3-10 LieCentre</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieCentre</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">L</var> is a Lie ring. Its centre is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= FreeLieRing( Integers, ["x","y"] );; x:= L.1;; y:= L.2;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rr:=[((y*x)*x)*x-6*(y*x)*y, 3*((((y*x)*x)*x)*x)*x-20*(((y*x)*x)*x)*y ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K:= FpLieRing( L, rr : maxdeg:= 7 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LieCentre(K);</span>
&lt;Lie ring with 16 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Torsion( Basis(K) );</span>
[ 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 12, 12, 12, 12, 360, 5040, 0, 0, 0, 0, 
  0, 0, 0, 0 ]
</pre></div>

<p><a id="X819C15027E16E335" name="X819C15027E16E335"></a></p>

<h5>2.3-11 TensorWithField</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TensorWithField</code>( <var class="Arg">L</var>, <var class="Arg">F</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">L</var> is a Lie ring, and <var class="Arg">F</var> is a field. This function returns the Lie algebra that is obtained by tensoring <var class="Arg">L</var> with <var class="Arg">F</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T:= EmptySCTable( 3, 0, "antisymmetric" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetEntrySCTable( T, 1, 2, [1,3] );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K:= LieRingByStructureConstants( [3,6,3], T );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TensorWithField( K, GF(3) );</span>
&lt;Lie algebra of dimension 3 over GF(3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TensorWithField( K, GF(2) );</span>
&lt;Lie algebra of dimension 1 over GF(2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dimension( TensorWithField( K, GF(5) ) );</span>
0
</pre></div>

<p><a id="X7994DA6587ABDA2D" name="X7994DA6587ABDA2D"></a></p>

<h4>2.4 <span class="Heading">The Lazard correspondence</span></h4>

<p>By the Lazard correspondence we can put a Lie ring structure on a <span class="SimpleMath">p</span>-group of class <span class="SimpleMath">&lt;p</span>. Conversely, we can define a group structure on a nilpotent Lie ring of order <span class="SimpleMath">p^n</span> and class <span class="SimpleMath">&lt;p</span>. The package contains functions for doing this effectively. However, we do not work with a single object having both the structure of a <span class="SimpleMath">p</span>-group and a Lie ring. Rather we define two objects, a <span class="SimpleMath">p</span>-group and a Lie ring, along with bijections between the two. Our programs use the BCH-formula and its inverses, that have been stored in a file, truncated at weight 14. This means that currently the package is able to deal with groups and algebras up to class 14. The underlying algorithms have been described in <a href="chapBib.html#biBcicgravl">[CdGVL11]</a></p>

<p><a id="X81FC256983DC2A94" name="X81FC256983DC2A94"></a></p>

<h5>2.4-1 PGroupToLieRing</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PGroupToLieRing</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">G</var> is a <span class="SimpleMath">p</span>-group of class <span class="SimpleMath">&lt;p</span>. This function returns a record with four components: <var class="Arg">pgroup</var> (the group <var class="Arg">G</var>), <var class="Arg">liering</var> (the corresponding Lie ring), <var class="Arg">GtoL</var> (a function mapping elements of the group to elements of the Lie ring), <var class="Arg">LtoG</var> (a function mapping elements of the Lie ring to elements of the group).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := FreeGroup(IsSyllableWordsFamily,"a","b","c","d", "e", "f", "g");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := F.1;; b := F.2;; c := F.3;; d := F.4;; e := F.5;; f := F.6;; g:=F.7;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rels := [ a^13, b^13/g, c^13, d^13, e^13, f^13, g^13,  </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Comm(b,a)/c, Comm(c,a)/d, Comm(d,a)/e, Comm(e,a)/f, Comm(f,a), Comm(g,a),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Comm(c,b)/(g^11), Comm(d,b)/g, Comm(e,b)/g, Comm(g,b), Comm(d,c)/(g^12),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Comm(e,c), Comm(f,c), Comm(g,c), Comm(e,d), Comm(f,d), Comm(g,d), Comm(f,e), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Comm(g,e), Comm(g,f)];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := PcGroupFpGroup( F/rels );</span>
&lt;pc group of size 62748517 with 7 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r:= PGroupToLieRing(G);</span>
rec( GtoL := function( g0 ) ... end, LtoG := function( x0 ) ... end, 
  liering := &lt;Lie ring with 6 generators&gt;, 
  pgroup := &lt;pc group of size 62748517 with 7 generators&gt; )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f:= r.GtoL; h:= r.LtoG;</span>
function( g0 ) ... end
function( x0 ) ... end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= r.liering;</span>
&lt;Lie ring with 6 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b:= Basis(L);</span>
Basis( &lt;Lie ring with 6 generators&gt;, [ v_1, v_2, v_3, v_4, v_5, v_6 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h(b[1]);</span>
a^12*c*d^5*e^3*f^8*g^7
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f(h(b[1]));</span>
v_1
</pre></div>

<p><a id="X7E683E5F80B27375" name="X7E683E5F80B27375"></a></p>

<h5>2.4-2 LieRingToPGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LieRingToPGroup</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Here <var class="Arg">L</var> is a nilpotent Lie ring of class <span class="SimpleMath">&lt;p</span> and order <span class="SimpleMath">p^n</span>. This function returns a record with four components: <var class="Arg">pgroup</var> (the <span class="SimpleMath">p</span>-group corresponding to <var class="Arg">L</var>), <var class="Arg">liering</var> (the Lie ring <var class="Arg">L</var>), <var class="Arg">GtoL</var> (a function mapping elements of the group to elements of the Lie ring), <var class="Arg">LtoG</var> (a function mapping elements of the Lie ring to elements of the group).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= FreeLieRing( Integers, ["a","b","c"] );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a:= L.1;; b:= L.2;; c:= L.3;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rels:= [ (b*a)*b, c*a, c*b-(b*a)*a, 7^2*a, 7*b-((b*a)*a)*a, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">7*c-((b*a)*a)*a];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K:= FpLieRing( L, rels );</span>
&lt;Lie ring with 5 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r:= LieRingToPGroup(K);</span>
rec( GtoL := function( g0 ) ... end, LtoG := function( x0 ) ... end, 
  liering := &lt;Lie ring with 5 generators&gt;, 
  pgroup := &lt;pc group of size 823543 with 7 generators&gt; )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:= r.pgroup;; f:= r.LtoG;; h:= r.GtoL;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u:= 5*Basis(K)[2]+9*Basis(K)[5];</span>
5*v_2+9*v_5
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f(u);</span>
f3^2*f4^2*f5^6*f7^3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h(f(u));</span>
5*v_2+9*v_5
</pre></div>

<p><a id="X7CB9E82C84258435" name="X7CB9E82C84258435"></a></p>

<h4>2.5 <span class="Heading">The database of <span class="SimpleMath">n</span>-Engel Lie rings</span></h4>

<p>A Lie ring <span class="SimpleMath">L</span> is said to satisfy the <span class="SimpleMath">n</span>-Engel condition if for all <span class="SimpleMath">x,y âˆˆ L</span> we have <span class="SimpleMath">(ad x)^n (y) = 0</span>. The package <strong class="pkg">LieRing</strong> contains a small database of Lie rings that satisfy an <span class="SimpleMath">n</span>-Engel condition. They have been computed with the algorithms described in <a href="chapBib.html#biBcicgra1">[CdG07]</a> and <a href="chapBib.html#biBcicgra2">[CdG09]</a>.</p>

<p>Currently the database contains the "freeest" (or "largest") <span class="SimpleMath">n</span>-Engel Lie rings with <span class="SimpleMath">k</span> generators for <span class="SimpleMath">(n,k) = (3,2), (3,3), (3,4), (4,2), (4,3)</span>.</p>

<p><a id="X7F6C2B1D82E381D0" name="X7F6C2B1D82E381D0"></a></p>

<h5>2.5-1 SmallNEngelLieRing</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SmallNEngelLieRing</code>( <var class="Arg">n</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>This returns the biggest <var class="Arg">n</var>-Engel Lie ring with <var class="Arg">k</var> generators, for the values of <var class="Arg">n,k</var> indicated above. For other values an error is raised.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:= SmallNEngelLieRing( 4, 3 );</span>
&lt;Lie ring with 133 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:= 10*Basis(L)[1]+7*Basis(L)[10]+19*Basis(L)[89];</span>
7*v_10+19*v_89
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll( Basis(L), y -&gt; IsZero( x*(x*(x*(x*y))) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K:= TensorWithField( L, GF(3) );</span>
&lt;Lie algebra of dimension 83 over GF(3)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:= Random(K);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll( Basis(K), y -&gt; IsZero( x*(x*(x*(x*y))) ) );</span>
true
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
