<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (digraphs) - Chapter 5: Attributes and operations</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap5"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chapA_mj.html">A</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap4_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap6_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap5.html">[MathJax off]</a></p>
<p><a id="X8739F6CD78C90B14" name="X8739F6CD78C90B14"></a></p>
<div class="ChapSects"><a href="chap5_mj.html#X8739F6CD78C90B14">5 <span class="Heading">Attributes and operations</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap5_mj.html#X7E814B6478F7D015">5.1 <span class="Heading">Vertices and edges</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7C45F7D878D896AC">5.1-1 DigraphVertices</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7C6F19B57CB2E882">5.1-2 DigraphNrVertices</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7D1C6A4D7ECEC317">5.1-3 DigraphEdges</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X85E1CFDD7E164AD0">5.1-4 DigraphNrEdges</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X85D5E08280914EE4">5.1-5 DigraphSinks</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7F5C6268839BE98C">5.1-6 DigraphSources</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X785C30378064CF47">5.1-7 DigraphTopologicalSort</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7CA91E4B7904F793">5.1-8 DigraphVertexLabel</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7E51F2FE87140B32">5.1-9 DigraphVertexLabels</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X79FAEACC7F438C2F">5.1-10 DigraphEdgeLabel</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7C24851087D4A8FB">5.1-11 DigraphEdgeLabels</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7EFAF01B7A155157">5.1-12 DigraphInEdges</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7BECFE6687ECD028">5.1-13 DigraphOutEdges</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7BB8ED88835F07B4">5.1-14 IsDigraphEdge</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X848FED0B7B4ACD1F">5.1-15 IsMatching</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap5_mj.html#X7D7CE8328187D0DF">5.2 <span class="Heading">Neighbours and degree</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7DC2CD70830BEE60">5.2-1 AdjacencyMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X87FA0A727CDB060B">5.2-2 CharacteristicPolynomial</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X8507DC4F794780C1">5.2-3 BooleanAdjacencyMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7AFCE34A7A04D5C1">5.2-4 DigraphAdjacencyFunction</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7FDEBF3279759961">5.2-5 DigraphRange</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7E9880767AE68E00">5.2-6 OutNeighbours</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X85C7AA5A81DA6E11">5.2-7 InNeighbours</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7F5ACE807D1BC2E2">5.2-8 OutDegrees</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7ADDFBFD7A365775">5.2-9 InDegrees</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7A09EB648070276D">5.2-10 OutDegreeOfVertex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X83315B0186850806">5.2-11 OutNeighboursOfVertex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7C9CD0527CB9E6EF">5.2-12 InDegreeOfVertex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7C0DA18B8291F302">5.2-13 InNeighboursOfVertex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X83271F607BD809CF">5.2-14 DigraphLoops</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7DDB33B686B3A2C6">5.2-15 PartialOrderDigraphMeetOfVertices</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7BEAE1C78267F54D">5.2-16 DegreeMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X865390B08331936B">5.2-17 LaplacianMatrix</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap5_mj.html#X8537F4088400DC48">5.3 <span class="Heading">Reachability and connectivity</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7F16B9EB8398459C">5.3-1 DigraphDiameter</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X8104A9D37BCD8A05">5.3-2 DigraphShortestDistance</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X81F99BC67E9D050F">5.3-3 DigraphShortestDistances</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X8223718079D98A82">5.3-4 DigraphLongestDistanceFromVertex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7CB7DDCD84621D38">5.3-5 DigraphDistanceSet</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X79A3DA4078CF3C90">5.3-6 DigraphGirth</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X8374B7357EC189C1">5.3-7 DigraphOddGirth</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X84688B337BDDBB09">5.3-8 DigraphUndirectedGirth</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X842FAD6A7B835977">5.3-9 DigraphConnectedComponents</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X8484EC557810CD31">5.3-10 DigraphConnectedComponent</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X833ECD6B7A84944C">5.3-11 DigraphStronglyConnectedComponents</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7EFCB5017D662254">5.3-12 DigraphStronglyConnectedComponent</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7F1B5A2782F598B1">5.3-13 DigraphBicomponents</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7DDE06E47E605DD7">5.3-14 ArticulationPoints</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X853D0B0981A33433">5.3-15 DigraphPeriod</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X864A31A8809F61C2">5.3-16 DigraphFloydWarshall</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7FBAB09E7C0BE5CF">5.3-17 IsReachable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X8039170B82A32257">5.3-18 DigraphPath</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X80E9D645843973A6">5.3-19 DigraphShortestPath</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7C0416FE7A69CA2C">5.3-20 IteratorOfPaths</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7ECD16838704FAAA">5.3-21 DigraphAllSimpleCircuits</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7C735C4E86BDD5F6">5.3-22 DigraphLongestSimpleCircuit</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X870E04307C5F213F">5.3-23 DigraphLayers</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7B2E42327DA118E0">5.3-24 DigraphDegeneracy</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X827C2BD17A4547E3">5.3-25 DigraphDegeneracyOrdering</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X863FDFC4839A3B82">5.3-26 HamiltonianPath</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X82F30D5681466BC6">5.3-27 NrSpanningTrees</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap5_mj.html#X82F900777D677F55">5.4 <span class="Heading">Cayley graphs of groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7A000B1D7CCF7093">5.4-1 GroupOfCayleyDigraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X8528455987D7D2BF">5.4-2 GeneratorsOfCayleyDigraph</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap5_mj.html#X790FD6647ECCAE3C">5.5 <span class="Heading">Associated semigroups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X87D5C60D7B0C1309">5.5-1 AsSemigroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7C6D5EC27C51066B">5.5-2 AsSemigroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap5_mj.html#X7E2305528492DDC0">5.6 <span class="Heading">Planarity</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7DC478637E8C190D">5.6-1 KuratowskiPlanarSubdigraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X78E8F09A8286501B">5.6-2 KuratowskiOuterPlanarSubdigraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X84E3947E7D39BA64">5.6-3 PlanarEmbedding</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X85DFB8C18088711F">5.6-4 OuterPlanarEmbedding</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X806D2D6B85E0B269">5.6-5 SubdigraphHomeomorphicToK23</a></span>
</div></div>
</div>

<h3>5 <span class="Heading">Attributes and operations</span></h3>

<p><a id="X7E814B6478F7D015" name="X7E814B6478F7D015"></a></p>

<h4>5.1 <span class="Heading">Vertices and edges</span></h4>

<p><a id="X7C45F7D878D896AC" name="X7C45F7D878D896AC"></a></p>

<h5>5.1-1 DigraphVertices</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphVertices</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of integers.</p>

<p>Returns the vertices of the digraph <var class="Arg">digraph</var>.</p>

<p>Note that the vertices of a digraph are always a range of positive integers from <code class="code">1</code> to the number of vertices of the graph.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph(["a", "b", "c"],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 ["a", "b", "b"],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 ["b", "c", "a"]);</span>
&lt;immutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertices(gr);</span>
[ 1 .. 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([1, 2, 3, 4, 5, 7],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 [1, 2, 2, 4, 4],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 [2, 7, 5, 3, 7]);</span>
&lt;immutable digraph with 6 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertices(gr);</span>
[ 1 .. 6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertices(RandomDigraph(100));</span>
[ 1 .. 100 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertices(D);</span>
[ 1 .. 3 ]
</pre></div>

<p><a id="X7C6F19B57CB2E882" name="X7C6F19B57CB2E882"></a></p>

<h5>5.1-2 DigraphNrVertices</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphNrVertices</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An integer.</p>

<p>Returns the number of vertices of the digraph <var class="Arg">digraph</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph(["a", "b", "c"],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 ["a", "b", "b"],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 ["b", "c", "a"]);</span>
&lt;immutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphNrVertices(gr);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([1, 2, 3, 4, 5, 7],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 [1, 2, 2, 4, 4],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 [2, 7, 5, 3, 7]);</span>
&lt;immutable digraph with 6 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphNrVertices(gr);</span>
6
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphNrVertices(RandomDigraph(100));</span>
100
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphNrVertices(D);</span>
3
</pre></div>

<p><a id="X7D1C6A4D7ECEC317" name="X7D1C6A4D7ECEC317"></a></p>

<h5>5.1-3 DigraphEdges</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphEdges</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of lists.</p>

<p><code class="code">DigraphEdges</code> returns a list of edges of the digraph <var class="Arg">digraph</var>, where each edge is a pair of elements of <code class="func">DigraphVertices</code> (<a href="chap5_mj.html#X7C45F7D878D896AC"><span class="RefLink">5.1-1</span></a>) of the form <code class="code">[source,range]</code>.</p>

<p>The entries of <code class="code">DigraphEdges(</code><var class="Arg">digraph</var><code class="code">)</code> are in one-to-one corresponence with the edges of <var class="Arg">digraph</var>. Hence <code class="code">DigraphEdges(</code><var class="Arg">digraph</var><code class="code">)</code> is duplicate-free if and only if <var class="Arg">digraph</var> contains no multiple edges.</p>

<p>The entries of <code class="code">DigraphEdges</code> are guaranteed to be sorted by their first component (i.e. by the source of each edge), but they are not necessarily then sorted by the second component.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := DigraphFromDiSparse6String(".DaXbOe?EAM@G~");</span>
&lt;immutable multidigraph with 5 vertices, 16 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">edges := ShallowCopy(DigraphEdges(gr));; Sort(edges);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">edges;</span>
[ [ 1, 1 ], [ 1, 3 ], [ 1, 3 ], [ 1, 4 ], [ 1, 5 ], [ 2, 1 ], 
  [ 2, 2 ], [ 2, 3 ], [ 2, 5 ], [ 3, 2 ], [ 3, 4 ], [ 3, 5 ], 
  [ 4, 2 ], [ 4, 4 ], [ 4, 5 ], [ 5, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdges(D);</span>
[ [ 1, 2 ], [ 2, 3 ], [ 3, 1 ] ]
</pre></div>

<p><a id="X85E1CFDD7E164AD0" name="X85E1CFDD7E164AD0"></a></p>

<h5>5.1-4 DigraphNrEdges</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphNrEdges</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An integer.</p>

<p>This function returns the number of edges of the digraph <var class="Arg">digraph</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 3, 4, 5], [1, 2, 3, 5], [2, 4, 5], [2, 4, 5], [1]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphNrEdges(gr);</span>
15
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph(["a", "b", "c"],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 ["a", "b", "b"],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 ["b", "a", "a"]);</span>
&lt;immutable multidigraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphNrEdges(gr);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphNrEdges(D);</span>
3
</pre></div>

<p><a id="X85D5E08280914EE4" name="X85D5E08280914EE4"></a></p>

<h5>5.1-5 DigraphSinks</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphSinks</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of vertices.</p>

<p>This function returns a list of the sinks of the digraph <var class="Arg">digraph</var>. A sink of a digraph is a vertex with out-degree zero. See <code class="func">OutDegreeOfVertex</code> (<a href="chap5_mj.html#X7A09EB648070276D"><span class="RefLink">5.2-10</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([[3, 5, 2, 2], [3], [], [5, 2, 5, 3], []]);</span>
&lt;immutable multidigraph with 5 vertices, 9 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphSinks(gr);</span>
[ 3, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphSinks(D);</span>
[  ]
</pre></div>

<p><a id="X7F5C6268839BE98C" name="X7F5C6268839BE98C"></a></p>

<h5>5.1-6 DigraphSources</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphSources</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of vertices.</p>

<p>This function returns an immutable list of the sources of the digraph <var class="Arg">digraph</var>. A source of a digraph is a vertex with in-degree zero. See <code class="func">InDegreeOfVertex</code> (<a href="chap5_mj.html#X7C9CD0527CB9E6EF"><span class="RefLink">5.2-12</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([[3, 5, 2, 2], [3], [], [5, 2, 5, 3], []]);</span>
&lt;immutable multidigraph with 5 vertices, 9 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphSources(gr);</span>
[ 1, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphSources(D);</span>
[  ]
</pre></div>

<p><a id="X785C30378064CF47" name="X785C30378064CF47"></a></p>

<h5>5.1-7 DigraphTopologicalSort</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphTopologicalSort</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of positive integers, or <code class="keyw">fail</code>.</p>

<p>If <var class="Arg">digraph</var> is a digraph whose only directed cycles are loops, then <code class="code">DigraphTopologicalSort</code> returns the vertices of <var class="Arg">digraph</var> ordered so that every edge's source appears no earlier in the list than its range. If the digraph <var class="Arg">digraph</var> contains directed cycles of length greater than <span class="SimpleMath">\(1\)</span>, then this operation returns <code class="keyw">fail</code>.</p>

<p>See section <a href="chap1_mj.html#X84541F61810C741D"><span class="RefLink">1.1-1</span></a> for the definition of a directed cycle, and the definition of a loop.</p>

<p>The method used for this attribute has complexity <span class="SimpleMath">\(O(m+n)\)</span> where <span class="SimpleMath">\(m\)</span> is the number of edges (counting multiple edges as one) and <span class="SimpleMath">\(n\)</span> is the number of vertices in the digraph.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 3], [], [4, 6], [5], [], [7, 8, 9], [], [], []]);</span>
&lt;immutable digraph with 9 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphTopologicalSort(D);</span>
[ 2, 5, 4, 7, 8, 9, 6, 3, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, [[2, 3], [3], [4], []]);</span>
&lt;mutable digraph with 4 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphTopologicalSort(D);</span>
[ 4, 3, 2, 1 ]
</pre></div>

<p><a id="X7CA91E4B7904F793" name="X7CA91E4B7904F793"></a></p>

<h5>5.1-8 DigraphVertexLabel</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphVertexLabel</code>( <var class="Arg">digraph</var>, <var class="Arg">i</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SetDigraphVertexLabel</code>( <var class="Arg">digraph</var>, <var class="Arg">i</var>, <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>If <var class="Arg">digraph</var> is a digraph, then the first operation returns the label of the vertex <var class="Arg">i</var>. The second operation can be used to set the label of the vertex <var class="Arg">i</var> in <var class="Arg">digraph</var> to the arbitrary <strong class="pkg">GAP</strong> object <var class="Arg">obj</var>.</p>

<p>The label of a vertex can be changed an arbitrary number of times. If no label has been set for the vertex <var class="Arg">i</var>, then the default value is <var class="Arg">i</var>.</p>

<p>If <var class="Arg">digraph</var> is a digraph created from a record with a component <code class="code">vertices</code>, then the labels of the vertices are set to the value of this component.</p>

<p>Induced subdigraphs, and some other operations which create new digraphs from old ones, inherit their labels from their parents.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphFromDigraph6String("&amp;DHUEe_");</span>
&lt;immutable digraph with 5 vertices, 11 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertexLabel(D, 3);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(["a", "b", "c"], [], []);</span>
&lt;immutable empty digraph with 3 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertexLabel(D, 2);</span>
"b"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetDigraphVertexLabel(D, 2, "d");</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertexLabel(D, 2);</span>
"d"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := InducedSubdigraph(D, [1, 2]);</span>
&lt;immutable empty digraph with 2 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertexLabel(D, 2);</span>
"d"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, ["e", "f", "g"], [], []);</span>
&lt;mutable empty digraph with 3 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertexLabel(D, 1);</span>
"e"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetDigraphVertexLabel(D, 1, "h");</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertexLabel(D, 1);</span>
"h"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InducedSubdigraph(D, [1, 2]);</span>
&lt;mutable empty digraph with 2 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertexLabel(D, 1);</span>
"h"
</pre></div>

<p><a id="X7E51F2FE87140B32" name="X7E51F2FE87140B32"></a></p>

<h5>5.1-9 DigraphVertexLabels</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphVertexLabels</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SetDigraphVertexLabels</code>( <var class="Arg">digraph</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>If <var class="Arg">digraph</var> is a digraph, then <code class="code">DigraphVertexLabels</code> returns a copy of the labels of the vertices in <var class="Arg">digraph</var>. <code class="code">SetDigraphVertexLabels</code> can be used to set the labels of the vertices in <var class="Arg">digraph</var> to the list of arbitrary <strong class="pkg">GAP</strong> objects <var class="Arg">list</var>.</p>

<p>The label of a vertex can be changed an arbitrary number of times. If no label has been set for the vertex <var class="Arg">i</var>, then the default value is <var class="Arg">i</var>.</p>

<p>If <var class="Arg">digraph</var> is a digraph created from a record with a component <code class="code">vertices</code>, then the labels of the vertices are set to the value of this component.</p>

<p>Induced subdigraphs, and other operations which create new digraphs from old ones, inherit their labels from their parents.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphFromDigraph6String("&amp;DHUEe_");</span>
&lt;immutable digraph with 5 vertices, 11 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertexLabels(D);</span>
[ 1 .. 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(["a", "b", "c"], [], []);</span>
&lt;immutable empty digraph with 3 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertexLabels(D);</span>
[ "a", "b", "c" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetDigraphVertexLabel(D, 2, "d");</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertexLabels(D);</span>
[ "a", "d", "c" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := InducedSubdigraph(D, [1, 3]);</span>
&lt;immutable empty digraph with 2 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertexLabels(D);</span>
[ "a", "c" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, ["e", "f", "g"], [], []);</span>
&lt;mutable empty digraph with 3 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetDigraphVertexLabels(D, ["h", "i", "j"]);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertexLabels(D);</span>
[ "h", "i", "j" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InducedSubdigraph(D, [1, 3]);</span>
&lt;mutable empty digraph with 2 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertexLabels(D);</span>
[ "h", "j" ]
</pre></div>

<p><a id="X79FAEACC7F438C2F" name="X79FAEACC7F438C2F"></a></p>

<h5>5.1-10 DigraphEdgeLabel</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphEdgeLabel</code>( <var class="Arg">digraph</var>, <var class="Arg">i</var>, <var class="Arg">j</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SetDigraphEdgeLabel</code>( <var class="Arg">digraph</var>, <var class="Arg">i</var>, <var class="Arg">j</var>, <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>If <var class="Arg">digraph</var> is a digraph without multiple edges, then the first operation returns the label of the edge from vertex <var class="Arg">i</var> to vertex <var class="Arg">j</var>. The second operation can be used to set the label of the edge between vertex <var class="Arg">i</var> and vertex <var class="Arg">j</var> to the arbitrary <strong class="pkg">GAP</strong> object <var class="Arg">obj</var>.</p>

<p>The label of an edge can be changed an arbitrary number of times. If no label has been set for the edge, then the default value is <var class="Arg">1</var>.</p>

<p>Induced subdigraphs, and some other operations which create new digraphs from old ones, inherit their edge labels from their parents. See also <code class="func">DigraphEdgeLabels</code> (<a href="chap5_mj.html#X7C24851087D4A8FB"><span class="RefLink">5.1-11</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphFromDigraph6String("&amp;DHUEe_");</span>
&lt;immutable digraph with 5 vertices, 11 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdgeLabel(D, 3, 1);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetDigraphEdgeLabel(D, 2, 5, [42]);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdgeLabel(D, 2, 5);</span>
[ 42 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := InducedSubdigraph(D, [2, 5]);</span>
&lt;immutable digraph with 2 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdgeLabel(D, 1, 2);</span>
[ 42 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := ChainDigraph(IsMutableDigraph, 5);</span>
&lt;mutable digraph with 5 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdgeLabel(D, 2, 3);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetDigraphEdgeLabel(D, 4, 5, [1729]);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdgeLabel(D, 4, 5);</span>
[ 1729 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InducedSubdigraph(D, [4, 5]);</span>
&lt;mutable digraph with 2 vertices, 1 edge&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdgeLabel(D, 1, 2);</span>
[ 1729 ]
</pre></div>

<p><a id="X7C24851087D4A8FB" name="X7C24851087D4A8FB"></a></p>

<h5>5.1-11 DigraphEdgeLabels</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphEdgeLabels</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SetDigraphEdgeLabels</code>( <var class="Arg">digraph</var>, <var class="Arg">labels</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SetDigraphEdgeLabels</code>( <var class="Arg">digraph</var>, <var class="Arg">func</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>If <var class="Arg">digraph</var> is a digraph without multiple edges, then <code class="code">DigraphEdgeLabels</code> returns a copy of the labels of the edges in <var class="Arg">digraph</var> as a list of lists <code class="code">labels</code> such that <code class="code">labels[i][j]</code> is the label on the edge from vertex <code class="code">i</code> to vertex <code class="code">OutNeighbours(digraph)[i][j]</code>. <code class="code">SetDigraphEdgeLabels</code> can be used to set the labels of the edges in <var class="Arg">digraph</var> without multiple edges to the list <var class="Arg">labels</var> of lists of arbitrary <strong class="pkg">GAP</strong> objects such that <code class="code">list[i][j]</code> is the label on the edge from vertex <code class="code">i</code> to the vertex <code class="code">OutNeighbours(digraph&gt;[i][j]</code>. Alternatively <code class="code">SetDigraphEdgeLabels</code> can be called with binary function <var class="Arg">func</var> that as its second argument that when passed two vertices <code class="code">i</code> and <code class="code">j</code> returns the label for the edge between vertex <code class="code">i</code> and vertex <code class="code">j</code>.</p>

<p>The label of an edge can be changed an arbitrary number of times. If no label has been set for an edge, then the default value is <code class="code">1</code>.</p>

<p>Induced subdigraphs, and some other operations which create new digraphs from old ones, inherit their labels from their parents.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphFromDigraph6String("&amp;DHUEe_");</span>
&lt;immutable digraph with 5 vertices, 11 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdgeLabels(D);</span>
[ [ 1 ], [ 1, 1, 1 ], [ 1 ], [ 1, 1, 1 ], [ 1, 1, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetDigraphEdgeLabel(D, 2, 1, "d");</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdgeLabels(D);</span>
[ [ 1 ], [ "d", 1, 1 ], [ 1 ], [ 1, 1, 1 ], [ 1, 1, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := InducedSubdigraph(D, [1, 2, 3]);</span>
&lt;immutable digraph with 3 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdgeLabels(D);</span>
[ [ 1 ], [ "d", 1 ], [ 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighbours(D);</span>
[ [ 3 ], [ 1, 3 ], [ 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CompleteBipartiteDigraph(IsMutableDigraph, 2, 3);</span>
&lt;mutable digraph with 5 vertices, 12 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdgeLabels(D);</span>
[ [ 1, 1, 1 ], [ 1, 1, 1 ], [ 1, 1 ], [ 1, 1 ], [ 1, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetDigraphEdgeLabel(D, 2, 4, "a");</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdgeLabels(D);</span>
[ [ 1, 1, 1 ], [ 1, "a", 1 ], [ 1, 1 ], [ 1, 1 ], [ 1, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InducedSubdigraph(D, [1, 2, 3, 4]);</span>
&lt;mutable digraph with 4 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdgeLabels(D);</span>
[ [ 1, 1 ], [ 1, "a" ], [ 1, 1 ], [ 1, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighbors(D);</span>
[ [ 3, 4 ], [ 3, 4 ], [ 1, 2 ], [ 1, 2 ] ]
</pre></div>

<p><a id="X7EFAF01B7A155157" name="X7EFAF01B7A155157"></a></p>

<h5>5.1-12 DigraphInEdges</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphInEdges</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of edges.</p>

<p><code class="code">DigraphInEdges</code> returns the list of all edges of <var class="Arg">digraph</var> which have <var class="Arg">vertex</var> as their range.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 2], [3, 3], [4, 4], [1, 1]]);</span>
&lt;immutable multidigraph with 4 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphInEdges(D, 2);</span>
[ [ 1, 2 ], [ 1, 2 ] ]
</pre></div>

<p><a id="X7BECFE6687ECD028" name="X7BECFE6687ECD028"></a></p>

<h5>5.1-13 DigraphOutEdges</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphOutEdges</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of edges.</p>

<p><code class="code">DigraphOutEdges</code> returns the list of all edges of <var class="Arg">digraph</var> which have <var class="Arg">vertex</var> as their source.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 2], [3, 3], [4, 4], [1, 1]]);</span>
&lt;immutable multidigraph with 4 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphOutEdges(D, 2);</span>
[ [ 2, 3 ], [ 2, 3 ] ]
</pre></div>

<p><a id="X7BB8ED88835F07B4" name="X7BB8ED88835F07B4"></a></p>

<h5>5.1-14 IsDigraphEdge</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDigraphEdge</code>( <var class="Arg">digraph</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDigraphEdge</code>( <var class="Arg">digraph</var>, <var class="Arg">u</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>In the first form, this function returns <code class="keyw">true</code> if and only if the list <var class="Arg">list</var> specifies an edge in the digraph <var class="Arg">digraph</var>. Specifically, this operation returns <code class="keyw">true</code> if <var class="Arg">list</var> is a pair of positive integers where <var class="Arg">list</var><code class="code">[1]</code> is the source and <var class="Arg">list</var><code class="code">[2]</code> is the range of an edge in <var class="Arg">digraph</var>, and <code class="keyw">false</code> otherwise.</p>

<p>The second form simply returns <code class="keyw">true</code> if <code class="code">[<var class="Arg">u</var>, <var class="Arg">v</var>]</code> is an edge in <var class="Arg">digraph</var>, and <code class="keyw">false</code> otherwise.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 2], [6], [], [3], [], [1]]);</span>
&lt;immutable multidigraph with 6 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphEdge(D, [1, 1]);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphEdge(D, [1, 2]);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphEdge(D, [1, 8]);</span>
false
</pre></div>

<p><a id="X848FED0B7B4ACD1F" name="X848FED0B7B4ACD1F"></a></p>

<h5>5.1-15 IsMatching</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsMatching</code>( <var class="Arg">digraph</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsMaximalMatching</code>( <var class="Arg">digraph</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPerfectMatching</code>( <var class="Arg">digraph</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>If <var class="Arg">digraph</var> is a digraph and <var class="Arg">list</var> is a list of pairs of vertices of <var class="Arg">digraph</var>, then <code class="code">IsMatching</code> returns <code class="keyw">true</code> if <var class="Arg">list</var> is a matching of <var class="Arg">digraph</var>. The operations <code class="code">IsMaximalMatching</code> and <code class="code">IsPerfectMatching</code> return <code class="keyw">true</code> if <var class="Arg">list</var> is a maximal, or perfect, matching of <var class="Arg">digraph</var>, respectively. Otherwise, these operations return <code class="keyw">false</code>.</p>

<p>A <em>matching</em> <code class="code">M</code> of a digraph <var class="Arg">digraph</var> is a subset of the edges of <var class="Arg">digraph</var>, i.e. <code class="code">DigraphEdges(<var class="Arg">digraph</var>)</code>, such that no pair of distinct edges in <code class="code">M</code> are incident to the same vertex of <var class="Arg">digraph</var>. Note that this definition allows a matching to contain loops. See <code class="func">DigraphHasLoops</code> (<a href="chap6_mj.html#X7D92935C7D535187"><span class="RefLink">6.1-1</span></a>). The matching <code class="code">M</code> is <em>maximal</em> if it is contained in no larger matching of the digraph, and is <em>perfect</em> if every vertex of the digraph is incident to an edge in the matching. Every perfect matching is maximal.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [1], [2, 3, 4], [3, 5], [1]]);</span>
&lt;immutable digraph with 5 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMatching(D, [[2, 1], [3, 2]]);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">edges := [[3, 2]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMatching(D, edges);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMaximalMatching(D, edges);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">edges := [[5, 1], [3, 3]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMaximalMatching(D, edges);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPerfectMatching(D, edges);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">edges := [[1, 2], [3, 3], [4, 5]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPerfectMatching(D, edges);</span>
true
</pre></div>

<p><a id="X7D7CE8328187D0DF" name="X7D7CE8328187D0DF"></a></p>

<h4>5.2 <span class="Heading">Neighbours and degree</span></h4>

<p><a id="X7DC2CD70830BEE60" name="X7DC2CD70830BEE60"></a></p>

<h5>5.2-1 AdjacencyMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AdjacencyMatrix</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AdjacencyMatrixMutableCopy</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A square matrix of non-negative integers.</p>

<p>This function returns the adjacency matrix <code class="code">mat</code> of the digraph <var class="Arg">digraph</var>. The value of the matrix entry <code class="code">mat[i][j]</code> is the number of edges in <var class="Arg">digraph</var> with source <code class="code">i</code> and range <code class="code">j</code>. If <var class="Arg">digraph</var> has no vertices, then the empty list is returned.</p>

<p>The function <code class="code">AdjacencyMatrix</code> returns an immutable list of lists, whereas the function <code class="code">AdjacencyMatrixMutableCopy</code> returns a copy of <code class="code">AdjacencyMatrix</code> that is a mutable list of mutable lists.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 2, 2], [1, 3, 6, 8, 9, 10], [4, 6, 8],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 2, 3, 9], [3, 3], [3, 5, 6, 10], [1, 2, 7],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 2, 3, 10, 5, 6, 10], [1, 3, 4, 5, 8, 10],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 3, 4, 6, 7, 10]]);</span>
&lt;immutable multidigraph with 10 vertices, 44 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := AdjacencyMatrix(gr);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(mat);</span>
[ [  0,  3,  0,  0,  0,  0,  0,  0,  0,  0 ],
  [  1,  0,  1,  0,  0,  1,  0,  1,  1,  1 ],
  [  0,  0,  0,  1,  0,  1,  0,  1,  0,  0 ],
  [  1,  1,  1,  0,  0,  0,  0,  0,  1,  0 ],
  [  0,  0,  2,  0,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  1,  0,  1,  1,  0,  0,  0,  1 ],
  [  1,  1,  0,  0,  0,  0,  1,  0,  0,  0 ],
  [  1,  1,  1,  0,  1,  1,  0,  0,  0,  2 ],
  [  1,  0,  1,  1,  1,  0,  0,  1,  0,  1 ],
  [  0,  1,  1,  1,  0,  1,  1,  0,  0,  1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(AdjacencyMatrix(D));</span>
[ [  0,  1,  0 ],
  [  0,  0,  1 ],
  [  1,  0,  0 ] ]
</pre></div>

<p><a id="X87FA0A727CDB060B" name="X87FA0A727CDB060B"></a></p>

<h5>5.2-2 CharacteristicPolynomial</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CharacteristicPolynomial</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A polynomial with integer coefficients.</p>

<p>This function returns the characteristic polynomial of the digraph <var class="Arg">digraph</var>. That is it returns the characteristic polynomial of the adjacency matrix of the digraph <var class="Arg">digraph</var></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 2, 2], [1, 3, 6, 8, 9, 10], [4, 6, 8],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 2, 3, 9], [3, 3], [3, 5, 6, 10], [1, 2, 7],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 2, 3, 10, 5, 6, 10], [1, 3, 4, 5, 8, 10],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 3, 4, 6, 7, 10]]);</span>
&lt;immutable multidigraph with 10 vertices, 44 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacteristicPolynomial(D);</span>
x_1^10-3*x_1^9-7*x_1^8-x_1^7+14*x_1^6+x_1^5-26*x_1^4+51*x_1^3-10*x_1^2\
+18*x_1-30
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CompleteDigraph(5);</span>
&lt;immutable complete digraph with 5 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacteristicPolynomial(D);</span>
x_1^5-10*x_1^3-20*x_1^2-15*x_1-4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacteristicPolynomial(D);</span>
x_1^3-1
</pre></div>

<p><a id="X8507DC4F794780C1" name="X8507DC4F794780C1"></a></p>

<h5>5.2-3 BooleanAdjacencyMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BooleanAdjacencyMatrix</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BooleanAdjacencyMatrixMutableCopy</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A square matrix of booleans.</p>

<p>If <var class="Arg">digraph</var> is a digraph with a positive number of vertices <code class="code">n</code>, then <code class="code">BooleanAdjacencyMatrix(</code><var class="Arg">digraph</var><code class="code">)</code> returns the boolean adjacency matrix <code class="code">mat</code> of <var class="Arg">digraph</var>. The value of the matrix entry <code class="code">mat[j][i]</code> is <code class="keyw">true</code> if and only if there exists an edge in <var class="Arg">digraph</var> with source <code class="code">j</code> and range <code class="code">i</code>. If <var class="Arg">digraph</var> has no vertices, then the empty list is returned.</p>

<p>Note that the boolean adjacency matrix loses information about multiple edges.</p>

<p>The attribute <code class="code">BooleanAdjacencyMatrix</code> returns an immutable list of immutable lists, whereas the function <code class="code">BooleanAdjacencyMatrixMutableCopy</code> returns a copy of the <code class="code">BooleanAdjacencyMatrix</code> that is a mutable list of mutable lists.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([[3, 4], [2, 3], [1, 2, 4], [4]]);</span>
&lt;immutable digraph with 4 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintArray(BooleanAdjacencyMatrix(gr));</span>
[ [  false,  false,   true,   true ],
  [  false,   true,   true,  false ],
  [   true,   true,  false,   true ],
  [  false,  false,  false,   true ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := CycleDigraph(4);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintArray(BooleanAdjacencyMatrix(gr));</span>
[ [  false,   true,  false,  false ],
  [  false,  false,   true,  false ],
  [  false,  false,  false,   true ],
  [   true,  false,  false,  false ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BooleanAdjacencyMatrix(EmptyDigraph(0));</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintArray(BooleanAdjacencyMatrix(D));</span>
[ [  false,   true,  false ],
  [  false,  false,   true ],
  [   true,  false,  false ] ]
</pre></div>

<p><a id="X7AFCE34A7A04D5C1" name="X7AFCE34A7A04D5C1"></a></p>

<h5>5.2-4 DigraphAdjacencyFunction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphAdjacencyFunction</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A function.</p>

<p>If <var class="Arg">digraph</var> is a digraph, then <code class="code">DigraphAdjacencyFunction</code> returns a function which takes two integer parameters <code class="code">x, y</code> and returns <code class="keyw">true</code> if there exists an edge from vertex <code class="code">x</code> to vertex <code class="code">y</code> in <var class="Arg">digraph</var> and <code class="keyw">false</code> if not.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph := Digraph([[1, 2], [3], []]);</span>
&lt;immutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">foo := DigraphAdjacencyFunction(digraph);</span>
function( u, v ) ... end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">foo(1, 1);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">foo(1, 2);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">foo(1, 3);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">foo(3, 1);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph(["a", "b", "c"],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 ["a", "b", "b"],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 ["b", "a", "a"]);</span>
&lt;immutable multidigraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">foo := DigraphAdjacencyFunction(gr);</span>
function( u, v ) ... end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">foo(1, 2);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">foo(3, 2);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">foo(3, 1);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">foo := DigraphAdjacencyFunction(D);</span>
function( u, v ) ... end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">foo(1, 2);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">foo(2, 1);</span>
false
</pre></div>

<p><a id="X7FDEBF3279759961" name="X7FDEBF3279759961"></a></p>

<h5>5.2-5 DigraphRange</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphRange</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphSource</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of positive integers.</p>

<p><code class="code">DigraphRange</code> and <code class="code">DigraphSource</code> return the range and source of the digraph <var class="Arg">digraph</var>. More precisely, position <code class="code">i</code> in <code class="code">DigraphRange(<var class="Arg">digraph</var>)</code> is the range of the <code class="code">i</code>th edge of <var class="Arg">digraph</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 1, 3, 5], [1, 3, 4], [2, 3], [2], [1, 2, 3, 4]]);</span>
&lt;immutable digraph with 5 vertices, 14 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphRange(gr);</span>
[ 2, 1, 3, 5, 1, 3, 4, 2, 3, 2, 1, 2, 3, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphSource(gr);</span>
[ 1, 1, 1, 1, 2, 2, 2, 3, 3, 4, 5, 5, 5, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdges(gr);</span>
[ [ 1, 2 ], [ 1, 1 ], [ 1, 3 ], [ 1, 5 ], [ 2, 1 ], [ 2, 3 ], 
  [ 2, 4 ], [ 3, 2 ], [ 3, 3 ], [ 4, 2 ], [ 5, 1 ], [ 5, 2 ], 
  [ 5, 3 ], [ 5, 4 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphRange(D);</span>
[ 2, 3, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphSource(D);</span>
[ 1, 2, 3 ]
</pre></div>

<p><a id="X7E9880767AE68E00" name="X7E9880767AE68E00"></a></p>

<h5>5.2-6 OutNeighbours</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OutNeighbours</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OutNeighbors</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OutNeighboursMutableCopy</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OutNeighborsMutableCopy</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: The adjacencies of a digraph.</p>

<p>This function returns the list <code class="code">out</code> of out-neighbours of each vertex of the digraph <var class="Arg">digraph</var>. More specifically, a vertex <code class="code">j</code> appears in <code class="code">out[i]</code> each time there exists an edge with source <code class="code">i</code> and range <code class="code">j</code> in <var class="Arg">digraph</var>.</p>

<p>The function <code class="code">OutNeighbours</code> returns an immutable list of lists, whereas the function <code class="code">OutNeighboursMutableCopy</code> returns a copy of <code class="code">OutNeighbours</code> which is a mutable list of mutable lists.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph(["a", "b", "c"],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 ["a", "b", "b"],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 ["b", "a", "c"]);</span>
&lt;immutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighbours(gr);</span>
[ [ 2 ], [ 1, 3 ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([[1, 2, 3], [2, 1], [3]]);</span>
&lt;immutable digraph with 3 vertices, 6 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighbours(gr);</span>
[ [ 1, 2, 3 ], [ 2, 1 ], [ 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := DigraphByAdjacencyMatrix([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [1, 2, 1],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [1, 1, 0],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [0, 0, 1]]);</span>
&lt;immutable multidigraph with 3 vertices, 7 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighbours(gr);</span>
[ [ 1, 2, 2, 3 ], [ 1, 2 ], [ 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighboursMutableCopy(gr);</span>
[ [ 1, 2, 2, 3 ], [ 1, 2 ], [ 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighbours(D);</span>
[ [ 2 ], [ 3 ], [ 1 ] ]
</pre></div>

<p><a id="X85C7AA5A81DA6E11" name="X85C7AA5A81DA6E11"></a></p>

<h5>5.2-7 InNeighbours</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InNeighbours</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InNeighbors</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InNeighboursMutableCopy</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InNeighborsMutableCopy</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of lists of vertices.</p>

<p>This function returns the list <code class="code">inn</code> of in-neighbours of each vertex of the digraph <var class="Arg">digraph</var>. More specifically, a vertex <code class="code">j</code> appears in <code class="code">inn[i]</code> each time there exists an edge with source <code class="code">j</code> and range <code class="code">i</code> in <var class="Arg">digraph</var>.</p>

<p>The function <code class="code">InNeighbours</code> returns an immutable list of lists, whereas the function <code class="code">InNeighboursMutableCopy</code> returns a copy of <code class="code">InNeighbours</code> which is a mutable list of mutable lists.</p>

<p>Note that each entry of <code class="code">inn</code> is sorted into ascending order.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph(["a", "b", "c"],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 ["a", "b", "b"],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 ["b", "a", "c"]);</span>
&lt;immutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InNeighbours(gr);</span>
[ [ 2 ], [ 1 ], [ 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([[1, 2, 3], [2, 1], [3]]);</span>
&lt;immutable digraph with 3 vertices, 6 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InNeighbours(gr);</span>
[ [ 1, 2 ], [ 1, 2 ], [ 1, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := DigraphByAdjacencyMatrix([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [1, 2, 1],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [1, 1, 0],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [0, 0, 1]]);</span>
&lt;immutable multidigraph with 3 vertices, 7 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InNeighbours(gr);</span>
[ [ 1, 2 ], [ 1, 1, 2 ], [ 1, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InNeighboursMutableCopy(gr);</span>
[ [ 1, 2 ], [ 1, 1, 2 ], [ 1, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InNeighbours(D);</span>
[ [ 3 ], [ 1 ], [ 2 ] ]
</pre></div>

<p><a id="X7F5ACE807D1BC2E2" name="X7F5ACE807D1BC2E2"></a></p>

<h5>5.2-8 OutDegrees</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OutDegrees</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OutDegreeSequence</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OutDegreeSet</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of non-negative integers.</p>

<p>Given a digraph <var class="Arg">digraph</var> with <span class="SimpleMath">\(n\)</span> vertices, the function <code class="code">OutDegrees</code> returns an immutable list <code class="code">out</code> of length <span class="SimpleMath">\(n\)</span>, such that for a vertex <code class="code">i</code> in <var class="Arg">digraph</var>, the value of <code class="code">out[i]</code> is the out-degree of vertex <code class="code">i</code>. See <code class="func">OutDegreeOfVertex</code> (<a href="chap5_mj.html#X7A09EB648070276D"><span class="RefLink">5.2-10</span></a>).</p>

<p>The function <code class="code">OutDegreeSequence</code> returns the same list, after it has been sorted into non-increasing order.</p>

<p>The function <code class="code">OutDegreeSet</code> returns the same list, sorted into increasing order with duplicate entries removed.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1, 3, 2, 2], [], [2, 1], []]);</span>
&lt;immutable multidigraph with 4 vertices, 6 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutDegrees(D);</span>
[ 4, 0, 2, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutDegreeSequence(D);</span>
[ 4, 2, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutDegreeSet(D);</span>
[ 0, 2, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutDegrees(D);</span>
[ 1, 1, 1 ]
</pre></div>

<p><a id="X7ADDFBFD7A365775" name="X7ADDFBFD7A365775"></a></p>

<h5>5.2-9 InDegrees</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InDegrees</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InDegreeSequence</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InDegreeSet</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of non-negative integers.</p>

<p>Given a digraph <var class="Arg">digraph</var> with <span class="SimpleMath">\(n\)</span> vertices, the function <code class="code">InDegrees</code> returns an immutable list <code class="code">inn</code> of length <span class="SimpleMath">\(n\)</span>, such that for a vertex <code class="code">i</code> in <var class="Arg">digraph</var>, the value of <code class="code">inn[i]</code> is the in-degree of vertex <code class="code">i</code>. See <code class="func">InDegreeOfVertex</code> (<a href="chap5_mj.html#X7C9CD0527CB9E6EF"><span class="RefLink">5.2-12</span></a>).</p>

<p>The function <code class="code">InDegreeSequence</code> returns the same list, after it has been sorted into non-increasing order.</p>

<p>The function <code class="code">InDegreeSet</code> returns the same list, sorted into increasing order with duplicate entries removed.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1, 3, 2, 2, 4], [], [2, 1, 4], []]);</span>
&lt;immutable multidigraph with 4 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InDegrees(D);</span>
[ 2, 3, 1, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InDegreeSequence(D);</span>
[ 3, 2, 2, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InDegreeSet(D);</span>
[ 1, 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InDegrees(D);</span>
[ 1, 1, 1 ]
</pre></div>

<p><a id="X7A09EB648070276D" name="X7A09EB648070276D"></a></p>

<h5>5.2-10 OutDegreeOfVertex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OutDegreeOfVertex</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: The non-negative integer.</p>

<p>This operation returns the out-degree of the vertex <var class="Arg">vertex</var> in the digraph <var class="Arg">digraph</var>. The out-degree of <var class="Arg">vertex</var> is the number of edges in <var class="Arg">digraph</var> whose source is <var class="Arg">vertex</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 2, 1], [1, 4], [2, 2, 4, 2], [1, 1, 2, 2, 1, 2, 2]]);</span>
&lt;immutable multidigraph with 4 vertices, 16 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutDegreeOfVertex(D, 1);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutDegreeOfVertex(D, 2);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutDegreeOfVertex(D, 3);</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutDegreeOfVertex(D, 4);</span>
7
</pre></div>

<p><a id="X83315B0186850806" name="X83315B0186850806"></a></p>

<h5>5.2-11 OutNeighboursOfVertex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OutNeighboursOfVertex</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OutNeighborsOfVertex</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of vertices.</p>

<p>This operation returns the list <code class="code">out</code> of vertices of the digraph <var class="Arg">digraph</var>. A vertex <code class="code">i</code> appears in the list <code class="code">out</code> each time there exists an edge with source <var class="Arg">vertex</var> and range <code class="code">i</code> in <var class="Arg">digraph</var>; in particular, this means that <code class="code">out</code> may contain duplicates.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 2, 3], [1, 3, 4], [2, 2, 3], [1, 1, 2, 2, 1, 2, 2]]);</span>
&lt;immutable multidigraph with 4 vertices, 16 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighboursOfVertex(D, 1);</span>
[ 2, 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighboursOfVertex(D, 3);</span>
[ 2, 2, 3 ]
</pre></div>

<p><a id="X7C9CD0527CB9E6EF" name="X7C9CD0527CB9E6EF"></a></p>

<h5>5.2-12 InDegreeOfVertex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InDegreeOfVertex</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A non-negative integer.</p>

<p>This operation returns the in-degree of the vertex <var class="Arg">vertex</var> in the digraph <var class="Arg">digraph</var>. The in-degree of <var class="Arg">vertex</var> is the number of edges in <var class="Arg">digraph</var> whose range is <var class="Arg">vertex</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 2, 1], [1, 4], [2, 2, 4, 2], [1, 1, 2, 2, 1, 2, 2]]);</span>
&lt;immutable multidigraph with 4 vertices, 16 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InDegreeOfVertex(D, 1);</span>
5
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InDegreeOfVertex(D, 2);</span>
9
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InDegreeOfVertex(D, 3);</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InDegreeOfVertex(D, 4);</span>
2
</pre></div>

<p><a id="X7C0DA18B8291F302" name="X7C0DA18B8291F302"></a></p>

<h5>5.2-13 InNeighboursOfVertex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InNeighboursOfVertex</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InNeighborsOfVertex</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of postitive vertices.</p>

<p>This operation returns the list <code class="code">inn</code> of vertices of the digraph <var class="Arg">digraph</var>. A vertex <code class="code">i</code> appears in the list <code class="code">inn</code> each time there exists an edge with source <code class="code">i</code> and range <var class="Arg">vertex</var> in <var class="Arg">digraph</var>; in particular, this means that <code class="code">inn</code> may contain duplicates.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 2, 3], [1, 3, 4], [2, 2, 3], [1, 1, 2, 2, 1, 2, 2]]);</span>
&lt;immutable multidigraph with 4 vertices, 16 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InNeighboursOfVertex(D, 1);</span>
[ 2, 4, 4, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InNeighboursOfVertex(D, 2);</span>
[ 1, 1, 3, 3, 4, 4, 4, 4 ]
</pre></div>

<p><a id="X83271F607BD809CF" name="X83271F607BD809CF"></a></p>

<h5>5.2-14 DigraphLoops</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphLoops</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of vertices.</p>

<p>If <var class="Arg">digraph</var> is a digraph, then <code class="code">DigraphLoops</code> returns the list consisting of the <code class="func">DigraphVertices</code> (<a href="chap5_mj.html#X7C45F7D878D896AC"><span class="RefLink">5.1-1</span></a>) of <var class="Arg">digraph</var> at which there is a loop. See <code class="func">DigraphHasLoops</code> (<a href="chap6_mj.html#X7D92935C7D535187"><span class="RefLink">6.1-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [3], []]);</span>
&lt;immutable digraph with 3 vertices, 2 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphHasLoops(D);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphLoops(D);</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3, 5], [1], [2, 4, 3], [4], [2, 1]]);</span>
&lt;immutable digraph with 5 vertices, 9 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphLoops(D);</span>
[ 3, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, [[1], [1]]);</span>
&lt;mutable digraph with 2 vertices, 2 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphLoops(D);</span>
[ 1 ]
</pre></div>

<p><a id="X7DDB33B686B3A2C6" name="X7DDB33B686B3A2C6"></a></p>

<h5>5.2-15 PartialOrderDigraphMeetOfVertices</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PartialOrderDigraphMeetOfVertices</code>( <var class="Arg">digraph</var>, <var class="Arg">u</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PartialOrderDigraphJoinOfVertices</code>( <var class="Arg">digraph</var>, <var class="Arg">u</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A positive integer or <code class="keyw">fail</code></p>

<p>If the first argument is a partial order digraph <code class="func">IsPartialOrderDigraph</code> (<a href="chap6_mj.html#X82BAE6D37D49A145"><span class="RefLink">6.1-16</span></a>) then these operations return the meet, or the join, of the two input vertices. If the meet (or join) is does not exist then <code class="keyw">fail</code> is returned. The meet (or join) is guaranteed to exist when the first argument satisfies <code class="func">IsMeetSemilatticeDigraph</code> (<a href="chap6_mj.html#X78D3E17B7F737516"><span class="RefLink">6.1-17</span></a>) (or <code class="func">IsJoinSemilatticeDigraph</code> (<a href="chap6_mj.html#X78D3E17B7F737516"><span class="RefLink">6.1-17</span></a>)) - see the documentation for these properties for the definition of the meet (or the join).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1], [1, 2], [1, 3], [1, 2, 3, 4]]);</span>
&lt;immutable digraph with 4 vertices, 9 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PartialOrderDigraphMeetOfVertices(D, 2, 3);</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PartialOrderDigraphJoinOfVertices(D, 2, 3);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PartialOrderDigraphMeetOfVertices(D, 1, 2);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PartialOrderDigraphJoinOfVertices(D, 3, 4);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1], [2], [1, 2, 3], [1, 2, 4]]);</span>
&lt;immutable digraph with 4 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PartialOrderDigraphMeetOfVertices(D, 3, 4);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PartialOrderDigraphJoinOfVertices(D, 3, 4);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PartialOrderDigraphMeetOfVertices(D, 1, 2);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PartialOrderDigraphJoinOfVertices(D, 1, 2);</span>
fail
</pre></div>

<p><a id="X7BEAE1C78267F54D" name="X7BEAE1C78267F54D"></a></p>

<h5>5.2-16 DegreeMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DegreeMatrix</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A square matrix of non-negative integers.</p>

<p>This function returns the outdegree matrix <code class="code">mat</code> of the digraph <var class="Arg">digraph</var>. The value of the <code class="code">i</code>th diagonal matrix entry is the outdegree of the vertex <code class="code">i</code> in <var class="Arg">digraph</var>. All off-diagonal entries are <code class="code">0</code>. If <var class="Arg">digraph</var> has no vertices, then the empty list is returned.</p>

<p>See <code class="func">OutDegrees</code> (<a href="chap5_mj.html#X7F5ACE807D1BC2E2"><span class="RefLink">5.2-8</span></a>) for more information.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1, 2, 3], [4], [1, 3, 4], []]);</span>
&lt;immutable digraph with 4 vertices, 7 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintArray(DegreeMatrix(D));</span>
[ [  3,  0,  0,  0 ],
  [  0,  1,  0,  0 ],
  [  0,  0,  3,  0 ],
  [  0,  0,  0,  0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(5);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintArray(DegreeMatrix(D));</span>
[ [  1,  0,  0,  0,  0 ],
  [  0,  1,  0,  0,  0 ],
  [  0,  0,  1,  0,  0 ],
  [  0,  0,  0,  1,  0 ],
  [  0,  0,  0,  0,  1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DegreeMatrix(EmptyDigraph(0));</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(DegreeMatrix(D));</span>
[ [  1,  0,  0 ],
  [  0,  1,  0 ],
  [  0,  0,  1 ] ]
</pre></div>

<p><a id="X865390B08331936B" name="X865390B08331936B"></a></p>

<h5>5.2-17 LaplacianMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LaplacianMatrix</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A square matrix of integers.</p>

<p>This function returns the outdegree Laplacian matrix <code class="code">mat</code> of the digraph <var class="Arg">digraph</var>. The outdegree Laplacian matrix is defined as <code class="code">DegreeMatrix(digraph) - AdjacencyMatrix(digraph)</code>. If <var class="Arg">digraph</var> has no vertices, then the empty list is returned.</p>

<p>See <code class="func">DegreeMatrix</code> (<a href="chap5_mj.html#X7BEAE1C78267F54D"><span class="RefLink">5.2-16</span></a>) and <code class="func">AdjacencyMatrix</code> (<a href="chap5_mj.html#X7DC2CD70830BEE60"><span class="RefLink">5.2-1</span></a>) for more information.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([[1, 2, 3], [4], [1, 3, 4], []]);</span>
&lt;immutable digraph with 4 vertices, 7 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintArray(LaplacianMatrix(gr));</span>
[ [   2,  -1,  -1,   0 ],
  [   0,   1,   0,  -1 ],
  [  -1,   0,   2,  -1 ],
  [   0,   0,   0,   0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LaplacianMatrix(EmptyDigraph(0));</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(LaplacianMatrix(D));</span>
[ [   1,  -1,   0 ],
  [   0,   1,  -1 ],
  [  -1,   0,   1 ] ]
</pre></div>

<p><a id="X8537F4088400DC48" name="X8537F4088400DC48"></a></p>

<h4>5.3 <span class="Heading">Reachability and connectivity</span></h4>

<p><a id="X7F16B9EB8398459C" name="X7F16B9EB8398459C"></a></p>

<h5>5.3-1 DigraphDiameter</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphDiameter</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An integer or <code class="code">fail</code>.</p>

<p>This function returns the diameter of the digraph <var class="Arg">digraph</var>.</p>

<p>If a digraph <var class="Arg">digraph</var> is strongly connected and has at least 1 vertex, then the <em>diameter</em> is the maximum shortest distance between any pair of distinct vertices. Otherwise then the diameter of <var class="Arg">digraph</var> is undefined, and this function returns the value <code class="code">fail</code>.</p>

<p>See <code class="func">DigraphShortestDistances</code> (<a href="chap5_mj.html#X81F99BC67E9D050F"><span class="RefLink">5.3-3</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [3], [4, 5], [5], [1, 2, 3, 4, 5]]);</span>
&lt;immutable digraph with 5 vertices, 10 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDiameter(D);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := ChainDigraph(2);</span>
&lt;immutable chain digraph with 2 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDiameter(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsStronglyConnectedDigraph(D);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := GeneralisedPetersenGraph(IsMutableDigraph, 6, 2);</span>
&lt;mutable digraph with 12 vertices, 36 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDiameter(D);</span>
4
</pre></div>

<p><a id="X8104A9D37BCD8A05" name="X8104A9D37BCD8A05"></a></p>

<h5>5.3-2 DigraphShortestDistance</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphShortestDistance</code>( <var class="Arg">digraph</var>, <var class="Arg">u</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphShortestDistance</code>( <var class="Arg">digraph</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphShortestDistance</code>( <var class="Arg">digraph</var>, <var class="Arg">list1</var>, <var class="Arg">list2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An integer or <code class="keyw">fail</code></p>

<p>If there is a directed path in the digraph <var class="Arg">digraph</var> between vertex <var class="Arg">u</var> and vertex <var class="Arg">v</var>, then this operation returns the length of the shortest such directed path. If no such directed path exists, then this operation returns <code class="keyw">fail</code>. See section <a href="chap1_mj.html#X84541F61810C741D"><span class="RefLink">1.1-1</span></a> for the definition of a directed path.</p>

<p>If the second form is used, then <var class="Arg">list</var> should be a list of length two, containing two positive integers which correspond to the vertices <var class="Arg">u</var> and <var class="Arg">v</var>.</p>

<p>Note that as usual, a vertex is considered to be at distance 0 from itself .</p>

<p>If the third form is used, then <var class="Arg">list1</var> and <var class="Arg">list2</var> are both lists of vertices. The shortest directed path between <var class="Arg">list1</var> and <var class="Arg">list2</var> is then the length of the shortest directed path which starts with a vertex in <var class="Arg">list1</var> and terminates at a vertex in <var class="Arg">list2</var>, if such directed path exists. If <var class="Arg">list1</var> and <var class="Arg">list2</var> have non-empty intersection, the operation returns <code class="code">0</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [3], [1, 4], [1, 3], [5]]);</span>
&lt;immutable digraph with 5 vertices, 7 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphShortestDistance(D, 1, 3);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphShortestDistance(D, [3, 3]);</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphShortestDistance(D, 5, 2);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphShortestDistance(D, [1, 2], [4, 5]);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphShortestDistance(D, [1, 3], [3, 5]);</span>
0
</pre></div>

<p><a id="X81F99BC67E9D050F" name="X81F99BC67E9D050F"></a></p>

<h5>5.3-3 DigraphShortestDistances</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphShortestDistances</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A square matrix.</p>

<p>If <var class="Arg">digraph</var> is a digraph with <span class="SimpleMath">\(n\)</span> vertices, then this function returns an <span class="SimpleMath">\(n \times n\)</span> matrix <code class="code">mat</code>, where each entry is either a non-negative integer, or <code class="keyw">fail</code>. If <span class="SimpleMath">\(n = 0\)</span>, then an empty list is returned.</p>

<p>If there is a directed path from vertex <code class="code">i</code> to vertex <code class="code">j</code>, then the value of <code class="code">mat[i][j]</code> is the length of the shortest such directed path. If no such directed path exists, then the value of <code class="code">mat[i][j]</code> is <code class="code">fail</code>. We use the convention that the distance from every vertex to itself is <code class="code">0</code>, i.e. <code class="code">mat[i][i] = 0</code> for all vertices <code class="code">i</code>.</p>

<p>The method used in this function is a version of the Floyd-Warshall algorithm, and has complexity <span class="SimpleMath">\(O(n^3)\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1, 2], [3], [1, 2], [4]]);</span>
&lt;immutable digraph with 4 vertices, 6 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := DigraphShortestDistances(D);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintArray(mat);</span>
[ [     0,     1,     2,  fail ],
  [     2,     0,     1,  fail ],
  [     1,     1,     0,  fail ],
  [  fail,  fail,  fail,     0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphShortestDistances(D);</span>
[ [ 0, 1, 2 ], [ 2, 0, 1 ], [ 1, 2, 0 ] ]
</pre></div>

<p><a id="X8223718079D98A82" name="X8223718079D98A82"></a></p>

<h5>5.3-4 DigraphLongestDistanceFromVertex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphLongestDistanceFromVertex</code>( <var class="Arg">digraph</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An integer, or <code class="keyw">infinity</code>.</p>

<p>If <var class="Arg">digraph</var> is a digraph and <var class="Arg">v</var> is a vertex in <var class="Arg">digraph</var>, then this operation returns the length of the longest directed walk in <var class="Arg">digraph</var> which begins at vertex <var class="Arg">v</var>. See section <a href="chap1_mj.html#X84541F61810C741D"><span class="RefLink">1.1-1</span></a> for the definitions of directed walk, directed cycle, and loop.</p>


<ul>
<li><p>If there exists a directed walk starting at vertex <var class="Arg">v</var> which traverses a loop or a directed cycle, then we consider there to be a walk of infinite length from <var class="Arg">v</var> (realised by repeatedly traversing the loop/directed cycle), and so the result is <code class="keyw">infinity</code>. To disallow walks using loops, try using <code class="func">DigraphRemoveLoops</code> (<a href="chap3_mj.html#X79324AF7818C0C02"><span class="RefLink">3.3-24</span></a>):</p>

<p><code class="code">DigraphLongestDistanceFromVertex(DigraphRemoveLoops(<var class="Arg">digraph</var>,<var class="Arg">v</var>))</code>.</p>

</li>
<li><p>Otherwise, if all directed walks starting at vertex <var class="Arg">v</var> have finite length, then the length of the longest such walk is returned.</p>

</li>
</ul>
<p>Note that the result is <code class="code">0</code> if and only if <var class="Arg">v</var> is a sink of <var class="Arg">digraph</var>. See <code class="func">DigraphSinks</code> (<a href="chap5_mj.html#X85D5E08280914EE4"><span class="RefLink">5.1-5</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [3, 4], [], [5], [], [6]]);</span>
&lt;immutable digraph with 6 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphLongestDistanceFromVertex(D, 1);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphLongestDistanceFromVertex(D, 3);</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">3 in DigraphSinks(D);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphLongestDistanceFromVertex(D, 6);</span>
infinity
</pre></div>

<p><a id="X7CB7DDCD84621D38" name="X7CB7DDCD84621D38"></a></p>

<h5>5.3-5 DigraphDistanceSet</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphDistanceSet</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex</var>, <var class="Arg">distance</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphDistanceSet</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex</var>, <var class="Arg">distances</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of vertices</p>

<p>This operation returns the list of all vertices in digraph <var class="Arg">digraph</var> such that the shortest distance to a vertex <var class="Arg">vertex</var> is <var class="Arg">distance</var> or is in the list <var class="Arg">distances</var>.</p>

<p><var class="Arg">digraph</var> should be a digraph, <var class="Arg">vertex</var> should be a positive integer, <var class="Arg">distance</var> should be a non-negative integer, and <var class="Arg">distances</var> should be a list of non-negative integers.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [3], [1, 4], [1, 3]]);</span>
&lt;immutable digraph with 4 vertices, 6 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDistanceSet(D, 2, [1, 2]);</span>
[ 3, 1, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDistanceSet(D, 3, 1);</span>
[ 1, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDistanceSet(D, 2, 0);</span>
[ 2 ]
</pre></div>

<p><a id="X79A3DA4078CF3C90" name="X79A3DA4078CF3C90"></a></p>

<h5>5.3-6 DigraphGirth</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphGirth</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An integer, or <code class="keyw">infinity</code>.</p>

<p>This attribute returns the <em>girth</em> of the digraph <var class="Arg">digraph</var>. The <em>girth</em> of a digraph is the length of its shortest simple circuit. See section <a href="chap1_mj.html#X84541F61810C741D"><span class="RefLink">1.1-1</span></a> for the definitions of simple circuit, directed cycle, and loop.</p>

<p>If <var class="Arg">digraph</var> has no directed cycles, then this function will return <code class="keyw">infinity</code>. If <var class="Arg">digraph</var> contains a loop, then this function will return <code class="code">1</code>.</p>

<p>In the worst case, the method used in this function is a version of the Floyd-Warshall algorithm, and has complexity <code class="code">O(<var class="Arg">n</var> ^ 3)</code>, where <var class="Arg">n</var> is the number of vertices in <var class="Arg">digraph</var>. If the digraph has known automorphisms [see <code class="func">DigraphGroup</code> (<a href="chap7_mj.html#X803ACEDA7BBAC5B3"><span class="RefLink">7.2-10</span></a>)], then the performance is likely to be better.</p>

<p>For symmetric digraphs, see also <code class="func">DigraphUndirectedGirth</code> (<a href="chap5_mj.html#X84688B337BDDBB09"><span class="RefLink">5.3-8</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1], [1]]);</span>
&lt;immutable digraph with 2 vertices, 2 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphGirth(D);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 3], [3], [4], []]);</span>
&lt;immutable digraph with 4 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphGirth(D);</span>
infinity
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 3], [3], [4], [1]]);</span>
&lt;immutable digraph with 4 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphGirth(D);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := GeneralisedPetersenGraph(IsMutableDigraph, 6, 2);</span>
&lt;mutable digraph with 12 vertices, 36 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphGirth(D);</span>
2
</pre></div>

<p><a id="X8374B7357EC189C1" name="X8374B7357EC189C1"></a></p>

<h5>5.3-7 DigraphOddGirth</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphOddGirth</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An integer, or <code class="keyw">infinity</code>.</p>

<p>This attribute returns the <em>odd girth</em> of the digraph <var class="Arg">digraph</var>. The <em>odd girth</em> of a digraph is the length of its shortest simple circuit of odd length. See Section <a href="chap1_mj.html#X84541F61810C741D"><span class="RefLink">1.1-1</span></a> for the definitions of simple circuit, directed cycle, and loop.</p>

<p>If <var class="Arg">digraph</var> has no directed cycles of odd length, then this function will return <code class="keyw">infinity</code>, even if <var class="Arg">digraph</var> has a directed cycle of even length. If <var class="Arg">digraph</var> contains a loop, then this function will return <code class="code">1</code>.</p>

<p>See also <code class="func">DigraphGirth</code> (<a href="chap5_mj.html#X79A3DA4078CF3C90"><span class="RefLink">5.3-6</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [3, 1], [1]]);</span>
&lt;immutable digraph with 3 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphOddGirth(D);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(4);</span>
&lt;immutable cycle digraph with 4 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphOddGirth(D);</span>
infinity
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [3], [], [3], [4]]);</span>
&lt;immutable digraph with 5 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphOddGirth(D);</span>
infinity
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 4);</span>
&lt;mutable digraph with 4 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDisjointUnion(D, CycleDigraph(5));</span>
&lt;mutable digraph with 9 vertices, 9 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphOddGirth(D);</span>
5
</pre></div>

<p><a id="X84688B337BDDBB09" name="X84688B337BDDBB09"></a></p>

<h5>5.3-8 DigraphUndirectedGirth</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphUndirectedGirth</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An integer or <code class="keyw">infinity</code>.</p>

<p>If <var class="Arg">digraph</var> is a symmetric digraph, then this function returns the girth of <var class="Arg">digraph</var> when treated as an undirected graph (i.e. each pair of edges <span class="SimpleMath">\([i, j]\)</span> and <span class="SimpleMath">\([j, i]\)</span> is treated as a single edge between <span class="SimpleMath">\(i\)</span> and <span class="SimpleMath">\(j\)</span>).</p>

<p>The <em>girth</em> of an undirected graph is the length of its shortest simple cycle, i.e. the shortest non-trivial path starting and ending at the same vertex and passing through no vertex or edge more than once.</p>

<p>If <var class="Arg">digraph</var> has no cycles, then this function will return <code class="keyw">infinity</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 4], [1, 3], [2, 4], [1, 3]]);</span>
&lt;immutable digraph with 4 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphUndirectedGirth(D);</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [1, 3], [2]]);</span>
&lt;immutable digraph with 3 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphUndirectedGirth(D);</span>
infinity
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1], [], [4], [3]]);</span>
&lt;immutable digraph with 4 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphUndirectedGirth(D);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := GeneralisedPetersenGraph(IsMutableDigraph, 9, 2);</span>
&lt;mutable digraph with 18 vertices, 54 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphUndirectedGirth(D);</span>
5
</pre></div>

<p><a id="X842FAD6A7B835977" name="X842FAD6A7B835977"></a></p>

<h5>5.3-9 DigraphConnectedComponents</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphConnectedComponents</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphNrConnectedComponents</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A record.</p>

<p>This function returns the record <code class="code">wcc</code> corresponding to the weakly connected components of the digraph <var class="Arg">digraph</var>. Two vertices of <var class="Arg">digraph</var> are in the same weakly connected component whenever they are equal, or there exists a directed path (ignoring the orientation of edges) between them. More formally, two vertices are in the same weakly connected component of <var class="Arg">digraph</var> if and only if they are in the same strongly connected component (see <code class="func">DigraphStronglyConnectedComponents</code> (<a href="chap5_mj.html#X833ECD6B7A84944C"><span class="RefLink">5.3-11</span></a>)) of the <code class="func">DigraphSymmetricClosure</code> (<a href="chap3_mj.html#X874883DD7DD450C4"><span class="RefLink">3.3-11</span></a>) of <var class="Arg">digraph</var>.</p>

<p>The set of weakly connected components is a partition of the vertex set of <var class="Arg">digraph</var>.</p>

<p>The record <code class="code">wcc</code> has 2 components: <code class="code">comps</code> and <code class="code">id</code>. The component <code class="code">comps</code> is a list of the weakly connected components of <var class="Arg">digraph</var> (each of which is a list of vertices). The component <code class="code">id</code> is a list such that the vertex <code class="code">i</code> is an element of the weakly connected component <code class="code">comps[id[i]]</code>.</p>

<p>The method used in this function has complexity <span class="SimpleMath">\(O(m+n)\)</span>, where <span class="SimpleMath">\(m\)</span> is the number of edges and <span class="SimpleMath">\(n\)</span> is the number of vertices in the digraph.</p>

<p><code class="code">DigraphNrConnectedComponents(<var class="Arg">digraph</var>)</code> is simply a shortcut for <code class="code">Length(DigraphConnectedComponents(<var class="Arg">digraph</var>).comps)</code>, and is no more efficient.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([[2], [3, 1], []]);</span>
&lt;immutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphConnectedComponents(gr);</span>
rec( comps := [ [ 1, 2, 3 ] ], id := [ 1, 1, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([[1], [1, 2], []]);</span>
&lt;immutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphConnectedComponents(gr);</span>
rec( comps := [ [ 1, 2 ], [ 3 ] ], id := [ 1, 1, 2 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphNrConnectedComponents(gr);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := EmptyDigraph(0);</span>
&lt;immutable empty digraph with 0 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphConnectedComponents(gr);</span>
rec( comps := [  ], id := [  ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 2);</span>
&lt;mutable digraph with 2 vertices, 2 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := CycleDigraph(3);</span>
&lt;immutable cycle digraph with 3 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDisjointUnion(D, G);</span>
&lt;mutable digraph with 5 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphConnectedComponents(D);</span>
rec( comps := [ [ 1, 2 ], [ 3, 4, 5 ] ], id := [ 1, 1, 2, 2, 2 ] )
</pre></div>

<p><a id="X8484EC557810CD31" name="X8484EC557810CD31"></a></p>

<h5>5.3-10 DigraphConnectedComponent</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphConnectedComponent</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of vertices.</p>

<p>If <var class="Arg">vertex</var> is a vertex in the digraph <var class="Arg">digraph</var>, then this operation returns the connected component of <var class="Arg">vertex</var> in <var class="Arg">digraph</var>. See <code class="func">DigraphConnectedComponents</code> (<a href="chap5_mj.html#X842FAD6A7B835977"><span class="RefLink">5.3-9</span></a>) for more information.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3], [2], [1, 2], [4]]);</span>
&lt;immutable digraph with 4 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphConnectedComponent(D, 3);</span>
[ 1, 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphConnectedComponent(D, 2);</span>
[ 1, 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphConnectedComponent(D, 4);</span>
[ 4 ]
</pre></div>

<p><a id="X833ECD6B7A84944C" name="X833ECD6B7A84944C"></a></p>

<h5>5.3-11 DigraphStronglyConnectedComponents</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphStronglyConnectedComponents</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphNrStronglyConnectedComponents</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A record.</p>

<p>This function returns the record <code class="code">scc</code> corresponding to the strongly connected components of the digraph <var class="Arg">digraph</var>. Two vertices of <var class="Arg">digraph</var> are in the same strongly connected component whenever they are equal, or there is a directed path from each vertex to the other. The set of strongly connected components is a partition of the vertex set of <var class="Arg">digraph</var>.</p>

<p>The record <code class="code">scc</code> has 2 components: <code class="code">comps</code> and <code class="code">id</code>. The component <code class="code">comps</code> is a list of the strongly connected components of <var class="Arg">digraph</var> (each of which is a list of vertices). The component <code class="code">id</code> is a list such that the vertex <code class="code">i</code> is an element of the strongly connected component <code class="code">comps[id[i]]</code>.</p>

<p>The method used in this function is a non-recursive version of Gabow's Algorithm <a href="chapBib_mj.html#biBGab00">[Gab00]</a> and has complexity <span class="SimpleMath">\(O(m+n)\)</span> where <span class="SimpleMath">\(m\)</span> is the number of edges (counting multiple edges as one) and <span class="SimpleMath">\(n\)</span> is the number of vertices in the digraph.</p>

<p><code class="code">DigraphNrStronglyConnectedComponents(<var class="Arg">digraph</var>)</code> is simply a shortcut for <code class="code">Length(DigraphStronglyConnectedComponents(<var class="Arg">digraph</var>).comps)</code>, and is no more efficient.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([[2], [3, 1], []]);</span>
&lt;immutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphStronglyConnectedComponents(gr);</span>
rec( comps := [ [ 3 ], [ 1, 2 ] ], id := [ 2, 2, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphNrStronglyConnectedComponents(gr);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphDisjointUnion(CycleDigraph(4), CycleDigraph(5));</span>
&lt;immutable digraph with 9 vertices, 9 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphStronglyConnectedComponents(D);</span>
rec( comps := [ [ 1, 2, 3, 4 ], [ 5, 6, 7, 8, 9 ] ], 
  id := [ 1, 1, 1, 1, 2, 2, 2, 2, 2 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphNrStronglyConnectedComponents(D);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 2);</span>
&lt;mutable digraph with 2 vertices, 2 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := CycleDigraph(3);</span>
&lt;immutable cycle digraph with 3 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDisjointUnion(D, G);</span>
&lt;mutable digraph with 5 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphStronglyConnectedComponents(D);</span>
rec( comps := [ [ 1, 2 ], [ 3, 4, 5 ] ], id := [ 1, 1, 2, 2, 2 ] )
</pre></div>

<p><a id="X7EFCB5017D662254" name="X7EFCB5017D662254"></a></p>

<h5>5.3-12 DigraphStronglyConnectedComponent</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphStronglyConnectedComponent</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of vertices.</p>

<p>If <var class="Arg">vertex</var> is a vertex in the digraph <var class="Arg">digraph</var>, then this operation returns the strongly connected component of <var class="Arg">vertex</var> in <var class="Arg">digraph</var>. See <code class="func">DigraphStronglyConnectedComponents</code> (<a href="chap5_mj.html#X833ECD6B7A84944C"><span class="RefLink">5.3-11</span></a>) for more information.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3], [2], [1, 2], [3]]);</span>
&lt;immutable digraph with 4 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphStronglyConnectedComponent(D, 3);</span>
[ 1, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphStronglyConnectedComponent(D, 2);</span>
[ 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphStronglyConnectedComponent(D, 4);</span>
[ 4 ]
</pre></div>

<p><a id="X7F1B5A2782F598B1" name="X7F1B5A2782F598B1"></a></p>

<h5>5.3-13 DigraphBicomponents</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphBicomponents</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A pair of lists of vertices, or <code class="keyw">fail</code>.</p>

<p>If <var class="Arg">digraph</var> is a bipartite digraph, i.e. if it satisfies <code class="func">IsBipartiteDigraph</code> (<a href="chap6_mj.html#X860CFB0C8665F356"><span class="RefLink">6.1-3</span></a>), then <code class="code">DigraphBicomponents</code> returns a pair of bicomponents of <var class="Arg">digraph</var>. Otherwise, <code class="code">DigraphBicomponents</code> returns <code class="keyw">fail</code>.</p>

<p>For a bipartite digraph, the vertices can be partitioned into two non-empty sets such that the source and range of any edge are in distinct sets. The parts of this partition are called <em>bicomponents</em> of <var class="Arg">digraph</var>. Equivalently, a pair of bicomponents of <var class="Arg">digraph</var> consists of the color-classes of a 2-coloring of <var class="Arg">digraph</var>.</p>

<p>For a bipartite digraph with at least 3 vertices, there is a unique pair of bicomponents of bipartite if and only if the digraph is connected. See <code class="func">IsConnectedDigraph</code> (<a href="chap6_mj.html#X83C08C0B7EC1A91F"><span class="RefLink">6.3-3</span></a>) for more information.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(3);</span>
&lt;immutable cycle digraph with 3 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphBicomponents(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := ChainDigraph(5);</span>
&lt;immutable chain digraph with 5 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphBicomponents(D);</span>
[ [ 1, 3, 5 ], [ 2, 4 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[5], [1, 4], [5], [5], []]);</span>
&lt;immutable digraph with 5 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphBicomponents(D);</span>
[ [ 1, 3, 4 ], [ 2, 5 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CompleteBipartiteDigraph(IsMutableDigraph, 2, 3);</span>
&lt;mutable digraph with 5 vertices, 12 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphBicomponents(D);</span>
[ [ 1, 2 ], [ 3, 4, 5 ] ]
</pre></div>

<p><a id="X7DDE06E47E605DD7" name="X7DDE06E47E605DD7"></a></p>

<h5>5.3-14 ArticulationPoints</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ArticulationPoints</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of vertices.</p>

<p>A connected digraph is <em>biconnected</em> if it is still connected (in the sense of <code class="func">IsConnectedDigraph</code> (<a href="chap6_mj.html#X83C08C0B7EC1A91F"><span class="RefLink">6.3-3</span></a>)) when any vertex is removed. If the digraph <var class="Arg">digraph</var> is not biconnected but is connected, then any vertex <code class="code">v</code> of <var class="Arg">digraph</var> whose removal makes the resulting digraph disconnected is called an <em>articulation point</em>.</p>

<p><code class="code">ArticulationPoints</code> returns a list of the articulation points of <var class="Arg">digraph</var>, if any, and, in particular, returns the empty list if <var class="Arg">digraph</var> is not connected.</p>

<p>Multiple edges and loops are ignored by this method.</p>

<p>The method used in this operation has complexity <span class="SimpleMath">\(O(m+n)\)</span> where <span class="SimpleMath">\(m\)</span> is the number of edges (counting multiple edges as one, and not counting loops) and <span class="SimpleMath">\(n\)</span> is the number of vertices in the digraph. See also <code class="func">IsBiconnectedDigraph</code> (<a href="chap6_mj.html#X838FAF2D825977BE"><span class="RefLink">6.3-4</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ArticulationPoints(CycleDigraph(5));</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 7], [3, 5], [4], [2], [6], [1], []]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ArticulationPoints(D);</span>
[ 2, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ArticulationPoints(ChainDigraph(5));</span>
[ 4, 3, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ArticulationPoints(NullDigraph(5));</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := ChainDigraph(IsMutableDigraph, 4);</span>
&lt;mutable digraph with 4 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ArticulationPoints(D);</span>
[ 3, 2 ]
</pre></div>

<p><a id="X853D0B0981A33433" name="X853D0B0981A33433"></a></p>

<h5>5.3-15 DigraphPeriod</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphPeriod</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An integer.</p>

<p>This function returns the period of the digraph <var class="Arg">digraph</var>.</p>

<p>If a digraph <var class="Arg">digraph</var> has at least one directed cycle, then the period is the greatest positive integer which divides the lengths of all directed cycles of <var class="Arg">digraph</var>. If <var class="Arg">digraph</var> has no directed cycles, then this function returns <span class="SimpleMath">\(0\)</span>. See section <a href="chap1_mj.html#X84541F61810C741D"><span class="RefLink">1.1-1</span></a> for the definition of a directed cycle.</p>

<p>A digraph with a period of <span class="SimpleMath">\(1\)</span> is said to be <em>aperiodic</em>. See <code class="func">IsAperiodicDigraph</code> (<a href="chap6_mj.html#X80E883967EBE839E"><span class="RefLink">6.3-6</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[6], [1], [2], [3], [4, 4], [5]]);</span>
&lt;immutable multidigraph with 6 vertices, 7 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphPeriod(D);</span>
6
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [3, 5], [4], [5], [1, 2]]);</span>
&lt;immutable digraph with 5 vertices, 7 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphPeriod(D);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := ChainDigraph(2);</span>
&lt;immutable chain digraph with 2 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphPeriod(D);</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAcyclicDigraph(D);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := GeneralisedPetersenGraph(IsMutableDigraph, 5, 2);</span>
&lt;mutable digraph with 10 vertices, 30 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphPeriod(D);</span>
1
</pre></div>

<p><a id="X864A31A8809F61C2" name="X864A31A8809F61C2"></a></p>

<h5>5.3-16 DigraphFloydWarshall</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphFloydWarshall</code>( <var class="Arg">digraph</var>, <var class="Arg">func</var>, <var class="Arg">nopath</var>, <var class="Arg">edge</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A matrix.</p>

<p>If <var class="Arg">digraph</var> is a digraph with <span class="SimpleMath">\(n\)</span> vertices, then this operation returns an <span class="SimpleMath">\(n \times n\)</span> matrix <code class="code">mat</code> containing the output of a generalised version of the Floyd-Warshall algorithm, applied to <var class="Arg">digraph</var>.</p>

<p>The operation <code class="code">DigraphFloydWarshall</code> is customised by the arguments <var class="Arg">func</var>, <var class="Arg">nopath</var>, and <var class="Arg">edge</var>. The arguments <var class="Arg">nopath</var> and <var class="Arg">edge</var> can be arbitrary <strong class="pkg">GAP</strong> objects. The argument <var class="Arg">func</var> must be a function which accepts 4 arguments: the matrix <code class="code">mat</code>, followed by 3 postive integers. The function <var class="Arg">func</var> is where the work to calculate the desired outcome must be performed.</p>

<p>This method initialises the matrix <code class="code">mat</code> by setting entry <code class="code">mat[i][j]</code> to equal <var class="Arg">edge</var> if there is an edge with source <code class="code">i</code> and range <code class="code">j</code>, and by setting entry <code class="code">mat[i][j]</code> to equal <var class="Arg">nopath</var> otherwise. The final part of <code class="code">DigraphFloydWarshall</code> then calls the function <var class="Arg">func</var> inside three nested for loops, over the vertices of <var class="Arg">digraph</var>:</p>


<div class="example"><pre>
for i in DigraphsVertices(digraph) do
  for j in DigraphsVertices(digraph) do
    for k in DigraphsVertices(digraph) do
      func(mat, i, j, k);
    od;
  od;
od;
</pre></div>

<p>The matrix <code class="code">mat</code> is then returned as the result. An example of using <code class="code">DigraphFloydWarshall</code> to calculate the shortest (non-zero) distances between the vertices of a digraph is shown below:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphFromDigraph6String("&amp;EAHQeDB");</span>
&lt;immutable digraph with 6 vertices, 12 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function(mat, i, j, k)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  if mat[i][k] &lt;&gt; -1 and mat[k][j] &lt;&gt; -1 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if (mat[i][j] = -1) or (mat[i][j] &gt; mat[i][k] + mat[k][j]) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      mat[i][j] := mat[i][k] + mat[k][j];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;</span>
function( mat, i, j, k ) ... end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">shortest_distances := DigraphFloydWarshall(D, func, -1, 1);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(shortest_distances);</span>
[ [   3,  -1,  -1,   2,   1,   2 ],
  [   4,   2,   1,   3,   2,   1 ],
  [   3,   1,   2,   2,   1,   2 ],
  [   1,  -1,  -1,   1,   1,   2 ],
  [   2,  -1,  -1,   1,   2,   1 ],
  [   3,  -1,  -1,   2,   1,   1 ] ]
</pre></div>

<p><a id="X7FBAB09E7C0BE5CF" name="X7FBAB09E7C0BE5CF"></a></p>

<h5>5.3-17 IsReachable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsReachable</code>( <var class="Arg">digraph</var>, <var class="Arg">u</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>This operation returns <code class="keyw">true</code> if there exists a non-trivial directed walk from vertex <var class="Arg">u</var> to vertex <var class="Arg">v</var> in the digraph <var class="Arg">digraph</var>, and <code class="keyw">false</code> if there does not exist such a directed walk. See section <a href="chap1_mj.html#X84541F61810C741D"><span class="RefLink">1.1-1</span></a> for the definition of a non-trivial directed walk.</p>

<p>The method for <code class="code">IsReachable</code> has worst case complexity of <span class="SimpleMath">\(O(m + n)\)</span> where <span class="SimpleMath">\(m\)</span> is the number of edges and <span class="SimpleMath">\(n\)</span> the number of vertices in <var class="Arg">digraph</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [3], [2, 3]]);</span>
&lt;immutable digraph with 3 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsReachable(D, 1, 3);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsReachable(D, 2, 1);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsReachable(D, 3, 3);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsReachable(D, 1, 1);</span>
false
</pre></div>

<p><a id="X8039170B82A32257" name="X8039170B82A32257"></a></p>

<h5>5.3-18 DigraphPath</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphPath</code>( <var class="Arg">digraph</var>, <var class="Arg">u</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A pair of lists, or <code class="keyw">fail</code>.</p>

<p>If there exists a non-trivial directed path (or a non-trivial cycle, in the case that <var class="Arg">u</var> <code class="code">=</code> <var class="Arg">v</var>) from vertex <var class="Arg">u</var> to vertex <var class="Arg">v</var> in the digraph <var class="Arg">digraph</var>, then this operation returns such a directed path (or directed cycle). Otherwise, this operation returns <code class="keyw">fail</code>. See Section <a href="chap1_mj.html#X84541F61810C741D"><span class="RefLink"><span class="Heading">Definitions</span></span></a> for the definition of a directed path and a directed cycle.</p>

<p>A directed path (or directed cycle) of non-zero length <code class="code">n-1</code>, <span class="SimpleMath">\((v_1, e_1, v_2, e_2, ..., e_{n-1}, v_n)\)</span>, is represented by a pair of lists <code class="code">[v,a]</code> as follows:</p>


<ul>
<li><p><code class="code">v</code> is the list <span class="SimpleMath">\([v_1, v_2, ..., v_n]\)</span>.</p>

</li>
<li><p><code class="code">a</code> is the list of positive integers <span class="SimpleMath">\([a_1, a_2, ..., a_{n-1}]\)</span> where for each each <span class="SimpleMath">\(i &lt; n\)</span>, <span class="SimpleMath">\(a_i\)</span> is the position of <span class="SimpleMath">\(v_{i+1}\)</span> in <code class="code">OutNeighboursOfVertex(</code><var class="Arg">digraph</var><code class="code">,</code><span class="SimpleMath">\(v_i\)</span><code class="code">)</code> corresponding to the edge <span class="SimpleMath">\(e_i\)</span>. This is can be useful if the position of a vertex in a list of out-neighours is significant, for example in orbit digraphs.</p>

</li>
</ul>
<p>The method for <code class="code">DigraphPath</code> has worst case complexity of <span class="SimpleMath">\(O(m + n)\)</span> where <span class="SimpleMath">\(m\)</span> is the number of edges and <span class="SimpleMath">\(n\)</span> the number of vertices in <var class="Arg">digraph</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [3], [2, 3]]);</span>
&lt;immutable digraph with 3 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphPath(D, 1, 3);</span>
[ [ 1, 2, 3 ], [ 1, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphPath(D, 2, 1);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphPath(D, 3, 3);</span>
[ [ 3, 3 ], [ 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphPath(D, 1, 1);</span>
fail
</pre></div>

<p><a id="X80E9D645843973A6" name="X80E9D645843973A6"></a></p>

<h5>5.3-19 DigraphShortestPath</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphShortestPath</code>( <var class="Arg">digraph</var>, <var class="Arg">u</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A pair of lists, or <code class="keyw">fail</code>.</p>

<p>Returns the shortest directed path in the digraph digraph from the vertex <var class="Arg">u</var> to the vertex <var class="Arg">v</var>, if such a path exists. If <code class="code"><var class="Arg">u</var> = <var class="Arg">v</var></code>, then the shortest non-trivial cycle is returned, again, if it exists. Otherwise, this operation returns <code class="keyw">fail</code>. See Section <a href="chap1_mj.html#X84541F61810C741D"><span class="RefLink"><span class="Heading">Definitions</span></span></a> for the definition of a directed path and a directed cycle.</p>

<p>See <code class="func">DigraphPath</code> (<a href="chap5_mj.html#X8039170B82A32257"><span class="RefLink">5.3-18</span></a>) for details on the output. The method for <code class="code">DigraphShortestPath</code> has worst case complexity of <span class="SimpleMath">\(O(m + n)\)</span> where <span class="SimpleMath">\(m\)</span> is the number of edges and <span class="SimpleMath">\(n\)</span> the number of vertices in <var class="Arg">digraph</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1, 2], [3], [2, 4], [1], [2, 4]]);</span>
&lt;immutable digraph with 5 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphShortestPath(D, 5, 1);</span>
[ [ 5, 4, 1 ], [ 2, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphShortestPath(D, 3, 3);</span>
[ [ 3, 2, 3 ], [ 1, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphShortestPath(D, 5, 5);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphShortestPath(D, 1, 1);</span>
[ [ 1, 1 ], [ 1 ] ]
</pre></div>

<p><a id="X7C0416FE7A69CA2C" name="X7C0416FE7A69CA2C"></a></p>

<h5>5.3-20 IteratorOfPaths</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IteratorOfPaths</code>( <var class="Arg">digraph</var>, <var class="Arg">u</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An iterator.</p>

<p>If <var class="Arg">digraph</var> is a digraph or a list of adjacencies which defines a digraph - see <code class="func">OutNeighbours</code> (<a href="chap5_mj.html#X7E9880767AE68E00"><span class="RefLink">5.2-6</span></a>) - then this operation returns an iterator of the non-trivial directed paths (or directed cycles, in the case that <var class="Arg">u</var> <code class="code">=</code> <var class="Arg">v</var>) in <var class="Arg">digraph</var> from the vertex <var class="Arg">u</var> to the vertex <var class="Arg">v</var>.</p>

<p>See <code class="func">DigraphPath</code> (<a href="chap5_mj.html#X8039170B82A32257"><span class="RefLink">5.3-18</span></a>) for more information about the repesentation of a directed path or directed cycle which is used, and see <a href="../../../doc/ref/chap30_mj.html#X85A3F00985453F95"><span class="RefLink">Reference: Iterators</span></a> for more information about iterators. See Section <a href="chap1_mj.html#X84541F61810C741D"><span class="RefLink"><span class="Heading">Definitions</span></span></a> for the definition of a directed path and a directed cycle.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1, 4, 4, 2], [3, 5], [2, 3], [1, 2], [4]]);</span>
&lt;immutable multidigraph with 5 vertices, 11 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iter := IteratorOfPaths(D, 1, 4);</span>
&lt;iterator&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextIterator(iter);</span>
[ [ 1, 4 ], [ 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextIterator(iter);</span>
[ [ 1, 4 ], [ 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextIterator(iter);</span>
[ [ 1, 2, 5, 4 ], [ 4, 2, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDoneIterator(iter);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iter := IteratorOfPaths(D, 4, 3);</span>
&lt;iterator&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextIterator(iter);</span>
[ [ 4, 1, 2, 3 ], [ 1, 4, 1 ] ]
</pre></div>

<p><a id="X7ECD16838704FAAA" name="X7ECD16838704FAAA"></a></p>

<h5>5.3-21 DigraphAllSimpleCircuits</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphAllSimpleCircuits</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of lists of vertices.</p>

<p>If <var class="Arg">digraph</var> is a digraph, then <code class="code">DigraphAllSimpleCircuits</code> returns a list of the <em>simple circuits</em> in <var class="Arg">digraph</var>.</p>

<p>See section <a href="chap1_mj.html#X84541F61810C741D"><span class="RefLink">1.1-1</span></a> for the definition of a simple circuit, and related notions. Note that a loop is a simple circuit.</p>

<p>For a digraph without multiple edges, a simple circuit is uniquely determined by its subsequence of vertices. However this is not the case for a multidigraph. The attribute <code class="code">DigraphAllSimpleCircuits</code> ignores multiple edges, and identifies a simple circuit using only its subsequence of vertices. For example, although the simple circuits <span class="SimpleMath">\((v, e, v)\)</span> and <span class="SimpleMath">\((v, e', v)\)</span> (for distinct edges <span class="SimpleMath">\(e\)</span> and <span class="SimpleMath">\(e'\)</span>) are mathematically distinct, <code class="code">DigraphAllSimpleCircuits</code> considers them to be the same.</p>

<p>With this approach, a directed circuit of length <code class="code">n</code> can be determined by a list of its first <code class="code">n</code> vertices. Thus a simple circuit <span class="SimpleMath">\((v_1, e_1, v_2, e_2, ..., e_{n-1}, v_n, e_{n+1}, v_1)\)</span> can be represented as the list <span class="SimpleMath">\([v_1, \ldots, v_n]\)</span>, or any cyclic permutation thereof. For each simple circuit of <var class="Arg">digraph</var>, <code class="code">DigraphAllSimpleCircuits(<var class="Arg">digraph</var>)</code> includes precisely one such list to represent the circuit.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[], [3], [2, 4], [5, 4], [4]]);</span>
&lt;immutable digraph with 5 vertices, 6 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphAllSimpleCircuits(D);</span>
[ [ 4 ], [ 4, 5 ], [ 2, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := ChainDigraph(10);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphAllSimpleCircuits(D);</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3], [1], [1]]);</span>
&lt;immutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphAllSimpleCircuits(D);</span>
[ [ 1, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1, 1]]);</span>
&lt;immutable multidigraph with 1 vertex, 2 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphAllSimpleCircuits(D);</span>
[ [ 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphAllSimpleCircuits(D);</span>
[ [ 1, 2, 3 ] ]
</pre></div>

<p><a id="X7C735C4E86BDD5F6" name="X7C735C4E86BDD5F6"></a></p>

<h5>5.3-22 DigraphLongestSimpleCircuit</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphLongestSimpleCircuit</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of vertices, or <code class="keyw">fail</code>.</p>

<p>If <var class="Arg">digraph</var> is a digraph, then <code class="code">DigraphLongestSimpleCircuit</code> returns the longest <em>simple circuit</em> in <var class="Arg">digraph</var>. See section <a href="chap1_mj.html#X84541F61810C741D"><span class="RefLink">1.1-1</span></a> for the definition of simple circuit, and the definition of length for a simple circuit.</p>

<p>This attribute computes <code class="code">DigraphAllSimpleCircuits(</code><var class="Arg">digraph</var><code class="code">)</code> to find all the simple circuits of <var class="Arg">digraph</var>, and returns one of maximal length. A simple circuit is represented as a list of vertices, in the same way as described in <code class="func">DigraphAllSimpleCircuits</code> (<a href="chap5_mj.html#X7ECD16838704FAAA"><span class="RefLink">5.3-21</span></a>).</p>

<p>If <var class="Arg">digraph</var> has no simple circuits, then this attribute returns <code class="keyw">fail</code>. If <var class="Arg">digraph</var> has multiple simple circuits of maximal length, then this attribute returns one of them.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[], [3], [2, 4], [5, 4], [4]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphLongestSimpleCircuit(D);</span>
[ 4, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := ChainDigraph(10);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphLongestSimpleCircuit(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3], [1], [1, 4], [1, 1]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphLongestSimpleCircuit(D);</span>
[ 1, 3, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := GeneralisedPetersenGraph(IsMutableDigraph, 4, 1);</span>
&lt;mutable digraph with 8 vertices, 24 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphLongestSimpleCircuit(D);</span>
[ 1, 2, 3, 4, 8, 7, 6, 5 ]
</pre></div>

<p><a id="X870E04307C5F213F" name="X870E04307C5F213F"></a></p>

<h5>5.3-23 DigraphLayers</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphLayers</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list.</p>

<p>This operation returns a list <code class="keyw">list</code> such that <code class="keyw">list[i]</code> is the list of vertices whose minimum distance from the vertex <var class="Arg">vertex</var> in <var class="Arg">digraph</var> is <code class="keyw">i - 1</code>. Vertex <var class="Arg">vertex</var> is assumed to be at distance <code class="keyw">0</code> from itself.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CompleteDigraph(4);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphLayers(D, 1);</span>
[ [ 1 ], [ 2, 3, 4 ] ]
</pre></div>

<p><a id="X7B2E42327DA118E0" name="X7B2E42327DA118E0"></a></p>

<h5>5.3-24 DigraphDegeneracy</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphDegeneracy</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A non-negative integer, or <code class="keyw">fail</code>.</p>

<p>If <var class="Arg">digraph</var> is a symmetric digraph without multiple edges - see <code class="func">IsSymmetricDigraph</code> (<a href="chap6_mj.html#X81B3EA7887219860"><span class="RefLink">6.1-12</span></a>) and <code class="func">IsMultiDigraph</code> (<a href="chap6_mj.html#X7BB84CFC7E8B2B26"><span class="RefLink">6.1-10</span></a>) - then this attribute returns the degeneracy of <var class="Arg">digraph</var>.</p>

<p>The degeneracy of a digraph is the least integer <code class="code">k</code> such that every induced of <var class="Arg">digraph</var> contains a vertex whose number of neighbours (excluding itself) is at most <code class="code">k</code>. Note that this means that loops are ignored.</p>

<p>If <var class="Arg">digraph</var> is not symmetric or has multiple edges then this attribute returns <code class="keyw">fail</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphSymmetricClosure(ChainDigraph(5));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDegeneracy(D);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CompleteDigraph(5);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDegeneracy(D);</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1], [2, 4, 5], [3, 4], [2, 3, 4], [2], []]);</span>
&lt;immutable digraph with 6 vertices, 10 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDegeneracy(D);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := GeneralisedPetersenGraph(IsMutableDigraph, 10, 3);</span>
&lt;mutable digraph with 20 vertices, 60 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDegeneracy(D);</span>
3
</pre></div>

<p><a id="X827C2BD17A4547E3" name="X827C2BD17A4547E3"></a></p>

<h5>5.3-25 DigraphDegeneracyOrdering</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphDegeneracyOrdering</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of integers, or <code class="keyw">fail</code>.</p>

<p>If <var class="Arg">digraph</var> is a digraph for which <code class="code">DigraphDegeneracy(</code><var class="Arg">digraph</var><code class="code">)</code> is a non-negative integer <code class="code">k</code> - see <code class="func">DigraphDegeneracy</code> (<a href="chap5_mj.html#X7B2E42327DA118E0"><span class="RefLink">5.3-24</span></a>) - then this attribute returns a degeneracy ordering of the vertices of the vertices of <var class="Arg">digraph</var>.</p>

<p>A degeneracy ordering of <var class="Arg">digraph</var> is a list <code class="code">ordering</code> of the vertices of <var class="Arg">digraph</var> ordered such that for any position <code class="code">i</code> of the list, the vertex <code class="code">ordering[i]</code> has at most <code class="code">k</code> neighbours in later position of the list.</p>

<p>If <code class="code">DigraphDegeneracy(</code><var class="Arg">digraph</var><code class="code">)</code> returns <code class="keyw">fail</code>, then this attribute returns <code class="keyw">fail</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphSymmetricClosure(ChainDigraph(5));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDegeneracyOrdering(D);</span>
[ 5, 4, 3, 2, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CompleteDigraph(5);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDegeneracyOrdering(D);</span>
[ 5, 4, 3, 2, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1], [2, 4, 5], [3, 4], [2, 3, 4], [2], []]);</span>
&lt;immutable digraph with 6 vertices, 10 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDegeneracyOrdering(D);</span>
[ 1, 6, 5, 2, 4, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := GeneralisedPetersenGraph(IsMutableDigraph, 3, 1);</span>
&lt;mutable digraph with 6 vertices, 18 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDegeneracyOrdering(D);</span>
[ 6, 5, 4, 1, 3, 2 ]
</pre></div>

<p><a id="X863FDFC4839A3B82" name="X863FDFC4839A3B82"></a></p>

<h5>5.3-26 HamiltonianPath</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HamiltonianPath</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list or <code class="keyw">fail</code>.</p>

<p>Returns a Hamiltonian path if one exists, <code class="keyw">fail</code> if not.</p>

<p>A <em>Hamiltonian path</em> of a digraph with <code class="code">n</code> vertices is directed cycle of length <code class="code">n</code>. If <var class="Arg">digraph</var> is a digraph that contains a Hamiltonian path, then this function returns one, described in the form used by <code class="func">DigraphAllSimpleCircuits</code> (<a href="chap5_mj.html#X7ECD16838704FAAA"><span class="RefLink">5.3-21</span></a>). Note if <var class="Arg">digraph</var> has 0 or 1 vertices, then <code class="code">HamiltonianPath</code> returns <code class="code">[]</code> or <code class="code">[1]</code>, respectively.</p>

<p>The method used in this attribute has the same worst case complexity as <code class="func">DigraphMonomorphism</code> (<a href="chap7_mj.html#X82D0FCD87D47ACA8"><span class="RefLink">7.3-4</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[]]);</span>
&lt;immutable empty digraph with 1 vertex&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HamiltonianPath(D);</span>
[ 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [1]]);</span>
&lt;immutable digraph with 2 vertices, 2 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HamiltonianPath(D);</span>
[ 1, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3], [], [2]]);</span>
&lt;immutable digraph with 3 vertices, 2 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HamiltonianPath(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [3], [1]]);</span>
&lt;immutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HamiltonianPath(D);</span>
[ 1, 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := GeneralisedPetersenGraph(IsMutableDigraph, 5, 2);</span>
&lt;mutable digraph with 10 vertices, 30 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HamiltonianPath(D);</span>
fail
</pre></div>

<p><a id="X82F30D5681466BC6" name="X82F30D5681466BC6"></a></p>

<h5>5.3-27 NrSpanningTrees</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NrSpanningTrees</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An integer.</p>

<p>Returns the number of spanning trees of the symmetric digraph <var class="Arg">digraph</var>. <code class="code">NrSpanningTrees</code> will return an error if <var class="Arg">digraph</var> is not a symmetric digraph.</p>

<p>See <code class="func">IsSymmetricDigraph</code> (<a href="chap6_mj.html#X81B3EA7887219860"><span class="RefLink">6.1-12</span></a>) and <code class="func">IsUndirectedSpanningTree</code> (<a href="chap4_mj.html#X833C3299787E2309"><span class="RefLink">4.1-2</span></a>) for more information.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CompleteDigraph(5);</span>
&lt;immutable complete digraph with 5 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrSpanningTrees(D);</span>
125
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphSymmetricClosure(CycleDigraph(24));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrSpanningTrees(D);</span>
24
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrSpanningTrees(EmptyDigraph(0));</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := GeneralisedPetersenGraph(IsMutableDigraph, 9, 2);</span>
&lt;mutable digraph with 18 vertices, 54 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrSpanningTrees(D);</span>
1134225
</pre></div>

<p><a id="X82F900777D677F55" name="X82F900777D677F55"></a></p>

<h4>5.4 <span class="Heading">Cayley graphs of groups</span></h4>

<p><a id="X7A000B1D7CCF7093" name="X7A000B1D7CCF7093"></a></p>

<h5>5.4-1 GroupOfCayleyDigraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GroupOfCayleyDigraph</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SemigroupOfCayleyDigraph</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A group or semigroup.</p>

<p>If <var class="Arg">digraph</var> is an immutable Cayley graph of a group <code class="code">G</code> and <var class="Arg">digraph</var> belongs to the category <code class="func">IsCayleyDigraph</code> (<a href="chap3_mj.html#X7E749324800B38A5"><span class="RefLink">3.1-4</span></a>), then <code class="code">GroupOfCayleyDigraph</code> returns <code class="code">G</code>.</p>

<p>If <var class="Arg">digraph</var> is a Cayley graph of a semigroup <code class="code">S</code> and <var class="Arg">digraph</var> belongs to the category <code class="func">IsCayleyDigraph</code> (<a href="chap3_mj.html#X7E749324800B38A5"><span class="RefLink">3.1-4</span></a>), then <code class="code">SemigroupOfCayleyDigraph</code> returns <code class="code">S</code>.</p>

<p>See also <code class="func">GeneratorsOfCayleyDigraph</code> (<a href="chap5_mj.html#X8528455987D7D2BF"><span class="RefLink">5.4-2</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := DihedralGroup(IsPermGroup, 8);</span>
Group([ (1,2,3,4), (2,4) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph := CayleyDigraph(G);</span>
&lt;immutable digraph with 8 vertices, 16 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GroupOfCayleyDigraph(digraph) = G;</span>
true
</pre></div>

<p><a id="X8528455987D7D2BF" name="X8528455987D7D2BF"></a></p>

<h5>5.4-2 GeneratorsOfCayleyDigraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GeneratorsOfCayleyDigraph</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of generators.</p>

<p>If <var class="Arg">digraph</var> is an immutable Cayley graph of a group or semigroup with respect to a set of generators <code class="code">gens</code> and <var class="Arg">digraph</var> belongs to the category <code class="func">IsCayleyDigraph</code> (<a href="chap3_mj.html#X7E749324800B38A5"><span class="RefLink">3.1-4</span></a>), then <code class="code">GeneratorsOfCayleyDigraph</code> return the list of generators <code class="code">gens</code> over which <var class="Arg">digraph</var> is defined.</p>

<p>See also <code class="func">GroupOfCayleyDigraph</code> (<a href="chap5_mj.html#X7A000B1D7CCF7093"><span class="RefLink">5.4-1</span></a>) or <code class="func">SemigroupOfCayleyDigraph</code> (<a href="chap5_mj.html#X7A000B1D7CCF7093"><span class="RefLink">5.4-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := DihedralGroup(IsPermGroup, 8);</span>
Group([ (1,2,3,4), (2,4) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph := CayleyDigraph(G);</span>
&lt;immutable digraph with 8 vertices, 16 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsOfCayleyDigraph(digraph) = GeneratorsOfGroup(G);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph := CayleyDigraph(G, [()]);</span>
&lt;immutable digraph with 8 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsOfCayleyDigraph(digraph) = [()];</span>
true</pre></div>

<p><a id="X790FD6647ECCAE3C" name="X790FD6647ECCAE3C"></a></p>

<h4>5.5 <span class="Heading">Associated semigroups</span></h4>

<p><a id="X87D5C60D7B0C1309" name="X87D5C60D7B0C1309"></a></p>

<h5>5.5-1 AsSemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsSemigroup</code>( <var class="Arg">filt</var>, <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsMonoid</code>( <var class="Arg">filt</var>, <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A semilattice of partial perms.</p>

<p>The operation <code class="code">AsSemigroup</code> requires that <var class="Arg">filt</var> be equal to <code class="func">IsPartialPermSemigroup</code> (<a href="../../../doc/ref/chap54_mj.html#X7D161674800B50E0"><span class="RefLink">Reference: IsPartialPermSemigroup</span></a>). If <var class="Arg">digraph</var> is a <code class="func">IsJoinSemilatticeDigraph</code> (<a href="chap6_mj.html#X78D3E17B7F737516"><span class="RefLink">6.1-17</span></a>) or <code class="func">IsLatticeDigraph</code> (<a href="chap6_mj.html#X78D3E17B7F737516"><span class="RefLink">6.1-17</span></a>) then <code class="code">AsSemigroup</code> returns a semigroup of partial perms which is isomorphic to the semigroup whose elements are the vertices of <var class="Arg">digraph</var> with the binary operation <code class="func">PartialOrderDigraphJoinOfVertices</code> (<a href="chap5_mj.html#X7DDB33B686B3A2C6"><span class="RefLink">5.2-15</span></a>). If <var class="Arg">digraph</var> satisfies <code class="func">IsMeetSemilatticeDigraph</code> (<a href="chap6_mj.html#X78D3E17B7F737516"><span class="RefLink">6.1-17</span></a>) but not <code class="func">IsJoinSemilatticeDigraph</code> (<a href="chap6_mj.html#X78D3E17B7F737516"><span class="RefLink">6.1-17</span></a>) then <code class="code">AsSemigroup</code> returns a semigroup of partial perms which is isomorphic to the semigroup whose elements are the vertices of <var class="Arg">digraph</var> with the binary operation <code class="func">PartialOrderDigraphMeetOfVertices</code> (<a href="chap5_mj.html#X7DDB33B686B3A2C6"><span class="RefLink">5.2-15</span></a>).</p>

<p>The operation <code class="code">AsMonoid</code> behaves similarly to <code class="code">AsSemigroup</code> except that <var class="Arg">filt</var> may also be equal to <code class="func">IsPartialPermMonoid</code> (<a href="../../../doc/ref/chap54_mj.html#X7D161674800B50E0"><span class="RefLink">Reference: IsPartialPermMonoid</span></a>), <var class="Arg">digraph</var> must satisfy <code class="func">IsLatticeDigraph</code> (<a href="chap6_mj.html#X78D3E17B7F737516"><span class="RefLink">6.1-17</span></a>), and the output satisfies <code class="func">IsMonoid</code> (<a href="../../../doc/ref/chap51_mj.html#X861C523483C6248C"><span class="RefLink">Reference: IsMonoid</span></a>).</p>

<p>The output of both of these operations is guaranteed to be of minimal degree (see <code class="func">DegreeOfPartialPermSemigroup</code> (<a href="../../../doc/ref/chap54_mj.html#X7D7F0BAB82F0D820"><span class="RefLink">Reference: DegreeOfPartialPermSemigroup</span></a>)). Furthermore the <code class="func">GeneratorsOfSemigroup</code> (<a href="../../../doc/ref/chap51_mj.html#X78147A247963F23B"><span class="RefLink">Reference: GeneratorsOfSemigroup</span></a>) of the output is guaranteed to be the unique generating set of minimal size.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">di := Digraph([[1], [1, 2], [1, 3], [1, 4], [1, 2, 3, 5]]);</span>
&lt;immutable digraph with 5 vertices, 11 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := AsSemigroup(IsPartialPermSemigroup, di);</span>
&lt;partial perm semigroup of rank 3 with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll(Elements(S), IsIdempotent);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsInverseSemigroup(S);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(S);</span>
5
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">di := Digraph([[1], [1, 2], [1, 2, 3]]);</span>
&lt;immutable digraph with 3 vertices, 6 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := AsMonoid(IsPartialPermMonoid, di);</span>
&lt;partial perm monoid of rank 2 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(M);</span>
3</pre></div>

<p><a id="X7C6D5EC27C51066B" name="X7C6D5EC27C51066B"></a></p>

<h5>5.5-2 AsSemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsSemigroup</code>( <var class="Arg">filt</var>, <var class="Arg">Y</var>, <var class="Arg">gps</var>, <var class="Arg">homs</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A Clifford semigroup of partial perms.</p>

<p>The operation <code class="code">AsSemigroup</code> requires that <var class="Arg">filt</var> be equal to <code class="func">IsPartialPermSemigroup</code> (<a href="../../../doc/ref/chap54_mj.html#X7D161674800B50E0"><span class="RefLink">Reference: IsPartialPermSemigroup</span></a>). If <var class="Arg">Y</var> is a <code class="func">IsJoinSemilatticeDigraph</code> (<a href="chap6_mj.html#X78D3E17B7F737516"><span class="RefLink">6.1-17</span></a>) or <code class="func">IsMeetSemilatticeDigraph</code> (<a href="chap6_mj.html#X78D3E17B7F737516"><span class="RefLink">6.1-17</span></a>), <var class="Arg">gps</var> is a list of groups corresponding to each vertex, and <var class="Arg">homs</var> is a list containing for each edge <code class="code">(i, j)</code> in the transitive reduction of <var class="Arg">digraph</var> a triple <code class="code">[i, j, hom]</code> where <code class="code">hom</code> is a group homomorphism from <code class="code">gps[i]</code> to <code class="code">gps[j]</code>, and the diagram of homomorphisms commutes, then <code class="code">AsSemigroup</code> returns a semigroup of partial perms which is isomorphic to the strong semilattice of groups <span class="SimpleMath">\(S[Y; gps; homs]\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G1 := AlternatingGroup(4);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G2 := SymmetricGroup(2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G3 := SymmetricGroup(3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([[1, 3], [2, 3], [3]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sgn := function(x)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">if SignPerm(x) = 1 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">return ();</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">return (1, 2);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom13 := GroupHomomorphismByFunction(G1, G3, sgn);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom23 := GroupHomomorphismByFunction(G2, G3, sgn);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := AsSemigroup(IsPartialPermSemigroup,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">gr,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[G1, G2, G3], [[1, 3, hom13], [2, 3, hom23]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(T);</span>
20
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := GreensDClasses(T);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(D, x -&gt; Size(x));</span>
[ 6, 12, 2 ]
</pre></div>

<p><a id="X7E2305528492DDC0" name="X7E2305528492DDC0"></a></p>

<h4>5.6 <span class="Heading">Planarity</span></h4>

<p><a id="X7DC478637E8C190D" name="X7DC478637E8C190D"></a></p>

<h5>5.6-1 KuratowskiPlanarSubdigraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; KuratowskiPlanarSubdigraph</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list or <code class="keyw">fail</code>.</p>

<p><code class="code">KuratowskiPlanarSubdigraph</code> returns the immutable list of lists of out-neighbours of a (not necessarily induced) subdigraph of the digraph <var class="Arg">digraph</var> that witnesses the fact that <var class="Arg">digraph</var> is not planar, or <code class="keyw">fail</code> if <var class="Arg">digraph</var> is planar. In other words, <code class="code">KuratowskiPlanarSubdigraph</code> returns the out-neighbours of a subdigraph of <var class="Arg">digraph</var> that is homeomorphic to the complete graph with <code class="code">5</code> vertices, or to the complete bipartite graph with vertex sets of sizes <code class="code">3</code> and <code class="code">3</code>.</p>

<p>The directions and multiplicities of any edges in <var class="Arg">digraph</var> are ignored when considering whether or not <var class="Arg">digraph</var> is planar.</p>

<p>See also <code class="func">IsPlanarDigraph</code> (<a href="chap6_mj.html#X8606D415858C40AA"><span class="RefLink">6.4-1</span></a>) and <code class="func">SubdigraphHomeomorphicToK33</code> (<a href="chap5_mj.html#X806D2D6B85E0B269"><span class="RefLink">5.6-5</span></a>).</p>

<p>This method uses the reference implementation in <span class="URL"><a href="https://github.com/graph-algorithms/edge-addition-planarity-suite">edge-addition-planarity-suite</a></span> by John Boyer of the algorithms described in <a href="chapBib_mj.html#biBBM06">[BM06]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3, 5, 10], [8, 9, 10], [1, 4], [3, 6], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 7, 11], [4, 7], [6, 8], [2, 7], [2, 11], [1, 2], [5, 9]]);</span>
&lt;immutable digraph with 11 vertices, 25 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KuratowskiPlanarSubdigraph(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 4, 7, 9, 10], [1, 3, 4, 6, 9, 10], [6, 10], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 5, 8, 9], [1, 2, 3, 4, 6, 7, 9, 10], [3, 4, 5, 7, 9, 10], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 4, 5, 6, 9, 10], [3, 4, 5, 7, 9], [2, 3, 5, 6, 7, 8], [3, 5]]);</span>
&lt;immutable digraph with 10 vertices, 50 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPlanarDigraph(D);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KuratowskiPlanarSubdigraph(D);</span>
[ [ 2, 9, 7 ], [ 3 ], [ 6 ], [ 5, 9 ], [ 6 ], [  ], [ 4 ], 
  [ 7, 9, 3 ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, [[3, 5, 10], [8, 9, 10], [1, 4],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 6], [1, 7, 11], [4, 7], [6, 8], [2, 7], [2, 11], [1, 2], [5, 9]]);</span>
&lt;mutable digraph with 11 vertices, 25 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KuratowskiPlanarSubdigraph(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, [[2, 4, 7, 9, 10],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 3, 4, 6, 9, 10], [6, 10], [2, 5, 8, 9],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 2, 3, 4, 6, 7, 9, 10], [3, 4, 5, 7, 9, 10],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 4, 5, 6, 9, 10], [3, 4, 5, 7, 9], [2, 3, 5, 6, 7, 8], [3, 5]]);</span>
&lt;mutable digraph with 10 vertices, 50 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPlanarDigraph(D);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KuratowskiPlanarSubdigraph(D);</span>
[ [ 2, 9, 7 ], [ 3 ], [ 6 ], [ 5, 9 ], [ 6 ], [  ], [ 4 ], 
  [ 7, 9, 3 ], [  ], [  ] ]
</pre></div>

<p><a id="X78E8F09A8286501B" name="X78E8F09A8286501B"></a></p>

<h5>5.6-2 KuratowskiOuterPlanarSubdigraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; KuratowskiOuterPlanarSubdigraph</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list or <code class="keyw">fail</code>.</p>

<p><code class="code">KuratowskiOuterPlanarSubdigraph</code> returns the immutable list of immutable lists of out-neighbours of a (not necessarily induced) subdigraph of the digraph <var class="Arg">digraph</var> that witnesses the fact that <var class="Arg">digraph</var> is not outer planar, or <code class="keyw">fail</code> if <var class="Arg">digraph</var> is outer planar. In other words, <code class="code">KuratowskiOuterPlanarSubdigraph</code> returns the out-neighbours of a subdigraph of <var class="Arg">digraph</var> that is homeomorphic to the complete graph with <code class="code">4</code> vertices, or to the complete bipartite graph with vertex sets of sizes <code class="code">2</code> and <code class="code">3</code>.</p>

<p>The directions and multiplicities of any edges in <var class="Arg">digraph</var> are ignored when considering whether or not <var class="Arg">digraph</var> is outer planar.</p>

<p>See also <code class="func">IsOuterPlanarDigraph</code> (<a href="chap6_mj.html#X8251E8B187E7F059"><span class="RefLink">6.4-2</span></a>), <code class="func">SubdigraphHomeomorphicToK4</code> (<a href="chap5_mj.html#X806D2D6B85E0B269"><span class="RefLink">5.6-5</span></a>), and <code class="func">SubdigraphHomeomorphicToK23</code> (<a href="chap5_mj.html#X806D2D6B85E0B269"><span class="RefLink">5.6-5</span></a>).</p>

<p>This method uses the reference implementation in <span class="URL"><a href="https://github.com/graph-algorithms/edge-addition-planarity-suite">edge-addition-planarity-suite</a></span> by John Boyer of the algorithms described in <a href="chapBib_mj.html#biBBM06">[BM06]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3, 5, 10], [8, 9, 10], [1, 4], [3, 6], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 7, 11], [4, 7], [6, 8], [2, 7], [2, 11], [1, 2], [5, 9]]);</span>
&lt;immutable digraph with 11 vertices, 25 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KuratowskiOuterPlanarSubdigraph(D);</span>
[ [ 3, 5, 10 ], [ 9, 8, 10 ], [ 4 ], [ 6 ], [ 11 ], [ 7 ], [ 8 ], 
  [  ], [ 11 ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 4, 7, 9, 10], [1, 3, 4, 6, 9, 10], [6, 10], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 5, 8, 9], [1, 2, 3, 4, 6, 7, 9, 10], [3, 4, 5, 7, 9, 10], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 4, 5, 6, 9, 10], [3, 4, 5, 7, 9], [2, 3, 5, 6, 7, 8], [3, 5]]);</span>
&lt;immutable digraph with 10 vertices, 50 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOuterPlanarDigraph(D);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KuratowskiOuterPlanarSubdigraph(D);</span>
[ [  ], [  ], [  ], [ 8, 9 ], [  ], [  ], [ 9, 4 ], [ 7, 9 ], [  ], 
  [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, [[3, 5, 10], [8, 9, 10], [1, 4],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 6], [1, 7, 11], [4, 7], [6, 8], [2, 7], [2, 11], [1, 2], [5, 9]]);</span>
&lt;mutable digraph with 11 vertices, 25 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KuratowskiOuterPlanarSubdigraph(D);</span>
[ [ 3, 5, 10 ], [ 9, 8, 10 ], [ 4 ], [ 6 ], [ 11 ], [ 7 ], [ 8 ], 
  [  ], [ 11 ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, [[2, 4, 7, 9, 10],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 3, 4, 6, 9, 10], [6, 10], [2, 5, 8, 9],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 2, 3, 4, 6, 7, 9, 10], [3, 4, 5, 7, 9, 10],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 4, 5, 6, 9, 10], [3, 4, 5, 7, 9], [2, 3, 5, 6, 7, 8], [3, 5]]);</span>
&lt;mutable digraph with 10 vertices, 50 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOuterPlanarDigraph(D);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KuratowskiOuterPlanarSubdigraph(D);</span>
[ [  ], [  ], [  ], [ 8, 9 ], [  ], [  ], [ 9, 4 ], [ 7, 9 ], [  ], 
  [  ] ]</pre></div>

<p><a id="X84E3947E7D39BA64" name="X84E3947E7D39BA64"></a></p>

<h5>5.6-3 PlanarEmbedding</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PlanarEmbedding</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list or <code class="keyw">fail</code>.</p>

<p>If <var class="Arg">digraph</var> is a planar digraph, then <code class="code">PlanarEmbedding</code> returns the immutable list of lists of out-neighbours of a subdigraph of <var class="Arg">digraph</var> such that each vertex's neighbours are given in clockwise order. If <var class="Arg">digraph</var> is not planar, then <code class="keyw">fail</code> is returned.</p>

<p>The directions and multiplicities of any edges in <var class="Arg">digraph</var> are ignored by <code class="code">PlanarEmbedding</code>.</p>

<p>See also <code class="func">IsPlanarDigraph</code> (<a href="chap6_mj.html#X8606D415858C40AA"><span class="RefLink">6.4-1</span></a>).</p>

<p>This method uses the reference implementation in <span class="URL"><a href="https://github.com/graph-algorithms/edge-addition-planarity-suite">edge-addition-planarity-suite</a></span> by John Boyer of the algorithms described in <a href="chapBib_mj.html#biBBM06">[BM06]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3, 5, 10], [8, 9, 10], [1, 4], [3, 6], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 7, 11], [4, 7], [6, 8], [2, 7], [2, 11], [1, 2], [5, 9]]);</span>
&lt;immutable digraph with 11 vertices, 25 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PlanarEmbedding(D);</span>
[ [ 3, 10, 5 ], [ 10, 8, 9 ], [ 4 ], [ 6 ], [ 11, 7 ], [ 7 ], [ 8 ], 
  [  ], [ 11 ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 4, 7, 9, 10], [1, 3, 4, 6, 9, 10], [6, 10], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 5, 8, 9], [1, 2, 3, 4, 6, 7, 9, 10], [3, 4, 5, 7, 9, 10], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 4, 5, 6, 9, 10], [3, 4, 5, 7, 9], [2, 3, 5, 6, 7, 8], [3, 5]]);</span>
&lt;immutable digraph with 10 vertices, 50 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PlanarEmbedding(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, [[3, 5, 10], [8, 9, 10], [1, 4],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 6], [1, 7, 11], [4, 7], [6, 8], [2, 7], [2, 11], [1, 2], [5, 9]]);</span>
&lt;mutable digraph with 11 vertices, 25 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PlanarEmbedding(D);</span>
[ [ 3, 10, 5 ], [ 10, 8, 9 ], [ 4 ], [ 6 ], [ 11, 7 ], [ 7 ], [ 8 ], 
  [  ], [ 11 ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, [[2, 4, 7, 9, 10],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 3, 4, 6, 9, 10], [6, 10], [2, 5, 8, 9],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 2, 3, 4, 6, 7, 9, 10], [3, 4, 5, 7, 9, 10],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 4, 5, 6, 9, 10], [3, 4, 5, 7, 9], [2, 3, 5, 6, 7, 8], [3, 5]]);</span>
&lt;mutable digraph with 10 vertices, 50 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PlanarEmbedding(D);</span>
fail
</pre></div>

<p><a id="X85DFB8C18088711F" name="X85DFB8C18088711F"></a></p>

<h5>5.6-4 OuterPlanarEmbedding</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OuterPlanarEmbedding</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list or <code class="keyw">fail</code>.</p>

<p>If <var class="Arg">digraph</var> is an outer planar digraph, then <code class="code">OuterPlanarEmbedding</code> returns the immutable list of lists of out-neighbours of a subdigraph of <var class="Arg">digraph</var> such that each vertex's neighbours are given in clockwise order. If <var class="Arg">digraph</var> is not outer planar, then <code class="keyw">fail</code> is returned.</p>

<p>The directions and multiplicities of any edges in <var class="Arg">digraph</var> are ignored by <code class="code">OuterPlanarEmbedding</code>.</p>

<p>See also <code class="func">IsOuterPlanarDigraph</code> (<a href="chap6_mj.html#X8251E8B187E7F059"><span class="RefLink">6.4-2</span></a>).</p>

<p>This method uses the reference implementation in <span class="URL"><a href="https://github.com/graph-algorithms/edge-addition-planarity-suite">edge-addition-planarity-suite</a></span> by John Boyer of the algorithms described in <a href="chapBib_mj.html#biBBM06">[BM06]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3, 5, 10], [8, 9, 10], [1, 4], [3, 6], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 7, 11], [4, 7], [6, 8], [2, 7], [2, 11], [1, 2], [5, 9]]);</span>
&lt;immutable digraph with 11 vertices, 25 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OuterPlanarEmbedding(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 4, 7, 9, 10], [1, 3, 4, 6, 9, 10], [6, 10], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 5, 8, 9], [1, 2, 3, 4, 6, 7, 9, 10], [3, 4, 5, 7, 9, 10], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 4, 5, 6, 9, 10], [3, 4, 5, 7, 9], [2, 3, 5, 6, 7, 8], [3, 5]]);</span>
&lt;immutable digraph with 10 vertices, 50 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OuterPlanarEmbedding(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OuterPlanarEmbedding(CompleteBipartiteDigraph(2, 2));</span>
[ [ 3, 4 ], [ 4, 3 ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, [[3, 5, 10], [8, 9, 10], [1, 4],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 6], [1, 7, 11], [4, 7], [6, 8], [2, 7], [2, 11], [1, 2], [5, 9]]);</span>
&lt;mutable digraph with 11 vertices, 25 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OuterPlanarEmbedding(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, [[2, 4, 7, 9, 10],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 3, 4, 6, 9, 10], [6, 10], [2, 5, 8, 9],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 2, 3, 4, 6, 7, 9, 10], [3, 4, 5, 7, 9, 10],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 4, 5, 6, 9, 10], [3, 4, 5, 7, 9], [2, 3, 5, 6, 7, 8], [3, 5]]);</span>
&lt;mutable digraph with 10 vertices, 50 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OuterPlanarEmbedding(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OuterPlanarEmbedding(CompleteBipartiteDigraph(2, 2));</span>
[ [ 3, 4 ], [ 4, 3 ], [  ], [  ] ]
</pre></div>

<p><a id="X806D2D6B85E0B269" name="X806D2D6B85E0B269"></a></p>

<h5>5.6-5 SubdigraphHomeomorphicToK23</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SubdigraphHomeomorphicToK23</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SubdigraphHomeomorphicToK33</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SubdigraphHomeomorphicToK4</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list or <code class="keyw">fail</code>.</p>

<p>These attributes return the immutable list of lists of out-neighbours of a subdigraph of the digraph <var class="Arg">digraph</var> which is homeomorphic to one of the following: the complete bipartite graph with vertex sets of sizes <code class="code">2</code> and <code class="code">3</code>; the complete bipartite graph with vertex sets of sizes <code class="code">3</code> and <code class="code">3</code>; or the complete graph with <code class="code">4</code> vertices. If <var class="Arg">digraph</var> has no such subdigraphs, then <code class="keyw">fail</code> is returned.</p>

<p>See also <code class="func">IsPlanarDigraph</code> (<a href="chap6_mj.html#X8606D415858C40AA"><span class="RefLink">6.4-1</span></a>) and <code class="func">IsOuterPlanarDigraph</code> (<a href="chap6_mj.html#X8251E8B187E7F059"><span class="RefLink">6.4-2</span></a>) for more details.</p>

<p>This method uses the reference implementation in <span class="URL"><a href="https://github.com/graph-algorithms/edge-addition-planarity-suite">edge-addition-planarity-suite</a></span> by John Boyer of the algorithms described in <a href="chapBib_mj.html#biBBM06">[BM06]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3, 5, 10], [8, 9, 10], [1, 4], [3, 6], [1, 7, 11], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[4, 7], [6, 8], [2, 7], [2, 11], [1, 2], [5, 9]]);</span>
&lt;immutable digraph with 11 vertices, 25 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK4(D);</span>
[ [ 3, 5, 10 ], [ 9, 8, 10 ], [ 4 ], [ 6 ], [ 7, 11 ], [ 7 ], [ 8 ], 
  [  ], [ 11 ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK23(D);</span>
[ [ 3, 5, 10 ], [ 9, 8, 10 ], [ 4 ], [ 6 ], [ 11 ], [ 7 ], [ 8 ], 
  [  ], [ 11 ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3, 5, 10], [8, 9, 10], [1, 4], [3, 6], [1, 11], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [4, 7], [6, 8], [2, 7], [2, 11], [1, 2], [5, 9]]);</span>
&lt;immutable digraph with 11 vertices, 24 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK4(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK23(D);</span>
[ [ 3, 10, 5 ], [ 10, 8, 9 ], [ 4 ], [ 6 ], [ 11 ], [ 7 ], [ 8 ], 
  [  ], [ 11 ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK33(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK23(NullDigraph(0));</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK33(CompleteDigraph(5));</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK33(CompleteBipartiteDigraph(3, 3));</span>
[ [ 4, 6, 5 ], [ 4, 5, 6 ], [ 6, 5, 4 ], [  ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK4(CompleteDigraph(3));</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, [[3, 5, 10], [8, 9, 10], [1, 4],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 6], [1, 7, 11], [4, 7], [6, 8], [2, 7], [2, 11], [1, 2], [5, 9]]);</span>
&lt;mutable digraph with 11 vertices, 25 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK4(D);</span>
[ [ 3, 5, 10 ], [ 9, 8, 10 ], [ 4 ], [ 6 ], [ 7, 11 ], [ 7 ], [ 8 ], 
  [  ], [ 11 ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK23(D);</span>
[ [ 3, 5, 10 ], [ 9, 8, 10 ], [ 4 ], [ 6 ], [ 11 ], [ 7 ], [ 8 ], 
  [  ], [ 11 ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, [[3, 5, 10], [8, 9, 10], [1, 4],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 6], [1, 11], [4, 7], [6, 8], [2, 7], [2, 11], [1, 2], [5, 9]]);</span>
&lt;mutable digraph with 11 vertices, 24 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK4(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK23(D);</span>
[ [ 3, 10, 5 ], [ 10, 8, 9 ], [ 4 ], [ 6 ], [ 11 ], [ 7 ], [ 8 ], 
  [  ], [ 11 ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK33(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK23(NullDigraph(0));</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK33(CompleteDigraph(5));</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK33(CompleteBipartiteDigraph(3, 3));</span>
[ [ 4, 6, 5 ], [ 4, 5, 6 ], [ 6, 5, 4 ], [  ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK4(CompleteDigraph(3));</span>
fail
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap4_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap6_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chapA_mj.html">A</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
