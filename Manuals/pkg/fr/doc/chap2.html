<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (FR) - Chapter 2: FR package</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap2"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"></p>
<p><a id="X7ADCE68284FB4ACF" name="X7ADCE68284FB4ACF"></a></p>
<div class="ChapSects"><a href="chap2.html#X7ADCE68284FB4ACF">2 <span class="Heading">FR package</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X80C332C686212786">2.1 <span class="Heading">A brief mathematical introduction</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X78DF4DE18260BD80">2.2 <span class="Heading">An example session</span></a>
</span>
</div>
</div>

<h3>2 <span class="Heading">FR package</span></h3>

<p><a id="X80C332C686212786" name="X80C332C686212786"></a></p>

<h4>2.1 <span class="Heading">A brief mathematical introduction</span></h4>

<p>This chapter assumes that you have no familiarity with groups generated by automata. If you do, and wish to see their usage within <strong class="pkg">GAP</strong> through a sample session, please skip to Section <a href="chap2.html#X78DF4DE18260BD80"><span class="RefLink">2.2</span></a>. For a more thourough introduction on self-similar groups see <a href="chapBib.html#biBMR2091700">[BGN03]</a> or <a href="chapBib.html#biBMR2035113">[BG{\v S}03]</a>.</p>

<p>We shall here be interested in groups <span class="SimpleMath">G</span> defined by their action on a regular rooted tree. Let <span class="SimpleMath">X</span> be a finite set; and let <span class="SimpleMath">X^*</span> denote the set of words (free monoid) over <span class="SimpleMath">X</span>. Then <span class="SimpleMath">X^*</span> naturally has the structure of a regular rooted tree: the root is the empty word, and vertex <span class="SimpleMath">v ∈ X^*</span> is connected to vertex <span class="SimpleMath">vx</span> for all choices of <span class="SimpleMath">x ∈ X</span>. Each vertex except the root therefore has <span class="SimpleMath">#X+1</span> neighbours.</p>

<p>Let <span class="SimpleMath">W</span> denote the automorphism group of the graph <span class="SimpleMath">X^*</span>. Given <span class="SimpleMath">a ∈ W</span>, we may restrict its action to <span class="SimpleMath">X ⊂ X^*</span>, and obtain a permutation <span class="SimpleMath">π_a</span> on <span class="SimpleMath">X</span>, called the <em>activity</em> of <span class="SimpleMath">a</span>. We may also obtain, for all <span class="SimpleMath">x∈ X</span>, a tree automorphism <span class="SimpleMath">a_x ∈ W</span>, called the <em>state of <span class="SimpleMath">a</span> at <span class="SimpleMath">x</span></em>, by the formula</p>

<p class="pcenter">(v){a_x} = w \quad\textrm{if}\quad (xv)a =  x^{\pi_a}w.</p>

<p>The data <span class="SimpleMath">(a_x,π_a)</span> determine uniquely the automorphism <span class="SimpleMath">a</span>, and any choice of <span class="SimpleMath">a_x</span> and <span class="SimpleMath">π_a</span> defines a tree isometry. We therefore have a group isomorphism</p>

<p class="pcenter">\phi: W \to W\wr \mathop{Sym}(X),</p>

<p>called the <em>Wreath recursion</em>. The image of <span class="SimpleMath">ϕ</span> is the permutational wreath product <span class="SimpleMath">W^X ⋊ Sym(X)</span>.</p>

<p>The state <span class="SimpleMath">a_x</span> should be interpreted as the restriction of the action of <span class="SimpleMath">a</span> on the subtree <span class="SimpleMath">xX^*</span>; the automorphism <span class="SimpleMath">a</span> is defined by acting first on each of the subtrees of the form <span class="SimpleMath">xX^*</span> by its respective state, and then permuting these subtrees according to <span class="SimpleMath">π_a</span>. The wreath recursion can be iterated on the states of <span class="SimpleMath">a</span>, to define states <span class="SimpleMath">a_v</span> for any <span class="SimpleMath">v ∈ X^*</span>.</p>

<p>The automorphism <span class="SimpleMath">a ∈ W</span> may be represented by a graph, as follows. There is one vertex for each state <span class="SimpleMath">a_v</span> of <span class="SimpleMath">a</span>, labeled <span class="SimpleMath">π_a_v</span>; and for each <span class="SimpleMath">x ∈ X</span> there is one edge from state <span class="SimpleMath">a_v</span> to state <span class="SimpleMath">a_vx</span>, labeled <span class="SimpleMath">x</span>. This graph is nothing but a quotient of the regular rooted tree <span class="SimpleMath">X^*</span>, where vertices <span class="SimpleMath">v</span> and <span class="SimpleMath">w</span> are identified if <span class="SimpleMath">a_v=a_w</span>. Again, this graph, with a choice of initial vertex, determines uniquely the automorphism <span class="SimpleMath">a</span>.</p>

<p>This graph may be conveniently encoded in what is called a <em>Moore machine</em>: it consists of a set <span class="SimpleMath">Q</span>, the vertex set of the graph; an alphabet, <span class="SimpleMath">X</span>; a `transition' function <span class="SimpleMath">ϕ:Q× X-&gt; Q</span>, where <span class="SimpleMath">ϕ(q,x)</span> is the endpoint of the edge starting at <span class="SimpleMath">q</span> and labeled <span class="SimpleMath">x</span>; and a labeling <span class="SimpleMath">π</span> of <span class="SimpleMath">X</span> by the symmetric group on <span class="SimpleMath">X</span>. We will use the equivalent <em>Mealy machines</em>, given by a `transition' function <span class="SimpleMath">ϕ:Q× X-&gt; X× Q</span>, encoding both <span class="SimpleMath">ϕ</span> and <span class="SimpleMath">π</span> together.</p>

<p>Of particular interest are <em>finite-state automorphisms</em>: these are automorphisms whose Mealy machine has finitely many states. The product and inverse of finite-state automorphisms is again finite-state.</p>

<p>A subgroup <span class="SimpleMath">G le W</span> is <em>self-similar</em> if <span class="SimpleMath">G^ϕ ⊂ G≀Sym(X)</span>. This is equivalent to asking, for every <span class="SimpleMath">a ∈ G</span>, that all of its states <span class="SimpleMath">a_x</span> also belong to <span class="SimpleMath">G</span>.</p>

<p>The following important properties have also been considered. A subgroup <span class="SimpleMath">G le W</span> is <em>level-transitive</em> if its action is transitive on all the <span class="SimpleMath">G</span>-subsets <span class="SimpleMath">X^n</span>. It is <em>weakly branched</em> if it is level-transitive, and for every <span class="SimpleMath">v∈ X^*</span> there is a non-trivial <span class="SimpleMath">a_v∈ G</span> that fixes <span class="SimpleMath">X^* ∖ vX^*</span>. It is <em>branched</em> if furthermore for each <span class="SimpleMath">n ∈ N</span> the group generated by all such <span class="SimpleMath">a_v</span> for all <span class="SimpleMath">v</span> of length <span class="SimpleMath">n</span> has finite index in <span class="SimpleMath">G</span>.</p>

<p>A self-similar finitely generated group <span class="SimpleMath">G le W</span> is <em>contracting</em> if there are constants <span class="SimpleMath">K,n ∈ N</span> and <span class="SimpleMath">λ&lt;1</span> such that <span class="SimpleMath">|a_v|leλ|a|+K</span> for all <span class="SimpleMath">a∈ G</span> and <span class="SimpleMath">v∈ X^n</span>; here <span class="SimpleMath">|a|</span> denotes the minimal number of generators needed to express <span class="SimpleMath">a</span>. It then follows that there exists a finite set <span class="SimpleMath">N⊂ G</span> such that for all <span class="SimpleMath">a∈ G</span>, all but finitely many of the states of <span class="SimpleMath">a</span> belong to <span class="SimpleMath">N</span>. The minimal such <span class="SimpleMath">N</span> is called the <em>nucleus</em> of <span class="SimpleMath">G</span>. Since the states of elements of the nucleus are again in the nucleus, we see that the nucleus is naturally a Mealy machine. By considering all elements of <span class="SimpleMath">W</span> obtained from this Mealy machine by choosing all possible initial states, we obtain a generating set for <span class="SimpleMath">G</span> made of all states of a single machine; this is the <em>group generated</em> by the machine.</p>

<p>In this package, we are mainly interested in self-similar groups of finite-state automorphisms. The reason is historical: Aleshin <a href="chapBib.html#biBMR713968">[Ale83]</a>, and later Grigorchuk <a href="chapBib.html#biBMR565099">[Gri80]</a> and Gupta and Sidki <a href="chapBib.html#biBMR696534">[GS83]</a> constructed peculiar examples of groups using self-similar finite-state automorphisms. All these groups can be defined by drawing a small machine (at most five vertices) and considering the group that they generate.</p>

<p>We assumed for simplicity that the elements <span class="SimpleMath">a</span> were invertible. Actually, in the definition of Mealy machines it makes sense to accept arbitrary maps, and not necessarily bijections of <span class="SimpleMath">X</span> as a label at each vertex. One may in this way define peculiar semigroups.</p>

<p><a id="X78DF4DE18260BD80" name="X78DF4DE18260BD80"></a></p>

<h4>2.2 <span class="Heading">An example session</span></h4>

<p>This is a brief introduction describing some of the simpler features of the <strong class="pkg">FR</strong> package. It assumes you have some familiarity with the theory of groups defined by automata; if not, a brief mathematical introduction may be found in Section <a href="chap2.html#X80C332C686212786"><span class="RefLink">2.1</span></a>. We show here and comment a typical use of the package.</p>

<p>The package is installed by unpacking the archive in the <code class="file">pkg/</code> directory of your <strong class="pkg">GAP</strong> installation. It can also be placed in a local directory, which must be added to the load-path by invoking <code class="code">gap</code> with the <code class="code">-l</code> option.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage("fr");</span>
----------------------------------------------------------------
Loading FR 0.857142p5 (Functionally recursive and automata groups)
by Laurent Bartholdi (http://www.uni-math.gwdg.de/laurent)
----------------------------------------------------------------
true
</pre></div>

<p>Many FR groups are predefined by <strong class="pkg">FR</strong>, see Chapter <a href="chap9.html#X7A489A5D79DA9E5C"><span class="RefLink">9</span></a>. We consider here the <em>Basilica group</em>, considered in <a href="chapBib.html#biBMR1902367">[G{\.Z}02]</a> and <a href="chapBib.html#biBMR2176547">[BV05]</a>.</p>

<p>We may start by defining a group: it has two generators <span class="SimpleMath">a</span> and <span class="SimpleMath">b</span>, satisfying the specified recursions.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := FRGroup("a=&lt;1,b&gt;(1,2)","b=&lt;1,a&gt;",IsFRMealyElement);</span>
&lt;self-similar group over [ 1 .. 2 ] with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AssignGeneratorVariables(B);</span>
#I  Assigned the global variables [ a, b ]
</pre></div>

<p>We have just created the group <span class="SimpleMath">B=⟨ a,b⟩</span>.</p>

<p>Note that this group is predefined as <code class="code">BasilicaGroup</code>. We now compute the decompositions of the generators:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DecompositionOfFRElement(a); DecompositionOfFRElement(b);</span>
[ [ &lt;2|identity ...&gt;, &lt;2|b&gt; ], [ 2, 1 ] ]
[ [ &lt;2|identity ...&gt;, &lt;2|a&gt; ], [ 1, 2 ] ]
</pre></div>

<p>Elements are described as words in the generators; they are printed as <code class="code">&lt;2|a&gt;</code>, where the <span class="SimpleMath">2</span> reminds of the degree of the tree on which <span class="SimpleMath">a</span> acts.</p>

<p>The optional argument <code class="func">IsFRElement</code> (<a href="chap10.html#X7966F9B982B1DFE1"><span class="RefLink">10.2-11</span></a>) tells <strong class="pkg">FR</strong> to store elements in this way. This representation is always possible, but it is usually inefficient for calculations. The argument <code class="func">IsMealyElement</code> (<a href="chap10.html#X7C86614187606A4C"><span class="RefLink">10.2-4</span></a>) forces <strong class="pkg">FR</strong> to use a more efficient representation, which in some cases may take an infinite time to set up. With no extra argument, <strong class="pkg">FR</strong> does what it thinks is best. The advantages of both representations are sometimes obtained by the argument <code class="func">IsFRMealyElement</code> (<a href="chap10.html#X847A4BBE82C736B6"><span class="RefLink">10.2-12</span></a>), which stores both representations.</p>

<p>Elements act on sequences over <span class="SimpleMath">{1,2}</span>. The action is computed in the standard manner:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">1^a; [1]^a; [1,1]^a;</span>
2
[ 2 ]
[ 2, 1 ]
</pre></div>

<p>Periodic sequences are also implemented in <strong class="pkg">FR</strong>; they are constructed by giving the period and preperiod. The period is printed by preceding it with a "/":</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v := PeriodicList([1],[2]);</span>
[ 1, / 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v^a; v^(a^2);</span>
[/ 2 ]
[/ 1, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">last{[1..10]};</span>
[ 1, 2, 1, 2, 1, 2, 1, 2, 1, 2 ]
</pre></div>

<p>Most computations are much more efficient if <span class="SimpleMath">B</span>'s elements are converted to <em>Mealy representation</em>,</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Bm := Image(IsomorphismMealyGroup(B));</span>
&lt;recursive group over [ 1 .. 2 ] with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := Bm.1; b := Bm.2;</span>
&lt;Mealy element on alphabet [ 1, 2 ] with 3 states&gt;
&lt;Mealy element on alphabet [ 1, 2 ] with 3 states&gt;
</pre></div>

<p>This could have been done automatically by specifying <code class="code">IsMealyElement</code> as last argument in the call to <code class="code">FRGroup</code>.</p>

<p>The group <span class="SimpleMath">B</span> is torsion-free, and its elements are bounded automata. Although torsion-freeness is difficult to check for <strong class="pkg">FR</strong>, it can be checked on individual elements:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsBoundedFRSemigroup(Bm);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order(a); Order(b);</span>
infinity
infinity
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := PseudoRandom(B);; Length(InitialState(g));</span>
4679
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order(g); time;</span>
infinity
2599
</pre></div>

<p>The group <span class="SimpleMath">B</span> is weakly branched; more precisely, the derived subgroup <span class="SimpleMath">B'</span> contains <span class="SimpleMath">B' × B'</span>. To prove that, it suffices to check <span class="SimpleMath">[a,b] × 1∈ B'</span> and <span class="SimpleMath">1 × [a,b]∈ B'</span>. These elements are constructed using <code class="func">VertexElement</code> (<a href="chap4.html#X7CE388057DAB4802"><span class="RefLink">4.1-5</span></a>):</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := Comm(a,b);</span>
&lt;Mealy element on alphabet [ 1, 2 ] with 9 states&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K := NormalClosure(Bm,Group(c));</span>
&lt;self-similar group over [ 1 .. 2 ] with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VertexElement(1,c) in K; VertexElement(1,c) in K;</span>
true
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DecompositionOfFRElement(VertexElement(1,c))=[[c,One(Bm)],[1,2]];</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VertexElement(2,c)=Comm(b,a^2);</span>
true
</pre></div>

<p>Note that we had to guess the form of the element <code class="code">VertexElement(2,c)</code> above. This could have been found out by <strong class="pkg">GAP</strong> using <code class="func">ShortGroupWordInSet</code> (<a href="chap11.html#X7B9942AA84B0753E"><span class="RefLink">11.4-2</span></a>).</p>

<p>We may also check the relations <span class="SimpleMath">[b^p,(b^p)^a^p]=1</span> and <span class="SimpleMath">[a^2p,(a^2p)^b^p]</span> for <span class="SimpleMath">p</span> any power of <span class="SimpleMath">2</span>:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll([0..10],i-&gt;IsOne(Comm(b^(2^i),(b^(2^i))^((a^(2^i)))))); time;</span>
true
1361
</pre></div>

<p>Since the group <span class="SimpleMath">B</span> is bounded, it is contracting. We compute its nucleus:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NucleusOfFRSemigroup(B);</span>
[ &lt;2|identity ...&gt;, &lt;2|b&gt;, &lt;2|b^-1&gt;, &lt;2|a&gt;, &lt;2|a^-1&gt;, &lt;2|b^-1*a&gt;, &lt;2|a^-1*b&gt; ]
</pre></div>

<p>We then compute the Mealy machine with stateset this nucleus, and draw it graphically (this requires the external programs <strong class="pkg">graphviz</strong> and <strong class="pkg">imagemagick</strong>):</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N := NucleusMachine(B);</span>
&lt;Mealy machine on alphabet [ 1, 2 ] with 7 states&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Draw(N);</span>
</pre></div>

<p>We may also draw powers of the dual automaton: these are approximations to the Schreier graph of <span class="SimpleMath">B</span>. However, we also construct a smaller Mealy machine with states only <span class="SimpleMath">a</span> and <span class="SimpleMath">b</span>, which give better images:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Draw(DualMachine(N)^3);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := AsMealyMachine(FRMachine(a))[1];</span>
&lt;Mealy machine on alphabet [ 1, 2 ] with 3 states&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Draw(DualMachine(M)^4);</span>
</pre></div>

<p>These Schreier graphs are orbits of the group; they can be displayed as follows:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">WordGrowth(B:point:=[1,1,1,1],draw);</span>
</pre></div>

<p>More properties of <span class="SimpleMath">B</span> can be checked, or experimented with, on its finite quotients obtained by truncating the tree on which <span class="SimpleMath">B</span> acts at a given length. <code class="code">PermGroup(B,n)</code> constructs a permutation group which is the natural quotient of <span class="SimpleMath">B</span> acting on <span class="SimpleMath">2^n</span> points:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := PermGroup(B,7);</span>
&lt;permutation group with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(G); LogInt(last,2);</span>
309485009821345068724781056
88
</pre></div>

<p>We may "guess" the structure of the Lie algebra of <span class="SimpleMath">B</span> by examining the ranks of the successive quotients along its Jennings series:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">J := JenningsLieAlgebra(G); time;</span>
&lt;Lie algebra of dimension 88 over GF(2)&gt;
18035
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List([1..15],i-&gt;Dimension(Grading(J).hom_components(i)));</span>
[ 2, 3, 1, 4, 1, 2, 1, 4, 1, 2, 1, 3, 1, 2, 1 ]
</pre></div>

<p>The "<span class="SimpleMath">4</span>" in position <span class="SimpleMath">8</span> of that list should really be a "<span class="SimpleMath">5</span>"; computations on finite quotients of <span class="SimpleMath">B</span> usually give lower bounds for invariants of <span class="SimpleMath">B</span>. In that case, we guess that the ranks behave like a "ruler" function, i.e. that the rank of the homogeneous component of degree <span class="SimpleMath">i</span> is <span class="SimpleMath">2+ν_2(i)</span> if <span class="SimpleMath">i</span> is a power of <span class="SimpleMath">2</span> and is <span class="SimpleMath">1+ν_2(i)</span> otherwise; here <span class="SimpleMath">ν_2(i)</span> is the number of times <span class="SimpleMath">2</span> divides <span class="SimpleMath">i</span>.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
