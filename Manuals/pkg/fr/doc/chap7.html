<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (FR) - Chapter 7: Self-similar groups, monoids and semigroups</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap7"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap6.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap8.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"></p>
<p><a id="X86C0E6F083DCCDC8" name="X86C0E6F083DCCDC8"></a></p>
<div class="ChapSects"><a href="chap7.html#X86C0E6F083DCCDC8">7 <span class="Heading">Self-similar groups, monoids and semigroups</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7.html#X80A26BAA7B53C1BD">7.1 <span class="Heading">Creators for FR semigroups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7AE8F92383272329">7.1-1 FRGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7D4A6996874A3DF3">7.1-2 NewSemigroupFRMachine</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X853E3F0680C76F56">7.1-3 SCGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7F15D57A7959FEF6">7.1-4 Correspondence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7D0B8334786E2802">7.1-5 FullSCGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7DB92C34827D513F">7.1-6 FRMachineFRGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7BF4AC9F830A8E1A">7.1-7 IsomorphismFRGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7DE1CAE981F2825B">7.1-8 IsomorphismMealyGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7BB8DDEA83946C73">7.1-9 FRGroupByVirtualEndomorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X79D75A7D80DD9AD1">7.1-10 TreeWreathProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X85840A047C04BFC6">7.1-11 WeaklyBranchedEmbedding</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7.html#X84E20571841DE1E4">7.2 <span class="Heading">Operations for FR semigroups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7C6D7BA0818A3A3D">7.2-1 PermGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X8620BEAF7957FA4D">7.2-2 PcGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X83834FF77F972912">7.2-3 TransformationMonoid</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X8768C22D859BE75F">7.2-4 TransformationSemigroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7BDC634086437315">7.2-5 EpimorphismGermGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X812242E584462766">7.2-6 GermData</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X87378D53791D0B70">7.2-7 StabilizerImage</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7B4CD9CA872BA368">7.2-8 LevelStabilizer</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7C5002E683A044C1">7.2-9 IsStateClosed</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X79246DB482BEAF2D">7.2-10 StateClosure</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7E2F34417EBB7673">7.2-11 IsRecurrentFRSemigroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7FBF56737D9063F4">7.2-12 IsLevelTransitive</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7D95219481AEDD20">7.2-13 IsInfinitelyTransitive</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7A6CB30181662C77">7.2-14 IsFinitaryFRSemigroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X791BCD9D782C6237">7.2-15 Degree</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7FA67E4387C91BD8">7.2-16 HasOpenSetConditionFRSemigroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7D870F9E82ACB54C">7.2-17 HasCongruenceProperty</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7EAB4B5B843C0EC5">7.2-18 IsContracting</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7CA062A67C1554BB">7.2-19 NucleusOfFRSemigroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X8443D711796F06E4">7.2-20 NucleusMachine</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X824A9E177F5A9753">7.2-21 AdjacencyBasesWithOne</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7A874A107D4944E1">7.2-22 BranchingSubgroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X78ADACCD8586D3C7">7.2-23 FindBranchingSubgroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X832D98E47ACA099C">7.2-24 IsBranched</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7A905CE87B49213F">7.2-25 IsBranchingSubgroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X8404ECA782F2521A">7.2-26 BranchStructure</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X8749E0797A99F531">7.2-27 TopVertexTransformations</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7C56C90086070A2E">7.2-28 VertexTransformations</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7DF2D9838625CDED">7.2-29 VirtualEndomorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7C81CB1C7F0D7A90">7.2-30 EpimorphismFromFpGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X8740656382656D63">7.2-31 IsomorphismSubgroupFpGroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7.html#X7E8485A081EBB3AA">7.3 <span class="Heading">Properties for infinite groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X840ED7D279ECAB7F">7.3-1 IsTorsionGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7914F2D68077F503">7.3-2 IsTorsionFreeGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X87E93FFC820ED40E">7.3-3 IsAmenableGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X873C0A7C8422C0C9">7.3-4 IsVirtuallySimpleGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X79A3A0CF82B6F089">7.3-5 IsResiduallyFinite</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X86E1182E7EEFAADB">7.3-6 IsSQUniversal</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7FDAEAFF78A5E7D2">7.3-7 IsJustInfinite</a></span>
</div></div>
</div>

<h3>7 <span class="Heading">Self-similar groups, monoids and semigroups</span></h3>

<p>Self-similar groups, monoids and semigroups (below <em>FR semigroups</em>) are simply groups, monoids and semigroups whose elements are FR machines. They naturally act on the alphabet of their elements, and on sequences over that alphabet.</p>

<p>Most non-trivial calculations in FR groups are performed as follows: <strong class="pkg">GAP</strong> searches through words of short length in the generating set of a FR group to find a solution to a group-theoretic question, and at the same time searches through the finite quotients to prove the inexistence of a solution. Often the calculation ends with the answer <code class="keyw">fail</code>, which means that no definite answer, neither positive nor negative, could be found; however, the cases where the calculation actually terminates have been most useful.</p>

<p>The maximal length of words to consider in the search is controlled by the variable <code class="code">FR_SEARCH.radius</code> (initially 10), and the maximal depth of the tree in which to search is controlled by the variable <code class="code">FR_SEARCH.depth</code> (initially 6). These limits can be modified in any function call using <strong class="pkg">GAP</strong>'s options mechanism, e.g. in <code class="code">Index(G,H:FRdepth:=5,FRradius:=5)</code>.</p>

<p><a id="X80A26BAA7B53C1BD" name="X80A26BAA7B53C1BD"></a></p>

<h4>7.1 <span class="Heading">Creators for FR semigroups</span></h4>

<p>The most straightforward creation method for FR groups is <code class="code">Group()</code>, applied with FR elements as arguments. There are shortcuts to this somewhat tedious method:</p>

<p><a id="X7AE8F92383272329" name="X7AE8F92383272329"></a></p>

<h5>7.1-1 FRGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FRGroup</code>( <var class="Arg">{definition</var>, <var class="Arg">}</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FRMonoid</code>( <var class="Arg">{definition</var>, <var class="Arg">}</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FRSemigroup</code>( <var class="Arg">{definition</var>, <var class="Arg">}</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A new self-similar group/monoid/semigroup.</p>

<p>This function constructs a new FR group/monoid/semigroup, generated by group FR elements. It receives as argument any number of strings, each of which represents a generator of the object to be constructed.</p>

<p>Each <var class="Arg">definition</var> is of the form <code class="code">"name=projtrans"</code>, where each of <code class="code">proj</code> and <code class="code">trans</code> is optional. <code class="code">proj</code> is of the form <code class="code">&lt;w1,...,wd&gt;</code>, where each <code class="code">wi</code> is a (possibly empty) word in the <code class="code">name</code>s or is 1. <code class="code">trans</code> is either a permutation in disjoint cycle notation, or a list, representing the images of a permutation.</p>

<p>The last argument may be one of the filters <code class="code">IsMealyElement</code>, <code class="code">IsFRMealyElement</code> or <code class="code">IsFRElement</code>. By default, if each of the states of generators is a generator or 1, the elements of the created object will be Mealy elements; otherwise, they will be FR elements. Specifying such a filter requires them to be in the appropriate category; e.g., <code class="code">FRGroup("a=(1,2)",IsFRMealyElement)</code> asks for the resulting group to be generated by FR-Mealy elements. The generators must of course be finite-state.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FRGroup("a=(1,2)","b=(1,2,3,4,5)"); Size(last);</span>
&lt;self-similar group over [ 1 .. 5 ] with 2 generators&gt;
120
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dinfinity := FRGroup("a=(1,2)","b=&lt;a,b&gt;");</span>
&lt;self-similar group over [ 1 .. 2 ] with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AssignGeneratorVariables(Dinfinity);</span>
#I  Assigned the global variables [ a, b ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order(a); Order(b); Order(a*b);</span>
2
2
infinity
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZZ := FRGroup("t=&lt;,t&gt;[2,1]");</span>
&lt;self-similar group over [ 1 .. 2 ] with 1 generator&gt;
tau := FRElement([[[b,1],[1]]],[()],[1]);
&lt;2|f3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubgroup(Dinfinity,ZZ);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubgroup(Dinfinity^tau,ZZ);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Index(Dinfinity^tau,ZZ);</span>
2
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i4 := FRMonoid("s=(1,2)","f=&lt;s,f&gt;[1,1]");</span>
&lt;self-similar monoid over [ 1 .. 2 ] with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := GeneratorsOfMonoid(i4){[1,2]};;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for i in [1..10] do Add(f,f[i]*f[i+1]); od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f[1]^2=One(m);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f[2]^3=f[2];</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f[11]*f[10]^2=f[1]*Product(f{[5,7..11]})*f[10];</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f[12]*f[11]^2=f[2]*Product(f{[6,8..12]})*f[11];</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i2 := FRSemigroup("f0=&lt;f0,f0&gt;(1,2)","f1=&lt;f1,f0&gt;[2,2]");</span>
&lt;self-similar semigroup over [ 1 .. 2 ] with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AssignGeneratorVariables(i2);</span>
#I  Assigned the global variables [ "f0", "f1" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f0^2=One(i2);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll([0..10],p-&gt;(f0*f1)^p*(f1*f0)^p*f1=f1^2*(f0*f1)^p*(f1*f0)^p*f1);</span>
true
</pre></div>

<p><a id="X7D4A6996874A3DF3" name="X7D4A6996874A3DF3"></a></p>

<h5>7.1-2 NewSemigroupFRMachine</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NewSemigroupFRMachine</code>( <var class="Arg">...</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NewMonoidFRMachine</code>( <var class="Arg">...</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NewGroupFRMachine</code>( <var class="Arg">...</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A new FR machine, based on string descriptions.</p>

<p>This command constructs a new FR machine, in a format similar to <code class="func">FRGroup</code> (<a href="chap7.html#X7AE8F92383272329"><span class="RefLink">7.1-1</span></a>); namely, the arguments are strings of the form "gen=&lt;word-1,...,word-d&gt;perm"; each <code class="code">word-i</code> is a word in the generators; and <code class="code">perm</code> is a transformation, either written in disjoint cycle or in images notation.</p>

<p>Except in the semigroup case, <code class="code">word-i</code> is allowed to be the empty string; and the "&lt;...&gt;" may be skipped altogether. In the group or IMG case, each <code class="code">word-i</code> may also contain inverses.</p>

<p>The following example constructs the "universal Grigorchuk machine".</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := NewGroupFRMachine("a=(1,2)(3,4)(5,6)","b=&lt;a,b,a,b,,b&gt;",</span>
     "c=&lt;a,c,,c,a,c&gt;","d=&lt;,d,a,d,a,d&gt;");
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">&lt;FR machine with alphabet [ 1, 2, 3, 4, 5, 6 ] on Group( [ a, b, c, d ] )&gt;</span>
</pre></div>

<p><a id="X853E3F0680C76F56" name="X853E3F0680C76F56"></a></p>

<h5>7.1-3 SCGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCGroup</code>( <var class="Arg">m</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCGroupNC</code>( <var class="Arg">m</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCMonoid</code>( <var class="Arg">m</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCMonoidNC</code>( <var class="Arg">m</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSemigroup</code>( <var class="Arg">m</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SCSemigroupNC</code>( <var class="Arg">m</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: The state-closed group/monoid/semigroup generated by the machine <var class="Arg">m</var>.</p>

<p>This function constructs a new FR group/monoid/semigroup <code class="code">g</code>, generated by all the states of the FR machine <var class="Arg">m</var>. There is a bijective correspondence between <code class="code">GeneratorsOfFRMachine(m)</code> and the generators of <code class="code">g</code>, which is accessible via <code class="code">Correspondence(g)</code> (See <code class="func">Correspondence</code> (<a href="chap7.html#X7F15D57A7959FEF6"><span class="RefLink">7.1-4</span></a>)); it is a homomorphism from the stateset of <var class="Arg">m</var> to <code class="code">g</code>, or a list indicating for each state of <var class="Arg">m</var> a corresponding generator index in the generators of <code class="code">g</code> (with negatives for inverses, and 0 for identity).</p>

<p>In the non-<code class="code">NC</code> forms, redundant (equal, trivial or mutually inverse) states are removed from the generating set of <code class="code">g</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b := MealyMachine([[3,2],[3,1],[3,3]],[(1,2),(),()]);; g := SCGroupNC(b);</span>
&lt;self-similar group over [ 1 .. 2 ] with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(g);</span>
infinity
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOne(Comm(g.2,g.2^g.1));</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i4machine := MealyMachine([[3,3],[1,2],[3,3]],[(1,2),[1,1],()]);</span>
&lt;Mealy machine on alphabet [ 1, 2 ] with 3 states&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsInvertible(i4machine);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i4 := SCMonoidNC(i4machine);</span>
&lt;self-similar monoid over [ 1 .. 2 ] with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := GeneratorsOfMonoid(i4){[1,2]};;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for i in [1..10] do Add(f,f[i]*f[i+1]); od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f[1]^2=One(m);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f[2]^3=f[2];</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f[11]*f[10]^2=f[1]*Product(f{[5,7..11]})*f[10];</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f[12]*f[11]^2=f[2]*Product(f{[6,8..12]})*f[11];</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i2machine := MealyMachine([[1,1],[2,1]],[(1,2),[2,2]]);</span>
&lt;Mealy machine on alphabet [ 1, 2 ] with 2 states&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i2 := SCSemigroupNC(i2machine);</span>
&lt;self-similar semigroup over [ 1 .. 2 ] with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f0 := GeneratorsOfSemigroup(i2)[1];; f1 := GeneratorsOfSemigroup(i2)[2];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f0^2=One(i2);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll([0..10],p-&gt;(f0*f1)^p*(f1*f0)^p*f1=f1^2*(f0*f1)^p*(f1*f0)^p*f1);</span>
true
</pre></div>

<p><a id="X7F15D57A7959FEF6" name="X7F15D57A7959FEF6"></a></p>

<h5>7.1-4 Correspondence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Correspondence</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A correspondence between the generators of the underlying FR machine of <var class="Arg">g</var> and <var class="Arg">g</var>.</p>

<p>If <var class="Arg">g</var> was created as the state closure of an FR machine <code class="code">m</code>, this attribute records the correspondence between <code class="code">m</code> and <var class="Arg">g</var>.</p>

<p>If <code class="code">m</code> is a group/monoid/semigroup/algebra FR machine, then <code class="code">Correspondence(g)</code> is a homomorphism from the stateset of <code class="code">m</code> to <var class="Arg">g</var>.</p>

<p>If <code class="code">m</code> is a Mealy or vector machine, then <code class="code">Correspondence(g)</code> is a list, with in position <span class="SimpleMath">i</span> the index in the generating set of <var class="Arg">g</var> of state number <span class="SimpleMath">i</span>. This index is 0 if there is no corresponding generator because the state is trivial, and is negative if there is no corresponding generator because the inverse of state number <span class="SimpleMath">i</span> is a generator.</p>

<p>See <code class="func">SCGroupNC</code> (<a href="chap7.html#X853E3F0680C76F56"><span class="RefLink">7.1-3</span></a>), <code class="func">SCGroup</code> (<a href="chap7.html#X853E3F0680C76F56"><span class="RefLink">7.1-3</span></a>), <code class="func">SCMonoidNC</code> (<a href="chap7.html#X853E3F0680C76F56"><span class="RefLink">7.1-3</span></a>), <code class="func">SCMonoid</code> (<a href="chap7.html#X853E3F0680C76F56"><span class="RefLink">7.1-3</span></a>), <code class="func">SCSemigroupNC</code> (<a href="chap7.html#X853E3F0680C76F56"><span class="RefLink">7.1-3</span></a>), <code class="func">SCSemigroup</code> (<a href="chap7.html#X853E3F0680C76F56"><span class="RefLink">7.1-3</span></a>), <code class="func">SCAlgebraNC</code> (<a href="chap8.html#X844B890F7BF56236"><span class="RefLink">8.1-2</span></a>), <code class="func">SCAlgebra</code> (<a href="chap8.html#X844B890F7BF56236"><span class="RefLink">8.1-2</span></a>), <code class="func">SCAlgebraWithOneNC</code> (<a href="chap8.html#X844B890F7BF56236"><span class="RefLink">8.1-2</span></a>), and <code class="func">SCAlgebraWithOne</code> (<a href="chap8.html#X844B890F7BF56236"><span class="RefLink">8.1-2</span></a>) for examples.</p>

<p><a id="X7D0B8334786E2802" name="X7D0B8334786E2802"></a></p>

<h5>7.1-5 FullSCGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FullSCGroup</code>( <var class="Arg">...</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FullSCMonoid</code>( <var class="Arg">...</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FullSCSemigroup</code>( <var class="Arg">...</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: A maximal state-closed group/monoid/semigroup on the alphabet <var class="Arg">a</var>.</p>

<p>This function constructs a new FR group, monoid or semigroup, which contains all transformations with given properties of the tree with given alphabet.</p>

<p>The arguments can be, in any order: a semigroup, specifying which vertex actions are allowed; a set or domain, specifying the alphabet of the tree; an integer, specifying the maximal depth of elements; and a filter among <code class="func">IsFinitaryFRElement</code> (<a href="chap5.html#X793C427084F830CE"><span class="RefLink">5.2-10</span></a>), <code class="func">IsBoundedFRElement</code> (<a href="chap5.html#X82F4410E85C54C7E"><span class="RefLink">5.2-12</span></a>), <code class="func">IsPolynomialGrowthFRElement</code> (<a href="chap5.html#X81D4A3F27C5FAD96"><span class="RefLink">5.2-13</span></a>) and <code class="func">IsFiniteStateFRElement</code> (<a href="chap4.html#X7C4076707CBBE945"><span class="RefLink">4.2-12</span></a>).</p>

<p>This object serves as a container for all FR elements with alphabet <var class="Arg">a</var>. Random elements can be drawn from it; they are Mealy elements with a random number of states, and with the required properties.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := FullSCGroup([1..3]);</span>
FullSCGroup([ 1 .. 3 ]);
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubgroup(g,GuptaSidkiGroup);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := FullSCGroup([1..3],Group((1,2,3)));</span>
FullSCGroup([ 1 .. 3 ], Group( [ (1,2,3) ] ))
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubgroup(g,GuptaSidkiGroup);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubgroup(g,GrigorchukGroup);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Random(g);</span>
&lt;Mealy element on alphabet [ 1, 2, 3 ] with 2 states, initial state 1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(FullSCGroup([1,2],3));</span>
128
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := FullSCMonoid([1..2]);</span>
FullSCMonoid([ 1 .. 2 ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubset(g,AsTransformation(FullSCGroup([1..2])));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubset(g,AsTransformation(GrigorchukGroup));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := FullSCSemigroup([1..3]);</span>
FullSCSemigroup([ 1 .. 3 ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h := FullSCSemigroup([1..3],Semigroup(Transformation([1,1,1])));</span>
FullSCSemigroup([ 1 .. 3 ], Semigroup( [ [ 1, 1, 1 ] ] ))
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(h);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubset(g,h);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g=FullSCMonoid([1..3]);</span>
true
</pre></div>

<p><a id="X7DB92C34827D513F" name="X7DB92C34827D513F"></a></p>

<h5>7.1-6 FRMachineFRGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FRMachineFRGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FRMachineFRMonoid</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FRMachineFRSemigroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MealyMachineFRGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MealyMachineFRMonoid</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MealyMachineFRSemigroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A machine describing all generators of <var class="Arg">g</var>.</p>

<p>This function constructs a new group/monoid/semigroup/Mealy FR machine, with (at least) one generator per generator of <var class="Arg">g</var>. This is done by adding all machines of all generators of <var class="Arg">g</var>, and minimizing.</p>

<p>In particular, if <var class="Arg">g</var> is state-closed, then <code class="code">SCGroup(FRMachineFRGroup(g))</code> gives a group isomorphic to <var class="Arg">g</var>, and similarly for monoids and semigroups.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FRMachineFRGroup(GuptaSidkiGroup);</span>
&lt;FR machine with alphabet [ 1 .. 3 ] on Group( [ f11, f12 ] )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(last);</span>
 G   |     1          2        3
-----+--------+----------+--------+
 f11 | &lt;id&gt;,2     &lt;id&gt;,3   &lt;id&gt;,1
 f12 |  f11,1   f11^-1,2    f12,3
-----+--------+----------+--------+
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FRMachineFRMonoid(I4Monoid);</span>
&lt;FR machine with alphabet [ 1 .. 2 ] on Monoid( [ m11, m12 ], ... )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(last);</span>
 M   |     1        2
-----+--------+--------+
 m11 | &lt;id&gt;,2   &lt;id&gt;,1
 m12 |  m11,1    m12,1
-----+--------+--------+
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FRMachineFRSemigroup(I2Monoid);</span>
&lt;FR machine with alphabet [ 1 .. 2 ] on Semigroup( [ s11, s12, s1 ] )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(last);</span>
 S   |    1       2
-----+-------+-------+
 s11 | s11,1   s11,2
 s12 | s12,2   s12,1
  s1 |  s1,2   s12,2
-----+-------+-------+
</pre></div>

<p><a id="X7BF4AC9F830A8E1A" name="X7BF4AC9F830A8E1A"></a></p>

<h5>7.1-7 IsomorphismFRGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismFRGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismFRMonoid</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismFRSemigroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An isomorphism towards a group/monoid/semigroup on a single FR machine.</p>

<p>This function constructs a new FR group/monoid/semigroup, such that all elements of the resulting object have the same underlying group/monoid/semigroup FR machine.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := IsomorphismFRGroup(GuptaSidkiGroup);</span>
[ &lt;Mealy element on alphabet [ 1, 2, 3 ] with 2 states, initial state 1&gt;,
  &lt;Mealy element on alphabet [ 1, 2, 3 ] with 4 states, initial state 1&gt; ] -&gt;
[ &lt;3|identity ...&gt;, &lt;3|f1&gt;, &lt;3|f1^-1&gt;, &lt;3|f2&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(GuptaSidkiGroup.2);</span>
   |  1     2     3
---+-----+-----+-----+
 a | a,1   a,2   a,3
 b | a,2   a,3   a,1
 c | a,3   a,1   a,2
 d | b,1   c,2   d,3
---+-----+-----+-----+
Initial state: d
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(GuptaSidkiGroup.2^phi);</span>
    |     1         2        3
----+--------+---------+--------+
 f1 | &lt;id&gt;,2    &lt;id&gt;,3   &lt;id&gt;,1
 f2 |   f1,1   f1^-1,2     f2,3
----+--------+---------+--------+
Initial state: f2
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := IsomorphismFRSemigroup(I2Monoid);</span>
MappingByFunction( I2, &lt;self-similar semigroup over [ 1 .. 2 ] with
3 generators&gt;, &lt;Operation "AsSemigroupFRElement"&gt; )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(GeneratorsOfSemigroup(I2Monoid)[3]);</span>
   |  1     2
---+-----+-----+
 a | a,2   b,2
 b | b,2   b,1
---+-----+-----+
Initial state: a
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(GeneratorsOfSemigroup(I2Monoid)[3]^phi);</span>
 S  |   1      2
----+------+------+
 s1 | s1,2   s2,2
 s2 | s2,2   s2,1
----+------+------+
Initial state: s1
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := IsomorphismFRMonoid(I4Monoid);</span>
MappingByFunction( I4, &lt;self-similar monoid over [ 1 .. 2 ] with
2 generators&gt;, &lt;Operation "AsMonoidFRElement"&gt; )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(GeneratorsOfMonoid(I4Monoid)[1]);</span>
   |  1     2
---+-----+-----+
 a | b,2   b,1
 b | b,1   b,2
---+-----+-----+
Initial state: a
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(GeneratorsOfMonoid(I4Monoid)[1]^phi);</span>
 M  |     1        2
----+--------+--------+
 m1 | &lt;id&gt;,2   &lt;id&gt;,1
----+--------+--------+
Initial state: m1
</pre></div>

<p><a id="X7DE1CAE981F2825B" name="X7DE1CAE981F2825B"></a></p>

<h5>7.1-8 IsomorphismMealyGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismMealyGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismMealyMonoid</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismMealySemigroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An isomorphism towards a group/monoid/semigroup all of whose elements are Mealy machines.</p>

<p>This function constructs a new FR group/monoid/semigroup, such that all elements of the resulting object are Mealy machines.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := FRGroup("a=(1,2)","b=&lt;a,b&gt;","c=&lt;c,b&gt;");</span>
&lt;self-similar group over [ 1 .. 2 ] with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := IsomorphismMealyGroup(G);</span>
[ &lt;2|a&gt;, &lt;2|b&gt;, &lt;2|c&gt; ] -&gt;
[ &lt;Mealy element on alphabet [ 1, 2 ] with 2 states, initial state 1&gt;,
  &lt;Mealy element on alphabet [ 1, 2 ] with 3 states, initial state 1&gt;,
  &lt;Mealy element on alphabet [ 1, 2 ] with 4 states, initial state 1&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(G.3);</span>
   |     1        2
---+--------+--------+
 a | &lt;id&gt;,2   &lt;id&gt;,1
 b |    a,1      b,2
 c |    c,1      b,2
---+--------+--------+
Initial state: c
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(G.3^phi);</span>
   |  1     2
---+-----+-----+
 a | a,1   b,2
 b | c,1   b,2
 c | d,2   d,1
 d | d,1   d,2
---+-----+-----+
Initial state: a
</pre></div>

<p><a id="X7BB8DDEA83946C73" name="X7BB8DDEA83946C73"></a></p>

<h5>7.1-9 FRGroupByVirtualEndomorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FRGroupByVirtualEndomorphism</code>( <var class="Arg">hom</var>[, <var class="Arg">transversal</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A new self-similar group.</p>

<p>This function constructs a new FR group <code class="code">P</code>, generated by group FR elements. Its first argument is a virtual endomorphism of a group <code class="code">G</code>, i.e. a homomorphism from a subgroup <code class="code">H</code> to <code class="code">G</code>. The constructed FR group acts on a tree with alphabet a transversal of <code class="code">H</code> in <code class="code">G</code> (represented as <code class="code">[1..d]</code>), and is a homomorphic image of <code class="code">G</code>. The stabilizer of the first-level vertex corresponding to the trivial coset is the image of <code class="code">H</code>. This function is loosely speaking an inverse of <code class="func">VirtualEndomorphism</code> (<a href="chap7.html#X7DF2D9838625CDED"><span class="RefLink">7.2-29</span></a>).</p>

<p>The optional second argument is a transversal of <code class="code">H</code> in <code class="code">G</code>, either of type <code class="code">IsRightTransversal</code> or a list.</p>

<p>Furthermore, an option "MealyElement" can be passed to the function, as <code class="code">FRGroupByVirtualEndomorphism(f:MealyElement)</code>, to require the resulting group to be generated by Mealy elements and not FR elements. The call will succeed, of course, only if the representation of <code class="code">G</code> is finite-state.</p>

<p>The resulting FR group has an attribute <code class="code">Correspondence(P)</code> that records a homomorphism from <code class="code">G</code> to <code class="code">P</code>.</p>

<p>The example below constructs the binary adding machine, and a non-standard representation of it.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := FreeGroup(1);</span>
&lt;free group on the generators [ f1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := GroupHomomorphismByImages(Group(G.1^2),G,[G.1^2],[G.1]);</span>
[ f1^2 ] -&gt; [ f1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := FRGroupByVirtualEndomorphism(f);</span>
&lt;self-similar group over [ 1 .. 2 ] with 1 generator&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(H.1);</span>
    |     1      2
----+--------+------+
 x1 | &lt;id&gt;,2   x1,1
----+--------+------+
Initial state: x1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Correspondence(H);</span>
[ f1 ] -&gt; [ &lt;2|x1&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := FRGroupByVirtualEndomorphism(f,[G.1^0,G.1^3]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(H.1);</span>
    |      1        2
----+---------+--------+
 x1 | x1^-1,2   x1^2,1
----+---------+--------+
Initial state: x1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := FRGroupByVirtualEndomorphism(f:MealyElement);</span>
&lt;self-similar group over [ 1 .. 2 ] with 1 generator&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(H.1);</span>
   |  1     2
---+-----+-----+
 a | b,2   a,1
 b | b,1   b,2
---+-----+-----+
Initial state: a
</pre></div>

<p><a id="X79D75A7D80DD9AD1" name="X79D75A7D80DD9AD1"></a></p>

<h5>7.1-10 TreeWreathProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TreeWreathProduct</code>( <var class="Arg">g</var>, <var class="Arg">h</var>, <var class="Arg">x0</var>, <var class="Arg">y0</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: The tree-wreath product of groups <var class="Arg">g,h</var>.</p>

<p>The tree-wreath product of two FR groups is a group generated by a copy of <var class="Arg">g</var> and of <var class="Arg">h</var>, in such a way that many conjugates of <var class="Arg">g</var> commute.</p>

<p>More formally, assume without loss of generality that all generators of <var class="Arg">g</var> are states of a machine <code class="code">m</code>, and that all generators of <var class="Arg">h</var> are states of a machine <code class="code">n</code>. Then the tree-wreath product is generated by the images of generators of <var class="Arg">g,h</var> in <code class="code">TreeWreathProduct(m,n,x0,y0)</code>.</p>

<p>For the operation on FR machines see <code class="func">TreeWreathProduct</code> (<a href="chap3.html#X7A0858097AA3FBDA"><span class="RefLink">3.5-8</span></a>)). It is described (with small variations, and in lesser generality) in <a href="chapBib.html#biBMR2197828">[Sid05]</a>. For example, in</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w := TreeWreathProduct(AddingGroup(2),AddingGroup(2),1,1);</span>
&lt;recursive group over [ 1 .. 4 ] with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := w.1; b := w.2;</span>
&lt;Mealy element on alphabet [ 1 .. 4 ] with 3 states&gt;
&lt;Mealy element on alphabet [ 1 .. 4 ] with 2 states&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order(a); Order(b);</span>
infinity
infinity
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll([-100..100],i-&gt;IsOne(Comm(a,a^(b^i))));</span>
true
</pre></div>

<p>the group <code class="code">w</code> is the wreath product <span class="SimpleMath">Zâ‰€ Z</span>.</p>

<p><a id="X85840A047C04BFC6" name="X85840A047C04BFC6"></a></p>

<h5>7.1-11 WeaklyBranchedEmbedding</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WeaklyBranchedEmbedding</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A embedding of <var class="Arg">g</var> in a weakly branched group.</p>

<p>This function constructs a new FR group, on alphabet the square of the alphabet of <var class="Arg">g</var>. It is generated by the canonical copy of <var class="Arg">g</var> and by the tree-wreath product of <var class="Arg">g</var> with an adding machine on the same alphabet as <var class="Arg">g</var> (see <code class="func">TreeWreathProduct</code> (<a href="chap7.html#X79D75A7D80DD9AD1"><span class="RefLink">7.1-10</span></a>)). The function returns a group homomorphism into this new FR group.</p>

<p>The main result of <a href="chapBib.html#biBMR1995624">[SW03]</a> is that the resulting group <span class="SimpleMath">h</span> is weakly branched. More precisely, <span class="SimpleMath">h'</span> contains <span class="SimpleMath">|X|^2</span> copies of itself. <code class="code"> gap&gt; f := WeaklyBranchedEmbedding(BabyAleshinGroup);; gap&gt; Range(f); &lt;recursive group over [ 1 .. 4 ] with 8 generators&gt; </code> constructs a finitely generated branched group containing a free subgroup.</p>

<p><a id="X84E20571841DE1E4" name="X84E20571841DE1E4"></a></p>

<h4>7.2 <span class="Heading">Operations for FR semigroups</span></h4>

<p><a id="X7C6D7BA0818A3A3D" name="X7C6D7BA0818A3A3D"></a></p>

<h5>7.2-1 PermGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PermGroup</code>( <var class="Arg">g</var>, <var class="Arg">l</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EpimorphismPermGroup</code>( <var class="Arg">g</var>, <var class="Arg">l</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: [An epimorphism to] the permutation group of <var class="Arg">g</var>'s action on level <var class="Arg">l</var>.</p>

<p>The first function returns a permutation group on <span class="SimpleMath">d^l</span> points, where <span class="SimpleMath">d</span> is the size of <var class="Arg">g</var>'s alphabet. It has as many generators as <var class="Arg">g</var>, and represents the action of <var class="Arg">g</var> on the <var class="Arg">l</var>th layer of the tree.</p>

<p>The second function returns a homomorphism from <var class="Arg">g</var> to this permutation group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := FRGroup("a=(1,2)","b=&lt;a,&gt;"); Size(g);</span>
&lt;self-similar group over [ 1 .. 2 ] with 2 generators&gt;
8
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PermGroup(g,2);</span>
Group([ (1,3)(2,4), (1,2) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PermGroup(g,3);</span>
Group([ (1,5)(2,6)(3,7)(4,8), (1,3)(2,4) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List([1..6],i-&gt;LogInt(Size(PermGroup(GrigorchukGroup,i)),2));</span>
[ 1, 3, 7, 12, 22, 42 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := FRGroup("t=&lt;,t&gt;(1,2)"); Size(g);</span>
&lt;self-similar group over [ 1 .. 2 ] with 1 generator&gt;
infinity
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi := EpimorphismPermGroup(g,5);</span>
MappingByFunction( &lt;self-similar group over [ 1 .. 2 ] with 1 generator,
of size infinity&gt;, Group([ (1,17,9,25,5,21,13,29,3,19,11,27,7,23,15,31,
2,18,10,26,6,22,14,30,4,20,12,28,8,24,16,32) ]), function( w ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order(g.1);</span>
infinity
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order(g.1^pi);</span>
32
</pre></div>

<p><a id="X8620BEAF7957FA4D" name="X8620BEAF7957FA4D"></a></p>

<h5>7.2-2 PcGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PcGroup</code>( <var class="Arg">g</var>, <var class="Arg">l</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EpimorphismPcGroup</code>( <var class="Arg">g</var>, <var class="Arg">l</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: [An epimorphism to] the pc group of <var class="Arg">g</var>'s action on level <var class="Arg">l</var>.</p>

<p>The first function returns a polycyclic group representing the action of <var class="Arg">g</var> on the <var class="Arg">l</var>th layer of the tree. It converts the permutation group <code class="code">PermGroup(g,l)</code> to a Pc group, in which computations are often faster.</p>

<p>The second function returns a homomorphism from <var class="Arg">g</var> to this pc group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := PcGroup(GrigorchukGroup,7); time;</span>
&lt;pc group with 5 generators&gt;
3370
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NormalClosure(g,Group(g.3)); time;</span>
&lt;pc group with 79 generators&gt;
240
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := PermGroup(GrigorchukGroup,7); time;</span>
&lt;permutation group with 5 generators&gt;
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NormalClosure(g,Group(g.3)); time;</span>
&lt;permutation group with 5 generators&gt;
5344
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := FRGroup("t=&lt;,t&gt;(1,2)"); Size(g);</span>
&lt;self-similar group over [ 1 .. 2 ] with 1 generator&gt;
infinity
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi := EpimorphismPcGroup(g,5);</span>
MappingByFunction( &lt;self-similar group over [ 1 .. 2 ] with
1 generator, of size infinity&gt;, Group([ f1, f2, f3, f4, f5 ]), function( w ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order(g.1);</span>
infinity
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order(g.1^pi);</span>
32
</pre></div>

<p><a id="X83834FF77F972912" name="X83834FF77F972912"></a></p>

<h5>7.2-3 TransformationMonoid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TransformationMonoid</code>( <var class="Arg">g</var>, <var class="Arg">l</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EpimorphismTransformationMonoid</code>( <var class="Arg">g</var>, <var class="Arg">l</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: [An epimorphism to] the transformation monoid of <var class="Arg">g</var>'s action on level <var class="Arg">l</var>.</p>

<p>The first function returns a transformation monoid on <span class="SimpleMath">d^l</span> points, where <span class="SimpleMath">d</span> is the size of <var class="Arg">g</var>'s alphabet. It has as many generators as <var class="Arg">g</var>, and represents the action of <var class="Arg">g</var> on the <var class="Arg">l</var>th layer of the tree.</p>

<p>The second function returns a homomorphism from <var class="Arg">g</var> to this transformation monoid.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i4 := SCMonoid(MealyMachine([[3,3],[1,2],[3,3]],[(1,2),[1,1],()]));</span>
&lt;self-similar monoid over [ 1 .. 2 ] with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := TransformationMonoid(i4,6);</span>
&lt;monoid with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List([1..6],i-&gt;Size(TransformationMonoid(i4,i)));</span>
[ 4, 14, 50, 170, 570, 1882 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Collected(List(g,RankOfTransformation));</span>
[ [ 1, 64 ], [ 2, 1280 ], [ 4, 384 ], [ 8, 112 ], [ 16, 32 ], [ 32, 8 ], [ 64, 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi := EpimorphismTransformationMonoid(i4,9);</span>
MappingByFunction( &lt;self-similar monoid over [ 1 .. 2 ] with 3 generators&gt;,
&lt;monoid with 3 generators&gt;, function( w ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := GeneratorsOfMonoid(i4){[1,2]};;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for i in [1..10] do Add(f,f[i]*f[i+1]); od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Product(f{[3,5,7,9,11]})=f[11]*f[10];</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Product(f{[3,5,7,9,11]})^pi=(f[11]*f[10])^pi;</span>
true
</pre></div>

<p><a id="X8768C22D859BE75F" name="X8768C22D859BE75F"></a></p>

<h5>7.2-4 TransformationSemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TransformationSemigroup</code>( <var class="Arg">g</var>, <var class="Arg">l</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EpimorphismTransformationSemigroup</code>( <var class="Arg">g</var>, <var class="Arg">l</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: [An epimorphism to] the transformation semigroup of <var class="Arg">g</var>'s action on level <var class="Arg">l</var>.</p>

<p>The first function returns a transformation semigroup on <span class="SimpleMath">d^l</span> points, where <span class="SimpleMath">d</span> is the size of <var class="Arg">g</var>'s alphabet. It has as many generators as <var class="Arg">g</var>, and represents the action of <var class="Arg">g</var> on the <var class="Arg">l</var>th layer of the tree.</p>

<p>The second function returns a homomorphism from <var class="Arg">g</var> to this transformation semigroup.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i2 := SCSemigroup(MealyMachine([[1,1],[2,1]],[(1,2),[2,2]]));</span>
&lt;self-similar semigroup over [ 1 .. 2 ] with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := TransformationSemigroup(i2,6);</span>
&lt;semigroup with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List([1..6],i-&gt;Size(TransformationSemigroup(i2,i)));</span>
[ 4, 14, 42, 114, 290, 706 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Collected(List(g,RankOfTransformation));</span>
[ [ 1, 64 ], [ 2, 384 ], [ 4, 160 ], [ 8, 64 ], [ 16, 24 ], [ 32, 8 ], [ 64, 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f0 := GeneratorsOfSemigroup(i2)[1];; f1 := GeneratorsOfSemigroup(i2)[2];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi := EpimorphismTransformationSemigroup(i2,10);</span>
MappingByFunction( &lt;self-similar semigroup over [ 1 .. 2 ] with
2 generators&gt;, &lt;semigroup with 2 generators&gt;, function( w ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">(f1*(f1*f0)^10)=((f1*f0)^10);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">(f1*(f1*f0)^10)^pi=((f1*f0)^10)^pi;</span>
true
</pre></div>

<p><a id="X7BDC634086437315" name="X7BDC634086437315"></a></p>

<h5>7.2-5 EpimorphismGermGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EpimorphismGermGroup</code>( <var class="Arg">g</var>, <var class="Arg">l</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EpimorphismGermGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A homomorphism to a polycyclic group.</p>

<p>This function returns an epimorphism to a polycyclic group, encoding the action on the first <var class="Arg">l</var> levels of the tree and on the germs below. If <var class="Arg">l</var> is omitted, it is assumed to be <span class="SimpleMath">0</span>.</p>

<p>Since the elements of <var class="Arg">g</var> are finite automata, they map periodic sequences to periodic sequences. The action on the periods, and in the immediate vicinity of them, is called the <em>germ action</em> of <var class="Arg">g</var>. This function returns the natural homomorphism from <var class="Arg">g</var> to the wreath product of this germ group with the quotient of <var class="Arg">g</var> acting on the <var class="Arg">l</var>th layer of the tree.</p>

<p>The germ group, by default, is abelian. If it is finite, this function returns a homomorphism to a Pc group; otherwise, a homomorphism to a polycyclic group.</p>

<p>The <code class="func">GrigorchukTwistedTwin</code> (<a href="chap9.html#X7E765AF77AAC21A6"><span class="RefLink">9.1-12</span></a>) is, for now, the only example with a hand-coded, non-abelian germ group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EpimorphismGermGroup(GrigorchukGroup,0);</span>
MappingByFunction( GrigorchukGroup, &lt;pc group of size 4 with 2 generators&gt;,
  function( g ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(GeneratorsOfGroup(GrigorchukGroup),x-&gt;x^last);</span>
[ &lt;identity&gt; of ..., f1, f1*f2, f2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription(Image(last2));</span>
"C2 x C2"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := FRGroup("t=&lt;,t&gt;(1,2)","m=&lt;,m^-1&gt;(1,2)");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EpimorphismGermGroup(g,0);</span>
MappingByFunction( &lt;state-closed, bounded group over [ 1, 2 ] with 2
  generators&gt;, Pcp-group with orders [ 0, 0 ], function( x ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EpimorphismGermGroup(g,1);; Range(last); Image(last2);</span>
Pcp-group with orders [ 2, 0, 0, 0, 0 ]
Pcp-group with orders [ 2, 0, 0, 0 ]
</pre></div>

<p><a id="X812242E584462766" name="X812242E584462766"></a></p>

<h5>7.2-6 GermData</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GermData</code>( <var class="Arg">group</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GermValue</code>( <var class="Arg">element</var>, <var class="Arg">data</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The first command computes some data useful to determine the germ value of a group element; the second command computes these germ values. For more information on germs, see <code class="func">Germs</code> (<a href="chap5.html#X81592E3D79745A40"><span class="RefLink">5.2-24</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">data := GermData(GrigorchukGroup);</span>
rec( endo := [ f1, f2 ] -&gt; [ f1*f2, f1 ], group := &lt;pc group of size 4 with 2 generators&gt;,
  machines := [  ], map := [ &lt;identity&gt; of ..., f2, f1, f1*f2, &lt;identity&gt; of ... ],
  nucleus := [ &lt;Trivial Mealy element on alphabet [ 1 .. 2 ]&gt;, d, c, b, a ],
  nucleusmachine := &lt;Mealy machine on alphabet [ 1 .. 2 ] with 5 states&gt; )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(GeneratorsOfGroup(GrigorchukGroup),x-&gt;GermValue(x,data));</span>
[ &lt;identity&gt; of ..., f1*f2, f1, f2 ]
</pre></div>

<p><a id="X87378D53791D0B70" name="X87378D53791D0B70"></a></p>

<h5>7.2-7 StabilizerImage</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StabilizerImage</code>( <var class="Arg">g</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: The group of all states at <var class="Arg">v</var> of elements of <var class="Arg">g</var> fixing <var class="Arg">v</var>.</p>

<p>This function constructs a new FR group, consisting of all states at vertex <var class="Arg">v</var> (which can be an integer or a list) of the stabilizer of <var class="Arg">v</var> in <var class="Arg">g</var>.</p>

<p>The result is <var class="Arg">g</var> itself precisely if <var class="Arg">g</var> is recurrent (see <code class="func">IsRecurrentFRSemigroup</code> (<a href="chap7.html#X7E2F34417EBB7673"><span class="RefLink">7.2-11</span></a>)).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := FRGroup("t=&lt;,t&gt;(1,2)","u=&lt;,u^-1&gt;(1,2)","b=&lt;u,t&gt;");</span>
&lt;self-similar group over [ 1 .. 2 ] with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Stabilizer(G,1);</span>
&lt;self-similar group over [ 1 .. 2 ] with 5 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsOfGroup(last);</span>
[ &lt;2|u*t^-1&gt;, &lt;2|b&gt;, &lt;2|t^2&gt;, &lt;2|t*u&gt;, &lt;2|t*b*t^-1&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StabilizerImage(G,1);</span>
&lt;self-similar group over [ 1 .. 2 ] with 5 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsOfGroup(last);</span>
[ &lt;2|identity ...&gt;, &lt;2|u&gt;, &lt;2|t&gt;, &lt;2|u^-1&gt;, &lt;2|t&gt; ]
</pre></div>

<p><a id="X7B4CD9CA872BA368" name="X7B4CD9CA872BA368"></a></p>

<h5>7.2-8 LevelStabilizer</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LevelStabilizer</code>( <var class="Arg">g</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: The fixator of the <var class="Arg">n</var>th level of the tree.</p>

<p>This function constructs the normal subgroup of <var class="Arg">g</var> that fixes the <var class="Arg">n</var>th level of the tree.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := FRGroup("t=&lt;,t&gt;(1,2)","a=(1,2)");</span>
&lt;self-similar group over [ 1 .. 2 ] with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LevelStabilizer(G,2);</span>
&lt;self-similar group over [ 1 .. 2 ] with 9 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Index(G,last);</span>
8
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsNormal(G,last2);</span>
true
</pre></div>

<p><a id="X7C5002E683A044C1" name="X7C5002E683A044C1"></a></p>

<h5>7.2-9 IsStateClosed</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsStateClosed</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if all states of elements of <var class="Arg">g</var> belong to <var class="Arg">g</var>.</p>

<p>This function tests whether <var class="Arg">g</var> is a <em>state-closed</em> group, i.e. a group such that all states of all elements of <var class="Arg">g</var> belong to <var class="Arg">g</var>.</p>

<p>The smallest state-closed group containing <var class="Arg">g</var> is computed with <code class="func">StateClosure</code> (<a href="chap7.html#X79246DB482BEAF2D"><span class="RefLink">7.2-10</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dinfinity := FRGroup("a=(1,2)","b=&lt;a,b&gt;");</span>
&lt;self-similar group over [ 1 .. 2 ] with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AssignGeneratorVariables(Dinfinity);</span>
#I  Assigned the global variables [ a, b ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsStateClosed(Group(a));</span>
     IsStateClosed(Group(b));
     IsStateClosed(Dinfinity);
true
false
true
</pre></div>

<p><a id="X79246DB482BEAF2D" name="X79246DB482BEAF2D"></a></p>

<h5>7.2-10 StateClosure</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StateClosure</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: The smallest state-closed group containing <var class="Arg">g</var>.</p>

<p>This function computes the smallest group containing all states of all elements of <var class="Arg">g</var>, i.e. the smallest group containing <var class="Arg">g</var> and for which <code class="func">IsStateClosed</code> (<a href="chap7.html#X7C5002E683A044C1"><span class="RefLink">7.2-9</span></a>) returns <code class="keyw">true</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dinfinity := FRGroup("a=(1,2)","b=&lt;a,b&gt;");</span>
&lt;self-similar group over [ 1 .. 2 ] with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AssignGeneratorVariables(Dinfinity);</span>
#I  Assigned the global variables [ a, b ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StateStateClosure(Group(a))=Dinfinity; StateClosure(Group(b))=Dinfinity;</span>
false
true
</pre></div>

<p><a id="X7E2F34417EBB7673" name="X7E2F34417EBB7673"></a></p>

<h5>7.2-11 IsRecurrentFRSemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsRecurrentFRSemigroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if <var class="Arg">g</var> is a recurrent group.</p>

<p>This function returns <code class="keyw">true</code> if <var class="Arg">g</var> is a <em>recurrent</em> group, i.e. if, for every vertex <code class="code">v</code>, all elements of <var class="Arg">g</var> appear as states at <code class="code">v</code> of elements fixing <code class="code">v</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dinfinity := FRGroup("a=(1,2)","b=&lt;a,b&gt;");</span>
&lt;self-similar group over [ 1 .. 2 ] with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AssignGeneratorVariables(Dinfinity);</span>
#I  Assigned the global variables [ a, b ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecurrentFRSemigroup(Group(a)); IsRecurrentFRSemigroup(Group(b));</span>
false
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecurrentFRSemigroup(Dinfinity);</span>
true
</pre></div>

<p><a id="X7FBF56737D9063F4" name="X7FBF56737D9063F4"></a></p>

<h5>7.2-12 IsLevelTransitive</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLevelTransitive</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if <var class="Arg">g</var> is a level-transitive group.</p>

<p>This function returns <code class="keyw">true</code> if <var class="Arg">g</var> is a <em>level-transitive</em> group, i.e. if the action of <var class="Arg">g</var> is transitive at every level of the tree on which it acts.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dinfinity := FRGroup("a=(1,2)","b=&lt;a,b&gt;");</span>
&lt;self-similar group over [ 1 .. 2 ] with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AssignGeneratorVariables(Dinfinity);</span>
#I  Assigned the global variables [ a, b ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLevelTransitive(Group(a)); IsLevelTransitive(Group(b));</span>
     IsLevelTransitive(Dinfinity);
false
false
true
</pre></div>

<p><a id="X7D95219481AEDD20" name="X7D95219481AEDD20"></a></p>

<h5>7.2-13 IsInfinitelyTransitive</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsInfinitelyTransitive</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLevelTransitiveOnPatterns</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if <var class="Arg">g</var> is infinitely transitive.</p>

<p>This function returns <code class="keyw">true</code> if <var class="Arg">g</var> is an <em>infinitely transitive</em> group. This means that <var class="Arg">g</var> is the state-closed group of a bireversible Mealy machine (see <code class="func">IsBireversible</code> (<a href="chap5.html#X80D2545D7D0990A2"><span class="RefLink">5.2-7</span></a>)), and that the action of the set of reduced words of any given length over the alphabet (where "reduced" means no successive letters related by the involution) is transitive.</p>

<p>Reduced words are defined as follows: if the underlying Mealy machine of <var class="Arg">g</var> has an involution on its alphabet (see <code class="func">AlphabetInvolution</code> (<a href="chap5.html#X7CCB79B981912CCC"><span class="RefLink">5.2-6</span></a>)), then reduced words are words in which two consecutive letters are not images of each other under the involution. If no involution is defined, then all words are considered reduced; the command then becomes synonymous to <code class="func">IsLevelTransitive</code> (<a href="chap7.html#X7FBF56737D9063F4"><span class="RefLink">7.2-12</span></a>).</p>

<p>This notion is of fundamental importance for the study of lattices in a product of trees; it implies under appropriate circumstances that the dual group is free.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsInfinitelyTransitive(BabyAleshinGroup);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLevelTransitive(BabyAleshinGroup);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s := DualMachine(BabyAleshinMachine);</span>
&lt;Mealy machine on alphabet [ 1 .. 3 ] with 2 states&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AlphabetInvolution(s); # set attribute</span>
[ 1, 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := SCGroup(s);</span>
&lt;state-closed group over [ 1 .. 3 ] with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsInfinitelyTransitive(g);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLevelTransitive(g);</span>
false
</pre></div>

<p><a id="X7A6CB30181662C77" name="X7A6CB30181662C77"></a></p>

<h5>7.2-14 IsFinitaryFRSemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFinitaryFRSemigroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsWeaklyFinitaryFRSemigroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsBoundedFRSemigroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPolynomialGrowthFRSemigroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFiniteStateFRSemigroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if all elements of <var class="Arg">g</var> have the required property.</p>

<p>This function returns <code class="keyw">true</code> if all elements of <var class="Arg">g</var> have the required property, as FR elements; see <code class="func">IsFinitaryFRElement</code> (<a href="chap5.html#X793C427084F830CE"><span class="RefLink">5.2-10</span></a>), <code class="func">IsWeaklyFinitaryFRElement</code> (<a href="chap5.html#X7A87ED9D789245E4"><span class="RefLink">5.2-23</span></a>), <code class="func">IsBoundedFRElement</code> (<a href="chap5.html#X82F4410E85C54C7E"><span class="RefLink">5.2-12</span></a>), <code class="func">IsPolynomialGrowthFRElement</code> (<a href="chap5.html#X81D4A3F27C5FAD96"><span class="RefLink">5.2-13</span></a>) and <code class="func">IsFiniteStateFRElement</code> (<a href="chap4.html#X7C4076707CBBE945"><span class="RefLink">4.2-12</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := FRGroup("a=(1,2)","b=&lt;a,b&gt;","c=&lt;c,b&gt;","d=&lt;d,d&gt;(1,2)");</span>
&lt;self-similar group over [ 1 .. 2 ] with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := [Group(G.1),Group(G.1,G.2),Group(G.1,G.2,G.3),G];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(L,IsFinitaryFRSemigroup);</span>
[ true, false, false, false ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(L,IsBoundedFRSemigroup);</span>
[ true, true, false, false ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(L,IsPolynomialGrowthFRSemigroup);</span>
[ true, true, true, false ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(L,IsFiniteStateFRSemigroup);</span>
[ true, true, true, true ]
</pre></div>

<p><a id="X791BCD9D782C6237" name="X791BCD9D782C6237"></a></p>

<h5>7.2-15 Degree</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Degree</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DegreeOfFRSemigroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Depth</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DepthOfFRSemigroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: The maximal degree/depth of elements of <var class="Arg">g</var>.</p>

<p>This function returns the maximal degree/depth of elements of <var class="Arg">g</var>; see <code class="func">Degree</code> (<a href="chap5.html#X84BE780A81CAC69C"><span class="RefLink">5.2-9</span></a>) and <code class="func">Depth</code> (<a href="chap5.html#X7E5E8B2C79688DC0"><span class="RefLink">5.2-11</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := FRGroup("a=(1,2)","b=&lt;a,b&gt;","c=&lt;c,b&gt;");</span>
&lt;self-similar group over [ 1 .. 2 ] with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Degree(Group(G.1)); Degree(Group(G.1,G.2)); Degree(G);</span>
0
1
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Depth(Group(G.1)); Depth(Group(G.1,G.2)); Depth(G);</span>
1
infinity
infinity
</pre></div>

<p><a id="X7FA67E4387C91BD8" name="X7FA67E4387C91BD8"></a></p>

<h5>7.2-16 HasOpenSetConditionFRSemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HasOpenSetConditionFRSemigroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if <var class="Arg">g</var> has the open set condition.</p>

<p>This function returns <code class="keyw">true</code> if all elements of <var class="Arg">g</var> have the <em>open set condition</em>, see <code class="func">HasOpenSetConditionFRElement</code> (<a href="chap5.html#X7F76AF2D7C0279F9"><span class="RefLink">5.2-25</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HasOpenSetConditionFRSemigroup(GrigorchukGroup);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HasOpenSetConditionFRSemigroup(BinaryAddingGroup);</span>
true
</pre></div>

<p><a id="X7D870F9E82ACB54C" name="X7D870F9E82ACB54C"></a></p>

<h5>7.2-17 HasCongruenceProperty</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HasCongruenceProperty</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if <var class="Arg">G</var> has the congruence property.</p>

<p>This function returns <code class="keyw">true</code> if the transformation (semi)group <var class="Arg">G</var> has the <em>congruence property</em>, namely if every homomorphism <span class="SimpleMath">G-&gt; Q</span> to a finite quotient factors as <span class="SimpleMath">G-&gt; H-&gt; Q</span> via an action of <span class="SimpleMath">G</span> on a finite set.</p>

<p>This command is not guaranteed to terminate.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HasCongruenceProperty(GrigorchukGroup);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HasCongruenceProperty(GrigorchukTwistedTwin);</span>
...runs forever...
</pre></div>

<p><a id="X7EAB4B5B843C0EC5" name="X7EAB4B5B843C0EC5"></a></p>

<h5>7.2-18 IsContracting</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsContracting</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if <var class="Arg">g</var> is a contracting semigroup.</p>

<p>This function returns <code class="keyw">true</code> if <var class="Arg">g</var> is a <em>contracting</em> semigroup, i.e. if there exists a finite subset <code class="code">N</code> of <var class="Arg">g</var> such that the <code class="func">LimitStates</code> (<a href="chap4.html#X8303B36C83371FB3"><span class="RefLink">4.2-11</span></a>) of every element of <var class="Arg">g</var> belong to <code class="code">N</code>.</p>

<p>The minimal such <code class="code">N</code> can be computed with <code class="func">NucleusOfFRSemigroup</code> (<a href="chap7.html#X7CA062A67C1554BB"><span class="RefLink">7.2-19</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dinfinity := FRGroup("a=(1,2)","b=&lt;a,b&gt;");</span>
&lt;self-similar group over [ 1 .. 2 ] with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsContracting(Dinfinity);</span>
true
</pre></div>

<p><a id="X7CA062A67C1554BB" name="X7CA062A67C1554BB"></a></p>

<h5>7.2-19 NucleusOfFRSemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NucleusOfFRSemigroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Nucleus</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: The nucleus of the contracting semigroup <var class="Arg">g</var>.</p>

<p>This function returns the <em>nucleus</em> of the contracting semigroup <var class="Arg">g</var>, i.e. the smallest subset <code class="code">N</code> of <var class="Arg">g</var> such that the <code class="func">LimitStates</code> (<a href="chap4.html#X8303B36C83371FB3"><span class="RefLink">4.2-11</span></a>) of every element of <var class="Arg">g</var> belong to <code class="code">N</code>.</p>

<p>This function returns <code class="keyw">fail</code> if no such <code class="code">N</code> exists. Usually, it loops forever without being able to decide whether <code class="code">N</code> is finite or infinite. It succeeds precisely when <code class="code">IsContracting(g)</code> succeeds.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dinfinity := FRGroup("a=(1,2)","b=&lt;a,b&gt;");</span>
&lt;self-similar group over [ 1 .. 2 ] with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NucleusOfFRSemigroup(Dinfinity);</span>
[ &lt;2|identity ...&gt;, &lt;2|b&gt;, &lt;2|a&gt; ]
</pre></div>

<p><a id="X8443D711796F06E4" name="X8443D711796F06E4"></a></p>

<h5>7.2-20 NucleusMachine</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NucleusMachine</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: The nucleus machine of the contracting semigroup <var class="Arg">g</var>.</p>

<p>This function returns the <em>nucleus</em> of the contracting semigroup <var class="Arg">g</var>, see <code class="func">NucleusOfFRSemigroup</code> (<a href="chap7.html#X7CA062A67C1554BB"><span class="RefLink">7.2-19</span></a>), in the form of a Mealy machine.</p>

<p>Since all states of the nucleus are elements of the nucleus, the transition and output function may be restricted to the nucleus, defining a Mealy machine. Finitely generated recurrent groups are generated by their nucleus machine.</p>

<p>This function returns <code class="keyw">fail</code> if no such <code class="code">n</code> exists. Usually, it loops forever without being able to decide whether <code class="code">n</code> is finite or infinite. It succeeds precisely when <code class="code">IsContracting(g)</code> succeeds.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dinfinity := FRGroup("a=(1,2)","b=&lt;a,b&gt;");</span>
&lt;self-similar group over [ 1 .. 2 ] with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := NucleusMachine(Dinfinity);</span>
&lt;Mealy machine on alphabet [ 1, 2 ] with 3 states&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(M);</span>
   |  1     2
---+-----+-----+
 a | a,1   a,2
 b | c,1   b,2
 c | a,2   a,1
---+-----+-----+
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dinfinity=SCGroup(M);</span>
true
</pre></div>

<p><a id="X824A9E177F5A9753" name="X824A9E177F5A9753"></a></p>

<h5>7.2-21 AdjacencyBasesWithOne</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AdjacencyBasesWithOne</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AdjacencyPoset</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: The bases, or the poset, of the simplicial model of <var class="Arg">g</var>.</p>

<p>For these arguments, <var class="Arg">g</var> can be either the nucleus of an FR semigroup, or that semigroup itself, in which case its nucleus is first computed.</p>

<p>The first function computes those maximal (for inclusion) subsets of the nucleus that are recurrent, namely subsets <code class="code">B</code> such that <code class="code">Set(B,x-&gt;States(x,v))=B</code> for a string <code class="code">v</code>.</p>

<p>The second function then computes the poset of intersections of these bases, and returns it as a binary relation.</p>

<p>For more details on these concepts, see <a href="chapBib.html#biB0810.4936">[Nek08a]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">n := NucleusOfFRSemigroup(BasilicaGroup);</span>
[ &lt;Trivial Mealy element on alphabet [ 1 .. 2 ]&gt;, b,
  &lt;Mealy element on alphabet [ 1 .. 2 ] with 3 states&gt;,
  &lt;Mealy element on alphabet [ 1 .. 2 ] with 3 states&gt;,
  &lt;Mealy element on alphabet [ 1 .. 2 ] with 3 states&gt;,
  &lt;Mealy element on alphabet [ 1 .. 2 ] with 3 states&gt;,
  &lt;Mealy element on alphabet [ 1 .. 2 ] with 3 states&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AdjacencyBasesWithOne(n);</span>
[ [ &lt;Trivial Mealy element on alphabet [ 1 .. 2 ]&gt;,
      &lt;Mealy element on alphabet [ 1 .. 2 ] with 3 states&gt;,
      &lt;Mealy element on alphabet [ 1 .. 2 ] with 3 states&gt; ],
  [ &lt;Trivial Mealy element on alphabet [ 1 .. 2 ]&gt;,
      &lt;Mealy element on alphabet [ 1 .. 2 ] with 3 states&gt;,
      &lt;Mealy element on alphabet [ 1 .. 2 ] with 3 states&gt; ],
  [ &lt;Trivial Mealy element on alphabet [ 1 .. 2 ]&gt;,
      &lt;Mealy element on alphabet [ 1 .. 2 ] with 3 states&gt;,
      &lt;Mealy element on alphabet [ 1 .. 2 ] with 3 states&gt; ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AdjacencyPoset(n);</span>
&lt;general mapping: &lt;object&gt; -&gt; &lt;object&gt; &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Draw(HasseDiagramBinaryRelation(last));</span>
</pre></div>

<p>This produces (in a new window) the following picture: <img alt="Hasse Diagram" src="hasse.jpg"></p>

<p><a id="X7A874A107D4944E1" name="X7A874A107D4944E1"></a></p>

<h5>7.2-22 BranchingSubgroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BranchingSubgroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A branching subgroup of <var class="Arg">g</var>.</p>

<p>This function searches for a subgroup <span class="SimpleMath">k</span> of <var class="Arg">g</var>, such that <span class="SimpleMath">k</span> contains <span class="SimpleMath">k Ã— â‹¯ Ã— k</span>.</p>

<p>It searches for elements in larger and larger balls in <var class="Arg">g</var>, calling <code class="func">FindBranchingSubgroup</code> (<a href="chap7.html#X78ADACCD8586D3C7"><span class="RefLink">7.2-23</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K := BranchingSubgroup(GrigorchukGroup);</span>
&lt;self-similar group over [ 1 .. 2 ] with 9 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsBranchingSubgroup(K);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsBranched(GrigorchukGroup);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Index(GrigorchukGroup,K);</span>
16
</pre></div>

<p><a id="X78ADACCD8586D3C7" name="X78ADACCD8586D3C7"></a></p>

<h5>7.2-23 FindBranchingSubgroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FindBranchingSubgroup</code>( <var class="Arg">g</var>, <var class="Arg">l</var>, <var class="Arg">r</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A branching subgroup of <var class="Arg">g</var>.</p>

<p>This function searches for a subgroup <span class="SimpleMath">k</span> of <var class="Arg">g</var>, such that <span class="SimpleMath">k</span> contains <span class="SimpleMath">k Ã— â‹¯ Ã— k</span>.</p>

<p>The second argument <var class="Arg">l</var> specifies the level at which branching must occur; i.e. asks to search for a subgroup <span class="SimpleMath">k</span> such that <var class="Arg">g</var> contains <span class="SimpleMath">k^d^l</span> where <span class="SimpleMath">d</span> is the size of the alphabet. If <code class="code">l=infinity</code>, the resulting <span class="SimpleMath">k</span> will be a regularly branched subgroup.</p>

<p>The third argument <var class="Arg">r</var> specifies the radius to explore in <var class="Arg">g</var> and all branching subgroups at levels smaller than <var class="Arg">l</var> for elements with all level-1 states trivial except one.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FindBranchingSubgroup(GrigorchukGroup,1,4);</span>
&lt;self-similar group over [ 1 .. 2 ] with 8 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Index(GrigorchukGroup,last);</span>
8
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FindBranchingSubgroup(GrigorchukGroup,2,4);</span>
&lt;self-similar group over [ 1 .. 2 ] with 6 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Index(GrigorchukGroup,last);</span>
16
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FindBranchingSubgroup(GrigorchukGroup,3,4);</span>
&lt;self-similar group over [ 1 .. 2 ] with 9 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Index(GrigorchukGroup,last);</span>
16
</pre></div>

<p><a id="X832D98E47ACA099C" name="X832D98E47ACA099C"></a></p>

<h5>7.2-24 IsBranched</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsBranched</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if <var class="Arg">g</var> has a finite-index branching subgroup.</p>

<p>This function returns <code class="keyw">true</code> if <var class="Arg">g</var> has a finite-index subgroup <span class="SimpleMath">k</span>, such that <span class="SimpleMath">k</span> contains <span class="SimpleMath">k Ã— â‹¯ Ã— k</span>.</p>


<div class="example"><pre>
&lt;Example&gt;&lt;![CDATA[
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K := BranchingSubgroup(GrigorchukGroup);</span>
&lt;self-similar group over [ 1 .. 2 ] with 9 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsBranchingSubgroup(K);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsBranched(GrigorchukGroup);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Index(GrigorchukGroup,K);</span>
16
</pre></div>

<p><a id="X7A905CE87B49213F" name="X7A905CE87B49213F"></a></p>

<h5>7.2-25 IsBranchingSubgroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsBranchingSubgroup</code>( <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if <var class="Arg">k</var> is a branching subgroup.</p>

<p>This function returns <code class="keyw">true</code> if <var class="Arg">k</var> contains <span class="SimpleMath">k Ã— â‹¯ Ã— k</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K := BranchingSubgroup(GrigorchukGroup);</span>
&lt;self-similar group over [ 1 .. 2 ] with 9 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsBranchingSubgroup(K);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsBranched(GrigorchukGroup);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Index(GrigorchukGroup,K);</span>
16
</pre></div>

<p><a id="X8404ECA782F2521A" name="X8404ECA782F2521A"></a></p>

<h5>7.2-26 BranchStructure</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BranchStructure</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A record describing the branching of <var class="Arg">G</var>.</p>

<p>This function constructs a record with fields <code class="code">group,quo,set,top,wreath,epi</code> giving respectively a group isomorphic to <code class="code">G/K</code>, the quotient map from <code class="code">G</code> to it, the alphabet of <code class="code">G</code>, the group of permutations of the alphabet, the wreath product of <code class="code">group</code> with its top permutations, and an epimorphism from a subgroup of <code class="code">wreath</code> to <code class="code">group</code>.</p>

<p>This information is used as essential data on the branch group, and are used to construct e.g. its Zeta function.</p>

<p><a id="X8749E0797A99F531" name="X8749E0797A99F531"></a></p>

<h5>7.2-27 TopVertexTransformations</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TopVertexTransformations</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: The transformations at the root under the action of <var class="Arg">g</var>.</p>

<p>This function returns the permutation group, or the transformation group/semigroup/monoid, of all activities of all elements under the root vertex of the tree on which <var class="Arg">g</var> acts.</p>

<p>It is a synonym for <code class="code">PermGroup(g,1)</code> or <code class="code">TransformationMonoid(g,1)</code> or <code class="code">TransformationSemigroup(g,1)</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TopVertexTransformations(GrigorchukGroup);</span>
Group([ (), (1,2) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsTransitive(last,AlphabetOfFRSemigroup(GrigorchukGroup));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TopVertexTransformations(FullSCMonoid([1..3]));</span>
&lt;monoid with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(last);</span>
27
</pre></div>

<p><a id="X7C56C90086070A2E" name="X7C56C90086070A2E"></a></p>

<h5>7.2-28 VertexTransformations</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VertexTransformations</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: The transformations at all vertices under the action of <var class="Arg">g</var>.</p>

<p>This function returns the permutation group, or the transformation group/monoid/semigroup, of all activities of all elements under all vertices of the tree on which <var class="Arg">g</var> acts.</p>

<p>This is the smallest group/monoid/semigroup <code class="code">P</code> such that <var class="Arg">g</var> is a subset of <code class="code">FullSCGroup(AlphabetOfFRSemigroup(g),P)</code> or <code class="code">FullSCMonoid(AlphabetOfFRSemigroup(g),P)</code> or <code class="code">FullSCSemigroup(AlphabetOfFRSemigroup(g),P)</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VertexTransformations(GuptaSidkiGroup);</span>
Group([ (), (1,2,3), (1,3,2) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TopVertexTransformations(Group(GuptaSidkiGroup.2));</span>
Group(())
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VertexTransformations(Group(GuptaSidkiGroup.2));</span>
Group([ (), (1,2,3), (1,3,2) ])
</pre></div>

<p><a id="X7DF2D9838625CDED" name="X7DF2D9838625CDED"></a></p>

<h5>7.2-29 VirtualEndomorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VirtualEndomorphism</code>( <var class="Arg">g/m</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: The virtual endomorphism at vertex <var class="Arg">v</var>.</p>

<p>This function returns the homomorphism from <code class="code">Stabilizer(g,v)</code> to <var class="Arg">g</var>, defined by computing the state at <var class="Arg">v</var>. It is loosely speaking an inverse of <code class="func">FRGroupByVirtualEndomorphism</code> (<a href="chap7.html#X7BB8DDEA83946C73"><span class="RefLink">7.1-9</span></a>).</p>

<p>The first argument <var class="Arg">m</var> may also be an FR machine.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A := SCGroup(MealyMachine([[2,1],[2,2]],[(1,2),()]));</span>
&lt;self-similar group over [ 1 .. 2 ] with 1 generator&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := VirtualEndomorphism(A,1);</span>
MappingByFunction( &lt;self-similar group over [ 1 .. 2 ] with
1 generator&gt;, &lt;self-similar group over [ 1 .. 2 ] with
1 generator&gt;, function( g ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">((A.1)^2)^f=A.1;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := FRGroupByVirtualEndomorphism(f);</span>
&lt;self-similar group over [ 1 .. 2 ] with 1 generator&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A=B;</span>
true
</pre></div>

<p><a id="X7C81CB1C7F0D7A90" name="X7C81CB1C7F0D7A90"></a></p>

<h5>7.2-30 EpimorphismFromFpGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EpimorphismFromFpGroup</code>( <var class="Arg">g</var>, <var class="Arg">l</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An epimorphism from a finitely presented group to <var class="Arg">g</var>.</p>

<p>For some examples of self-similar groups, a recursive presentation of the group is coded into <strong class="pkg">FR</strong>, and an approximate presentation is returned by this command, together with a map onto the group <var class="Arg">g</var>. The argument <var class="Arg">l</var> roughly means the number of iterates of an endomorphism were applied to a finite set of relators. An isomorphic group would be obtained by setting <code class="code">l=infinity</code>; for that purpose, see <code class="func">IsomorphismSubgroupFpGroup</code> (<a href="chap7.html#X8740656382656D63"><span class="RefLink">7.2-31</span></a>).</p>

<p>Preimages can be computed, with <code class="code">PreImagesRepresentative</code>. They are usually reasonably short words, though by no means guaranteed to be of minimal length.</p>

<p>Currently this command is implemented through an ad hoc method for <code class="func">BinaryKneadingGroup</code> (<a href="chap9.html#X813F53C57F41F5F5"><span class="RefLink">9.1-2</span></a>), <code class="func">GrigorchukGroup</code> (<a href="chap9.html#X85BAE48780E665A4"><span class="RefLink">9.1-10</span></a>) and <code class="func">GrigorchukOverGroup</code> (<a href="chap9.html#X800640597E9C707D"><span class="RefLink">9.1-11</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := EpimorphismFromFpGroup(GrigorchukGroup,1);</span>
MappingByFunction( &lt;fp group on the generators
[ a, b, c, d ]&gt;, GrigorchukGroup, function( w ) ... end )
4 gap&gt; RelatorsOfFpGroup(Source(f));
[ a^2, b^2, c^2, d^2, b*c*d, a*d*a*d*a*d*a*d, a^-1*c*a*c*a^-1*c*a*c*a^-1*c*a*c*a^
    -1*c*a*c, a^-1*c^-1*a*b*a^-1*c*a*b*a^-1*c^-1*a*b*a^-1*c*a*b*a^-1*c^-1*a*b*a^-1*
    c*a*b*a^-1*c^-1*a*b*a^-1*c*a*b, a*d*a*c*a*c*a*d*a*c*a*c*a*d*a*c*a*c*a*d*a*c*a*c,
  a^-1*c*a*c*a^-1*c*a*b*a^-1*c*a*b*a^-1*c*a*c*a^-1*c*a*b*a^-1*c*a*b*a^-1*c*a*c*a^
    -1*c*a*b*a^-1*c*a*b*a^-1*c*a*c*a^-1*c*a*b*a^-1*c*a*b ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreImagesRepresentative(f,Comm(GrigorchukGroup.1,GrigorchukGroup.2));</span>
a*c*a*d*a*d*a*c
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Source(f).4^f=GrigorchukGroup.4;</span>
true
</pre></div>

<p><a id="X8740656382656D63" name="X8740656382656D63"></a></p>

<h5>7.2-31 IsomorphismSubgroupFpGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismSubgroupFpGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsSubgroupFpGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismLpGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsLpGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An isomorphism to a subgroup of a finitely presented group, or an L-presented group.</p>

<p>For some examples of self-similar groups, a recursive presentation of the group is coded into <strong class="pkg">FR</strong>, and is returned by this command. The group <var class="Arg">g</var> itself sits as a subgroup of a finitely presented group. To obtain a finitely presented group approximating <var class="Arg">g</var>, see <code class="func">EpimorphismFromFpGroup</code> (<a href="chap7.html#X7C81CB1C7F0D7A90"><span class="RefLink">7.2-30</span></a>). PreImages can also be computed; it is usually better to use <code class="code">PreImageElm</code>, since the word problem may not be solvable by <strong class="pkg">GAP</strong> in the f.p. group.</p>

<p>Currently this command is implemented through an ad hoc method for <code class="func">BinaryKneadingGroup</code> (<a href="chap9.html#X813F53C57F41F5F5"><span class="RefLink">9.1-2</span></a>), <code class="func">GrigorchukGroup</code> (<a href="chap9.html#X85BAE48780E665A4"><span class="RefLink">9.1-10</span></a>), <code class="func">GrigorchukOverGroup</code> (<a href="chap9.html#X800640597E9C707D"><span class="RefLink">9.1-11</span></a>), generalized <code class="func">GuptaSidkiGroups</code> (<a href="chap9.html#X82D3CB6A7C189C78"><span class="RefLink">9.1-18</span></a>) and generalized <code class="func">FabrykowskiGuptaGroups</code> (<a href="chap9.html#X878D1C7080EA9797"><span class="RefLink">9.1-21</span></a>).</p>

<p>The second form returns an isomorphism to an L-presented group (see <a href="chapBib.html#biBMR2009317">[Bar03a]</a> and <a href="chapBib.html#biBMR2483125">[BEH08]</a>. It requires the package <strong class="pkg">NQL</strong>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := IsomorphismSubgroupFpGroup(BasilicaGroup);</span>
MappingByFunction( BasilicaGroup, Group([ a^-1, a*t^-1*a^-1*t*a^-1
 ]), function( g ) ... end, function( w ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Range(f);</span>
Group([ a^-1, a*t^-1*a^-1*t*a^-1 ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := Comm(BasilicaGroup.1,BasilicaGroup.2);</span>
&lt;Mealy element on alphabet [ 1, 2 ] with 9 states, initial state 1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c^f;</span>
t^-2*a*t^-1*a*t*a^-2*t*a*t^-2*a*t^-1*a*t*a^-1*t*a*t^-1*a*t^-2*
a^-1*t*a*t^-1*a*t^-1*a^-1*t*a^-1*t^5*a*t^-1*a^-1*t*a^-1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreImageElm(f,last);</span>
&lt;Mealy element on alphabet [ 1, 2 ] with 9 states, initial state 1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">last=c;</span>
true
</pre></div>

<p><a id="X7E8485A081EBB3AA" name="X7E8485A081EBB3AA"></a></p>

<h4>7.3 <span class="Heading">Properties for infinite groups</span></h4>

<p><a id="X840ED7D279ECAB7F" name="X840ED7D279ECAB7F"></a></p>

<h5>7.3-1 IsTorsionGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsTorsionGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if <var class="Arg">g</var> is a torsion group.</p>

<p>This function returns <code class="keyw">true</code> if <var class="Arg">g</var> is a torsion group, i.e. if every element in <var class="Arg">g</var> has finite order; and <code class="keyw">false</code> if <var class="Arg">g</var> contains an element of infinite order.</p>

<p>This method is quite rudimentary, and is not guaranteed to terminate. At the minimum, <var class="Arg">g</var> should be a group in which <code class="code">Order()</code> succeeds in computing element orders; e.g. a bounded group in Mealy machine format.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dinfinity := FRGroup("a=(1,2)","b=&lt;a,b&gt;":IsMealyElement);</span>
&lt;self-similar group over [ 1 .. 2 ] with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsTorsionGroup(Dinfinity);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsTorsionGroup(GrigorchukGroup); IsTorsionGroup(GuptaSidkiGroup);</span>
true
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsTorsionGroup(FabrykowskiGuptaGroup);</span>
false
</pre></div>

<p><a id="X7914F2D68077F503" name="X7914F2D68077F503"></a></p>

<h5>7.3-2 IsTorsionFreeGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsTorsionFreeGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if <var class="Arg">g</var> is a torsion-free group.</p>

<p>This function returns <code class="keyw">true</code> if <var class="Arg">g</var> is a torsion-free group, i.e. if no element in <var class="Arg">g</var> has finite order; and <code class="keyw">false</code> if <var class="Arg">g</var> contains an element of finite order.</p>

<p>This method is quite rudimentary, and is not guaranteed to terminate. At the minimum, <var class="Arg">g</var> should be a group in which <code class="code">Order()</code> succeeds in computing element orders; e.g. a bounded group in Mealy machine format.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dinfinity := FRGroup("a=(1,2)","b=&lt;a,b&gt;":IsMealyElement);</span>
&lt;self-similar group over [ 1 .. 2 ] with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsTorsionFreeGroup(Dinfinity);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsTorsionFreeGroup(BasilicaGroup);</span>
true
</pre></div>

<p><a id="X87E93FFC820ED40E" name="X87E93FFC820ED40E"></a></p>

<h5>7.3-3 IsAmenableGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsAmenableGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if <var class="Arg">g</var> is an amenable group.</p>

<p>Amenable groups, introduced by von Neumann <a href="chapBib.html#biBvneumann">[vN29]</a>, are those groups that admit a finitely additive, translation-invariant measure.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAmenableGroup(FreeGroup(2));</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAmenableGroup(BasilicaGroup);</span>
true
</pre></div>

<p><a id="X873C0A7C8422C0C9" name="X873C0A7C8422C0C9"></a></p>

<h5>7.3-4 IsVirtuallySimpleGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsVirtuallySimpleGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LambdaElementVHGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if <var class="Arg">g</var> admits a finite-index simple subgroup.</p>

<p>This function attempts to prove that the VH group <var class="Arg">g</var> admits a finite-index simple subgroup.</p>

<p>It is based on the following test: let <code class="code">D</code> be a direction (vertical or horizontal) such that the corresponding action is infinitely transitive (see <code class="func">IsInfinitelyTransitive</code> (<a href="chap7.html#X7D95219481AEDD20"><span class="RefLink">7.2-13</span></a>)). If the corresponding subgroup of <var class="Arg">g</var> contains a non-trivial element <span class="SimpleMath">Î»</span> that acts trivially in the corresponding action, then every normal subgroup contains <span class="SimpleMath">Î»</span>. It then remains to check that the normal closure of <span class="SimpleMath">Î»</span> has finite index. This element <span class="SimpleMath">Î»</span> is then stored as the attribute <code class="code">LambdaElementVHGroup(g)</code>.</p>

<p>The current implementation is based on results in <a href="chapBib.html#biBMR1839488">[BM00a]</a> and <a href="chapBib.html#biBMR1839489">[BM00b]</a>, and does not work for the Rattaggi examples (see <code class="func">RattaggiGroup</code> (<a href="chap9.html#X80B617717C2887D4"><span class="RefLink">9.1-24</span></a>)).</p>

<p><a id="X79A3A0CF82B6F089" name="X79A3A0CF82B6F089"></a></p>

<h5>7.3-5 IsResiduallyFinite</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsResiduallyFinite</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if <var class="Arg">obj</var> is residually finite.</p>

<p>An object is <em>residually finite</em> if it can be approximated arbitrarily well by finite quotients; i.e. if for every <span class="SimpleMath">gâ‰  hâˆˆ X</span> there exists a finite quotient <span class="SimpleMath">Ï€:X-&gt; Q</span> such that <span class="SimpleMath">g^Ï€â‰  h^Ï€</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsResiduallyFinite(FreeGroup(2));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsResiduallyFinite(BasilicaGroup);</span>
true
</pre></div>

<p><a id="X86E1182E7EEFAADB" name="X86E1182E7EEFAADB"></a></p>

<h5>7.3-6 IsSQUniversal</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSQUniversal</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if <var class="Arg">obj</var> is SQ-universal.</p>

<p>An object <var class="Arg">obj</var> is <em>SQ-universal</em> if every countable object of the same category as <var class="Arg">obj</var> is a subobject of a quotient of <var class="Arg">obj</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSQUniversal(FreeGroup(2));</span>
true
</pre></div>

<p><a id="X7FDAEAFF78A5E7D2" name="X7FDAEAFF78A5E7D2"></a></p>

<h5>7.3-7 IsJustInfinite</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsJustInfinite</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> if <var class="Arg">obj</var> is just-infinite.</p>

<p>An object <var class="Arg">obj</var> is <em>just-infinite</em> if <var class="Arg">obj</var> is infinite, but every quotient of <var class="Arg">obj</var> is finite.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsJustInfinite(FreeGroup(2));</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsJustInfinite(FreeGroup(1));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsJustInfinite(GrigorchukGroup); time</span>
true
8284
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap6.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap8.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
