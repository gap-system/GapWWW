<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (YangBaxter) - Chapter 1: Preliminaries</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap1"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap2.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap1_mj.html">[MathJax on]</a></p>
<p><a id="X8749E1888244CC3D" name="X8749E1888244CC3D"></a></p>
<div class="ChapSects"><a href="chap1.html#X8749E1888244CC3D">1 <span class="Heading">Preliminaries</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X7BB9D67179296AA0">1.1 <span class="Heading">Definition and examples</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7F66BB617A79542D">1.1-1 IsSkewbrace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7C2FB9E27C641F49">1.1-2 Skewbrace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7BBF6AC978DC5CC1">1.1-3 SmallSkewbrace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7B1AAF517D8D209D">1.1-4 TrivialBrace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X82BB1BB37932DF70">1.1-5 TrivialSkewbrace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X86AFF9C586B5C2B1">1.1-6 SmallBrace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7ED6436A7DC2AB48">1.1-7 IdSkewbrace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7DF9D5E8817C3564">1.1-8 AutomorphismGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X80F7E6B78327BD5E">1.1-9 IdBrace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X79746AAC863EA794">1.1-10 IsomorphismSkewbraces</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X87A9198C8456D193">1.1-11 DirectProductSkewbraces</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X879A94807C0A65D2">1.1-12 DirectProductOp</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X84880C7484699973">1.1-13 IsTwoSided</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X84CB08C88574F438">1.1-14 IsAutomorphismGroupOfSkewbrace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7BC5B7CF7877F333">1.1-15 IsClassical</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7B398DBF7B2476B5">1.1-16 IsOfAbelianType</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X78A3A59A86F96508">1.1-17 IsBiSkewbrace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X797C4B6480DFCDDA">1.1-18 IsOfNilpotentType</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7F8C6C4B81096AF0">1.1-19 IsTrivialSkewbrace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X8426ABE1808B92DC">1.1-20 Skewbrace2YB</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7F09E6DE78CC240B">1.1-21 Brace2YB</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7E2F64338788EBF9">1.1-22 SkewbraceSubset2YB</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X8439C2087DD1D9A6">1.1-23 SemidirectProduct</a></span>
</div></div>
</div>

<h3>1 <span class="Heading">Preliminaries</span></h3>

<p>In this section we define skew braces and list some of their main properties <a href="chapBib.html#biBMR3647970">[GV17]</a>.</p>

<p><a id="X7BB9D67179296AA0" name="X7BB9D67179296AA0"></a></p>

<h4>1.1 <span class="Heading">Definition and examples</span></h4>

<p>A skew brace is a triple <span class="Math">(A,+,\circ)</span>, where <span class="Math">(A,+)</span> and <span class="Math">(A,\circ)</span> are two (not necessarily abelian) groups such that the compatibility <span class="Math">a\circ (b+c)=a\circ b-a+a\circ c</span> holds for all <span class="Math">a,b,c\in A</span>. Ones proves that the map <span class="Math">\lambda\colon (A,\circ)\to\mathrm{Aut}(A,+)</span>, <span class="Math">a\mapsto\lambda_a(b)</span>, <span class="Math">\lambda_a(b)=-a+a\circ b</span>, is a group homomorphism. Notation: For <span class="Math">a,b\in A</span>, we write <span class="Math">a*b=\lambda_a(b)-b</span>.</p>

<p><a id="X7F66BB617A79542D" name="X7F66BB617A79542D"></a></p>

<h5>1.1-1 IsSkewbrace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSkewbrace</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> or <code class="code">false</code></p>

<p><a id="X7C2FB9E27C641F49" name="X7C2FB9E27C641F49"></a></p>

<h5>1.1-2 Skewbrace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Skewbrace</code>( <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a skew brace</p>

<p>The argument <var class="Arg">list</var> is a list of pairs of elements in a group. By Proposition 5.11 of <a href="chapBib.html#biBMR3647970">[GV17]</a>, skew braces over an abelian group <span class="Math">A</span> are equivalent to pairs <span class="Math">(G,\pi)</span>, where <span class="Math">G</span> is a group and <span class="Math">\pi\colon G\to A</span> is a bijective <span class="Math">1</span>-cocycle, a finite skew brace can be constructed from the set <span class="Math">\{(a_j,g_j):1\leq j\leq n\}</span>, where <span class="Math">G=\{g_1,\dots,g_n\}</span> and <span class="Math">A=\{a_1,\dots,a_n\}</span> are permutation groups. This function is used to construct skew braces.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Skewbrace([[(),()]]);</span>
&lt;brace of size 1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Skewbrace([[(),()],[(1,2),(1,2)]]);</span>
&lt;brace of size 2&gt;
</pre></div>

<p><a id="X7BBF6AC978DC5CC1" name="X7BBF6AC978DC5CC1"></a></p>

<h5>1.1-3 SmallSkewbrace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SmallSkewbrace</code>( <var class="Arg">n</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a skew brace</p>

<p>The function returns the <var class="Arg">k</var>-th skew brace from the database of skew braces of order <var class="Arg">n</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SmallSkewbrace(8,3);</span>
&lt;brace of size 8&gt;
</pre></div>

<p><a id="X7B1AAF517D8D209D" name="X7B1AAF517D8D209D"></a></p>

<h5>1.1-4 TrivialBrace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TrivialBrace</code>( <var class="Arg">abelian_group</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a brace</p>

<p>This function returns the trivial brace over the abelian group <var class="Arg">abelian_group</var>. Here <var class="Arg">abelian_group</var> should be an abelian group!</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TrivialBrace(CyclicGroup(IsPermGroup, 5));</span>
&lt;brace of size 5&gt;
</pre></div>

<p><a id="X82BB1BB37932DF70" name="X82BB1BB37932DF70"></a></p>

<h5>1.1-5 TrivialSkewbrace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TrivialSkewbrace</code>( <var class="Arg">group</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a skew brace</p>

<p>This function returns the trivial skew brace over <var class="Arg">group</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TrivialSkewbrace(DihedralGroup(10));</span>
&lt;skew brace of size 10&gt;
</pre></div>

<p><a id="X86AFF9C586B5C2B1" name="X86AFF9C586B5C2B1"></a></p>

<h5>1.1-6 SmallBrace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SmallBrace</code>( <var class="Arg">n</var>, <var class="Arg">k</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a brace of abelian type</p>

<p>The function returns the <var class="Arg">k</var>-th brace (of abelian type) from the database of braces of order <var class="Arg">n</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SmallBrace(8,3);</span>
&lt;brace of size 8&gt;
</pre></div>

<p><a id="X7ED6436A7DC2AB48" name="X7ED6436A7DC2AB48"></a></p>

<h5>1.1-7 IdSkewbrace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IdSkewbrace</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>The function returns <var class="Arg">[ n, k ]</var> if the skew brace <var class="Arg">obj</var> is isomorphic to <var class="Arg">SmallSkewbrace(n,k)</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdSkewbrace(SmallSkewbrace(8,5));</span>
[ 8, 5 ]
</pre></div>

<p><a id="X7DF9D5E8817C3564" name="X7DF9D5E8817C3564"></a></p>

<h5>1.1-8 AutomorphismGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AutomorphismGroup</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>The function computes the automorphism group of a skew brace.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">br := SmallSkewbrace(8,20);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AutomorphismGroup(br);</span>
&lt;group with 8 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription(last);</span>
"D8"
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">br := SmallSkewbrace(8,25);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">aut := AutomorphismGroup(br);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := Random(aut);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := Random(br);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ImageElm(f, x) in br;</span>
true
</pre></div>

<p><a id="X80F7E6B78327BD5E" name="X80F7E6B78327BD5E"></a></p>

<h5>1.1-9 IdBrace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IdBrace</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>The function returns <var class="Arg">[ n, k ]</var> if the brace of abelian type <var class="Arg">obj</var> is isomorphic to <var class="Arg">SmallBrace(n,k)</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdBrace(SmallBrace(8,5));</span>
[ 8, 5 ]
</pre></div>

<p><a id="X79746AAC863EA794" name="X79746AAC863EA794"></a></p>

<h5>1.1-10 IsomorphismSkewbraces</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismSkewbraces</code>( <var class="Arg">obj1</var>, <var class="Arg">obj2</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: an isomorphism of skew braces if <var class="Arg">obj1</var> and <var class="Arg">obj2</var> are isomorphic and <var class="Arg">fail</var> otherwise.</p>

<p>If <span class="Math">A</span> and <span class="Math">B</span> are skew braces, a skew brace homomorphism is a map <span class="Math">f\colon A\to B</span> such that</p>

<p class="pcenter">f(a+b)=f(a)+f(b)\quad
f(a\circ b)=f(a)\circ f(b)</p>

<p>hold for all <span class="Math">a,b\in A</span>. A skew brace isomorphism is a bijective skew brace homomorphism. <var class="Arg">IsomorphismSkewbraces</var> first computes all injective homomorphisms from <span class="Math">(A,+)</span> to <span class="Math">(B,+)</span> and then tries to find one <span class="Math">f</span> such that <span class="Math">f(a\circ b)=f(a)\circ f(b)</span> for all <span class="Math">a,b\in A</span>.</p>

<p><a id="X87A9198C8456D193" name="X87A9198C8456D193"></a></p>

<h5>1.1-11 DirectProductSkewbraces</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DirectProductSkewbraces</code>( <var class="Arg">obj1</var>, <var class="Arg">obj2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: the direct product of <var class="Arg">obj1</var> and <var class="Arg">obj2</var></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">br1 := SmallBrace(8,18);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">br2 := SmallBrace(12,2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">br := DirectProductSkewbraces(br1,br2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLeftNilpotent(br);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRightNilpotent(br);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSolvable(br);</span>
true
</pre></div>

<p><a id="X879A94807C0A65D2" name="X879A94807C0A65D2"></a></p>

<h5>1.1-12 DirectProductOp</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DirectProductOp</code>( <var class="Arg">arg1</var>, <var class="Arg">arg2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p><a id="X84880C7484699973" name="X84880C7484699973"></a></p>

<h5>1.1-13 IsTwoSided</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsTwoSided</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <var class="Arg">true</var> if the skew brace is two sided, <var class="Arg">false</var> otherwise</p>

<p>A skew brace <span class="Math">A</span> is said to be <em>two-sided</em> if <span class="Math">(a+b)\circ c=a\circ c-c+b\circ c</span> holds for all <span class="Math">a,b,c\in A</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsTwoSided(SmallSkewbrace(8,2));</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsTwoSided(SmallSkewbrace(8,4));</span>
true
</pre></div>

<p><a id="X84CB08C88574F438" name="X84CB08C88574F438"></a></p>

<h5>1.1-14 IsAutomorphismGroupOfSkewbrace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsAutomorphismGroupOfSkewbrace</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <var class="Arg">true</var> if the group is the automorphism group of a skew braces, <var class="Arg">false</var> otherwise</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">br := SmallSkewbrace(8,25);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">aut := AutomorphismGroup(br);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order(aut);</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAutomorphismGroupOfSkewbrace(aut);</span>
true
</pre></div>

<p><a id="X7BC5B7CF7877F333" name="X7BC5B7CF7877F333"></a></p>

<h5>1.1-15 IsClassical</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsClassical</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <var class="Arg">true</var> if the skew brace is of abelian type, <var class="Arg">false</var> otherwise</p>

<p>Let <span class="Math">\mathcal{X}</span> be a property of groups. A skew brace <span class="Math">A</span> is said to be of <span class="Math">\mathcal{X}</span>-type if its additive group belongs to <span class="Math">\mathcal{X}</span>. In particular, skew braces of abelian type are those skew braces with abelian additive group. Such skew braces were introduced by Rump in <a href="chapBib.html#biBMR2278047">[Rum07]</a>.</p>

<p><a id="X7B398DBF7B2476B5" name="X7B398DBF7B2476B5"></a></p>

<h5>1.1-16 IsOfAbelianType</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsOfAbelianType</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> or <code class="code">false</code></p>

<p><a id="X78A3A59A86F96508" name="X78A3A59A86F96508"></a></p>

<h5>1.1-17 IsBiSkewbrace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsBiSkewbrace</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <var class="Arg">true</var> if the skew brace is a bi-skew brace, <var class="Arg">false</var> otherwise</p>

<p>A skew brace <span class="Math">(A,+,\circ)</span> is said to be a bi-skew brace if <span class="Math">(A,\circ,+)</span> is a skew brace</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Number([1..NrSmallSkewbraces(8)], k-&gt;IsBiSkewbrace(SmallSkewbrace(8,k)));</span>
39
</pre></div>

<p><a id="X797C4B6480DFCDDA" name="X797C4B6480DFCDDA"></a></p>

<h5>1.1-18 IsOfNilpotentType</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsOfNilpotentType</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <var class="Arg">true</var> if the skew brace is of nilpotent type, <var class="Arg">false</var> otherwise</p>

<p>Let <span class="Math">\mathcal{X}</span> be a property of groups. A skew brace <span class="Math">A</span> is said to be of <span class="Math">\mathcal{X}</span>-type if its additive group belongs to <span class="Math">\mathcal{X}</span>. In particular, skew braces of nilpotent type are those skew braces with nilpotent additive group.</p>

<p><a id="X7F8C6C4B81096AF0" name="X7F8C6C4B81096AF0"></a></p>

<h5>1.1-19 IsTrivialSkewbrace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsTrivialSkewbrace</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <var class="Arg">true</var> if the skew brace is trivial, <var class="Arg">false</var> otherwise</p>

<p>The function returns <var class="Arg">true</var> if the skew brace <span class="Math">A</span> is trivial, i.e., <span class="Math">a\circ b=a+b</span> for all <span class="Math">a,b\in A</span>. WARNING: The property IsTrivial applied to a skew brace will return true if and only if the skew brace has only one element.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">br := SmallSkewbrace(9,1);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsTrivialSkewbrace(br);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsTrivial(br);</span>
false
</pre></div>

<p><a id="X8426ABE1808B92DC" name="X8426ABE1808B92DC"></a></p>

<h5>1.1-20 Skewbrace2YB</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Skewbrace2YB</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: the set-theoretic solution associated with the skew brace <var class="Arg">obj</var></p>

<p>If <span class="Math">A</span> is a skew brace, the map <span class="Math">r_A\colon A\times A\to A\times A</span></p>

<p class="pcenter">r_A(a,b)=(\lambda_a(b),\lambda_a(b)'\circ a\circ b)</p>

<p>is a non-degenerate set-theoretic solution of the Yang--Baxter equation. Furthermore, <span class="Math">r_A</span> is involutive if and only if <span class="Math">A</span> is of abelian type (i.e., the additive group of <span class="Math">A</span> is abelian).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Skewbrace2YB(TrivialBrace(CyclicGroup(6)));</span>
&lt;A set-theoretical solution of size 6&gt;
</pre></div>

<p><a id="X7F09E6DE78CC240B" name="X7F09E6DE78CC240B"></a></p>

<h5>1.1-21 Brace2YB</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Brace2YB</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><a id="X7E2F64338788EBF9" name="X7E2F64338788EBF9"></a></p>

<h5>1.1-22 SkewbraceSubset2YB</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SkewbraceSubset2YB</code>( <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: the set-theoretic solution associated with a given subset of a skew brace</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">br := TrivialSkewbrace(SymmetricGroup(3));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsList(br);</span>
[ &lt;()&gt;, &lt;(2,3)&gt;, &lt;(1,2)&gt;, &lt;(1,2,3)&gt;, &lt;(1,3,2)&gt;, &lt;(1,3)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SkewbraceSubset2YB(br, last{[4,5]});</span>
&lt;A set-theoretical solution of size 2&gt;
</pre></div>

<p><a id="X8439C2087DD1D9A6" name="X8439C2087DD1D9A6"></a></p>

<h5>1.1-23 SemidirectProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SemidirectProduct</code>( <var class="Arg">A</var>, <var class="Arg">B</var>, <var class="Arg">s</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: the semidirect product of skew braces</p>

<p>Let <span class="Math">A</span> and <span class="Math">B</span> be two skew braces and <span class="Math">\sigma</span> be a skew brace action of <span class="Math">B</span> on <span class="Math">A</span>, this is a group homomorphism <span class="Math">\sigma\colon (B,\circ)\to Aut_{\mathrm{Br}}(A)</span> from the multiplicative group of <span class="Math">B</span> to the skew brace automorphism of <span class="Math">A</span>. The semidirect product of <span class="Math">A</span> and <span class="Math">B</span> with with respect to <span class="Math">\sigma</span> is the skew brace <span class="Math">A\rtimes_{\sigma}B</span> with operations</p>

<p class="pcenter">
(a_1,b_1)+(a_2,b_2)=(a_1+a_2,b_1+b_2),
\quad
(a_1,b_1)\circ (b_2,b_2)=(a_1\circ\sigma(b_1)(a_2),b_1\circ b_2)
</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A := SmallSkewbrace(4,2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := SmallSkewbrace(3,1);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s := SkewbraceActions(B,A);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(s);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdSkewbrace(SemidirectProduct(A,B,s[1]));</span>
[ 12, 11 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdSkewbrace(DirectProduct(A,B));</span>
[ 12, 11 ]
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap2.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
