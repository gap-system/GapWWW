<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (Circle) - Chapter 3: Circle functions</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap3"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap3.html">[MathJax off]</a></p>
<p><a id="X81CE94FA8343B1D8" name="X81CE94FA8343B1D8"></a></p>
<div class="ChapSects"><a href="chap3_mj.html#X81CE94FA8343B1D8">3 <span class="Heading"><strong class="pkg">Circle</strong> functions</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X7E25EF1786B5F87C">3.1 <span class="Heading">Circle objects</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7F5C18AA7B433BDD">3.1-1 CircleObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X874B2B2A7F5A9A78">3.1-2 UnderlyingRingElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X810FB77F860F888D">3.1-3 IsCircleObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X8469C7F67A8864B3">3.1-4 IsPositionalObjectOneSlotRep</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7F88A0017DC2E878">3.1-5 CircleFamily</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X85ECB0B482AB3170">3.2 <span class="Heading">Operations with circle objects</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X8129A6877FFD804B">3.2-1 One</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X82EC4F49877D6EB1">3.2-2 InverseOp</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X85CBFBAE78DE72E8">3.2-3 IsUnit</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7CE7866F7CD00709">3.2-4 IsCircleUnit</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X86F80DD8823966F7">3.3 <span class="Heading">Construction of the adjoint semigroup and adjoint group</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X83993FD0848D0C80">3.3-1 AdjointSemigroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X868FAC7E87D11137">3.3-2 AdjointGroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X80DFB24F8289C323">3.4 <span class="Heading">Service functions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7A24C0997AC7C6A3">3.4-1 InfoCircle</a></span>
</div></div>
</div>

<h3>3 <span class="Heading"><strong class="pkg">Circle</strong> functions</span></h3>

<p>To use the <strong class="pkg">Circle</strong> package first you need to load it as follows:</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage("circle");</span>
-----------------------------------------------------------------------------
Loading  Circle 1.4.0 (Adjoint groups of finite rings)
by Alexander Konovalov (http://www.cs.st-andrews.ac.uk/~alexk/) and
   Panagiotis Soules (psoules@math.uoa.gr).
-----------------------------------------------------------------------------
true
gap&gt;

</pre></div>

<p>Note that if you entered examples from the previous chapter, you need to restart <strong class="pkg">GAP</strong> before loading the <strong class="pkg">Circle</strong> package.</p>

<p><a id="X7E25EF1786B5F87C" name="X7E25EF1786B5F87C"></a></p>

<h4>3.1 <span class="Heading">Circle objects</span></h4>

<p>Because for elements of the ring <span class="SimpleMath">\(R\)</span> the ordinary multiplication is already denoted by <code class="code">*</code>, for the implementation of the circle multiplication in the adjoint semigroup we need to wrap up ring elements as CircleObjects, for which <code class="code">*</code> is defined to be the circle multiplication.</p>

<p><a id="X7F5C18AA7B433BDD" name="X7F5C18AA7B433BDD"></a></p>

<h5>3.1-1 CircleObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CircleObject</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">x</var> be a ring element. Then <code class="code">CircleObject(x)</code> returns the corresponding circle object. If <var class="Arg">x</var> lies in the family <code class="code">fam</code>, then <code class="code">CircleObject(x)</code> lies in the family <code class="func">CircleFamily</code> (<a href="chap3_mj.html#X7F88A0017DC2E878"><span class="RefLink">3.1-5</span></a>), corresponding to the family <code class="code">fam</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := CircleObject( 2 );</span>
CircleObject( 2 )

</pre></div>

<p><a id="X874B2B2A7F5A9A78" name="X874B2B2A7F5A9A78"></a></p>

<h5>3.1-2 UnderlyingRingElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnderlyingRingElement</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns the corresponding ring element for the circle object <var class="Arg">x</var>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := CircleObject( 2 );</span>
CircleObject( 2 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnderlyingRingElement( a );    </span>
2

</pre></div>

<p><a id="X810FB77F860F888D" name="X810FB77F860F888D"></a></p>

<h5>3.1-3 IsCircleObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCircleObject</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCircleObjectCollection</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;category&nbsp;)</td></tr></table></div>
<p>An object <var class="Arg">x</var> lies in the category <code class="code">IsCircleObject</code> if and only if it lies in a family constructed by <code class="func">CircleFamily</code> (<a href="chap3_mj.html#X7F88A0017DC2E878"><span class="RefLink">3.1-5</span></a>). Since circle objects can be multiplied via <code class="code">*</code> with elements in their family, and we need operations <code class="code">One</code> and <code class="code">Inverse</code> to deal with groups they generate, circle objects are implemented in the category <code class="code">IsMultiplicativeElementWithInverse</code>. A collection of circle objects (e.g. adjoint semigroup or adjoint group) will lie in the category <code class="code">IsCircleObjectCollection</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCircleObject( 2 ); IsCircleObject( CircleObject( 2 ) );            </span>
false
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMultiplicativeElementWithInverse( CircleObject( 2 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCircleObjectCollection( [ CircleObject(0), CircleObject(2) ] );</span>
true

</pre></div>

<p><a id="X8469C7F67A8864B3" name="X8469C7F67A8864B3"></a></p>

<h5>3.1-4 IsPositionalObjectOneSlotRep</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPositionalObjectOneSlotRep</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;representation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDefaultCircleObject</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;representation&nbsp;)</td></tr></table></div>
<p>To store the corresponding circle object, we need only to store the underlying ring element. Since this is quite common situation, we defined the representation <code class="code">IsPositionalObjectOneSlotRep</code> for a more general case. Then we defined <code class="code">IsDefaultCircleObject</code> as a synonym of <code class="code">IsPositionalObjectOneSlotRep</code> for objects in <code class="func">IsCircleObject</code> (<a href="chap3_mj.html#X810FB77F860F888D"><span class="RefLink">3.1-3</span></a>).</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPositionalObjectOneSlotRep( CircleObject( 2 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDefaultCircleObject( CircleObject( 2 ) );                          </span>
true

</pre></div>

<p><a id="X7F88A0017DC2E878" name="X7F88A0017DC2E878"></a></p>

<h5>3.1-5 CircleFamily</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CircleFamily</code>( <var class="Arg">fam</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p><code class="code">CircleFamily(fam)</code> is a family, elements of which are in one-to-one correspondence with elements of the family <var class="Arg">fam</var>, but with the circle multiplication as an infix multiplication. That is, for <span class="SimpleMath">\(x\)</span>, <span class="SimpleMath">\(y\)</span> in <var class="Arg">fam</var>, the product of their images in the <code class="code">CircleFamily(fam)</code> will be the image of <span class="SimpleMath">\( x + y + x y \)</span>. The relation between these families is demonstrated by the following equality:</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FamilyObj( CircleObject ( 2 ) ) = CircleFamily( FamilyObj( 2 ) );</span>
true

</pre></div>

<p><a id="X85ECB0B482AB3170" name="X85ECB0B482AB3170"></a></p>

<h4>3.2 <span class="Heading">Operations with circle objects</span></h4>

<p><a id="X8129A6877FFD804B" name="X8129A6877FFD804B"></a></p>

<h5>3.2-1 One</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; One</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>This operation returns the multiplicative neutral element for the circle object <var class="Arg">x</var>. The result is the circle object corresponding to the additive neutral element of the appropriate ring.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">One( CircleObject( 5 ) );</span>
CircleObject( 0 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">One( CircleObject( 5 ) ) = CircleObject( Zero( 5 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">One( CircleObject( [ [ 1, 1 ],[ 0, 1 ] ] ) );</span>
CircleObject( [ [ 0, 0 ], [ 0, 0 ] ] )

</pre></div>

<p><a id="X82EC4F49877D6EB1" name="X82EC4F49877D6EB1"></a></p>

<h5>3.2-2 InverseOp</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InverseOp</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>For a circle object <var class="Arg">x</var>, returns the multiplicative inverse of <var class="Arg">x</var> with respect to the circle multiplication; if such one does not exist then <code class="keyw">fail</code> is returned.</p>

<p>In our implementation we assume that the underlying ring is a subring of the ring with one, thus, if the circle inverse for an element <span class="SimpleMath">\(x\)</span> exists, than it can be computed as <span class="SimpleMath">\(-x(1+x)^{-1}\)</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CircleObject( -2 )^-1;                        </span>
CircleObject( -2 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CircleObject( 2 )^-1; </span>
CircleObject( -2/3 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CircleObject( -2 )*CircleObject( -2 )^-1;</span>
CircleObject( 0 )

</pre></div>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := CircleObject( [ [ 1, 1 ], [ 0, 1 ] ] );   </span>
CircleObject( [ [ 1, 1 ], [ 0, 1 ] ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m^-1;    </span>
CircleObject( [ [ -1/2, -1/4 ], [ 0, -1/2 ] ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m * m^-1;</span>
CircleObject( [ [ 0, 0 ], [ 0, 0 ] ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CircleObject( [ [ 0, 1 ], [ 1, 0 ] ] )^-1; </span>
fail

</pre></div>

<p><a id="X85CBFBAE78DE72E8" name="X85CBFBAE78DE72E8"></a></p>

<h5>3.2-3 IsUnit</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsUnit</code>( [<var class="Arg">R</var>, ]<var class="Arg">x</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">x</var> be a circle object corresponding to an element of the ring <var class="Arg">R</var>. Then the operation <code class="code">IsUnit</code> returns <code class="code">true</code>, if <var class="Arg">x</var> is invertible in <var class="Arg">R</var> with respect to the circle multiplication, and <code class="code">false</code> otherwise.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsUnit( Integers, CircleObject( -2 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsUnit( Integers, CircleObject( 2 ) ); </span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsUnit( Rationals, CircleObject( 2 ) );        </span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsUnit( ZmodnZ(8), CircleObject( ZmodnZObj(2,8) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := CircleObject( [ [ 1, 1 ],[ 0, 1 ] ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsUnit( FullMatrixAlgebra( Rationals, 2 ), m );</span>
true

</pre></div>

<p>If the first argument is omitted, the result will be returned with respect to the default ring of the circle object <var class="Arg">x</var>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsUnit( CircleObject( -2 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsUnit( CircleObject( 2 ) ); </span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsUnit( CircleObject( ZmodnZObj(2,8) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsUnit( CircleObject( [ [ 1, 1 ],[ 0, 1 ] ] ) );                                    </span>
false

</pre></div>

<p><a id="X7CE7866F7CD00709" name="X7CE7866F7CD00709"></a></p>

<h5>3.2-4 IsCircleUnit</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCircleUnit</code>( [<var class="Arg">R</var>, ]<var class="Arg">x</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Let <var class="Arg">x</var> be an element of the ring <var class="Arg">R</var>. Then <code class="code">IsCircleUnit( R, x )</code> determines whether <var class="Arg">x</var> is invertible in <var class="Arg">R</var> with respect to the circle multilpication. This is equivalent to the condition that 1+<var class="Arg">x</var> is a unit in <var class="Arg">R</var> with respect to the ordinary multiplication.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCircleUnit( Integers, -2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCircleUnit( Integers, 2 ); </span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCircleUnit( Rationals, 2 );          </span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCircleUnit( ZmodnZ(8), ZmodnZObj(2,8) ); </span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := [ [ 1, 1 ],[ 0, 1 ] ];                </span>
[ [ 1, 1 ], [ 0, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCircleUnit( FullMatrixAlgebra(Rationals,2), m );</span>
true

</pre></div>

<p>If the first argument is omitted, the result will be returned with respect to the default ring of <var class="Arg">x</var>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCircleUnit( -2 );                               </span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCircleUnit( 2 ); </span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCircleUnit( ZmodnZObj(2,8) );           </span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCircleUnit( [ [ 1, 1 ],[ 0, 1 ] ] ); </span>
false

</pre></div>

<p><a id="X86F80DD8823966F7" name="X86F80DD8823966F7"></a></p>

<h4>3.3 <span class="Heading">Construction of the adjoint semigroup and adjoint group</span></h4>

<p><a id="X83993FD0848D0C80" name="X83993FD0848D0C80"></a></p>

<h5>3.3-1 AdjointSemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AdjointSemigroup</code>( <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>If <var class="Arg">R</var> is a finite ring then <code class="code">AdjointSemigroup(<var class="Arg">R</var>)</code> will return the monoid which is formed by all elements of <var class="Arg">R</var> with respect to the circle multiplication.</p>

<p>The implementation is rather straightforward and was added to provide a link to the <strong class="pkg">GAP</strong> functionality for semigroups. It assumes that the enumaration of all elements of the ring <var class="Arg">R</var> is feasible.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:=Ring( [ ZmodnZObj(2,8) ] );</span>
&lt;ring with 1 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S:=AdjointSemigroup(R);</span>
&lt;monoid with 4 generators&gt;

</pre></div>

<p><a id="X868FAC7E87D11137" name="X868FAC7E87D11137"></a></p>

<h5>3.3-2 AdjointGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AdjointGroup</code>( <var class="Arg">R</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>If <var class="Arg">R</var> is a finite radical algebra then <code class="code">AdjointGroup(<var class="Arg">R</var>)</code> will return the adjoint group of <var class="Arg">R</var>, given as a group generated by a set of circle objects.</p>

<p>To compute the adjoint group of a finite radical algebra, <strong class="pkg">Circle</strong> uses the fact that all elements of a radical algebra form a group with respect to the circle multiplication. Thus, the adjoint group of <var class="Arg">R</var> coincides with <var class="Arg">R</var> elementwise, and we can randomly select an appropriate set of generators for the adjoint group.</p>

<p>The warning is displayed by <code class="code">IsGeneratorsOfMagmaWithInverses</code> method defined in <code class="file">gap4r4/lib/grp.gi</code> and may be ignored.</p>

<p><strong class="button">WARNINGS:</strong></p>

<p>1. The set of generators of the returned group is not required to be a generating set of minimal possible order.</p>

<p>2. <code class="code">AdjointGroup</code> is stored as an attribute of <var class="Arg">R</var>, so for the same copy of <var class="Arg">R</var> calling it again you will get the same result. But if you will create another copy of <var class="Arg">R</var> in the future, the output may differ because of the random selection of generators. If you want to have the same generating set, next time you should construct a group immediately specifying circle objects that generate it.</p>

<p>3. In most cases, to investigate some properties of the adjoint group, it is necessary first to convert it to an isomorphic permutation group or to a PcGroup.</p>

<p>For example, we can create the following commutative 2-dimensional radical algebra of order 4 over the field of two elements, and show that its adjoint group is a cyclic group of order 4:</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:=[ [ 0, 1, 0 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [ 0, 0, 1 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [ 0, 0, 0 ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := Algebra( GF(2), [ One(GF(2))*x ] );  </span>
&lt;algebra over GF(2), with 1 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RadicalOfAlgebra( R ) = R;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dimension(R);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := AdjointGroup( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( R ) = Size( G );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription( G );</span>
"C4"

</pre></div>

<p>In the following example we construct a non-commutative 3-dimensional radical algebra of order 8 over the field of two elements, and demonstrate that its adjoint group is the dihedral group of order 8:</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:=[ [ 0, 1, 0 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [ 0, 0, 0 ],     </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [ 0, 0, 0 ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">y:=[ [ 0, 0, 0 ],     </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [ 0, 0, 1 ],  </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [ 0, 0, 0 ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := Algebra( GF(2), One(GF(2))*[x,y] );  </span>
&lt;algebra over GF(2), with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RadicalOfAlgebra(R) = R;                </span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dimension(R);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := AdjointGroup( R );</span>
&lt;group of size 8 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription( G );</span>
"D8"

</pre></div>

<p>If the ring <var class="Arg">R</var> is not a radical algebra, then <strong class="pkg">Circle</strong> will use another approach. We will enumerate all elements of the ring <var class="Arg">R</var> and select those that are units with respect to the circle multiplication. Then we will use a random approach similar to the case of the radical algebra, to find some generating set of the adjoint group. Again, all warnings 1-3 above refer also to this case.</p>

<p>Of course, enumeration of all elements of <var class="Arg">R</var> should be feasible for this computation. In the following example we demonstrate how it works for rings, generated by residue classes:</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := Ring( [ ZmodnZObj(2,8) ] );</span>
&lt;ring with 1 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := AdjointGroup( R );</span>
&lt;group of size 4 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription( G );</span>
"C2 x C2"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := Ring( [ ZmodnZObj(2,256) ] );   </span>
&lt;ring with 1 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := AdjointGroup( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription( G );</span>
"C64 x C2"

</pre></div>

<p>Due to the <code class="func">AdjointSemigroup</code> (<a href="chap3_mj.html#X83993FD0848D0C80"><span class="RefLink">3.3-1</span></a>), there is also another way to compute the adjoint group of a ring <span class="SimpleMath">\(R\)</span> by means of the computation of its adjoint semigroup <span class="SimpleMath">\(S(R)\)</span> and taking the Green's <span class="SimpleMath">\(H\)</span>-class of the multiplicative neutral element of <span class="SimpleMath">\(S(R)\)</span>. Let us repeat the last example in this way:</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := Ring( [ ZmodnZObj(2,256) ] );  </span>
&lt;ring with 1 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := AdjointSemigroup( R );</span>
&lt;monoid with 128 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := GreensHClassOfElement(S,One(S));</span>
&lt;Green's H-class: &lt;object&gt;&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:=AsGroup(H);</span>
&lt;group of size 128 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription(G);</span>
"C64 x C2"

</pre></div>

<p>However, the conversion of the Green's <span class="SimpleMath">\(H\)</span>-class to the group may take some time which may vary dependently on the particular ring in question, and will also display a lot of warnings about the default <code class="code">IsGeneratorsOfMagmaWithInverses</code> method, so we did not implemented this as as standard method. In the following example the method based on Green's <span class="SimpleMath">\(H\)</span>-class is much slower than an application of earlier described random approach (20s vs 10ms):</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := Ring( [ ZmodnZObj(2,256) ] );   </span>
&lt;ring with 1 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AdjointGroup(R);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := Ring( [ ZmodnZObj(2,256) ] );</span>
&lt;ring with 1 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S:=AdjointSemigroup(R); </span>
&lt;monoid with 128 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsGroup(GreensHClassOfElement(S,One(S))); </span>
&lt;group of size 128 with 2 generators&gt;

</pre></div>

<p>Finally, note that if <var class="Arg">R</var> has a unity <span class="SimpleMath">\(1\)</span>, then the set <span class="SimpleMath">\(1+R^{ad}\)</span>, where <span class="SimpleMath">\(R^{ad}\)</span> is the adjoint semigroup of <var class="Arg">R</var>, coincides with the multiplicative semigroup <span class="SimpleMath">\(R^{mult}\)</span> of <span class="SimpleMath">\(R\)</span>, and the map <span class="SimpleMath">\( r \mapsto (1+r) \)</span> for <span class="SimpleMath">\(r\)</span> in <span class="SimpleMath">\(R\)</span> is an isomorphism from <span class="SimpleMath">\(R^{ad}\)</span> onto <span class="SimpleMath">\(R^{mult}\)</span>.</p>

<p>Similarly, the set <span class="SimpleMath">\(1+R^*\)</span>, where <span class="SimpleMath">\(R^{*}\)</span> is the adjoint group of <var class="Arg">R</var>, coincides with the unit group of <span class="SimpleMath">\(R\)</span>, which we denote <span class="SimpleMath">\(U(R)\)</span>, and the map <span class="SimpleMath">\(r \mapsto (1+r)\)</span> for <span class="SimpleMath">\(r\)</span> in <span class="SimpleMath">\(R\)</span> is an isomorphism from <span class="SimpleMath">\(R^*\)</span> onto <span class="SimpleMath">\(U(R)\)</span>.</p>

<p>We demonstrate this isomorphism using the following example.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "laguna", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FG := GroupRing( GF(2), DihedralGroup(8) );</span>
&lt;algebra-with-one over GF(2), with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := AugmentationIdeal( FG );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := AdjointGroup( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdGroup( G );</span>
[ 128, 170 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdGroup( Units( FG ) );</span>
#I  LAGUNA package: Computing the unit group ...
[ 128, 170 ]

</pre></div>

<p>Thus, dependently on the ring <code class="code">R</code> in question, it might be possible that you can compute much faster its unit group using <code class="code">Units(R)</code> than its adjoint group using <code class="code">AdjointGroup(R)</code>. This is why in an attempt of computation of the adjoint group of the ring with one a warning message will be displayed:</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( AdjointGroup( GroupRing( GF(2), DihedralGroup(8) ) ) );</span>

WARNING: usage of AdjointGroup for associative ring &lt;R&gt; with one!!! 
In this case the adjoint group is isomorphic to the unit group 
Units(&lt;R&gt;), which possibly may be computed faster!!! 

128
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( AdjointGroup( Integers mod 11 ) );                  </span>

WARNING: usage of AdjointGroup for associative ring &lt;R&gt; with one!!! 
In this case the adjoint group is isomorphic to the unit group 
Units(&lt;R&gt;), which possibly may be computed faster!!! 

10

</pre></div>

<p>If <var class="Arg">R</var> is infinite, an error message will appear, telling that <strong class="pkg">Circle</strong> does not provide methods to deal with infinite rings.</p>

<p><a id="X80DFB24F8289C323" name="X80DFB24F8289C323"></a></p>

<h4>3.4 <span class="Heading">Service functions</span></h4>

<p><a id="X7A24C0997AC7C6A3" name="X7A24C0997AC7C6A3"></a></p>

<h5>3.4-1 InfoCircle</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InfoCircle</code></td><td class="tdright">(&nbsp;info class&nbsp;)</td></tr></table></div>
<p><code class="code">InfoCircle</code> is a special Info class for <strong class="pkg">Circle</strong> algorithms. It has 2 levels: 0 (default) and 1. To change info level to <code class="code">k</code>, use command <code class="code">SetInfoLevel(InfoCircle, k)</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetInfoLevel( InfoCircle, 1 );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetInfoLevel(InfoCircle,1);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := Ring( [ ZmodnZObj(2,8) ]);</span>
&lt;ring with 1 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := AdjointGroup( R );</span>
#I  Circle : &lt;R&gt; is not a radical algebra, computing circle units ...
#I  Circle : searching generators for adjoint group ...
&lt;group of size 4 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetInfoLevel( InfoCircle, 0 );</span>

</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
